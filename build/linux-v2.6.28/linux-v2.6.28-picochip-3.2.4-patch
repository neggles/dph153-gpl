diff --git a/Documentation/ioctl/ioctl-number.txt b/Documentation/ioctl/ioctl-number.txt
index b880ce5..194b136 100644
--- a/Documentation/ioctl/ioctl-number.txt
+++ b/Documentation/ioctl/ioctl-number.txt
@@ -127,6 +127,10 @@ Code	Seq#	Include File		Comments
 'e'	00-1F	linux/video_encoder.h	conflict!
 'e'	00-1F	net/irda/irtty.h	conflict!
 'f'	00-1F	linux/ext2_fs.h
+'g'	00-05	linux/pc302gpio.h       picoChip PC302 GPIO device
+                                        <mailto:support@picochip.com>
+'g'	00-05	linux/pc202gpio.h       picoChip PC"02 GPIO device
+                                        <mailto:support@picochip.com>
 'h'	00-7F				Charon filesystem
 					<mailto:zapman@interlan.net>
 'i'	00-3F	linux/i2o.h
@@ -147,6 +151,8 @@ Code	Seq#	Include File		Comments
 'p'	40-7F	linux/nvram.h
 'p'	80-9F				user-space parport
 					<mailto:tim@cyberelk.net>
+'p'     A0-AF   linux/pc302fuse.h       picoChip PC302 Fuse device
+                                        <mailto:support@picochip.com>
 'q'	00-1F	linux/serio.h
 'q'	80-FF				Internet PhoneJACK, Internet LineJACK
 					<http://www.quicknet.net>
diff --git a/Documentation/networking/timestamping.txt b/Documentation/networking/timestamping.txt
new file mode 100644
index 0000000..49c117f
--- /dev/null
+++ b/Documentation/networking/timestamping.txt
@@ -0,0 +1,178 @@
+The existing interfaces for getting network packages time stamped are:
+
+* SO_TIMESTAMP
+  Generate time stamp for each incoming packet using the (not necessarily
+  monotonous!) system time. Result is returned via recv_msg() in a
+  control message as timeval (usec resolution).
+
+* SO_TIMESTAMPNS
+  Same time stamping mechanism as SO_TIMESTAMP, but returns result as
+  timespec (nsec resolution).
+
+* IP_MULTICAST_LOOP + SO_TIMESTAMP[NS]
+  Only for multicasts: approximate send time stamp by receiving the looped
+  packet and using its receive time stamp.
+
+The following interface complements the existing ones: receive time
+stamps can be generated and returned for arbitrary packets and much
+closer to the point where the packet is really sent. Time stamps can
+be generated in software (as before) or in hardware (if the hardware
+has such a feature).
+
+SO_TIMESTAMPING:
+
+Instructs the socket layer which kind of information is wanted. The
+parameter is an integer with some of the following bits set. Setting
+other bits is an error and doesn't change the current state.
+
+SOF_TIMESTAMPING_TX_HARDWARE:  try to obtain send time stamp in hardware
+SOF_TIMESTAMPING_TX_SOFTWARE:  if SOF_TIMESTAMPING_TX_HARDWARE is off or
+                               fails, then do it in software
+SOF_TIMESTAMPING_RX_HARDWARE:  return the original, unmodified time stamp
+                               as generated by the hardware
+SOF_TIMESTAMPING_RX_SOFTWARE:  if SOF_TIMESTAMPING_RX_HARDWARE is off or
+                               fails, then do it in software
+SOF_TIMESTAMPING_RAW_HARDWARE: return original raw hardware time stamp
+SOF_TIMESTAMPING_SYS_HARDWARE: return hardware time stamp transformed to
+                               the system time base
+SOF_TIMESTAMPING_SOFTWARE:     return system time stamp generated in
+                               software
+
+SOF_TIMESTAMPING_TX/RX determine how time stamps are generated.
+SOF_TIMESTAMPING_RAW/SYS determine how they are reported in the
+following control message:
+    struct scm_timestamping {
+           struct timespec systime;
+           struct timespec hwtimetrans;
+           struct timespec hwtimeraw;
+    };
+
+recvmsg() can be used to get this control message for regular incoming
+packets. For send time stamps the outgoing packet is looped back to
+the socket's error queue with the send time stamp(s) attached. It can
+be received with recvmsg(flags=MSG_ERRQUEUE). The call returns the
+original outgoing packet data including all headers preprended down to
+and including the link layer, the scm_timestamping control message and
+a sock_extended_err control message with ee_errno==ENOMSG and
+ee_origin==SO_EE_ORIGIN_TIMESTAMPING. A socket with such a pending
+bounced packet is ready for reading as far as select() is concerned.
+
+All three values correspond to the same event in time, but were
+generated in different ways. Each of these values may be empty (= all
+zero), in which case no such value was available. If the application
+is not interested in some of these values, they can be left blank to
+avoid the potential overhead of calculating them.
+
+systime is the value of the system time at that moment. This
+corresponds to the value also returned via SO_TIMESTAMP[NS]. If the
+time stamp was generated by hardware, then this field is
+empty. Otherwise it is filled in if SOF_TIMESTAMPING_SOFTWARE is
+set.
+
+hwtimeraw is the original hardware time stamp. Filled in if
+SOF_TIMESTAMPING_RAW_HARDWARE is set. No assumptions about its
+relation to system time should be made.
+
+hwtimetrans is the hardware time stamp transformed so that it
+corresponds as good as possible to system time. This correlation is
+not perfect; as a consequence, sorting packets received via different
+NICs by their hwtimetrans may differ from the order in which they were
+received. hwtimetrans may be non-monotonic even for the same NIC.
+Filled in if SOF_TIMESTAMPING_SYS_HARDWARE is set. Requires support
+by the network device and will be empty without that support.
+
+
+SIOCSHWTSTAMP:
+
+Hardware time stamping must also be initialized for each device driver
+that is expected to do hardware time stamping. The parameter is:
+
+struct hwtstamp_config {
+    int flags;           /**\u2264 no flags defined right now, must be zero */
+    int tx_type;         /**\u2264 HWTSTAMP_TX_* */
+    int rx_filter_type;  /**\u2264 HWTSTAMP_RX_* */
+};
+
+Desired behavior is passed into the kernel and to a specific device by
+calling ioctl(SIOCSHWTSTAMP) with a pointer to a struct ifreq whose
+ifr_data points to a struct hwtstamp_config. The tx_type and
+rx_filter_type are hints to the driver what it is expected to do. If
+the requested fine-grained filtering for incoming packets is not
+supported, the driver may time stamp more than just the requested types
+of packets.
+
+A driver which supports hardware time stamping shall update the struct
+with the actual, possibly more permissive configuration. If the
+requested packets cannot be time stamped, then nothing should be
+changed and ERANGE shall be returned (in contrast to EINVAL, which
+indicates that SIOCSHWTSTAMP is not supported at all).
+
+Only a processes with admin rights may change the configuration. User
+space is responsible to ensure that multiple processes don't interfere
+with each other and that the settings are reset.
+
+/** possible values for hwtstamp_config->tx_type */
+enum {
+	/**
+	 * no outgoing packet will need hardware time stamping;
+	 * should a packet arrive which asks for it, no hardware
+	 * time stamping will be done
+	 */
+	HWTSTAMP_TX_OFF,
+
+	/**
+	 * enables hardware time stamping for outgoing packets;
+	 * the sender of the packet decides which are to be
+	 * time stamped by setting SOF_TIMESTAMPING_TX_SOFTWARE
+	 * before sending the packet
+	 */
+	HWTSTAMP_TX_ON,
+};
+
+/** possible values for hwtstamp_config->rx_filter_type */
+enum {
+	/** time stamp no incoming packet at all */
+	HWTSTAMP_FILTER_NONE,
+
+	/** time stamp any incoming packet */
+	HWTSTAMP_FILTER_ALL,
+
+        /** return value: time stamp all packets requested plus some others */
+        HWTSTAMP_FILTER_SOME,
+
+	/** PTP v1, UDP, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_EVENT,
+
+        ...
+};
+
+
+DEVICE IMPLEMENTATION
+
+A driver which supports hardware time stamping must support the
+SIOCSHWTSTAMP ioctl. Time stamps for received packets must be stored
+in the skb with skb_hwtstamp_set().
+
+Time stamps for outgoing packets are to be generated as follows:
+- In hard_start_xmit(), check if skb_hwtstamp_check_tx_hardware()
+  returns non-zero. If yes, then the driver is expected
+  to do hardware time stamping.
+- If this is possible for the skb and requested, then declare
+  that the driver is doing the time stamping by calling
+  skb_hwtstamp_tx_in_progress(). A driver not supporting
+  hardware time stamping doesn't do that. A driver must never
+  touch sk_buff::tstamp! It is used to store how time stamping
+  for an outgoing packets is to be done.
+- As soon as the driver has sent the packet and/or obtained a
+  hardware time stamp for it, it passes the time stamp back by
+  calling skb_hwtstamp_tx() with the original skb, the raw
+  hardware time stamp and a handle to the device (necessary
+  to convert the hardware time stamp to system time). If obtaining
+  the hardware time stamp somehow fails, then the driver should
+  not fall back to software time stamping. The rationale is that
+  this would occur at a later time in the processing pipeline
+  than other software time stamping and therefore could lead
+  to unexpected deltas between time stamps.
+- If the driver did not call skb_hwtstamp_tx_in_progress(), then
+  dev_hard_start_xmit() checks whether software time stamping
+  is wanted as fallback and potentially generates the time stamp.
diff --git a/Documentation/networking/timestamping/Makefile b/Documentation/networking/timestamping/Makefile
new file mode 100644
index 0000000..7613c2d
--- /dev/null
+++ b/Documentation/networking/timestamping/Makefile
@@ -0,0 +1,32 @@
+# BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+#
+# Makefile for pc302 hardware timestamp testing
+#
+# Make sure the arm cross development environment is setup in the 
+# terminal window, then issue a 'make' command.
+#
+# The resulting 'timestamping' executable can then be copied to the 
+# root filesystem of the cpe20x platform and run.
+#
+
+CC=$(CROSS_COMPILE)gcc
+AR=$(CROSS_COMPILE)ar
+LD=$(CROSS_COMPILE)ld
+
+CFLAGS=-Wall -g
+CPPFLAGS=-I../../../include
+
+ARCH := $(shell $(CC) -dumpmachine)
+
+ifeq ("arm-none-linux-gnueabi", "$(TARGET_NAME)")
+    CPPFLAGS += -DARCH_ARM
+endif
+
+TARGET=timestamping
+
+$(TARGET): timestamping.o
+
+all:	$(TARGET)
+
+clean:
+	rm -f $(TARGET)
diff --git a/Documentation/networking/timestamping/timestamping b/Documentation/networking/timestamping/timestamping
new file mode 100755
index 0000000..1b3c9e6
Binary files /dev/null and b/Documentation/networking/timestamping/timestamping differ
diff --git a/Documentation/networking/timestamping/timestamping.c b/Documentation/networking/timestamping/timestamping.c
new file mode 100644
index 0000000..79f5751
--- /dev/null
+++ b/Documentation/networking/timestamping/timestamping.c
@@ -0,0 +1,470 @@
+/**
+ * This program demonstrates how the various time stamping features in
+ * the Linux kernel work. It emulates the behavior of a PTP
+ * implementation in stand-alone master mode by sending PTPv1 Sync
+ * multicasts once every second. It looks for similar packets, but
+ * beyond that doesn't actually implement PTP.
+ *
+ * Outgoing packets are time stamped with SO_TIMESTAMPING with or
+ * without hardware support.
+ *
+ * Incoming packets are time stamped with SO_TIMESTAMPING with or
+ * without hardware support, SIOCGSTAMP[NS] (per-socket time stamp) and
+ * SO_TIMESTAMP[NS].
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/select.h>
+#include <sys/ioctl.h>
+#include <arpa/inet.h>
+#include <net/if.h>
+
+#include "asm/types.h"
+#include "net/timestamping.h"
+#include "linux/errqueue.h"
+
+#ifndef SO_TIMESTAMPNS
+# define SO_TIMESTAMPNS 35
+#endif
+
+#ifndef SIOCGSTAMPNS
+# define SIOCGSTAMPNS 0x8907
+#endif
+
+static void usage(const char *error)
+{
+	if (error)
+		printf("invalid option: %s\n", error);
+	printf("timestamping interface (IP_MULTICAST_LOOP|SO_TIMESTAMP|SO_TIMESTAMPNS|SOF_TIMESTAMPING_TX_HARDWARE|SOF_TIMESTAMPING_TX_SOFTWARE|SOF_TIMESTAMPING_RX_HARDWARE|SOF_TIMESTAMPING_RX_SOFTWARE|SOF_TIMESTAMPING_SOFTWARE|SOF_TIMESTAMPING_SYS_HARDWARE|SOF_TIMESTAMPING_RAW_HARDWARE|SIOCGSTAMP|SIOCGSTAMPNS)*\n");
+	exit(1);
+}
+
+static void bail(const char *error)
+{
+	printf("%s: %s\n", error, strerror(errno));
+	exit(1);
+}
+
+static const unsigned char sync[] = {
+	0x00,0x01, 0x00,0x01,
+	0x5f,0x44, 0x46,0x4c,
+	0x54,0x00, 0x00,0x00,
+	0x00,0x00, 0x00,0x00,
+	0x00,0x00, 0x00,0x00,
+	0x01,0x01,
+
+	/* fake uuid */
+	0x00,0x01,
+	0x02,0x03, 0x04,0x05,
+
+	0x00,0x01, 0x00,0x37,
+	0x00,0x00, 0x00,0x08,
+	0x00,0x00, 0x00,0x00,
+	0x49,0x05, 0xcd,0x01,
+	0x29,0xb1, 0x8d,0xb0,
+	0x00,0x00, 0x00,0x00,
+	0x00,0x01,
+
+	/* fake uuid */
+	0x00,0x01,
+	0x02,0x03, 0x04,0x05,
+
+	0x00,0x00, 0x00,0x37,
+	0x00,0x00, 0x00,0x04,
+	0x44,0x46, 0x4c,0x54,
+	0x00,0x00, 0xf0,0x60,
+	0x00,0x01, 0x00,0x00,
+	0x00,0x00, 0x00,0x01,
+	0x00,0x00, 0xf0,0x60,
+	0x00,0x00, 0x00,0x00,
+	0x00,0x00, 0x00,0x04,
+	0x44,0x46, 0x4c,0x54,
+	0x00,0x01,
+
+	/* fake uuid */
+	0x00,0x01,
+	0x02,0x03, 0x04,0x05,
+
+	0x00,0x00, 0x00,0x00,
+	0x00,0x00, 0x00,0x00,
+	0x00,0x00, 0x00,0x00,
+	0x00,0x00, 0x00,0x00
+};
+
+static void sendpacket(int sock, struct sockaddr *addr, socklen_t addr_len)
+{
+	struct timeval now;
+	int res;
+
+	res = sendto(sock, sync, sizeof(sync), 0,
+		addr, addr_len);
+	gettimeofday(&now, 0);
+	if (res < 0)
+		printf("%s: %s\n", "send", strerror(errno));
+	else
+		printf("%ld.%06ld: sent %d bytes\n",
+			(long)now.tv_sec, (long)now.tv_usec,
+			res);
+}
+
+static void recvpacket(int sock, int recvmsg_flags,
+		int siocgstamp, int siocgstampns)
+{
+	char data[256];
+	struct timeval now;
+	struct msghdr msg;
+	struct iovec entry;
+	struct sockaddr_in from_addr;
+	struct {
+		struct cmsghdr cm;
+		char control[512];
+	} control;
+	int res;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &entry;
+	msg.msg_iovlen = 1;
+	entry.iov_base = data;
+	entry.iov_len = sizeof(data);
+	msg.msg_name = (caddr_t)&from_addr;
+	msg.msg_namelen = sizeof(from_addr);
+	msg.msg_control = &control;
+	msg.msg_controllen = sizeof(control);
+
+	res = recvmsg(sock, &msg, recvmsg_flags|MSG_DONTWAIT);
+	gettimeofday(&now, 0);
+	if (res < 0) {
+		printf("%s %s: %s\n",
+			"recvmsg",
+			(recvmsg_flags & MSG_ERRQUEUE) ? "error" : "regular",
+			strerror(errno));
+	} else {
+		struct cmsghdr *cmsg;
+		struct timeval tv;
+		struct timespec ts;
+
+		printf("%ld.%06ld: received %s data, %d bytes from %s, %d bytes control messages\n",
+			(long)now.tv_sec, (long)now.tv_usec,
+			(recvmsg_flags & MSG_ERRQUEUE) ? "error" : "regular",
+			res,
+			inet_ntoa(from_addr.sin_addr),
+			msg.msg_controllen);
+		for (cmsg = CMSG_FIRSTHDR(&msg);
+		     cmsg;
+		     cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+			printf("   cmsg len %d: ", cmsg->cmsg_len);
+			switch (cmsg->cmsg_level) {
+			case SOL_SOCKET:
+				printf("SOL_SOCKET ");
+				switch (cmsg->cmsg_type) {
+				case SO_TIMESTAMP: {
+					struct timeval *stamp =
+						(struct timeval *)CMSG_DATA(cmsg);
+					printf("SO_TIMESTAMP %ld.%06ld",
+						(long)stamp->tv_sec,
+						(long)stamp->tv_usec);
+					break;
+				}
+				case SO_TIMESTAMPNS: {
+					struct timespec *stamp =
+						(struct timespec *)CMSG_DATA(cmsg);
+					printf("SO_TIMESTAMPNS %ld.%09ld",
+						(long)stamp->tv_sec,
+						(long)stamp->tv_nsec);
+					break;
+				}
+				case SO_TIMESTAMPING: {
+					struct timespec *stamp =
+						(struct timespec *)CMSG_DATA(cmsg);
+					printf("SO_TIMESTAMPING ");
+					printf("SW %ld.%09ld ",
+						(long)stamp->tv_sec,
+						(long)stamp->tv_nsec);
+					stamp++;
+					printf("HW transformed %ld.%09ld ",
+						(long)stamp->tv_sec,
+						(long)stamp->tv_nsec);
+					stamp++;
+					printf("HW raw %ld.%09ld",
+						(long)stamp->tv_sec,
+						(long)stamp->tv_nsec);
+					break;
+				}
+				default:
+					printf("type %d", cmsg->cmsg_type);
+					break;
+				}
+				break;
+			case IPPROTO_IP:
+				printf("IPPROTO_IP ");
+				switch (cmsg->cmsg_type) {
+				case IP_RECVERR: {
+					struct sock_extended_err *err =
+						(struct sock_extended_err *)CMSG_DATA(cmsg);
+					printf("IP_RECVERR ee_errno '%s' ee_origin %d => %s",
+						strerror(err->ee_errno),
+						err->ee_origin,
+#ifdef SO_EE_ORIGIN_TIMESTAMPING
+						err->ee_origin == SO_EE_ORIGIN_TIMESTAMPING ?
+						"bounced packet" : "unexpected origin"
+#else
+						"probably SO_EE_ORIGIN_TIMESTAMPING"
+#endif
+						);
+					if (res < sizeof(sync))
+						printf(" => truncated data?!");
+					else if (!memcmp(sync, data + res - sizeof(sync),
+								sizeof(sync)))
+						printf(" => GOT OUR DATA BACK (HURRAY!)");
+					break;
+				}
+				case IP_PKTINFO: {
+					struct in_pktinfo *pktinfo =
+						(struct in_pktinfo *)CMSG_DATA(cmsg);
+					printf("IP_PKTINFO interface index %u",
+						pktinfo->ipi_ifindex);
+					break;
+				}
+				default:
+					printf("type %d", cmsg->cmsg_type);
+					break;
+				}
+				break;
+			default:
+				printf("level %d type %d",
+					cmsg->cmsg_level,
+					cmsg->cmsg_type);
+				break;
+			}
+			printf("\n");
+		}
+
+		if (siocgstamp) {
+			if (ioctl(sock, SIOCGSTAMP, &tv))
+				printf("   %s: %s\n", "SIOCGSTAMP", strerror(errno));
+			else
+				printf("SIOCGSTAMP %ld.%06ld\n",
+					(long)tv.tv_sec,
+					(long)tv.tv_usec);
+		}
+		if (siocgstampns) {
+			if (ioctl(sock, SIOCGSTAMPNS, &ts))
+				printf("   %s: %s\n", "SIOCGSTAMPNS", strerror(errno));
+			else
+				printf("SIOCGSTAMPNS %ld.%09ld\n",
+					(long)ts.tv_sec,
+					(long)ts.tv_nsec);
+		}
+	}
+}
+
+int main(int argc, char **argv)
+{
+	int so_timestamping_flags = 0;
+	int so_timestamp = 0;
+	int so_timestampns = 0;
+	int siocgstamp = 0;
+	int siocgstampns = 0;
+	int ip_multicast_loop = 0;
+	char *interface;
+	int i;
+	int enabled = 1;
+	int sock;
+	struct ifreq device;
+	struct ifreq hwtstamp;
+	struct hwtstamp_config hwconfig, hwconfig_requested;
+	struct sockaddr_in addr;
+	struct ip_mreq imr;
+	struct in_addr iaddr;
+	int val;
+	socklen_t len;
+	struct timeval next;
+
+	if (argc < 2)
+		usage(0);
+	interface = argv[1];
+
+	for (i = 2; i < argc; i++ ) {
+		if (!strcasecmp(argv[i], "SO_TIMESTAMP")) {
+			so_timestamp = 1;
+		} else if (!strcasecmp(argv[i], "SO_TIMESTAMPNS")) {
+			so_timestampns = 1;
+		} else if (!strcasecmp(argv[i], "SIOCGSTAMP")) {
+			siocgstamp = 1;
+		} else if (!strcasecmp(argv[i], "SIOCGSTAMPNS")) {
+			siocgstampns = 1;
+		} else if (!strcasecmp(argv[i], "IP_MULTICAST_LOOP")) {
+			ip_multicast_loop = 1;
+		} else if (!strcasecmp(argv[i], "SOF_TIMESTAMPING_TX_HARDWARE")) {
+			so_timestamping_flags |= SOF_TIMESTAMPING_TX_HARDWARE;
+		} else if (!strcasecmp(argv[i], "SOF_TIMESTAMPING_TX_SOFTWARE")) {
+			so_timestamping_flags |= SOF_TIMESTAMPING_TX_SOFTWARE;
+		} else if (!strcasecmp(argv[i], "SOF_TIMESTAMPING_RX_HARDWARE")) {
+			so_timestamping_flags |= SOF_TIMESTAMPING_RX_HARDWARE;
+		} else if (!strcasecmp(argv[i], "SOF_TIMESTAMPING_RX_SOFTWARE")) {
+			so_timestamping_flags |= SOF_TIMESTAMPING_RX_SOFTWARE;
+		} else if (!strcasecmp(argv[i], "SOF_TIMESTAMPING_SOFTWARE")) {
+			so_timestamping_flags |= SOF_TIMESTAMPING_SOFTWARE;
+		} else if (!strcasecmp(argv[i], "SOF_TIMESTAMPING_SYS_HARDWARE")) {
+			so_timestamping_flags |= SOF_TIMESTAMPING_SYS_HARDWARE;
+		} else if (!strcasecmp(argv[i], "SOF_TIMESTAMPING_RAW_HARDWARE")) {
+			so_timestamping_flags |= SOF_TIMESTAMPING_RAW_HARDWARE;
+		} else {
+			usage(argv[i]);
+		}
+	}
+
+	sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
+	if (socket < 0)
+		bail("socket");
+
+	memset(&device, 0, sizeof(device));
+	strncpy(device.ifr_name, interface, sizeof(device.ifr_name));
+	if (ioctl(sock, SIOCGIFADDR, &device) < 0)
+		bail("getting interface IP address");
+
+	memset(&hwtstamp, 0, sizeof(hwtstamp));
+	strncpy(hwtstamp.ifr_name, interface, sizeof(hwtstamp.ifr_name));
+	hwtstamp.ifr_data = (void *)&hwconfig;
+	memset(&hwconfig, 0, sizeof(&hwconfig));
+	hwconfig.tx_type =
+		(so_timestamping_flags & SOF_TIMESTAMPING_TX_HARDWARE) ?
+		HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;
+	hwconfig.rx_filter_type =
+		(so_timestamping_flags & SOF_TIMESTAMPING_RX_HARDWARE) ?
+		HWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE;
+	hwconfig_requested = hwconfig;
+	if (ioctl(sock, SIOCSHWTSTAMP, &hwtstamp) < 0) {
+		if ((errno == EINVAL || errno == ENOTSUP) &&
+			hwconfig_requested.tx_type == HWTSTAMP_TX_OFF &&
+			hwconfig_requested.rx_filter_type == HWTSTAMP_FILTER_NONE)
+			printf("SIOCSHWTSTAMP: disabling hardware time stamping not possible\n");
+		else
+			bail("SIOCSHWTSTAMP");
+	}
+	printf("SIOCSHWTSTAMP: tx_type %d requested, got %d; rx_filter_type %d requested, got %d\n",
+		hwconfig_requested.tx_type, hwconfig.tx_type,
+		hwconfig_requested.rx_filter_type, hwconfig.rx_filter_type);
+
+	/* bind to PTP port */
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = htonl(INADDR_ANY);
+	addr.sin_port = htons(319 /* PTP event port */);
+	if (bind(sock, (struct sockaddr*)&addr, sizeof(struct sockaddr_in)) < 0)
+		bail("bind");
+
+	/* set multicast group for outgoing packets */
+	inet_aton("224.0.1.130", &iaddr); /* alternate PTP domain 1 */
+	addr.sin_addr = iaddr;
+	imr.imr_multiaddr.s_addr = iaddr.s_addr;
+	imr.imr_interface.s_addr = ((struct sockaddr_in *)&device.ifr_addr)->sin_addr.s_addr;
+	if (setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF,
+			&imr.imr_interface.s_addr, sizeof(struct in_addr)) < 0)
+		bail("set multicast");
+
+	/* join multicast group, loop our own packet */
+	if (setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &imr, sizeof(struct ip_mreq)) < 0)
+		bail("join multicast group");
+
+	if (setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP, &ip_multicast_loop, sizeof(enabled)) < 0) {
+		bail("loop multicast");
+	}
+
+	/* set socket options for time stamping */
+	if (so_timestamp &&
+		setsockopt(sock, SOL_SOCKET, SO_TIMESTAMP, &enabled, sizeof(enabled)) < 0)
+		bail("setsockopt SO_TIMESTAMP");
+
+	if (so_timestampns &&
+		setsockopt(sock, SOL_SOCKET, SO_TIMESTAMPNS, &enabled, sizeof(enabled)) < 0)
+		bail("setsockopt SO_TIMESTAMPNS");
+
+	if (so_timestamping_flags &&
+		setsockopt(sock, SOL_SOCKET, SO_TIMESTAMPING, &so_timestamping_flags,
+               sizeof(so_timestamping_flags)) < 0)
+		bail("setsockopt SO_TIMESTAMPING");
+
+	/* request IP_PKTINFO for debugging purposes */
+	if (setsockopt(sock, SOL_IP, IP_PKTINFO, &enabled, sizeof(enabled)) < 0)
+		printf("%s: %s\n", "setsockopt IP_PKTINFO", strerror(errno));
+
+	/* verify socket options */
+	len = sizeof(val);
+	if (getsockopt(sock, SOL_SOCKET, SO_TIMESTAMP, &val, &len) < 0)
+		printf("%s: %s\n", "getsockopt SO_TIMESTAMP", strerror(errno));
+	else
+		printf("SO_TIMESTAMP %d\n", val);
+
+	if (getsockopt(sock, SOL_SOCKET, SO_TIMESTAMPNS, &val, &len) < 0)
+		printf("%s: %s\n", "getsockopt SO_TIMESTAMPNS", strerror(errno));
+	else
+		printf("SO_TIMESTAMPNS %d\n", val);
+
+	if (getsockopt(sock, SOL_SOCKET, SO_TIMESTAMPING, &val, &len) < 0) {
+		printf("%s: %s\n", "getsockopt SO_TIMESTAMPING", strerror(errno));
+	} else {
+		printf("SO_TIMESTAMPING %d\n", val);
+		if (val != so_timestamping_flags)
+			printf("   not the expected value %d\n", so_timestamping_flags);
+	}
+
+	/* send packets forever every five seconds */
+	gettimeofday(&next, 0);
+	next.tv_sec = (next.tv_sec + 1) / 5 * 5;
+	next.tv_usec = 0;
+	while(1) {
+		struct timeval now;
+		struct timeval delta;
+		long delta_us;
+		int res;
+		fd_set readfs, errorfs;
+
+		gettimeofday(&now, 0);
+		delta_us = (long)(next.tv_sec - now.tv_sec) * 1000000 +
+			(long)(next.tv_usec - now.tv_usec);
+		if (delta_us > 0) {
+			/* continue waiting for timeout or data */
+			delta.tv_sec = delta_us / 1000000;
+			delta.tv_usec = delta_us % 1000000;
+
+			FD_ZERO(&readfs);
+			FD_ZERO(&errorfs);
+			FD_SET(sock, &readfs);
+			FD_SET(sock, &errorfs);
+			printf("%ld.%06ld: select %ldus\n",
+				(long)now.tv_sec, (long)now.tv_usec,
+				delta_us);
+			res = select(sock + 1, &readfs, 0, &errorfs, &delta);
+			gettimeofday(&now, 0);
+			printf("%ld.%06ld: select returned: %d, %s\n",
+				(long)now.tv_sec, (long)now.tv_usec,
+				res,
+				res < 0 ? strerror(errno) : "success");
+			if (res > 0) {
+				if (FD_ISSET(sock, &readfs))
+					printf("ready for reading\n");
+				if (FD_ISSET(sock, &errorfs))
+					printf("has error\n");
+				recvpacket(sock, 0,
+					siocgstamp,
+					siocgstampns);
+				recvpacket(sock, MSG_ERRQUEUE,
+					siocgstamp,
+					siocgstampns);
+			}
+		} else {
+			/* write one packet */
+			sendpacket(sock, (struct sockaddr *)&addr, sizeof(addr));
+			next.tv_sec += 5;
+			continue;
+		}
+	}
+
+	return 0;
+}
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 9722f8b..2502b5b 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -49,10 +49,6 @@ config GENERIC_CLOCKEVENTS_BROADCAST
 	depends on GENERIC_CLOCKEVENTS
 	default y if SMP && !LOCAL_TIMERS
 
-config MMU
-	bool
-	default y
-
 config NO_IOPORT
 	bool
 	default n
@@ -195,6 +191,13 @@ source "kernel/Kconfig.freezer"
 
 menu "System Type"
 
+config MMU
+	bool "MMU-based Paged Memory Management Support"
+	default y
+	help
+	  Select if you want MMU-based virtualised addressing space
+	  support by paged memory management. If unsure, say 'Y'.
+
 choice
 	prompt "ARM system type"
 	default ARCH_VERSATILE
@@ -277,6 +280,15 @@ config ARCH_EP93XX
 	help
 	  This enables support for the Cirrus EP93xx series of CPUs.
 
+config ARCH_FIRECRACKER
+	bool "Firecracker"
+	select ARM_AMBA
+	select ARM_VIC
+        select GENERIC_GPIO
+	select ARCH_DISCONTIGMEM_ENABLE
+	help
+	  This enables support for systems based on the picoChip PC202, PC205 family of devices.
+
 config ARCH_FOOTBRIDGE
 	bool "FootBridge"
 	select FOOTBRIDGE
@@ -448,6 +460,16 @@ config ARCH_PNX4008
 	help
 	  This enables support for Philips PNX4008 mobile platform.
 
+config ARCH_PC302
+	bool "PC302"
+	select ARM_AMBA
+        select HAS_TLS_REG
+        select GENERIC_TIME
+        select GENERIC_CLOCKEVENTS
+        select GENERIC_GPIO
+	help
+	  This enables support for systems based on the picoChip PC302 device.
+
 config ARCH_PXA
 	bool "PXA2xx/PXA3xx-based"
 	depends on MMU
@@ -557,6 +579,8 @@ source "arch/arm/mach-ep93xx/Kconfig"
 
 source "arch/arm/mach-footbridge/Kconfig"
 
+source "arch/arm/mach-firecracker/Kconfig"
+
 source "arch/arm/mach-integrator/Kconfig"
 
 source "arch/arm/mach-iop32x/Kconfig"
@@ -575,6 +599,8 @@ source "arch/arm/mach-loki/Kconfig"
 
 source "arch/arm/mach-mv78xx0/Kconfig"
 
+source "arch/arm/mach-pc302/Kconfig"
+
 source "arch/arm/mach-pxa/Kconfig"
 
 source "arch/arm/mach-sa1100/Kconfig"
@@ -657,6 +683,105 @@ if !MMU
 source "arch/arm/Kconfig-nommu"
 endif
 
+config ARM_ERRATA_364296
+	bool "Enable partial low interrupt latency mode for ARM1136"
+	depends on CPU_V6 && !SMP
+	default n
+	help
+	  This options enables the workaround for the 364296 ARM1136
+	  r0pX errata (possible cache data corruption with
+	  hit-under-miss enabled). It sets the undocumented bit 31 in
+	  the auxiliary control register and the FI bit in the control
+	  register, thus disabling hit-under-miss without putting the
+	  processor into full low interrupt latency mode. ARM11MPCore
+	  is not affected.
+
+config ARM_ERRATA_411920
+	bool "Workaround for the global I cache invalidation on ARM1136"
+	depends on CPU_V6 && !SMP
+	default n
+	help
+	  Invalidation of the Instruction Cache operation can
+	  fail. This Erratum is present in 1136, 1156 and 1176. It
+	  does not affect the MPCore. This option enables the ARM Ltd.
+	  recommended workaround.
+
+config ARM_ERRATA_351422
+	bool "Spinlocks using LDREX and STREX instructions can livelock"
+	depends on CPU_V6 && SMP
+	default n
+	help
+	  According to the ARM11MPCore Erratum 351422 (r0p0), under
+	  extremely rare conditions, in an MPCore node consisting of
+	  at least 3 CPUs, two CPUs trying to perform a STREX to data
+	  on the same shared cache line can enter a livelock
+	  situation. This option adds variable spinning time to the
+	  locking routines.
+
+config ARM_ERRATA_430973
+	bool "Stale prediction on replaced interworking branch on Cortex-A8"
+	depends on CPU_V7
+	default n
+	help
+	  This option enables the workaround for the 430973 Cortex-A8
+	  (r1p0) erratum. If a code sequence containing an ARM/Thumb
+	  interworking branch is replaced with another code sequence
+	  at the same virtual address, whether due to self-modifying
+	  code or virtual to physical address re-mapping, Cortex-A8
+	  does not recover from the stale interworking branch
+	  prediction. This results in Cortex-A8 executing the new code
+	  sequence in the incorrect ARM or Thumb state.
+
+config ARM_ERRATA_458693
+	bool "Processor deadlock when a false hazard is created on Cortex-A8"
+	depends on CPU_V7
+	default n
+	help
+	  This option enables the workaround for the 458693 Cortex-A8
+	  (r2p0) erratum. For very specific sequences of memory
+	  operations, it is possible for a hazard condition intended
+	  for a cache line to instead be incorrectly associated with a
+	  different cache line. This false hazard might then cause a
+	  processor deadlock.
+
+config ARM_ERRATA_460075
+	bool "Data written to the L2 cache can be overwritten with stale data on Cortex-A8"
+	depends on CPU_V7
+	default n
+	help
+	  This option enables the workaround for the 458692 Cortex-A8
+	  (r2p0) erratum. Any asynchronous access to the L2 cache may
+	  encounter a situation in which recent store transactions to
+	  the L2 cache are lost and overwritten with stale memory
+	  contents from external memory.
+
+config ARM_ERRATUM_451034
+	bool "Enable workaround for ARM erratum 451034"
+	depends on VFPv3
+	help
+	  On Cortex-A8 r1p0 and r1p1, executing a NEON store with an integer
+	  store in the store buffer, can cause a processor deadlock under
+	  certain conditions.
+
+	  See ARM Cortex-A8 Errata Notice (PR120-PRDC-008070) for full details.
+
+	  Say Y to include a partial workaround.
+
+	  WARNING: Even with this option enabled, userspace code can trigger
+	  the deadlock.	 To safely run untrusted code, a different fix is
+	  required.
+
+config ARM_ERRATA_484863
+	bool "The Cache Sync operation does not guarantee that the the Eviction Buffer is empty"
+	depends on CACHE_L2X0
+	default n
+	help
+	  According to the L220 Erratum 484863, the actual behaviour of
+	  the L220 cache controller is that the Cache Sync operation
+	  only ensures that the Write Buffer and the Write Allocate
+	  Buffer are empty but not the Eviction Buffer. This option
+	  enables the first workaround from the Errata document.
+
 endmenu
 
 source "arch/arm/common/Kconfig"
@@ -690,7 +815,7 @@ config ISA_DMA_API
 	bool
 
 config PCI
-	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE
+	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE || ARCH_FIRECRACKER_PB
 	help
 	  Find out whether you have a PCI motherboard. PCI is the name of a
 	  bus system, i.e. the way the CPU talks to the other stuff inside
@@ -724,7 +849,7 @@ source "kernel/time/Kconfig"
 
 config SMP
 	bool "Symmetric Multi-Processing (EXPERIMENTAL)"
-	depends on EXPERIMENTAL && (REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP)
+	depends on EXPERIMENTAL && (REALVIEW_EB_ARM11MP || REALVIEW_EB_A9MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PBX)
 	select USE_GENERIC_SMP_HELPERS
 	help
 	  This enables support for systems with more than one CPU. If you have
@@ -781,7 +906,7 @@ config HOTPLUG_CPU
 
 config LOCAL_TIMERS
 	bool "Use local timer interrupts"
-	depends on SMP && (REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP)
+	depends on SMP && (REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || REALVIEW_EB_A9MP || MACH_REALVIEW_PBX)
 	default y
 	help
 	  Enable support for local timers on SMP platforms, rather then the
@@ -808,8 +933,26 @@ config HZ
 	default 200 if ARCH_EBSA110 || ARCH_S3C2410
 	default OMAP_32K_TIMER_HZ if ARCH_OMAP && OMAP_32K_TIMER
 	default AT91_TIMER_HZ if ARCH_AT91
+	default 1000 if ARCH_FIRECRACKER || ARCH_PC302
 	default 100
 
+config THUMB2_KERNEL
+	bool "Compile the kernel in Thumb-2 mode"
+	depends on CPU_V7 && EXPERIMENTAL
+	default n
+	select AEABI
+	select ARM_ASM_UNIFIED
+	help
+	  By enabling this option, the kernel will be compiled in
+	  Thumb-2 mode. A compiler/assembler that understand the unified
+	  ARM-Thumb syntax is needed.
+
+	  If unsure, say N.
+
+config ARM_ASM_UNIFIED
+	bool
+	default n
+
 config AEABI
 	bool "Use the ARM EABI to compile the kernel"
 	help
@@ -876,7 +1019,8 @@ config LEDS
 		   ARCH_OMAP || ARCH_P720T || ARCH_PXA_IDP || \
 		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE || \
 		   ARCH_AT91 || ARCH_DAVINCI || \
-		   ARCH_KS8695 || MACH_RD88F5182
+		   ARCH_KS8695 || MACH_RD88F5182 || ARCH_REALVIEW || \
+		   ARCH_FIRECRACKER
 	help
 	  If you say Y here, the LEDs on your machine will be used
 	  to provide useful information about your current system status.
@@ -1037,7 +1181,7 @@ endmenu
 
 menu "CPU Power Management"
 
-if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP || ARCH_IMX || ARCH_PXA)
+if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP || ARCH_IMX || ARCH_PXA || ARCH_REALVIEW)
 
 source "drivers/cpufreq/Kconfig"
 
@@ -1077,6 +1221,15 @@ config CPU_FREQ_PXA
 	default y
 	select CPU_FREQ_DEFAULT_GOV_USERSPACE
 
+config CPU_FREQ_REALVIEW
+	tristate "CPUfreq driver for ARM RealView platform"
+	depends on CPU_FREQ && MACH_REALVIEW_PB1176
+	default y
+	help
+	  This enables the CPUfreq driver for ARM RealView platform.
+
+	  If in doubt, say Y.
+
 endif
 
 source "drivers/cpuidle/Kconfig"
@@ -1276,6 +1429,10 @@ source "drivers/regulator/Kconfig"
 
 source "drivers/uio/Kconfig"
 
+source "drivers/picochip/Kconfig"
+
+source "drivers/perfcounters/Kconfig"
+
 endmenu
 
 source "fs/Kconfig"
diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug
index 192ee01..f34b02f 100644
--- a/arch/arm/Kconfig.debug
+++ b/arch/arm/Kconfig.debug
@@ -2,18 +2,29 @@ menu "Kernel hacking"
 
 source "lib/Kconfig.debug"
 
-# RMK wants arm kernels compiled with frame pointers so hardwire this to y.
+# RMK wants arm kernels compiled with frame pointers or stack unwinding.
 # If you know what you are doing and are willing to live without stack
 # traces, you can get a slightly smaller kernel by setting this option to
 # n, but then RMK will have to kill you ;).
 config FRAME_POINTER
 	bool
-	default y
+	default y if !ARM_UNWIND && !THUMB2_KERNEL
 	help
 	  If you say N here, the resulting kernel will be slightly smaller and
-	  faster. However, when a problem occurs with the kernel, the
-	  information that is reported is severely limited. Most people
-	  should say Y here.
+	  faster. However, if neither FRAME_POINTER nor ARM_UNWIND are enabled,
+	  when a problem occurs with the kernel, the information that is
+	  reported is severely limited.
+
+config ARM_UNWIND
+	bool "Enable stack unwinding support"
+	depends on AEABI && EXPERIMENTAL
+	default y
+	help
+	  This option enables stack unwinding support in the kernel
+	  using the information automatically generated by the
+	  compiler. The resulting kernel image is slightly bigger but
+	  the performance is not affected. Currently, this feature
+	  only works with EABI compilers. If unsure say Y.
 
 config DEBUG_USER
 	bool "Verbose user fault messages"
@@ -50,6 +61,57 @@ config DEBUG_STACK_USAGE
 	  Enables the display of the minimum amount of free stack which each
 	  task has ever had available in the sysrq-T output.
 
+config DEBUG_RVIDCC
+	bool "Include the RealView ICE DCC channel device driver"
+	depends on !DEBUG_ICEDCC
+	help
+	  Say Y here if you want a serial channel connected through ARM's
+	  RealView ICE emulator through to your debugging host.
+
+	  IMPORTANT: if you are not using one of the pre-configured platforms
+	  (notably ARM's Integrator or Versatile Platform) then you will need to
+	  configure interrupts for DCC and pass the IRQ numbers in the module
+	  parameters 'txirq' and 'rxirq', assuming they have been wired into your
+	  interrupt controller.
+
+	  If interrupts are not used then a timed polling scheme is used. This
+	  introduces poorer performance, using more CPU bandwidth and reducing
+	  communication throughput on DCC.
+
+	  This feature requires at least the RealView ICE 1.5 firmware version.
+
+config DEBUG_DCC_KGDB
+	bool "Use the RealView ICE DCC serial channel for KGDB debugging"
+	depends on DEBUG_RVIDCC && KGDB
+	help
+	  Say Y here if you want to remotely debug the kernel using gdb and the
+	  KGDB kernel debugging patches. Refer to the KGDB documentation for more
+	  details.
+
+	  Note that only one device can be enabled as the KGDB communications
+	  device, so if this is selected, then KGDB on serial devices or Ethernet
+	  must be deselected, or the kernel won't link.
+
+config DEBUG_DCC_RAW
+	bool "Disable virtual Ethernet on the RealView ICE DCC channel"
+	depends on DEBUG_RVIDCC
+	help
+	  Say Y here if you want to disable the virtual Ethernet facility
+	  of the RealView ICE.
+
+	  The virtual Ethernet facility provides both a serial channel and an
+	  Ethernet channel, and can be used for its serial channel even if
+	  Ethernet is not required. Using this has the advantage over raw
+	  DCC communications in that serial channel writes that do not have
+	  an integral multiple of 4 bytes are not stuffed with nulls to make
+	  the packet size.
+
+	  DCC communicates in 32-bit words and, in raw mode, data is packed in
+	  4 bytes per word. Individual write calls pack the data provided, padding
+	  any remainder with nulls. Any protocol using this channel must tolerate
+	  the embedded nulls. GDB is such a protocol, provided the driver is fed with
+	  complete packets, and not one byte at a time.
+
 # These options are only for real kernel hackers who want to get their hands dirty.
 config DEBUG_LL
 	bool "Kernel low-level debugging functions"
@@ -59,6 +121,14 @@ config DEBUG_LL
 	  in the kernel.  This is helpful if you are debugging code that
 	  executes before the console is initialized.
 
+config DEBUG_LL_CONSOLE
+	bool "Kernel early console"
+	depends on DEBUG_LL
+	help
+	  Say Y here if you want to have an early console using the Kernel
+	  low-level debugging functions. Add earlyprintk to your kernel
+	  parameters to enable this console.
+
 config DEBUG_ICEDCC
 	bool "Kernel low-level debugging via EmbeddedICE DCC channel"
 	depends on DEBUG_LL
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index bd6e281..e6a138a 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -11,6 +11,9 @@
 # Copyright (C) 1995-2001 by Russell King
 
 LDFLAGS_vmlinux	:=-p --no-undefined -X
+ifeq ($(CONFIG_CPU_ENDIAN_BE8),y)
+LDFLAGS_vmlinux	+= --be8
+endif
 CPPFLAGS_vmlinux.lds = -DTEXT_OFFSET=$(TEXT_OFFSET)
 OBJCOPYFLAGS	:=-O binary -R .note -R .note.gnu.build-id -R .comment -S
 GZFLAGS		:=-9
@@ -84,9 +87,19 @@ else
 CFLAGS_ABI	:=$(call cc-option,-mapcs-32,-mabi=apcs-gnu) $(call cc-option,-mno-thumb-interwork,)
 endif
 
+ifeq ($(CONFIG_ARM_UNWIND),y)
+CFLAGS_ABI	+=-funwind-tables
+endif
+
+ifeq ($(CONFIG_THUMB2_KERNEL),y)
+AFLAGS_NOWARN	:=$(call as-option,-Wa$(comma)-mno-warn-deprecated,-Wa$(comma)-W)
+CFLAGS_THUMB2	:=-mthumb $(AFLAGS_NOWARN)
+AFLAGS_THUMB2	:=-Wa$(comma)-mthumb $(AFLAGS_NOWARN)
+endif
+
 # Need -Uarm for gcc < 3.x
-KBUILD_CFLAGS	+=$(CFLAGS_ABI) $(arch-y) $(tune-y) $(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,)) -msoft-float -Uarm
-KBUILD_AFLAGS	+=$(CFLAGS_ABI) $(arch-y) $(tune-y) -msoft-float
+KBUILD_CFLAGS	+=$(CFLAGS_ABI) $(CFLAGS_THUMB2) $(arch-y) $(tune-y) $(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,)) -msoft-float -Uarm
+KBUILD_AFLAGS	+=$(CFLAGS_ABI) $(AFLAGS_THUMB2) $(arch-y) $(tune-y) -include asm/unified.h -msoft-float
 
 CHECKFLAGS	+= -D__arm__
 
@@ -124,6 +137,8 @@ endif
     plat-$(CONFIG_PLAT_S3C24XX)	   := s3c24xx s3c
  machine-$(CONFIG_ARCH_LH7A40X)	   := lh7a40x
  machine-$(CONFIG_ARCH_VERSATILE)  := versatile
+ machine-$(CONFIG_ARCH_FIRECRACKER)	:= firecracker
+ machine-$(CONFIG_ARCH_PC302)	:= pc302
  machine-$(CONFIG_ARCH_IMX)	   := imx
  machine-$(CONFIG_ARCH_H720X)	   := h720x
  machine-$(CONFIG_ARCH_AAEC2000)   := aaec2000
diff --git a/arch/arm/boot/Makefile b/arch/arm/boot/Makefile
index da226ab..b2b146d 100644
--- a/arch/arm/boot/Makefile
+++ b/arch/arm/boot/Makefile
@@ -61,7 +61,7 @@ endif
 
 quiet_cmd_uimage = UIMAGE  $@
       cmd_uimage = $(CONFIG_SHELL) $(MKIMAGE) -A arm -O linux -T kernel \
-		   -C none -a $(LOADADDR) -e $(LOADADDR) \
+		   -C none -a $(LOADADDR) -e $(STARTADDR) \
 		   -n 'Linux-$(KERNELRELEASE)' -d $< $@
 
 ifeq ($(CONFIG_ZBOOT_ROM),y)
@@ -70,6 +70,13 @@ else
 $(obj)/uImage: LOADADDR=$(ZRELADDR)
 endif
 
+ifeq ($(CONFIG_THUMB2_KERNEL),y)
+# Set bit 0 to 1 so that "mov pc, lr" switches to Thumb-2 mode
+$(obj)/uImage: STARTADDR=$(shell echo $(LOADADDR) | sed -e "s/.$$/1/")
+else
+$(obj)/uImage: STARTADDR=$(LOADADDR)
+endif
+
 $(obj)/uImage:	$(obj)/zImage FORCE
 	$(call if_changed,uimage)
 	@echo '  Image $@ is ready'
diff --git a/arch/arm/boot/compressed/Makefile b/arch/arm/boot/compressed/Makefile
index c47f2a3..6a591f0 100644
--- a/arch/arm/boot/compressed/Makefile
+++ b/arch/arm/boot/compressed/Makefile
@@ -82,6 +82,9 @@ EXTRA_AFLAGS  := -Wa,-march=all
 # linker symbols.  We only define initrd_phys and params_phys if the
 # machine class defined the corresponding makefile variable.
 LDFLAGS_vmlinux := --defsym zreladdr=$(ZRELADDR)
+ifeq ($(CONFIG_CPU_ENDIAN_BE8),y)
+LDFLAGS_vmlinux += --be8
+endif
 ifneq ($(INITRD_PHYS),)
 LDFLAGS_vmlinux += --defsym initrd_phys=$(INITRD_PHYS)
 endif
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index 84a1e04..72277d9 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -134,7 +134,8 @@ start:
 		tst	r2, #3			@ not user?
 		bne	not_angel
 		mov	r0, #0x17		@ angel_SWIreason_EnterSVC
-		swi	0x123456		@ angel_SWI_ARM
+ ARM(		swi	0x123456	)	@ angel_SWI_ARM
+ THUMB(		svc	0xab		)	@ angel_SWI_THUMB
 not_angel:
 		mrs	r2, cpsr		@ turn off interrupts to
 		orr	r2, r2, #0xc0		@ prevent angel from running
@@ -155,7 +156,9 @@ not_angel:
 
 		.text
 		adr	r0, LC0
-		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}
+ ARM(		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}	)
+ THUMB(		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip}	)
+ THUMB(		ldr	sp, [r0, #28]				)
 		subs	r0, r0, r1		@ calculate the delta offset
 
 						@ if delta is zero, we are
@@ -257,22 +260,25 @@ not_relocated:	mov	r0, #0
  * r6     = processor ID
  * r7     = architecture ID
  * r8     = atags pointer
- * r9-r14 = corrupted
+ * r9-r12,r14 = corrupted
  */
 		add	r1, r5, r0		@ end of decompressed kernel
 		adr	r2, reloc_start
 		ldr	r3, LC1
 		add	r3, r2, r3
-1:		ldmia	r2!, {r9 - r14}		@ copy relocation code
-		stmia	r1!, {r9 - r14}
-		ldmia	r2!, {r9 - r14}
-		stmia	r1!, {r9 - r14}
+1:		ldmia	r2!, {r9 - r12, r14}	@ copy relocation code
+		stmia	r1!, {r9 - r12, r14}
+		ldmia	r2!, {r9 - r12, r14}
+		stmia	r1!, {r9 - r12, r14}
 		cmp	r2, r3
 		blo	1b
-		add	sp, r1, #128		@ relocate the stack
+		mov	sp, r1
+		add	sp, sp, #128		@ relocate the stack
 
 		bl	cache_clean_flush
-		add	pc, r5, r0		@ call relocation code
+ ARM(		add	pc, r5, r0		) @ call relocation code
+ THUMB(		add	r12, r5, r0		)
+ THUMB(		mov	pc, r12			) @ call relocation code
 
 /*
  * We're not in danger of overwriting ourselves.  Do this the simple way.
@@ -285,6 +291,7 @@ wont_overwrite:	mov	r0, r4
 		bl	decompress_kernel
 		b	call_kernel
 
+		.align	2
 		.type	LC0, #object
 LC0:		.word	LC0			@ r1
 		.word	__bss_start		@ r2
@@ -399,8 +406,10 @@ __setup_mmu:	sub	r3, r4, #16384		@ Page directory size
 		orr	r1, r1, #3 << 10
 		add	r2, r3, #16384
 1:		cmp	r1, r9			@ if virt > start of RAM
+		it	hs
 		orrhs	r1, r1, #0x0c		@ set cacheable, bufferable
 		cmp	r1, r10			@ if virt > end of RAM
+		it	hs
 		bichs	r1, r1, #0x0c		@ clear cacheable, bufferable
 		str	r1, [r0], #4		@ 1:1 mapping
 		add	r1, r1, #1048576
@@ -425,6 +434,7 @@ ENDPROC(__setup_mmu)
 
 __armv4_mmu_cache_on:
 		mov	r12, lr
+#ifdef CONFIG_MMU
 		bl	__setup_mmu
 		mov	r0, #0
 		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
@@ -432,27 +442,41 @@ __armv4_mmu_cache_on:
 		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
 		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
 		orr	r0, r0, #0x0030
+#ifdef CONFIG_CPU_ENDIAN_BE8
+		orr	r0, r0, #1 << 25	@ big-endian page tables
+#endif
 		bl	__common_mmu_cache_on
 		mov	r0, #0
 		mcr	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
+#endif
 		mov	pc, r12
 
 __armv7_mmu_cache_on:
 		mov	r12, lr
+#ifdef CONFIG_MMU
 		mrc	p15, 0, r11, c0, c1, 4	@ read ID_MMFR0
 		tst	r11, #0xf		@ VMSA
+		it	ne
 		blne	__setup_mmu
 		mov	r0, #0
 		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
 		tst	r11, #0xf		@ VMSA
+		it	ne
 		mcrne	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
+#endif
 		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
 		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
 		orr	r0, r0, #0x003c		@ write buffer
+#ifdef CONFIG_CPU_ENDIAN_BE8
+		orr	r0, r0, #1 << 25	@ big-endian page tables
+#endif
+#ifdef CONFIG_MMU
+		itttt	ne
 		orrne	r0, r0, #1		@ MMU enabled
 		movne	r1, #-1
 		mcrne	p15, 0, r3, c2, c0, 0	@ load page table pointer
 		mcrne	p15, 0, r1, c3, c0, 0	@ load domain access control
+#endif
 		mcr	p15, 0, r0, c1, c0, 0	@ load control register
 		mrc	p15, 0, r0, c1, c0, 0	@ and read it back
 		mov	r0, #0
@@ -472,6 +496,7 @@ __arm6_mmu_cache_on:
 		mov	pc, r12
 
 __common_mmu_cache_on:
+#ifndef CONFIG_THUMB2_KERNEL
 #ifndef DEBUG
 		orr	r0, r0, #0x000d		@ Write buffer, mmu
 #endif
@@ -483,6 +508,7 @@ __common_mmu_cache_on:
 1:		mcr	p15, 0, r0, c1, c0, 0	@ load control register
 		mrc	p15, 0, r0, c1, c0, 0	@ and read it back to
 		sub	pc, lr, r0, lsr #32	@ properly flush pipeline
+#endif
 
 /*
  * All code following this line is relocatable.  It is relocated by
@@ -496,7 +522,7 @@ __common_mmu_cache_on:
  * r6     = processor ID
  * r7     = architecture ID
  * r8     = atags pointer
- * r9-r14 = corrupted
+ * r9-r12,r14 = corrupted
  */
 		.align	5
 reloc_start:	add	r9, r5, r0
@@ -505,13 +531,14 @@ reloc_start:	add	r9, r5, r0
 		mov	r1, r4
 1:
 		.rept	4
-		ldmia	r5!, {r0, r2, r3, r10 - r14}	@ relocate kernel
-		stmia	r1!, {r0, r2, r3, r10 - r14}
+		ldmia	r5!, {r0, r2, r3, r10 - r12, r14}	@ relocate kernel
+		stmia	r1!, {r0, r2, r3, r10 - r12, r14}
 		.endr
 
 		cmp	r5, r9
 		blo	1b
-		add	sp, r1, #128		@ relocate the stack
+		mov	sp, r1
+		add	sp, sp, #128		@ relocate the stack
 		debug_reloc_end
 
 call_kernel:	bl	cache_clean_flush
@@ -545,7 +572,10 @@ call_cache_fn:	adr	r12, proc_types
 		ldr	r2, [r12, #4]		@ get mask
 		eor	r1, r1, r6		@ (real ^ match)
 		tst	r1, r2			@       & mask
-		addeq	pc, r12, r3		@ call cache function
+		itt	eq
+ ARM(		addeq	pc, r12, r3		) @ call cache function
+ THUMB(		addeq	r12, r3			)
+ THUMB(		moveq	pc, r12			) @ call cache function
 		add	r12, r12, #4*5
 		b	1b
 
@@ -563,13 +593,15 @@ call_cache_fn:	adr	r12, proc_types
  * methods.  Writeback caches _must_ have the flush method
  * defined.
  */
+		.align	2
 		.type	proc_types,#object
 proc_types:
 		.word	0x41560600		@ ARM6/610
 		.word	0xffffffe0
-		b	__arm6_mmu_cache_off	@ works, but slow
-		b	__arm6_mmu_cache_off
+		W(b)	__arm6_mmu_cache_off	@ works, but slow
+		W(b)	__arm6_mmu_cache_off
 		mov	pc, lr
+ THUMB(		nop				)
 @		b	__arm6_mmu_cache_on		@ untested
 @		b	__arm6_mmu_cache_off
 @		b	__armv3_mmu_cache_flush
@@ -577,96 +609,107 @@ proc_types:
 		.word	0x00000000		@ old ARM ID
 		.word	0x0000f000
 		mov	pc, lr
+ THUMB(		nop				)
 		mov	pc, lr
+ THUMB(		nop				)
 		mov	pc, lr
+ THUMB(		nop				)
 
 		.word	0x41007000		@ ARM7/710
 		.word	0xfff8fe00
-		b	__arm7_mmu_cache_off
-		b	__arm7_mmu_cache_off
+		W(b)	__arm7_mmu_cache_off
+		W(b)	__arm7_mmu_cache_off
 		mov	pc, lr
+ THUMB(		nop				)
 
 		.word	0x41807200		@ ARM720T (writethrough)
 		.word	0xffffff00
-		b	__armv4_mmu_cache_on
-		b	__armv4_mmu_cache_off
+		W(b)	__armv4_mmu_cache_on
+		W(b)	__armv4_mmu_cache_off
 		mov	pc, lr
+ THUMB(		nop				)
 
 		.word	0x41007400		@ ARM74x
 		.word	0xff00ff00
-		b	__armv3_mpu_cache_on
-		b	__armv3_mpu_cache_off
-		b	__armv3_mpu_cache_flush
+		W(b)	__armv3_mpu_cache_on
+		W(b)	__armv3_mpu_cache_off
+		W(b)	__armv3_mpu_cache_flush
 		
 		.word	0x41009400		@ ARM94x
 		.word	0xff00ff00
-		b	__armv4_mpu_cache_on
-		b	__armv4_mpu_cache_off
-		b	__armv4_mpu_cache_flush
+		W(b)	__armv4_mpu_cache_on
+		W(b)	__armv4_mpu_cache_off
+		W(b)	__armv4_mpu_cache_flush
 
 		.word	0x00007000		@ ARM7 IDs
 		.word	0x0000f000
 		mov	pc, lr
+ THUMB(		nop				)
 		mov	pc, lr
+ THUMB(		nop				)
 		mov	pc, lr
+ THUMB(		nop				)
 
 		@ Everything from here on will be the new ID system.
 
 		.word	0x4401a100		@ sa110 / sa1100
 		.word	0xffffffe0
-		b	__armv4_mmu_cache_on
-		b	__armv4_mmu_cache_off
-		b	__armv4_mmu_cache_flush
+		W(b)	__armv4_mmu_cache_on
+		W(b)	__armv4_mmu_cache_off
+		W(b)	__armv4_mmu_cache_flush
 
 		.word	0x6901b110		@ sa1110
 		.word	0xfffffff0
-		b	__armv4_mmu_cache_on
-		b	__armv4_mmu_cache_off
-		b	__armv4_mmu_cache_flush
+		W(b)	__armv4_mmu_cache_on
+		W(b)	__armv4_mmu_cache_off
+		W(b)	__armv4_mmu_cache_flush
 
 		.word	0x56050000		@ Feroceon
 		.word	0xff0f0000
-		b	__armv4_mmu_cache_on
-		b	__armv4_mmu_cache_off
-		b	__armv5tej_mmu_cache_flush
+		W(b)	__armv4_mmu_cache_on
+		W(b)	__armv4_mmu_cache_off
+		W(b)	__armv5tej_mmu_cache_flush
 
 		@ These match on the architecture ID
 
 		.word	0x00020000		@ ARMv4T
 		.word	0x000f0000
-		b	__armv4_mmu_cache_on
-		b	__armv4_mmu_cache_off
-		b	__armv4_mmu_cache_flush
+		W(b)	__armv4_mmu_cache_on
+		W(b)	__armv4_mmu_cache_off
+		W(b)	__armv4_mmu_cache_flush
 
 		.word	0x00050000		@ ARMv5TE
 		.word	0x000f0000
-		b	__armv4_mmu_cache_on
-		b	__armv4_mmu_cache_off
-		b	__armv4_mmu_cache_flush
+		W(b)	__armv4_mmu_cache_on
+		W(b)	__armv4_mmu_cache_off
+		W(b)	__armv4_mmu_cache_flush
 
 		.word	0x00060000		@ ARMv5TEJ
 		.word	0x000f0000
-		b	__armv4_mmu_cache_on
-		b	__armv4_mmu_cache_off
-		b	__armv5tej_mmu_cache_flush
+		W(b)	__armv4_mmu_cache_on
+		W(b)	__armv4_mmu_cache_off
+		W(b)	__armv4_mmu_cache_flush
 
 		.word	0x0007b000		@ ARMv6
 		.word	0x000ff000
-		b	__armv4_mmu_cache_on
-		b	__armv4_mmu_cache_off
-		b	__armv6_mmu_cache_flush
+		W(b)	__armv4_mmu_cache_on
+		W(b)	__armv4_mmu_cache_off
+		W(b)	__armv6_mmu_cache_flush
 
 		.word	0x000f0000		@ new CPU Id
 		.word	0x000f0000
-		b	__armv7_mmu_cache_on
-		b	__armv7_mmu_cache_off
-		b	__armv7_mmu_cache_flush
+		W(b)	__armv7_mmu_cache_on
+		W(b)	__armv7_mmu_cache_off
+		W(b)	__armv7_mmu_cache_flush
 
 		.word	0			@ unrecognised type
 		.word	0
 		mov	pc, lr
+ THUMB(		nop				)
 		mov	pc, lr
+ THUMB(		nop				)
 		mov	pc, lr
+ THUMB(		nop				)
 
 		.size	proc_types, . - proc_types
 
@@ -701,22 +744,33 @@ __armv3_mpu_cache_off:
 		mov	pc, lr
 
 __armv4_mmu_cache_off:
+#ifdef CONFIG_MMU
 		mrc	p15, 0, r0, c1, c0
 		bic	r0, r0, #0x000d
 		mcr	p15, 0, r0, c1, c0	@ turn MMU and cache off
 		mov	r0, #0
 		mcr	p15, 0, r0, c7, c7	@ invalidate whole cache v4
 		mcr	p15, 0, r0, c8, c7	@ invalidate whole TLB v4
+#endif
 		mov	pc, lr
 
 __armv7_mmu_cache_off:
 		mrc	p15, 0, r0, c1, c0
+#ifdef CONFIG_MMU
 		bic	r0, r0, #0x000d
+#else
+		bic	r0, r0, #0x000c
+#endif
 		mcr	p15, 0, r0, c1, c0	@ turn MMU and cache off
 		mov	r12, lr
 		bl	__armv7_mmu_cache_flush
 		mov	r0, #0
+#ifdef CONFIG_MMU
 		mcr	p15, 0, r0, c8, c7, 0	@ invalidate whole TLB
+#endif
+		mcr	p15, 0, r0, c7, c5, 6	@ invalidate BTC
+		mcr	p15, 0, r0, c7, c10, 4	@ DSB
+		mcr	p15, 0, r0, c7, c5, 4	@ ISB
 		mov	pc, r12
 
 __arm6_mmu_cache_off:
@@ -762,6 +816,7 @@ __armv4_mpu_cache_flush:
 		bcs	1b			@ segments 7 to 0
 
 		teq	r2, #0
+		it	ne
 		mcrne	p15, 0, ip, c7, c5, 0	@ invalidate I cache
 		mcr	p15, 0, ip, c7, c10, 4	@ drain WB
 		mov	pc, lr
@@ -778,12 +833,13 @@ __armv6_mmu_cache_flush:
 __armv7_mmu_cache_flush:
 		mrc	p15, 0, r10, c0, c1, 5	@ read ID_MMFR1
 		tst	r10, #0xf << 16		@ hierarchical cache (ARMv7)
-		beq	hierarchical
 		mov	r10, #0
+		beq	hierarchical
 		mcr	p15, 0, r10, c7, c14, 0	@ clean+invalidate D
 		b	iflush
 hierarchical:
-		stmfd	sp!, {r0-r5, r7, r9-r11}
+		mcr	p15, 0, r10, c7, c10, 5	@ DMB
+		stmfd	sp!, {r0-r7, r9-r11}
 		mrc	p15, 1, r0, c0, c0, 1	@ read clidr
 		ands	r3, r0, #0x7000000	@ extract loc from clidr
 		mov	r3, r3, lsr #23		@ left align loc bit field
@@ -808,8 +864,12 @@ loop1:
 loop2:
 		mov	r9, r4			@ create working copy of max way size
 loop3:
-		orr	r11, r10, r9, lsl r5	@ factor way and cache number into r11
-		orr	r11, r11, r7, lsl r2	@ factor index number into r11
+ ARM(		orr	r11, r10, r9, lsl r5	) @ factor way and cache number into r11
+ ARM(		orr	r11, r11, r7, lsl r2	) @ factor index number into r11
+ THUMB(		lsl	r6, r9, r5		)
+ THUMB(		orr	r11, r10, r6		) @ factor way and cache number into r11
+ THUMB(		lsl	r6, r7, r2		)
+ THUMB(		orr	r11, r11, r6		) @ factor index number into r11
 		mcr	p15, 0, r11, c7, c14, 2	@ clean & invalidate by set/way
 		subs	r9, r9, #1		@ decrement the way
 		bge	loop3
@@ -820,12 +880,14 @@ skip:
 		cmp	r3, r10
 		bgt	loop1
 finished:
+		ldmfd	sp!, {r0-r7, r9-r11}
 		mov	r10, #0			@ swith back to cache level 0
 		mcr	p15, 2, r10, c0, c0, 0	@ select current cache level in cssr
-		ldmfd	sp!, {r0-r5, r7, r9-r11}
 iflush:
+		mcr	p15, 0, r10, c7, c10, 4	@ DSB
 		mcr	p15, 0, r10, c7, c5, 0	@ invalidate I+BTB
-		mcr	p15, 0, r10, c7, c10, 4	@ drain WB
+		mcr	p15, 0, r10, c7, c10, 4	@ DSB
+		mcr	p15, 0, r10, c7, c5, 4	@ ISB
 		mov	pc, lr
 
 __armv5tej_mmu_cache_flush:
@@ -846,15 +908,20 @@ __armv4_mmu_cache_flush:
 		mov	r2, #1024
 		mov	r2, r2, lsl r1		@ base dcache size *2
 		tst	r3, #1 << 14		@ test M bit
+		it	ne
 		addne	r2, r2, r2, lsr #1	@ +1/2 size if M == 1
 		mov	r3, r3, lsr #12
 		and	r3, r3, #3
 		mov	r11, #8
 		mov	r11, r11, lsl r3	@ cache line size in bytes
 no_cache_id:
-		bic	r1, pc, #63		@ align to longest cache line
+		mov	r1, pc
+		bic	r1, r1, #63		@ align to longest cache line
 		add	r2, r1, r2
-1:		ldr	r3, [r1], r11		@ s/w flush D cache
+1:
+ ARM(		ldr	r3, [r1], r11		) @ s/w flush D cache
+ THUMB(		ldr	r3, [r1]		) @ s/w flush D cache
+ THUMB(		add	r1, r1, r11		)
 		teq	r1, r2
 		bne	1b
 
@@ -874,6 +941,7 @@ __armv3_mpu_cache_flush:
  * memory, which again must be relocatable.
  */
 #ifdef DEBUG
+		.align	2
 		.type	phexbuf,#object
 phexbuf:	.space	12
 		.size	phexbuf, . - phexbuf
diff --git a/arch/arm/boot/compressed/misc.c b/arch/arm/boot/compressed/misc.c
index 65ce8ff..dd46b18 100644
--- a/arch/arm/boot/compressed/misc.c
+++ b/arch/arm/boot/compressed/misc.c
@@ -19,56 +19,14 @@
 unsigned int __machine_arch_type;
 
 #include <linux/string.h>
+#include <mach/uncompress.h>
 
 #ifdef STANDALONE_DEBUG
 #define putstr printf
+#elif defined(CONFIG_DEBUG_ICEDCC) || defined(CONFIG_DEBUG_RVIDCC)
+#define putstr icedcc_putstr
 #else
 
-static void putstr(const char *ptr);
-
-#include <linux/compiler.h>
-#include <mach/uncompress.h>
-
-#ifdef CONFIG_DEBUG_ICEDCC
-
-#ifdef CONFIG_CPU_V6
-
-static void icedcc_putc(int ch)
-{
-	int status, i = 0x4000000;
-
-	do {
-		if (--i < 0)
-			return;
-
-		asm volatile ("mrc p14, 0, %0, c0, c1, 0" : "=r" (status));
-	} while (status & (1 << 29));
-
-	asm("mcr p14, 0, %0, c0, c5, 0" : : "r" (ch));
-}
-
-#else
-
-static void icedcc_putc(int ch)
-{
-	int status, i = 0x4000000;
-
-	do {
-		if (--i < 0)
-			return;
-
-		asm volatile ("mrc p14, 0, %0, c0, c0, 0" : "=r" (status));
-	} while (status & 2);
-
-	asm("mcr p14, 0, %0, c1, c0, 0" : : "r" (ch));
-}
-
-#endif
-
-#define putc(ch)	icedcc_putc(ch)
-#define flush()	do { } while (0)
-#endif
-
 static void putstr(const char *ptr)
 {
 	char c;
@@ -330,3 +288,149 @@ int main()
 }
 #endif
 	
+#if defined(CONFIG_DEBUG_ICEDCC) || defined(CONFIG_DEBUG_RVIDCC)
+
+#define _DCC_ARM9_RBIT  (1 << 0)
+#define _DCC_ARM9_WBIT  (1 << 1)
+#define _DCC_ARM10_RBIT (1 << 7)
+#define _DCC_ARM10_WBIT (1 << 6)
+#define _DCC_ARM11_RBIT (1 << 30)
+#define _DCC_ARM11_WBIT (1 << 29)
+
+#define _READ_CORE_ID(x) { __asm__ ("mrc p15, 0, %0, c0, c0, 0\n" : "=r" (x)); \
+                           x = (x >> 4) & 0xFFF; }
+
+#define _WRITE_ARM9_DCC(x) __asm__ volatile ("mcr p14, 0, %0, c1, c0, 0\n" : : "r" (x))
+#define _READ_ARM9_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c1, c0, 0\n" : "=r" (x))
+#define _STATUS_ARM9_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c0, 0\n" : "=r" (x))
+#define _CAN_READ_ARM9_DCC(x) {_STATUS_ARM9_DCC(x); x &= _DCC_ARM9_RBIT;}
+#define _CAN_WRITE_ARM9_DCC(x) {_STATUS_ARM9_DCC(x); x &= _DCC_ARM9_WBIT; x = (x==0);}
+
+#define _WRITE_ARM10_DCC(x) __asm__ volatile ("mcr p14, 0, %0, c0, c5, 0\n" : : "r" (x))
+#define _READ_ARM10_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c5, 0\n" : "=r" (x))
+#define _STATUS_ARM10_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c1, 0\n" : "=r" (x))
+#define _CAN_READ_ARM10_DCC(x) {_STATUS_ARM10_DCC(x); x &= _DCC_ARM10_RBIT;}
+#define _CAN_WRITE_ARM10_DCC(x) {_STATUS_ARM10_DCC(x); x &= _DCC_ARM10_WBIT; x = (x==0);}
+
+#define _WRITE_ARM11_DCC(x) __asm__ volatile ("mcr p14, 0, %0, c0, c5, 0\n" : : "r" (x))
+#define _READ_ARM11_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c5, 0\n" : "=r" (x))
+#define _STATUS_ARM11_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c1, 0\n" : "=r" (x))
+#define _CAN_READ_ARM11_DCC(x) {_STATUS_ARM11_DCC(x); x &= _DCC_ARM11_RBIT;}
+#define _CAN_WRITE_ARM11_DCC(x) {_STATUS_ARM11_DCC(x); x &= _DCC_ARM11_WBIT; x = (x==0);}
+
+#define TIMEOUT_COUNT 0x4000000
+
+void icedcc_putc(unsigned int ch)
+{
+    static enum {unknown, arm9_and_earlier, arm10, arm11_and_later} _arm_type = unknown;
+    static int has_timed_out = 0;
+
+    if (has_timed_out)
+        return;
+
+    if (_arm_type == unknown)
+    {
+        register unsigned int id;
+        _READ_CORE_ID(id);
+
+        if ((id & 0xF00) == 0xA00)
+            _arm_type = arm10;
+        else if (id >= 0xb00)
+            _arm_type = arm11_and_later;
+        else
+            _arm_type = arm9_and_earlier;
+    }
+
+    if (_arm_type == arm9_and_earlier)
+    {
+        register unsigned int reg;
+        unsigned int timeout_count = TIMEOUT_COUNT;
+        while (--timeout_count)
+        {
+            _CAN_WRITE_ARM9_DCC(reg);
+            if (reg)
+                break;
+        }
+        if (timeout_count == 0)
+            has_timed_out = 1;
+        else
+            _WRITE_ARM9_DCC(ch);
+    }
+    else if (_arm_type == arm10)
+    {
+        register unsigned int reg;
+        unsigned int timeout_count = TIMEOUT_COUNT;
+        while (--timeout_count)
+        {
+            _CAN_WRITE_ARM10_DCC(reg);
+            if (reg)
+                break;
+        }
+        if (timeout_count == 0)
+            has_timed_out = 1;
+        else
+            _WRITE_ARM10_DCC(ch);
+    }
+    else
+    {
+        register unsigned int reg;
+        unsigned int timeout_count = TIMEOUT_COUNT;
+        while (--timeout_count)
+        {
+            _CAN_WRITE_ARM11_DCC(reg);
+            if (reg)
+                break;
+        }
+        if (timeout_count == 0)
+            has_timed_out = 1;
+        else
+            _WRITE_ARM11_DCC(ch);
+    }
+}
+
+static void icedcc_putstr(const char *ptr)
+{
+#if defined(CONFIG_DEBUG_ICEDCC)
+	for (; *ptr != '\0'; ptr++)
+		icedcc_putc(*ptr);
+#else
+    unsigned int sendbuf[16];
+    unsigned short cnt;
+    char *ptr1 = (char*)&sendbuf[1];
+    unsigned int *wordptr;
+
+    for (cnt=0; *ptr != '\0'; ptr++)
+    {
+        if (*ptr == '\n')
+        {
+            *ptr1++ = '\r';
+            cnt++;
+        }
+        *ptr1++ = *ptr;
+        cnt++;
+    }
+
+    *sendbuf = 0xa5580000 | cnt;
+
+    while(cnt % 4)
+    {
+        *ptr1++ = '\0';
+        cnt++;
+    }
+
+    cnt /= 4;
+
+#ifdef CONFIG_DEBUG_DCC_RAW
+    wordptr = &sendbuf[1];
+#else
+    wordptr = &sendbuf[0];
+    cnt++;
+#endif
+
+    while(cnt--)
+        icedcc_putc(*wordptr++);
+
+#endif
+}
+
+#endif
diff --git a/arch/arm/boot/compressed/vmlinux.lds.in b/arch/arm/boot/compressed/vmlinux.lds.in
index 153a07e..a5924b9 100644
--- a/arch/arm/boot/compressed/vmlinux.lds.in
+++ b/arch/arm/boot/compressed/vmlinux.lds.in
@@ -11,6 +11,11 @@ OUTPUT_ARCH(arm)
 ENTRY(_start)
 SECTIONS
 {
+  /DISCARD/ : {
+    *(.ARM.exidx*)
+    *(.ARM.extab*)
+  }
+
   . = TEXT_START;
   _text = .;
 
diff --git a/arch/arm/common/Makefile b/arch/arm/common/Makefile
index 325e4b6..e6bdb96 100644
--- a/arch/arm/common/Makefile
+++ b/arch/arm/common/Makefile
@@ -17,3 +17,5 @@ obj-$(CONFIG_SHARP_SCOOP)	+= scoop.o
 obj-$(CONFIG_ARCH_IXP2000)	+= uengine.o
 obj-$(CONFIG_ARCH_IXP23XX)	+= uengine.o
 obj-$(CONFIG_PCI_HOST_ITE8152)  += it8152.o
+obj-$(CONFIG_DEBUG_RVIDCC)	+= rvidcc.o
+rvidcc-objs			:= rvidcc_common.o rvidcc_linux.o
diff --git a/arch/arm/common/rvidcc_common.c b/arch/arm/common/rvidcc_common.c
new file mode 100644
index 0000000..3e21709
--- /dev/null
+++ b/arch/arm/common/rvidcc_common.c
@@ -0,0 +1,794 @@
+/* 
+   Copyright (C) 2004-2007 ARM Limited.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License version 2
+   as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+   As a special exception, if other files instantiate templates or use macros
+   or inline functions from this file, or you compile this file and link it
+   with other works to produce a work based on this file, this file does not
+   by itself cause the resulting work to be covered by the GNU General Public
+   License. However the source code for this file must still be made available
+   in accordance with section (3) of the GNU General Public License.
+
+   This exception does not invalidate any other reasons why a work based on
+   this file might be covered by the GNU General Public License.
+*/
+
+/*     ================================================================
+       Universal RealView ICE DCC communications driver - How to use it
+       ================================================================
+
+   This driver is split into 2 sections: a generic section (this file) that
+   handles the DCC hardware access and buffering and an OS-dependent file that
+   integrates the driver into the OS network and TTY layers.  The interface
+   between the sections is defined in rvidcc_interface.h, which contains
+   prototypes and documentation for the functions in the generic section that
+   can be called from the OS-dependent section and the callback functions
+   called from the generic section that must be provided by the OS-dependent
+   section.
+
+   This driver is designed to be able to work with or without interrupts, to
+   use raw DCC comms (as a TTY) or virtual Ethernet.  The driver is configured
+   in the rvidcc_config.h header, including options to select which cores to
+   support, whether to support ethernet, buffer sizes and how to
+   enable/disable interrupts.  See the example configs for details of all
+   options.
+
+   All buffers used by the driver are in the system memory space.  All
+   pointer arguments for functions called by or from the generic section are
+   pointers to system memory.  It is the responsibility of the OS-dependent
+   section to copy to/from user memory.
+
+   ARM Ltd. highly recommends using interrupt-driven DCC communications, and
+   to use the virtual Ethernet system, even if only a TTY is required.
+
+   Raw DCC communications transfers data in 32-bit words. Thus if virtual
+   Ethernet is not used, data transfers will contain null padding for blocks
+   of data that do not have a multiple of 4 bytes. For most command-line
+   applications, this is unacceptable. However protocols, such as the remote
+   gdb protocol, will tolerate the extra nulls, provided they occur between
+   packets. This, of course, requires that data be passed to the driver as
+   packets, and not as byte-by-byte as some TTY drivers are in the habit of
+   doing.
+
+   Using the virtual Ethernet system does not force you to have to support
+   networking, or an IP stack, etc. The virtual Ethernet system contains a
+   TTY channel and an Ethernet channel, and if only the TTY channel is
+   required, the Ethernet channel and its data can be ignored. Using this
+   for TTY only has the advantage that data packets do not have to be a
+   multiple of 4 bytes, and so it is suitable for command-line consoles.
+
+   The virtual Ethernet system is not true Ethernet in that it can only carry
+   IP traffic. It does, however, have a mechanism for obtaining a unique MAC
+   address from the ICE, and the target will receive ARP-style queries to
+   determine if the target has a particular IP address. Thus DHCP can be used
+   to obtain an IP address from an external DHCP server, without the need for
+   any special configuration of the ICE.
+*/
+
+#include "rvidcc_config.h"
+#include "rvidcc_interface.h"
+
+
+#ifdef __ARMCC_VERSION
+#define INLINE __inline
+#else
+#define INLINE inline
+#endif
+
+
+#ifndef RVIDCC_RAW
+
+#define UNCOMP_TTY_START 0xa5580000
+#define UNCOMP_ETH_START 0xa55a0000
+#define START_MASK       0xfffc0000
+#define START_SENTINEL   UNCOMP_TTY_START
+
+#endif /* RVIDCC_RAW */
+
+#if !defined(RVIDCC_ARM79) && !defined(RVIDCC_ARM10) && !defined(RVIDCC_ARM11)
+#warning No cores are enabled.  Define at least one of RVIDCC_ARM79, RVIDCC_ARM10 or RVIDCC_ARM11
+#endif
+
+
+#define DCC_ARM9_RBIT  (1 << 0)
+#define DCC_ARM9_WBIT  (1 << 1)
+#define DCC_ARM10_RBIT (1 << 7)
+#define DCC_ARM10_WBIT (1 << 6)
+#define DCC_ARM11_RBIT (1 << 30)
+#define DCC_ARM11_WBIT (1 << 29)
+
+/* Access primitives: x must be unsigned int */
+
+#ifdef __ARMCC_VERSION
+
+/* RVCT versions */
+#define READ_CORE_ID(x) { __asm { mrc p15, 0, x, c0, c0, 0 } \
+                           x = (x >> 4) & 0xFFF; }
+
+#ifdef RVIDCC_ARM79
+#define WRITE_ARM9_DCC(x) __asm { mcr p14, 0, x, c1, c0, 0 }
+#define READ_ARM9_DCC(x) __asm { mrc p14, 0, x, c1, c0, 0 }
+#define STATUS_ARM9_DCC(x) __asm { mrc p14, 0, x, c0, c0, 0 }
+#define CAN_READ_ARM9_DCC(x) {STATUS_ARM9_DCC(x); x &= DCC_ARM9_RBIT;}
+#define CAN_WRITE_ARM9_DCC(x) {STATUS_ARM9_DCC(x); x &= DCC_ARM9_WBIT; x = (x==0);}
+#endif
+
+#ifdef RVIDCC_ARM10
+#define WRITE_ARM10_DCC(x) __asm { mcr p14, 0, x, c0, c5, 0 }
+#define READ_ARM10_DCC(x) __asm { mrc p14, 0, x, c0, c5, 0 }
+#define STATUS_ARM10_DCC(x) __asm { mrc p14, 0, x, c0, c1, 0 }
+#define CAN_READ_ARM10_DCC(x) {STATUS_ARM10_DCC(x); x &= DCC_ARM10_RBIT;}
+#define CAN_WRITE_ARM10_DCC(x) {STATUS_ARM10_DCC(x); x &= DCC_ARM10_WBIT; x = (x==0);}
+#endif
+
+#ifdef RVIDCC_ARM11
+#define WRITE_ARM11_DCC(x) __asm { mcr p14, 0, x, c0, c5, 0 }
+#define READ_ARM11_DCC(x) __asm { mrc p14, 0, x, c0, c5, 0 }
+#define STATUS_ARM11_DCC(x) __asm { mrc p14, 0, x, c0, c1, 0 }
+#define CAN_READ_ARM11_DCC(x) {STATUS_ARM11_DCC(x); x &= DCC_ARM11_RBIT;}
+#define CAN_WRITE_ARM11_DCC(x) {STATUS_ARM11_DCC(x); x &= DCC_ARM11_WBIT; x = (x==0);}
+#endif
+
+#else
+
+/* GCC versions */
+#define READ_CORE_ID(x) { __asm__ ("mrc p15, 0, %0, c0, c0, 0\n" : "=r" (x)); \
+                           x = (x >> 4) & 0xFFF; }
+
+#ifdef RVIDCC_ARM79
+#define WRITE_ARM9_DCC(x) __asm__ volatile ("mcr p14, 0, %0, c1, c0, 0\n" : : "r" (x))
+#define READ_ARM9_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c1, c0, 0\n" : "=r" (x))
+#define STATUS_ARM9_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c0, 0\n" : "=r" (x))
+#define CAN_READ_ARM9_DCC(x) {STATUS_ARM9_DCC(x); x &= DCC_ARM9_RBIT;}
+#define CAN_WRITE_ARM9_DCC(x) {STATUS_ARM9_DCC(x); x &= DCC_ARM9_WBIT; x = (x==0);}
+#endif
+
+#ifdef RVIDCC_ARM10
+#define WRITE_ARM10_DCC(x) __asm__ volatile ("mcr p14, 0, %0, c0, c5, 0\n" : : "r" (x))
+#define READ_ARM10_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c5, 0\n" : "=r" (x))
+#define STATUS_ARM10_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c1, 0\n" : "=r" (x))
+#define CAN_READ_ARM10_DCC(x) {STATUS_ARM10_DCC(x); x &= DCC_ARM10_RBIT;}
+#define CAN_WRITE_ARM10_DCC(x) {STATUS_ARM10_DCC(x); x &= DCC_ARM10_WBIT; x = (x==0);}
+#endif
+
+#ifdef RVIDCC_ARM11
+#define WRITE_ARM11_DCC(x) __asm__ volatile ("mcr p14, 0, %0, c0, c5, 0\n" : : "r" (x))
+#define READ_ARM11_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c5, 0\n" : "=r" (x))
+#define STATUS_ARM11_DCC(x) __asm__ volatile ("mrc p14, 0, %0, c0, c1, 0\n" : "=r" (x))
+#define CAN_READ_ARM11_DCC(x) {STATUS_ARM11_DCC(x); x &= DCC_ARM11_RBIT;}
+#define CAN_WRITE_ARM11_DCC(x) {STATUS_ARM11_DCC(x); x &= DCC_ARM11_WBIT; x = (x==0);}
+#endif
+
+#endif
+
+static enum {arm9_and_earlier, arm10, arm11_and_later} arm_type = arm9_and_earlier;
+
+/* Prototypes */
+static void rvidcc_write_lowlevel(const void *ptr, size_t len);
+
+/* Queues */
+
+struct ringbuffer
+{
+    unsigned char *buf;
+    size_t size;
+    unsigned char* readPtr;
+    unsigned char* writePtr;
+};
+
+static unsigned char dcc_inbuffer[RVIDCC_BUFSIZE];
+static struct ringbuffer dcc_inbuf;
+static unsigned char dcc_outbuffer[RVIDCC_BUFSIZE];
+static struct ringbuffer dcc_outbuf;
+
+#ifndef RVIDCC_RAW
+#define DCC_TTY_INBUF_SIZE (RVIDCC_BUFSIZE/2)
+static unsigned char dcc_temp_source[DCC_TTY_INBUF_SIZE];
+static unsigned char dcc_tty_inbuffer[DCC_TTY_INBUF_SIZE];
+static struct ringbuffer dcc_tty_inbuf;
+#define DCC_TTY_INBUF      dcc_tty_inbuf
+
+#else
+
+#define DCC_TTY_INBUF      dcc_inbuf
+
+#endif
+
+
+/* This ringbuffer has no locks as it assumes only 1 reader and 1 writer and
+ * assumes a 32-bit access is atomic */
+INLINE static void ringbuf_advance_read(struct ringbuffer* ring_buf, size_t amount)
+{
+    unsigned char* temptr = ring_buf->readPtr + amount;
+    while (temptr >= ring_buf->buf + ring_buf->size)
+        temptr -= ring_buf->size;
+    ring_buf->readPtr = temptr;
+}
+
+
+INLINE static void ringbuf_advance_write(struct ringbuffer* ring_buf, size_t amount)
+{
+    unsigned char* temptr = ring_buf->writePtr + amount;
+    while (temptr >= ring_buf->buf + ring_buf->size)
+        temptr -= ring_buf->size;
+    ring_buf->writePtr = temptr;
+}
+
+
+INLINE static void ringbuf_get(struct ringbuffer* ring_buf,
+                        unsigned char* dst, size_t amount)
+{
+    unsigned char* source = ring_buf->readPtr;
+    size_t len_to_end = ring_buf->buf + ring_buf->size - source;
+    if (amount > len_to_end)
+    {
+        memcpy(dst, source, len_to_end);
+        memcpy(dst + len_to_end, ring_buf->buf, (amount - len_to_end));
+    }
+    else
+        memcpy(dst, source, amount);
+}
+
+
+INLINE static void ringbuf_put(struct ringbuffer* ring_buf,
+                        unsigned char* src, size_t amount)
+{
+    unsigned char* dest = ring_buf->writePtr;
+    unsigned int len_to_end = ring_buf->buf + ring_buf->size - dest;
+    if (amount > len_to_end)
+    {
+        memcpy(dest, src, len_to_end);
+        memcpy(ring_buf->buf, src + len_to_end, amount - len_to_end);
+    }
+    else
+        memcpy(dest, src, amount);
+}
+
+
+INLINE static size_t ringbuf_available_data(struct ringbuffer* ring_buf)
+{
+    int avail = ring_buf->writePtr - ring_buf->readPtr;
+
+    if (avail < 0)
+        /* handle wrap around */
+        avail += ring_buf->size;
+
+    return (size_t)avail;
+}
+
+
+INLINE static size_t ringbuf_available_space(struct ringbuffer* ring_buf)
+{
+    size_t avail;
+
+    if (ring_buf->writePtr >= ring_buf->readPtr)
+        avail = ring_buf->size - (ring_buf->writePtr - ring_buf->readPtr) - 1;
+    else
+        avail = ring_buf->readPtr - ring_buf->writePtr - 1;
+
+    return avail;
+}
+
+
+// conditionally swap endian of a 32bit word
+#ifdef RVIDCC_BIG_ENDIAN
+#define to_little_endian(x) ((((x)&0xff) << 24) | (((x)&0xff00) << 8) | (((x)&0xff0000) >> 8) | (((x)&0xff000000) >> 24))
+#else
+#define to_little_endian(x) (x)
+#endif
+
+
+int rvidcc_init(void)
+{
+    register unsigned int id;
+    int err = 0;
+#ifndef RVIDCC_RAW
+    unsigned int macRequest = to_little_endian(UNCOMP_ETH_START);
+#endif
+
+    RVIDCC_DISABLE_INTERRUPTS;
+
+    /* check core type, raising error if core not supported */
+    READ_CORE_ID(id);
+    if ((id & 0xF00) == 0xA00)
+    {
+        arm_type = arm10;
+#ifndef RVIDCC_ARM10
+        err = RVIDCC_ERR_CORE_NOT_SUPPORTED;
+#endif
+    }
+    else if (id >= 0xb00)
+    {
+        arm_type = arm11_and_later;
+#ifndef RVIDCC_ARM11
+        err = RVIDCC_ERR_CORE_NOT_SUPPORTED;
+#endif
+    }
+    else
+    {
+        arm_type = arm9_and_earlier;
+#ifndef RVIDCC_ARM79
+        err = RVIDCC_ERR_CORE_NOT_SUPPORTED;
+#endif
+    }
+
+    if (!err)
+    {
+        dcc_inbuf.buf = dcc_inbuffer;
+        dcc_inbuf.size = RVIDCC_BUFSIZE;
+        dcc_inbuf.readPtr  = dcc_inbuf.buf;
+        dcc_inbuf.writePtr = dcc_inbuf.buf;
+
+        dcc_outbuf.buf = dcc_outbuffer;
+        dcc_outbuf.size = RVIDCC_BUFSIZE;
+        dcc_outbuf.readPtr  = dcc_outbuf.buf;
+        dcc_outbuf.writePtr = dcc_outbuf.buf;
+
+#ifndef RVIDCC_RAW
+        dcc_tty_inbuf.buf = dcc_tty_inbuffer;
+        dcc_tty_inbuf.size = DCC_TTY_INBUF_SIZE;
+        dcc_tty_inbuf.readPtr  = dcc_tty_inbuf.buf;
+        dcc_tty_inbuf.writePtr = dcc_tty_inbuf.buf;
+
+        /* request a MAC address */
+        rvidcc_write_lowlevel(&macRequest, sizeof(unsigned int));
+#endif
+
+        /* Enable interrupts (write interrupt will be enabled when something is written) */
+        RVIDCC_ENABLE_READ_INTERRUPT;
+        RVIDCC_ENABLE_INTERRUPTS;
+    }
+
+    return err;
+}
+
+
+void rvidcc_write(void)
+{
+    register unsigned int reg;
+    int pollcount = -1;
+    int some_transfer = 0;
+
+    switch (arm_type)
+    {
+#ifdef RVIDCC_ARM79
+    case arm9_and_earlier:
+    {
+        /* Try to write everything available */
+        while (ringbuf_available_data(&dcc_outbuf) >= sizeof(unsigned int))
+        {
+            /* On the first word, the write is aborted immediately if the DCC write
+             * register is full.  On subsequent words, the driver waits for a
+             * bit (RVIDCC_MAX_INLINE_POLLS times) as the RVI will probably
+             * read the DCC register soon because it knows data is being sent. */
+            do
+            {
+                CAN_WRITE_ARM9_DCC(reg);
+            } while (!reg && pollcount != -1 && --pollcount > 0);
+
+            if (!reg)
+                break;
+
+            reg = to_little_endian(*(unsigned int *)dcc_outbuf.readPtr);
+            WRITE_ARM9_DCC(reg);
+            ringbuf_advance_read(&dcc_outbuf, sizeof(unsigned int));
+            pollcount = RVIDCC_MAX_INLINE_POLLS;
+            some_transfer = 1;
+        }
+
+        pollcount = -1;
+        break;
+    }
+#endif
+
+#ifdef RVIDCC_ARM10
+    case arm10:
+    {
+        /* Try to write everything available */
+        while (ringbuf_available_data(&dcc_outbuf) >= sizeof(unsigned int))
+        {
+            do
+            {
+                CAN_WRITE_ARM10_DCC(reg);
+            } while (!reg && pollcount != -1 && --pollcount > 0);
+
+            if (!reg)
+                break;
+
+            reg = to_little_endian(*(unsigned int *)dcc_outbuf.readPtr);
+            WRITE_ARM10_DCC(reg);
+            ringbuf_advance_read(&dcc_outbuf, sizeof(unsigned int));
+            pollcount = RVIDCC_MAX_INLINE_POLLS;
+            some_transfer = 1;
+        }
+
+        pollcount = -1;
+        break;
+    }
+#endif
+
+#ifdef RVIDCC_ARM11
+    case arm11_and_later:
+    {
+        /* Try to write everything available */
+        while (ringbuf_available_data(&dcc_outbuf) >= sizeof(unsigned int))
+        {
+            do
+            {
+                CAN_WRITE_ARM11_DCC(reg);
+            } while (!reg && pollcount != -1 && --pollcount > 0);
+
+            if (!reg)
+                break;
+
+            reg = to_little_endian(*(unsigned int *)dcc_outbuf.readPtr);
+            WRITE_ARM11_DCC(reg);
+            ringbuf_advance_read(&dcc_outbuf, sizeof(unsigned int));
+            pollcount = RVIDCC_MAX_INLINE_POLLS;
+            some_transfer = 1;
+        }
+
+        pollcount = -1;
+        break;
+    }
+#endif
+
+    default:
+        break;
+    }
+
+    if (some_transfer)
+        rvidcc_cb_notify();
+
+    /* Disable interrupt if nothing left to write */
+    if (ringbuf_available_data(&dcc_outbuf) == 0)
+        RVIDCC_DISABLE_WRITE_INTERRUPT;
+}
+
+
+/* this routine assumes it is non-interruptible by others that access the queue pointers */
+/* this is written out longhand because it may be called from an interrupt routine */
+void rvidcc_read(void)
+{
+    register unsigned int reg;
+    int pollcount = -1;
+    int some_transfer = 0;
+
+    switch (arm_type)
+    {
+#ifdef RVIDCC_ARM79
+    case arm9_and_earlier:
+    {
+        /* Try to read everything available */
+        while (ringbuf_available_space(&dcc_inbuf) >= sizeof(unsigned int))
+        {
+            do
+            {
+                CAN_READ_ARM9_DCC(reg);
+            } while (!reg && pollcount != -1 && --pollcount > 0);
+
+            if (!reg)
+                break;
+
+            READ_ARM9_DCC(reg);
+            *(unsigned int *)dcc_inbuf.writePtr = to_little_endian(reg);
+            ringbuf_advance_write(&dcc_inbuf, sizeof(unsigned int));
+            pollcount = RVIDCC_MAX_INLINE_POLLS;
+            some_transfer = 1;
+        }
+        break;
+    }
+#endif
+
+#ifdef RVIDCC_ARM10
+    case arm10:
+    {
+        /* Try to read everything available */
+        while (ringbuf_available_space(&dcc_inbuf) >= sizeof(unsigned int))
+        {
+            do
+            {
+                CAN_READ_ARM10_DCC(reg);
+            } while (!reg && pollcount != -1 && --pollcount > 0);
+
+            if (!reg)
+                break;
+
+            READ_ARM10_DCC(reg);
+            *(unsigned int *)dcc_inbuf.writePtr = to_little_endian(reg);
+            ringbuf_advance_write(&dcc_inbuf, sizeof(unsigned int));
+            pollcount = RVIDCC_MAX_INLINE_POLLS;
+            some_transfer = 1;
+        }
+        break;
+    }
+#endif
+
+#ifdef RVIDCC_ARM11
+    case arm11_and_later:
+    {
+        /* Try to read everything available */
+        while (ringbuf_available_space(&dcc_inbuf) >= sizeof(unsigned int))
+        {
+            do
+            {
+                CAN_READ_ARM11_DCC(reg);
+            } while (!reg && pollcount != -1 && --pollcount > 0);
+
+            if (!reg)
+                break;
+
+            READ_ARM11_DCC(reg);
+            *(unsigned int *)dcc_inbuf.writePtr = to_little_endian(reg);
+            ringbuf_advance_write(&dcc_inbuf, sizeof(unsigned int));
+            pollcount = RVIDCC_MAX_INLINE_POLLS;
+            some_transfer = 1;
+        }
+        break;
+    }
+#endif
+
+    default:
+        break;
+    }
+
+    if (ringbuf_available_space(&dcc_inbuf) == 0)
+        RVIDCC_DISABLE_READ_INTERRUPT;
+
+    if (some_transfer)
+        rvidcc_cb_notify();
+}
+
+
+/* this routine assumes it is not interrupted by others that access the queue pointers */
+void rvidcc_poll(void)
+{
+    rvidcc_write();
+    rvidcc_read();
+}
+
+
+#ifndef RVIDCC_RAW
+void rvidcc_process(void)
+{
+    unsigned int sentinel = 0;
+    int compsize = 0;
+
+    /* Process received data */
+    while (ringbuf_available_data(&dcc_inbuf) >= sizeof(unsigned int))
+    {
+        int bytes;
+        unsigned char *buf;
+
+        /* Search for start sentinel */
+        sentinel = to_little_endian(*(unsigned int *)dcc_inbuf.readPtr);
+        compsize = sentinel & 0xffff;
+
+        /* Discard if not a start sentinel */
+        if ((sentinel & START_MASK) != START_SENTINEL || 
+            compsize > sizeof(dcc_temp_source) || compsize <= 0)
+        {
+            ringbuf_advance_read(&dcc_inbuf, sizeof(unsigned int));
+            continue;
+        }
+
+        /* Sentinel found, come back later if not enough data */
+        bytes = ringbuf_available_data(&dcc_inbuf);
+        if (bytes < compsize + sizeof(unsigned int))
+            break;
+
+        /* Copy to a contiguous buffer */
+        ringbuf_get(&dcc_inbuf,
+                    dcc_temp_source, compsize + sizeof(unsigned int));
+
+        sentinel &= 0xffff0000;
+        buf = dcc_temp_source + sizeof(unsigned int);
+
+        bytes = compsize;
+
+        /* Round up to nearest whole word */
+        if (compsize & 0x3)
+            compsize = (compsize + 4) & ~0x3;
+
+        /* advance by packet size + sentinel */
+        ringbuf_advance_read(&dcc_inbuf, compsize + sizeof(unsigned int));
+
+        /* allow more data to be received */
+        RVIDCC_ENABLE_READ_INTERRUPT;
+
+        /* Process TTY or IP packet accordingly */
+        if (sentinel == UNCOMP_TTY_START)
+        {
+            ringbuf_put(&dcc_tty_inbuf, buf, bytes);
+            ringbuf_advance_write(&dcc_tty_inbuf, bytes);
+        }
+        else
+        {
+            if (bytes == 4) /* ARP 'is this IP address you?' */
+            {
+                if (rvidcc_cb_has_addr(buf))
+                    rvidcc_transmit_ip_packet(buf, 4);
+            }
+            else if (bytes == 6) /* set MAC address */
+                rvidcc_cb_set_mac_address(buf);
+            else
+                rvidcc_cb_ip_packet_received(buf, (size_t)bytes);
+        }
+    }
+}
+#endif
+
+
+#ifdef RVIDCC_SCAN_INPUT_FOR
+int rvidcc_scan_input_for(char c, size_t span)
+{
+    int ret = 0;
+
+    size_t bytesAvail = ringbuf_available_data(&DCC_TTY_INBUF);
+    if (bytesAvail && span)
+    {
+        unsigned char *p = DCC_TTY_INBUF.readPtr;
+
+        if (span > bytesAvail)
+            span = bytesAvail;
+
+        while (span--)
+        {
+            if (*p++ == c)
+            {
+                ret = 1;
+                break;
+            }
+
+            if (p >= DCC_TTY_INBUF.buf + DCC_TTY_INBUF.size)
+                p = DCC_TTY_INBUF.buf;
+        }
+    }   
+    return ret;
+}
+#endif
+
+
+#ifdef RVIDCC_OUTBUF_DATA
+size_t rvidcc_outbuf_data(void)
+{
+    return ringbuf_available_data(&dcc_outbuf);
+}
+#endif
+
+
+size_t rvidcc_serial_can_read(void)
+{
+    return ringbuf_available_data(&DCC_TTY_INBUF);
+}
+
+
+size_t rvidcc_serial_can_write(void)
+{
+    size_t space = ringbuf_available_space(&dcc_outbuf);
+
+    // protocol only has 16 bits for packet size, so limit packets to this size
+    if (space > (65536 - 4))
+      space = (65536 - 4);
+
+    return space;
+}
+
+
+size_t rvidcc_read_serial(void *ptr, size_t len)
+{
+    size_t bytes = ringbuf_available_data(&DCC_TTY_INBUF);
+    if (bytes && len)
+    {
+        if (bytes > len)
+            bytes = len;
+
+        ringbuf_get(&DCC_TTY_INBUF, (unsigned char*)ptr, bytes);
+#ifdef RVIDCC_RAW
+        /* round up to 4 bytes */
+        if (bytes & 0x3)
+            ringbuf_advance_read(&DCC_TTY_INBUF, ((bytes + 4) & ~0x3));
+        else
+            ringbuf_advance_read(&DCC_TTY_INBUF, bytes);
+
+        RVIDCC_ENABLE_READ_INTERRUPT;
+#else
+        ringbuf_advance_read(&DCC_TTY_INBUF, bytes);
+#endif
+    }
+    else
+        bytes = 0;
+
+    return bytes;
+}
+
+
+static void rvidcc_write_lowlevel(const void *ptr, size_t len)
+{
+    size_t rem;
+
+    ringbuf_put(&dcc_outbuf, (unsigned char*)ptr, len);
+
+    ringbuf_advance_write(&dcc_outbuf, len & ~0x3); // advance whole words
+
+    /* ensure excess bytes up to word boundary are null */
+    rem = (len & 0x3);
+    if (rem)
+    {
+        for (; rem < 4; rem++)
+            *(dcc_outbuf.writePtr + rem) = '\0';
+
+        ringbuf_advance_write(&dcc_outbuf, sizeof(unsigned long)); // advance remainder word
+    }
+
+
+    RVIDCC_ENABLE_WRITE_INTERRUPT;
+}
+
+
+size_t rvidcc_write_serial(const void *ptr, size_t len)
+{
+    size_t bytes;
+#ifndef RVIDCC_RAW
+    unsigned long sentinel;
+#endif
+
+    bytes = rvidcc_serial_can_write();
+
+#ifndef RVIDCC_RAW
+    if (bytes > sizeof(unsigned long))
+    {
+        /* Size limit the amount of data to be written, allowing for sentinel */
+        if (len > (bytes - sizeof(unsigned long)))
+            len = (bytes - sizeof(unsigned long));
+
+        sentinel = to_little_endian(UNCOMP_TTY_START | (unsigned short)len);
+        rvidcc_write_lowlevel(&sentinel, sizeof(unsigned long));
+        rvidcc_write_lowlevel(ptr, len);
+    }
+#else
+    if (bytes > 0)
+    {
+        /* Size limit the amount of data to be written */
+        if (len > bytes)
+            len = bytes;
+
+        rvidcc_write_lowlevel(ptr, len);
+    }
+#endif
+    else
+        len = 0;
+
+    return len;
+}
+
+
+#ifndef RVIDCC_RAW
+int rvidcc_transmit_ip_packet(void *packet, size_t length)
+{
+    if (rvidcc_serial_can_write() >= (length + 4))
+    {
+        unsigned long sentinel = to_little_endian(UNCOMP_ETH_START | (unsigned short)length);
+        rvidcc_write_lowlevel(&sentinel, 4);
+        rvidcc_write_lowlevel(packet, length);
+    }
+    else
+        length = 0;
+
+    return length;
+}
+#endif
+
+/* End of file */
diff --git a/arch/arm/common/rvidcc_config.h b/arch/arm/common/rvidcc_config.h
new file mode 100644
index 0000000..faabe1d
--- /dev/null
+++ b/arch/arm/common/rvidcc_config.h
@@ -0,0 +1,166 @@
+/* 
+   Copyright (C) 2004-2007 ARM Limited.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License version 2
+   as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+   As a special exception, if other files instantiate templates or use macros
+   or inline functions from this file, or you compile this file and link it
+   with other works to produce a work based on this file, this file does not
+   by itself cause the resulting work to be covered by the GNU General Public
+   License. However the source code for this file must still be made available
+   in accordance with section (3) of the GNU General Public License.
+
+   This exception does not invalidate any other reasons why a work based on
+   this file might be covered by the GNU General Public License.
+*/
+
+#ifndef RVIDCC_CONFIG_H
+#define RVIDCC_CONFIG_H
+
+/*
+ *
+ * Platform headers that define basic types (e.g. size_t)
+ * ------------------------------------------------------
+ * 
+ */
+#include <linux/types.h>
+#include <linux/netdevice.h>
+
+
+/*
+ * Put any platform specific definitions required by the interrupt macros here
+ * ---------------------------------------------------------------------------
+ */
+
+/* Structure containing our internal state, etc. */
+struct dccconfig
+{
+  unsigned int rx_interrupt;
+  unsigned int tx_interrupt;
+  unsigned long timer_poll_period;
+  int use_timer_poll;
+
+  volatile unsigned long irq_disable;
+};
+
+extern struct dccconfig dcc_config;
+
+
+/*
+ * Configuration
+ * -------------
+ */
+
+/*
+ * Define which ARM cores this binary is to be used on
+ *  - RVIDCC_ARM79 for all ARM 7 and ARM 9 based cores
+ *  - RVIDCC_ARM10 for all ARM 10 cores
+ *  - RVIDCC_ARM11 for all ARM 11 and later cores (including Cortex)
+ */
+#define RVIDCC_ARM79
+#define RVIDCC_ARM10
+#define RVIDCC_ARM11
+
+/*
+ * Define RVIDCC_OUTBUF_DATA if the OS needs to check if all pending data
+ * has been sent out to the ICE.
+ */
+#define RVIDCC_OUTBUF_DATA
+
+/*
+ * Define RVIDCC_RAW if the virtual ethernet functionality is not required.  See
+ * rvidcc.c for more information.
+ */
+#ifdef CONFIG_DEBUG_DCC_RAW
+#define RVIDCC_RAW
+#endif
+
+/*
+ * Define RVIDCC_BIG_ENDIAN if your platform is big endian.
+ */
+#ifdef CONFIG_CPU_BIG_ENDIAN
+#define RVIDCC_BIG_ENDIAN
+#endif
+
+/*
+ * Define RVIDCC_SCAN_INPUT_FOR if the OS needs to peek ahead in the TTY data
+ */
+#ifdef CONFIG_DEBUG_DCC_KGDB
+#define RVIDCC_SCAN_INPUT_FOR
+#endif
+
+/*
+ * RVIDCC_BUFSIZE defines the size of the input and output buffers for DCC data
+ */
+#ifndef RVIDCC_BUFSIZE
+#ifdef RVIDCC_RAW
+#define RVIDCC_BUFSIZE 4096
+#else
+#define RVIDCC_BUFSIZE 8192
+#endif
+#endif
+
+/*
+ * RVIDCC_MAX_INLINE_POLLS defines the number of times to the driver should
+ * check if the host is ready for more data in rvidcc_write or if the host has
+ * sent more data in rvidcc_read.  Increasing this value may improve the data
+ * transfer rate, but will increase the length of time spent in the interrupt
+ * handler.  Adjust this value according to the performance and latency
+ * requirements of the system.
+ */
+#define RVIDCC_MAX_INLINE_POLLS 500
+
+/*
+ * Interrupt configuration
+ *
+ * Define macros here to enable and disable interrupts.  If the OS uses
+ * polling instead of interrupts, define as empty.
+ *
+ */
+
+#define RVIDCC_ENABLE_INTERRUPTS
+
+#define RVIDCC_DISABLE_INTERRUPTS
+
+/* Interrupt control macros */
+#define RVIDCC_ENABLE_WRITE_INTERRUPT do {                \
+    if (!dcc_config.use_timer_poll) {                     \
+      if (test_and_clear_bit(0, &dcc_config.irq_disable)) \
+        enable_irq(dcc_config.tx_interrupt);              \
+    }                                                   \
+  } while(0)
+
+#define RVIDCC_DISABLE_WRITE_INTERRUPT do {             \
+    if (!dcc_config.use_timer_poll) {                     \
+      if (!test_and_set_bit(0, &dcc_config.irq_disable))  \
+        disable_irq(dcc_config.tx_interrupt);             \
+    }                                                   \
+  } while(0)
+
+#define RVIDCC_ENABLE_READ_INTERRUPT do {               \
+    if (!dcc_config.use_timer_poll) {                     \
+      if (test_and_clear_bit(1, &dcc_config.irq_disable)) \
+        enable_irq(dcc_config.rx_interrupt);              \
+    }                                                   \
+  } while(0)
+
+#define RVIDCC_DISABLE_READ_INTERRUPT do {              \
+    if (!dcc_config.use_timer_poll) {                     \
+      if (!test_and_set_bit(1, &dcc_config.irq_disable))  \
+        disable_irq(dcc_config.rx_interrupt);             \
+    }                                                   \
+  } while(0)
+
+
+#endif /* RVIDCC_CONFIG_H */
diff --git a/arch/arm/common/rvidcc_interface.h b/arch/arm/common/rvidcc_interface.h
new file mode 100644
index 0000000..9ccf439
--- /dev/null
+++ b/arch/arm/common/rvidcc_interface.h
@@ -0,0 +1,182 @@
+/* 
+   Copyright (C) 2004-2007 ARM Limited.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License version 2
+   as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+   As a special exception, if other files instantiate templates or use macros
+   or inline functions from this file, or you compile this file and link it
+   with other works to produce a work based on this file, this file does not
+   by itself cause the resulting work to be covered by the GNU General Public
+   License. However the source code for this file must still be made available
+   in accordance with section (3) of the GNU General Public License.
+
+   This exception does not invalidate any other reasons why a work based on
+   this file might be covered by the GNU General Public License.
+*/
+
+#ifndef RVIDCC_INTERFACE_H
+#define RVIDCC_INTERFACE_H
+
+/*
+ * These are the functions provided by the generic section that the OS-dependent
+ * section is allowed to call
+ */
+
+#define RVIDCC_ERR_CORE_NOT_SUPPORTED 1
+
+/* Initialise DCC comms driver.
+ *
+ * Note that this triggers the request to the RVI for a MAC address when using
+ * virtual Ethernet.  Returns 0 on success, RVIDCC_ERR_* on failure
+ */
+extern int rvidcc_init(void);
+
+/* Poll for DCC communications.
+ *
+ * If interrupts are not being used then this should be called periodically,
+ * otherwise this is the interrupt handler for DCC communications.
+ */
+extern void rvidcc_poll(void);
+
+#ifndef RVIDCC_RAW
+/* Process received DCC data.
+ *
+ * This function is only relevant if using virtual Ethernet. This is a
+ * 'bottom half' routine and processes the data captured in rvidcc_poll(). If
+ * using interrupts, this routine should be scheduled to be called at the next
+ * available opportunity once the interrupt handler has completed. If not
+ * using interrupts then this can be called immediately on notification of the
+ * arrival of incoming data.
+ */
+extern void rvidcc_process(void);
+#endif
+
+/* Handle low level reading of dcc information
+ *
+ * This should be called from the interrupt handler for the dcc read interrupt
+ * to read data from the DCC register.  It is also called by rvidcc_poll.
+ */
+extern void rvidcc_read(void);
+
+/* Handle low level writing of dcc information
+ *
+ * This should be called from the interrupt handler for the dcc write interrupt
+ * to write data to the DCC register.  It is also called by rvidcc_poll.
+ */
+extern void rvidcc_write(void);
+
+#ifdef RVIDCC_OUTBUF_DATA
+/* Get the number of bytes left to be sent out to the ICE */
+extern size_t rvidcc_outbuf_data(void);
+#endif
+
+/* Get the number of bytes available for reading from TTY.
+ *
+ * Zero is returned if no data is available.
+ */
+extern size_t rvidcc_serial_can_read(void);
+
+/* Get the number of bytes that can be written to the TTY.
+ *
+ * Zero is returned if no data can be written.
+ */
+extern size_t rvidcc_serial_can_write(void);
+
+/* Read and consume incoming TTY data.
+ *
+ * This is the primary TTY read routine.
+ */
+extern size_t rvidcc_read_serial(void *ptr, size_t len);
+
+/* Write and queue up outgoing TTY data.
+ *
+ * This is the primary TTY write routine.
+ */
+extern size_t rvidcc_write_serial(const void *ptr, size_t len);
+
+/* Send an IP packet out to the virtual network.
+ *
+ * The data provided must be a valid IP packet and must not contain an
+ * Ethernet header. The data provided is all copied, if there is space on the
+ * queue, othewise none of it is and the packet should be treated as still
+ * pending. The return value is the number of bytes copied.
+ */
+extern int rvidcc_transmit_ip_packet(void *packet, size_t length);
+
+
+#ifdef RVIDCC_SCAN_INPUT_FOR
+/* Scan pending incoming TTY data for a character.
+ *
+ * This is primarily provided for detecting ^C (interrupt) on pending incoming
+ * TTY data, e.g. to allow a gdb stub to be re-activated when a program is
+ * running. It should be called from 'bottom half' processing, or from a
+ * regular poll. The scan starts at the latest character received and works
+ * backwards for a maximum of 'span' characters.
+ */
+extern int rvidcc_scan_input_for(char c, size_t span);
+#endif
+
+
+/*
+ * Callbacks
+ * These are called from the generic section (in rvidcc.c) and should be provided
+ * by the OS-dependent section.
+ */
+
+
+/* DCC incoming data notification callback.
+ *
+ * This is called by rvidcc_poll() whenever new data is received on the DCC
+ * channel. It indicates rvidcc_process() should be called at the next
+ * available opportunity (and also rvidcc_scaninput_for() if required). If
+ * using interrupts, schedule a 'bottom half' or tasklet to run. If not using
+ * interrupts, rvidcc_process() can be called directly from here.
+ */
+extern void rvidcc_cb_notify(void);
+
+#ifndef RVIDCC_RAW
+
+/* Network IP packet received callback.
+ *
+ * This is called from rvidcc_process() whenever an IP packet is received. Note:
+ * this only contains IP data without any Ethernet headers. The data must be
+ * copied and passed on to the OS appropriately.
+ */
+extern void rvidcc_cb_ip_packet_received(void *packet, size_t length);
+
+/* Pseudo ARP callback.
+ *
+ * This is called from rvidcc_process() whenever the ICE needs to determine if
+ * it should direct IP packets for the given IP address to this processor.
+ * Return non-zero if this is the case, or zero otherwise.  The parameter
+ * passed is a pointer to 4-byte array which is the binary IP address in
+ * network (big-endian) order.
+ */
+extern int rvidcc_cb_has_addr(unsigned char *ip_binary);
+
+/* Set Ethernet MAC address callback.
+ *
+ * This is called from rvidcc_process() whenever in response to _init_dcc()'s
+ * request to the ICE for a (globally unique) MAC address. This happens very
+ * soon after initialisation, and if a MAC is required, then the virtual
+ * Ethernet driver should not be considered fully up and running until this
+ * has been received. The parameter is a pointer to a 6-byte array which is
+ * the MAC address.
+ */
+extern void rvidcc_cb_set_mac_address(unsigned char *mac);
+
+#endif
+
+
+#endif // RVIDCC_INTERFACE_H
diff --git a/arch/arm/common/rvidcc_linux.c b/arch/arm/common/rvidcc_linux.c
new file mode 100644
index 0000000..c070583
--- /dev/null
+++ b/arch/arm/common/rvidcc_linux.c
@@ -0,0 +1,1014 @@
+/* 
+   Copyright (C) 2004-2007 ARM Limited.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License version 2
+   as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+   As a special exception, if other files instantiate templates or use macros
+   or inline functions from this file, or you compile this file and link it
+   with other works to produce a work based on this file, this file does not
+   by itself cause the resulting work to be covered by the GNU General Public
+   License. However the source code for this file must still be made available
+   in accordance with section (3) of the GNU General Public License.
+
+   This exception does not invalidate any other reasons why a work based on
+   this file might be covered by the GNU General Public License.
+*/
+
+#include <linux/module.h>
+#include <linux/reboot.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <net/route.h>
+#include <asm/hardware/rvidcc.h>
+
+#ifdef CONFIG_DEBUG_DCC_KGDB
+#include <linux/kgdb.h>
+#endif
+
+#include "rvidcc_config.h"
+#include "rvidcc_interface.h"
+
+#define ARM_DCC_VER   "1.0"
+#define ARM_TTY_NAME  "ttyDCC"
+#define ARM_ETH_NAME  "ethDCC"
+#define ARM_DCC_MAJOR 204
+#define ARM_DCC_MINOR 46
+#define ARM_DCC_POLL_PERIOD 1 /* jiffies per poll: used in timed polled (non-interrupt) mode */
+
+/* SMP not supported */
+#ifdef CONFIG_SMP
+#error DCC module does not support SMP
+#endif
+
+/* Interrupt defininitons for known achitectures that have them */
+#ifdef CONFIG_ARCH_INTEGRATOR
+
+#define DCC_RX_IRQ IRQ_CM_COMMRX
+#define DCC_TX_IRQ IRQ_CM_COMMTX
+
+#elif defined(CONFIG_ARCH_L7200)
+
+#define DCC_RX_IRQ IRQ_DEBUG_RX
+#define DCC_TX_IRQ IRQ_DEBUG_TX
+
+#elif defined(CONFIG_ARCH_LH7A404)
+
+#define DCC_RX_IRQ IRQ_COMMRX
+#define DCC_TX_IRQ IRQ_COMMTX
+
+#elif defined(CONFIG_ARCH_VERSATILE_PB)
+
+#define DCC_RX_IRQ IRQ_COMMRx
+#define DCC_TX_IRQ IRQ_COMMTx
+
+#else
+
+#define DCC_RX_IRQ 0
+#define DCC_TX_IRQ 0
+
+#endif
+
+/* This section contains the primary OS driver functions and definitions */
+
+/* Structure containing our internal state, etc. */
+
+struct dccconfig dcc_config =
+{
+  .rx_interrupt = DCC_RX_IRQ,
+  .tx_interrupt = DCC_TX_IRQ,
+  .use_timer_poll = 1, /* use timer poll until interrupts are enabled (if ever) */
+  .timer_poll_period = ARM_DCC_POLL_PERIOD
+};
+
+struct dccinfo
+{
+  struct tty_struct *tty;
+  int tty_opens;
+  int init_called;
+  int kernel_in_panic;
+  volatile unsigned long timerpoll_lock;
+  volatile unsigned long tx_locked;
+#ifndef CONFIG_DEBUG_DCC_RAW
+  struct net_device *netdev;
+  char mac_address[ETH_ALEN];
+  struct sk_buff *pending_skb;
+#endif
+};
+static struct dccinfo dcc_info;
+
+/* Module parameters - IRQ's etc. an be set on the boot line */
+module_param_named(rxirq, dcc_config.rx_interrupt, uint, 0444);
+module_param_named(txirq, dcc_config.tx_interrupt, uint, 0444);
+module_param_named(pollperiod, dcc_config.timer_poll_period, ulong, 0444);
+MODULE_PARM_DESC(rxirq, "DCC receive IRQ number");
+MODULE_PARM_DESC(txirq, "DCC transmit IRQ number");
+MODULE_PARM_DESC(pollperiod, "DCC timer polling period");
+
+/* Tasklet used as a "bottom half" - services data collected by interrupt or timed poll */
+static void dcc_tasklet_action(unsigned long data);
+static DECLARE_TASKLET(dcc_tasklet, dcc_tasklet_action, 0);
+static void dcc_poll(void);
+
+/*
+ * Write data on the serial channel if no other write is in progress
+ */
+static size_t dcc_write_serial(const void *ptr, size_t len)
+{
+  size_t res = 0;
+
+  if (!test_and_set_bit(0, &dcc_info.tx_locked))
+  {
+    res = rvidcc_write_serial(ptr, len);
+    clear_bit(0, &dcc_info.tx_locked);
+  }
+
+  return res;
+}
+
+#ifndef RVIDCC_RAW
+/*
+ * Send a network packet if no other write is in progress
+ */
+static int dcc_transmit_ip_packet(void *packet, size_t length)
+{
+  int res = 0;
+
+  if (!test_and_set_bit(0, &dcc_info.tx_locked))
+  {
+    res = rvidcc_transmit_ip_packet(packet, length);
+    clear_bit(0, &dcc_info.tx_locked);
+  }
+
+  return res;
+}
+#endif
+
+/* KGDB support
+ *
+ * KGDB and the console/tty channel are mutually exclusive, 
+ * i.e. KGDB takes over the tty channel if it is enabled.
+ */
+#ifdef CONFIG_DEBUG_DCC_KGDB
+
+#define KGDB_BUF_SIZE 1024 /* needs to be big enough to hold one GDB packet */
+static int dcc_init_dcc(void);
+static void dcc_print_banner(void);
+static void dcc_tasklet_action(unsigned long data);
+
+static char kgdb_buf[KGDB_BUF_SIZE];
+static size_t kgdb_buf_chars = 0;
+
+/* KGDB getchar routine */
+static int kgdb_getDebugChar(void)
+{
+  char ch;
+
+  /* The rest of the system is frozen at this point, so this is all that is running */
+  while (!rvidcc_read_serial(&ch, 1))
+  {
+    rvidcc_poll();
+    dcc_tasklet_action(1);
+  }
+
+  return (int)ch;
+}
+
+/* KGDB flush routine - ensures each GDB packet is sent as one message (more efficient) */
+static void kgdb_flushDebugChar(void)
+{
+  size_t written = 0;
+
+  /* The rest of the system is frozen at this point, so this is all that is running */
+  while (written < kgdb_buf_chars)
+  {
+    written += dcc_write_serial(&kgdb_buf[written], kgdb_buf_chars - written);
+    rvidcc_poll();
+    dcc_tasklet_action(1);
+  }
+
+  kgdb_buf_chars = 0;
+}
+
+/* KGDB putchar routine */
+static void kgdb_putDebugChar(int chr)
+{
+  kgdb_buf[kgdb_buf_chars++] = (char)chr;
+  if (kgdb_buf_chars >= KGDB_BUF_SIZE)
+    kgdb_flushDebugChar();
+}
+
+/* KGDB initialisation routine - can be called very early in kernel startup */
+static int init_kgdbDcc(void)
+{
+  int err = 0;
+  if (!dcc_info.init_called)
+  {
+    dcc_print_banner();
+    err = dcc_init_dcc();
+    if (!err)
+      printk(KERN_INFO "kgdb: debugging over DCC enabled\n");
+  }
+
+  return err;
+}
+
+/* KGDB device driver structure - only one of these is allowed globally */
+struct kgdb_io kgdb_io_ops =
+{
+  .read_char = kgdb_getDebugChar,
+  .write_char = kgdb_putDebugChar,
+  .init = init_kgdbDcc,
+  .flush = kgdb_flushDebugChar
+};
+
+#else
+
+/* TTY device driver routines. Must peacefully co-exist with console support.
+ *
+ * Not present when KGDB is enabled. KGDB has its own driver format (above).
+ */
+/* TTY device open routine */
+static int dcc_chr_open(struct tty_struct *tty, struct file *filp)
+{
+  if (!dcc_info.tty_opens++)
+    dcc_info.tty = tty;
+
+  return 0;
+}
+
+/* TTY device close routine */
+static void dcc_chr_close(struct tty_struct *tty, struct file *filp)
+{
+  if (!--dcc_info.tty_opens)
+    dcc_info.tty = NULL;
+}
+
+/* TTY device write routine */
+static int dcc_chr_write(struct tty_struct * tty,
+                         const unsigned char *buf, int count)
+{
+  int bytes = 0;
+
+  if (count == 0)
+    return 0;
+
+  bytes = (int)dcc_write_serial(buf, count);
+
+  if (dcc_config.use_timer_poll)
+    dcc_poll();
+
+  return bytes;
+}
+
+/* TTY device routine to determine space left in output buffer */
+static int dcc_chr_write_room(struct tty_struct *tty)
+{
+  int space;
+
+  if (dcc_config.use_timer_poll)
+    dcc_poll();
+
+  space = rvidcc_serial_can_write() - 4 ; /* Leave 1 word spare for sentinel*/
+  return space > 0 ? space : 0;
+}
+
+/* TTY device routine to determine number of chars waiting in input buffer */
+static int dcc_chr_chars_in_buffer(struct tty_struct *tty)
+{
+  if (dcc_config.use_timer_poll)
+    dcc_poll();
+
+  return rvidcc_serial_can_read();
+}
+
+/* TTY device ioctl routine. Global and affects virtual Ethernet as well */
+static int dcc_chr_ioctl(struct tty_struct *tty, struct file *filp, 
+                         unsigned int cmd, unsigned long arg)
+{
+  int ret_val = 0;
+
+  switch (cmd) {
+    case DCC_SETPOLLPERIOD:
+      dcc_config.timer_poll_period = arg;
+      break;
+
+    case DCC_GETPOLLPERIOD:
+      ret_val = dcc_config.timer_poll_period;
+      break;
+
+    default:
+      ret_val = -ENOIOCTLCMD;
+      break;
+  }
+
+  return ret_val;
+}
+
+#endif /* CONFIG_DEBUG_DCC_KGDB */
+
+/* Network (virtual Ethernet over DCC) device driver routines
+ *
+ * Co-exists with KGDB, and will run when KGDB is at a breakpoint.
+ * Developer beware !
+ */
+#ifndef CONFIG_DEBUG_DCC_RAW
+
+/* Network device driver structure */
+static struct net_device* dcc_netdev;
+
+/* Callback from the universal DCC driver when a MAC address arrives from the RVI */
+void rvidcc_cb_set_mac_address(unsigned char *mac)
+{
+  memcpy(dcc_info.mac_address, mac, ETH_ALEN);
+
+  printk(KERN_INFO "DCC: MAC address %02x:%02x:%02x:%02x:%02x:%02x\n", dcc_info.mac_address[0],
+         dcc_info.mac_address[1], dcc_info.mac_address[2], dcc_info.mac_address[3],
+         dcc_info.mac_address[4], dcc_info.mac_address[5]);
+}
+
+
+/* Network device address validation */
+static int dcc_net_validate_addr(struct net_device *dev)
+{
+  /* Wait for the MAC address from the RVI */
+  unsigned long startjif = jiffies;
+  while (dcc_info.mac_address[0] == 0 && 
+         dcc_info.mac_address[1] == 0 &&
+         dcc_info.mac_address[2] == 0 &&
+         dcc_info.mac_address[3] == 0 &&
+         dcc_info.mac_address[4] == 0 &&
+         dcc_info.mac_address[5] == 0)
+  {
+    if (dcc_config.use_timer_poll)
+      dcc_poll();
+
+    /* Wait for a maximum of 1/2 a second */
+    if (startjif - jiffies > HZ/2)
+    {
+      printk(KERN_ERR "DCC: Virtual ethernet timed out waiting for MAC address\n");
+      break;
+    }
+    schedule();
+  }
+
+  memcpy(dev->dev_addr, dcc_info.mac_address, ETH_ALEN);
+
+  if (!is_valid_ether_addr(dev->dev_addr))
+    return -EINVAL;
+
+  return 0;
+}
+
+/* Network device open routine */
+static int dcc_net_open(struct net_device *dev)
+{
+  netif_start_queue(dev);
+  dcc_info.netdev = dev; /* mark as running */
+  return 0;
+}
+
+/* Network device close routine */
+static int dcc_net_close(struct net_device *dev)
+{
+  /* Discard any pending TX packet */
+  if (dcc_info.pending_skb)
+  {
+    dev->stats.tx_dropped++;
+    dev_kfree_skb(dcc_info.pending_skb);
+    dcc_info.pending_skb = NULL;
+  }
+
+  /* Mark as not running, to discard incoming packets */
+  dcc_info.netdev = NULL;
+
+  netif_stop_queue(dev);
+  return 0;
+}
+
+/* Called by universal driver when an IP packet is received */
+void rvidcc_cb_ip_packet_received(void *packet, size_t length)
+{
+  /* Drop the packet if the device isn't open */
+  if (dcc_info.netdev)
+  {
+    struct sk_buff *skb = dev_alloc_skb(length + 16);
+    struct ethhdr *buf;
+
+    if (!skb)
+    {
+      dcc_info.netdev->stats.rx_dropped++;
+      return;
+    }
+
+    /* Create Ethernet header */
+    skb_reserve(skb,2);	/* Force 16 byte alignment */
+    buf = (struct ethhdr*)skb_put(skb, length + 14);
+    memcpy(buf->h_dest, dcc_info.mac_address, 6);
+    memcpy(&buf->h_source[3], &dcc_info.mac_address[3], 3);
+    buf->h_source[0] = 0x00;
+    buf->h_source[1] = 0x02;
+    buf->h_source[2] = 0xf7;  /* RVI MAC address */
+    buf->h_proto = htons(ETH_P_IP);
+
+    /* Fill in the rest of the data */
+    memcpy((char*)buf + sizeof(struct ethhdr), packet, length);
+    skb->dev = dcc_info.netdev;
+    skb->protocol = eth_type_trans(skb, dcc_info.netdev);
+    dcc_info.netdev->stats.rx_packets++;
+    dcc_info.netdev->stats.rx_bytes += length+14;
+    netif_rx(skb);
+  }
+}
+
+/* Network device packet transmit routine */
+static int dcc_net_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+  switch (ntohs(((struct ethhdr*)skb->data)->h_proto))
+  {
+    case ETH_P_ARP: /* ARP protocol */
+    {
+      struct sk_buff *skbreply = dev_alloc_skb(skb->len);
+      struct ethhdr *buf;
+      struct arphdr *arp;
+      unsigned char *arpdata, *origarpdata;
+
+      if (!skbreply)
+      {
+        dcc_info.netdev->stats.tx_dropped++;
+        dev_kfree_skb(skb);
+        return 0;
+      }
+
+      /* Set up manufactured ARP reply data */
+      buf = (struct ethhdr*)skb_put(skbreply, skb->len);
+      arp = (struct arphdr*)((char*)buf + sizeof(struct ethhdr));
+      arpdata = (unsigned char*)((char*)arp + sizeof(struct arphdr));
+      origarpdata = skb->data + sizeof(struct ethhdr) + sizeof(struct arphdr);
+      memcpy(buf, skb->data, skb->len);
+      memcpy(buf->h_dest, dcc_info.mac_address, 6);
+      memcpy(&buf->h_source[3], &dcc_info.mac_address[3], 3);
+      buf->h_source[0] = 0x00;
+      buf->h_source[1] = 0x02;
+      buf->h_source[2] = 0xf7;  /* RVI MAC address */
+      arp->ar_op = htons(ARPOP_REPLY);
+      memcpy(&arpdata[0], buf->h_source, ETH_ALEN);
+      memcpy(&arpdata[10], buf->h_dest, ETH_ALEN);
+      memcpy(&arpdata[6], &origarpdata[16], 4);
+      memcpy(&arpdata[16], &origarpdata[6], 4);
+
+      skbreply->dev = dcc_info.netdev;
+      skbreply->protocol = eth_type_trans(skbreply, dcc_info.netdev);
+      dcc_info.netdev->stats.rx_packets++;
+      dcc_info.netdev->stats.rx_bytes += skb->len;
+      dcc_info.netdev->stats.tx_packets++;
+      dcc_info.netdev->stats.tx_bytes += skb->len;
+      dev_kfree_skb(skb);
+      netif_rx(skbreply);
+      break;
+    }
+    case ETH_P_IP:  /* IP protocol */
+    {
+      if (dcc_transmit_ip_packet(&skb->data[14], skb->len-14)) /* discard eth header */
+      {
+        dcc_info.netdev->stats.tx_packets++;
+        dcc_info.netdev->stats.tx_bytes += skb->len;
+        dev_kfree_skb(skb);
+      }
+      else
+      {
+        dcc_info.pending_skb = skb;
+        netif_stop_queue(dev);
+      }
+
+      if (dcc_config.use_timer_poll)
+        dcc_poll();
+
+      break;
+    }
+    default:
+      printk(KERN_WARNING "DCC: dropping packet ethertype 0x%04x\n", 
+             (int)ntohs(((struct ethhdr*)skb->data)->h_proto));
+      dcc_info.netdev->stats.tx_dropped++;
+      dev_kfree_skb(skb);
+  }
+
+  return 0;
+}
+
+/* Universal driver callback to handle pseudo-ARP */
+int rvidcc_cb_has_addr(unsigned char *ip_binary)
+{
+  u32 ip;
+  memcpy(&ip, ip_binary, 4);
+
+  if (!dcc_info.netdev || IN_LOOPBACK(ip) || IN_MULTICAST(ip))
+    return 0;
+
+  /* Return 1 if address is local to the target */
+  return inet_addr_type(dev_net(dcc_info.netdev), ip) == RTN_LOCAL ? 1 : 0;
+}
+
+/* Network device initialisation routine */
+static void dcc_net_init(struct net_device *dev)
+{
+  /* Like normal Ethernet, but with specific differences */
+  ether_setup(dev);
+  dev->tx_queue_len = 3;
+
+  /* Driver routines */
+  dev->validate_addr = dcc_net_validate_addr;
+  dev->open = dcc_net_open;
+  dev->stop = dcc_net_close;
+  dev->hard_start_xmit = dcc_net_xmit;
+}
+
+#endif /* !CONFIG_DEBUG_DCC_RAW */
+
+/* Data transfer handling functionality
+ *
+ * We support interrupt and timer polled functionality
+ * if interrupts are not available.
+ */
+static void dcc_timer_poll(unsigned long arg);
+
+static struct timer_list dcc_timer = {
+  function:   dcc_timer_poll
+};
+
+/* Poll routine for when interrupts are not used */
+static void dcc_poll(void)
+{
+  if (!test_and_set_bit(0, &dcc_info.timerpoll_lock) &&
+      !dcc_info.kernel_in_panic)
+  {
+    rvidcc_poll();
+    clear_bit(0, &dcc_info.timerpoll_lock);
+  }
+}
+
+/* Self-recheduling timer poll routine */
+static void dcc_timer_poll(unsigned long arg)
+{
+  dcc_poll();
+  dcc_timer.expires = jiffies + dcc_config.timer_poll_period;
+  add_timer(&dcc_timer);
+}
+
+/* DCC interrupt handler */
+static irqreturn_t dcc_read_interrupt(int irq, void *devid)
+{
+  if (!dcc_info.kernel_in_panic)
+    rvidcc_read();
+  return IRQ_HANDLED;
+}
+
+/* DCC interrupt handler */
+static irqreturn_t dcc_write_interrupt(int irq, void *devid)
+{
+  if (!dcc_info.kernel_in_panic)
+    rvidcc_write();
+  return IRQ_HANDLED;
+}
+
+/* Routine to process incoming DCC data from interrupt or timer poll */
+static void dcc_tasklet_action(unsigned long data)
+{
+#ifndef CONFIG_DEBUG_DCC_RAW
+  rvidcc_process();
+
+  /* Try to transmit any pending packet */
+  if (dcc_info.pending_skb && dcc_info.netdev)
+  {
+    if (dcc_transmit_ip_packet(&dcc_info.pending_skb->data[14], dcc_info.pending_skb->len-14))
+    {
+      dcc_info.netdev->stats.tx_packets++;
+      dcc_info.netdev->stats.tx_bytes += dcc_info.pending_skb->len;
+      dev_kfree_skb(dcc_info.pending_skb);
+      dcc_info.pending_skb = NULL;
+      netif_wake_queue(dcc_info.netdev);
+    }
+  }
+#endif
+
+  /* tasklet can only run on one CPU at a time and this is the only place
+   * we do a serial read, so no locking needed here */
+#ifdef CONFIG_DEBUG_DCC_KGDB
+  if (data != 1 && rvidcc_serial_can_read())
+  {
+    /* Absorb ^C before triggering a hardcoded breakpoint */
+    if (rvidcc_scan_input_for(0x03, 1))
+    {
+      char buf;
+      rvidcc_read_serial(&buf, 1);
+    }
+    breakpoint();
+  }
+#else
+  /* Receive any bytes that may be pending if the device has been opened */
+  if (dcc_info.tty)
+  {
+    size_t data_available = rvidcc_serial_can_read();
+    if (data_available)
+    {
+      unsigned char* buf;
+      int len = tty_prepare_flip_string(dcc_info.tty, &buf, data_available);
+      if (len)
+      {
+        rvidcc_read_serial(buf, len);
+        tty_flip_buffer_push(dcc_info.tty);
+      }
+    }
+  }
+#endif
+}
+
+/* Universal driver callback called when data has arrived on DCC */
+void rvidcc_cb_notify()
+{
+  tasklet_schedule(&dcc_tasklet);
+}
+
+/* Universal initialisation - ensures init only happens once */
+static int dcc_init_dcc(void)
+{
+  int err = 0;
+  if (!dcc_info.init_called)
+  {
+      err = rvidcc_init();
+      if (err == 0)
+          dcc_info.init_called = 1;
+      else
+          return -ENODEV;
+  }
+
+  return err;
+}
+
+/* Banner to be printed on initialisation */
+static void dcc_print_banner(void)
+{
+  printk(KERN_INFO "RealView ICE DCC device driver %s " 
+#ifdef CONFIG_DEBUG_DCC_RAW
+         "[raw mode] "
+#else
+         "[tty_eth mode] "
+#endif
+         "(C)2004-2007 ARM Limited\n", ARM_DCC_VER);
+}
+
+static void dcc_drain_outbuf(void)
+{
+  size_t bytesPending;
+  size_t lastBytesPending = 0;
+  int failcount = 0;
+
+  while ((bytesPending = rvidcc_outbuf_data()) > 0)
+  {
+    if (bytesPending >= lastBytesPending)
+      ++failcount;
+
+    if (failcount > 10)
+    {
+      /* The queue isn't draining: either the connection to the RVI is
+       * lost or we can't process messages fast enough.  Either way, it's
+       * bad to block forever, so bail out */
+      break;
+    }
+
+    lastBytesPending = bytesPending;
+
+    rvidcc_poll();
+  }
+}
+
+#ifndef CONFIG_DEBUG_DCC_KGDB
+
+/* TTY device driver structure */
+static const struct tty_operations dcc_tty_ops = 
+{
+  .open           = dcc_chr_open,
+  .close          = dcc_chr_close,
+  .write          = dcc_chr_write,
+  .write_room     = dcc_chr_write_room,
+  .chars_in_buffer = dcc_chr_chars_in_buffer,
+  .ioctl          = dcc_chr_ioctl
+};
+
+static struct tty_driver *dcc_tty_driver;
+
+/* Create and install TTY driver */
+static int dcc_init_tty_driver(void)
+{
+  int error = 0;
+
+  dcc_tty_driver = alloc_tty_driver(1);
+  if (!dcc_tty_driver)
+    return -ENOMEM;
+  dcc_tty_driver->owner = THIS_MODULE;
+  dcc_tty_driver->driver_name = ARM_TTY_NAME;
+  dcc_tty_driver->name = ARM_TTY_NAME;
+  dcc_tty_driver->major = ARM_DCC_MAJOR;
+  dcc_tty_driver->minor_start = ARM_DCC_MINOR;
+  dcc_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
+  dcc_tty_driver->subtype = SERIAL_TYPE_NORMAL;
+  dcc_tty_driver->flags = TTY_DRIVER_REAL_RAW;
+  dcc_tty_driver->init_termios = tty_std_termios;
+  tty_set_operations(dcc_tty_driver, &dcc_tty_ops);
+  if ((error = tty_register_driver(dcc_tty_driver)))
+  {
+    printk(KERN_ERR "DCC: Can't register tty device %d, error = %d\n",
+           ARM_DCC_MINOR, error);
+    put_tty_driver(dcc_tty_driver);
+    dcc_tty_driver = NULL;
+    return error;
+  }
+  return 0;
+}
+
+/* Console device print routine */
+static void dcc_console_print(struct console *co, const char *buf, unsigned count)
+{
+  unsigned int bytes = 0;
+
+  /* Send message out */
+  bytes = (unsigned int)dcc_write_serial(buf, count);
+
+  /* If buffer is full stall the system until there is space */
+  /* A flood of printk's usually means the system is dying anyway */
+  if (bytes < count)
+  {
+    unsigned long flags;
+    local_irq_save(flags);
+
+    while (bytes < count)
+    {
+      rvidcc_poll();
+      bytes += (unsigned int)dcc_write_serial(buf + bytes, count - bytes);
+    }
+
+    local_irq_restore(flags);
+  }
+
+  /* Do an immediate flush if kernel has panicked */
+  if (dcc_info.kernel_in_panic)
+  {
+    unsigned long flags;
+    local_irq_save(flags);
+
+    dcc_drain_outbuf();
+
+    local_irq_restore(flags);
+  }
+}
+
+/* Console device initialisation routine */
+static struct tty_driver* dcc_console_device(struct console *co, int *index)
+{
+  *index = 0;
+  return dcc_tty_driver;
+}
+
+/* Console device driver */
+static struct console dcc_con_driver =
+{
+  .name       = ARM_TTY_NAME,
+  .write      = dcc_console_print,
+  .device     = dcc_console_device,
+  .flags      = CON_PRINTBUFFER,
+  .index      = -1,
+};
+
+
+/* Routine to ensure DCC is flushed on reboot or kernel panic */
+static int dcc_reboot_handler(struct notifier_block *this,
+                              unsigned long event, void *unused)
+{
+  unsigned long flags;
+  local_irq_save(flags);
+
+  dcc_drain_outbuf();
+
+  local_irq_restore(flags);
+
+  return NOTIFY_OK;
+}
+
+/* Reboot notifier structure */
+static struct notifier_block dcc_reboot_notifier =
+{
+  dcc_reboot_handler,
+  NULL,
+  0
+};
+
+/* Called when kernel enters the panic state */
+static int dcc_panic_handler(struct notifier_block *this,
+                             unsigned long event, void *unused)
+{
+  dcc_info.kernel_in_panic = 1;
+  return dcc_reboot_handler(this, event, unused);
+}
+
+/* Panic notifier structure */
+static struct notifier_block dcc_panic_notifier =
+{
+  .notifier_call = dcc_panic_handler,
+  .next = NULL,
+  .priority = 0
+};
+
+/* Early console initialization.  Preceeds driver initialization. */
+static int __init dcc_console_init(void)
+{
+  int err = 0;
+
+  if (!dcc_info.init_called)
+  {
+    dcc_print_banner();
+    err = dcc_init_dcc();
+  }
+
+  if (!err)
+  {
+    register_reboot_notifier(&dcc_reboot_notifier);
+    atomic_notifier_chain_register(&panic_notifier_list, &dcc_panic_notifier);
+    register_console(&dcc_con_driver);
+  }
+
+  return err;
+}
+#endif /* !CONFIG_DEBUG_DCC_KGDB */
+
+/* Primary module (and devices) initialisation routine */
+int __init dcc_init(void)
+{
+  int ret = 0;
+
+  if (!dcc_info.init_called)
+    dcc_print_banner();
+
+  /* Detect whether timer polling when required */
+  if (dcc_config.rx_interrupt == dcc_config.tx_interrupt)
+  {
+    dcc_config.use_timer_poll = 1;
+
+    if (dcc_config.rx_interrupt != 0)
+      printk(KERN_ERR "DCC: IRQ numbers must be different for Rx and Tx !!!!!\n");
+  }
+  else
+    dcc_config.use_timer_poll = 0;
+
+#ifndef CONFIG_DEBUG_DCC_KGDB
+  ret = dcc_init_tty_driver();
+#endif
+
+#ifndef CONFIG_DEBUG_DCC_RAW
+  if (!ret)
+  {
+    /* Install network device driver */
+    dcc_netdev = alloc_netdev(0, ARM_ETH_NAME, dcc_net_init);
+    if (dcc_netdev == NULL)
+    {
+      printk(KERN_ERR "DCC: Can't allocate net device\n");
+      ret = -ENOMEM;
+      goto error;
+    }
+    else
+    {
+      ret = register_netdev(dcc_netdev);
+
+      if (ret)
+      {
+        printk(KERN_ERR "DCC: Can't register net device\n");
+        free_netdev(dcc_netdev);
+        goto error;
+      }
+    }
+  }
+#endif
+
+  /* Initiate interrupts or timer polling as necessary */
+  if (!ret)
+  {
+    if (!dcc_config.use_timer_poll)
+    {
+      ret = dcc_init_dcc();
+
+      if (ret)
+      {
+        goto error;
+      }
+      else
+      {
+        if (request_irq(dcc_config.rx_interrupt, dcc_read_interrupt, 0, "dcc:rx", NULL) ||
+            request_irq(dcc_config.tx_interrupt, dcc_write_interrupt, 0, "dcc:tx", NULL))
+        {
+          printk(KERN_ERR "DCC: Can't install interrupt handlers for IRQ%u and/or IRQ%u\n",
+                 dcc_config.rx_interrupt, dcc_config.tx_interrupt);
+          /* unregister tty & netdev drivers on error */
+          ret = -EBUSY;
+          goto error;
+        }
+        else
+          printk(KERN_INFO "DCC: Using IRQ%u (Rx) and IRQ%u (Tx)\n",
+                 dcc_config.rx_interrupt, dcc_config.tx_interrupt);
+      }
+    }
+    else
+    {
+      init_timer(&dcc_timer);
+      printk(KERN_INFO "DCC: Using timer polled mode\n");
+
+      ret = dcc_init_dcc();
+      if (ret)
+      {
+        del_timer_sync(&dcc_timer);
+        goto error;
+      }
+      else
+      {
+        dcc_timer.expires = jiffies + dcc_config.timer_poll_period;
+        add_timer(&dcc_timer);
+      }
+    }
+  }
+
+  return ret;
+
+error:
+
+#ifndef CONFIG_DEBUG_DCC_KGDB
+  if (dcc_tty_driver)
+  {
+    tty_unregister_driver(dcc_tty_driver);
+    put_tty_driver(dcc_tty_driver);
+    dcc_tty_driver = NULL;
+  }
+#endif
+
+#ifndef CONFIG_DEBUG_DCC_RAW
+  if (dcc_netdev)
+  {
+    unregister_netdev(dcc_netdev);
+    free_netdev(dcc_netdev);
+    dcc_netdev = NULL;
+  }
+#endif
+
+  return ret;
+}
+
+/* Module cleanup (exit) routine - only called if compiled as a module */
+void __exit dcc_cleanup(void)
+{
+  if (!dcc_config.use_timer_poll)
+  {
+    free_irq(dcc_config.rx_interrupt, NULL);
+    free_irq(dcc_config.tx_interrupt, NULL);
+  }
+  else
+    del_timer_sync(&dcc_timer);
+
+#ifndef CONFIG_DEBUG_DCC_KGDB
+  tty_unregister_driver(dcc_tty_driver);
+  put_tty_driver(dcc_tty_driver);
+#endif
+
+#ifndef CONFIG_DEBUG_DCC_RAW
+  unregister_netdev(dcc_netdev);
+  free_netdev(dcc_netdev);
+#endif
+
+#ifndef CONFIG_DEBUG_DCC_KGDB
+  unregister_console(&dcc_con_driver);
+  unregister_reboot_notifier(&dcc_reboot_notifier);
+  atomic_notifier_chain_unregister(&panic_notifier_list, &dcc_panic_notifier);
+#endif
+
+  dcc_drain_outbuf();
+}
+
+#ifndef CONFIG_DEBUG_DCC_KGDB
+console_initcall(dcc_console_init);
+#endif
+module_init(dcc_init);
+module_exit(dcc_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("ARM Ltd");
+MODULE_DESCRIPTION("Driver for the ARM Debug Communications Channel");
+MODULE_SUPPORTED_DEVICE(ARM_TTY_NAME);
diff --git a/arch/arm/configs/firecracker_defconfig b/arch/arm/configs/firecracker_defconfig
new file mode 100644
index 0000000..7991559
--- /dev/null
+++ b/arch/arm/configs/firecracker_defconfig
@@ -0,0 +1,1107 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Mon Sep 28 14:28:41 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-picochip-3.2.4"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+# CONFIG_MARKERS is not set
+CONFIG_OPROFILE=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+CONFIG_ARCH_FIRECRACKER=y
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PC302 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# Firecracker platform type
+#
+CONFIG_MACH_PC72052_I10_REVB=y
+CONFIG_MACH_PC7802=y
+# CONFIG_FIRECRACKER_DMA_TEST is not set
+CONFIG_FIRECRACKER_DMA_DEBUG=0
+CONFIG_FIRECRACKER_EMAC_DEBUG=0
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+CONFIG_ARM_VIC=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=1000
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_NODES_SHIFT=2
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_DISCONTIGMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_DISCONTIGMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/mtdblock1 rootfstype=jffs2 console=ttyS0,115200n8 noinitrd"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_SUSPEND is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=y
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_GEOMETRY is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_PICOHDP=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_PC202_GPIO=m
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+CONFIG_SERIAL_8250_FIRECRACKER=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+CONFIG_I2C_GPIO=m
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_FIRECRACKER=m
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# picoChip Drivers
+#
+CONFIG_PICOCPE20X_FPGA=m
+CONFIG_PICOIF=m
+CONFIG_PICOIF_PC202=y
+CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL=1
+# CONFIG_PICOIF_DEBUG_TO_CONSOLE is not set
+# CONFIG_PERFCOUNTERS is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_RVIDCC is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_KEYSTREAM is not set
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/pc302_defconfig b/arch/arm/configs/pc302_defconfig
new file mode 100644
index 0000000..823a29b
--- /dev/null
+++ b/arch/arm/configs/pc302_defconfig
@@ -0,0 +1,1116 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Tue Jan  5 15:01:13 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_OPROFILE_ARMV6=y
+CONFIG_OPROFILE_ARM11_CORE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-picochip-3.2.4"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+# CONFIG_MARKERS is not set
+CONFIG_OPROFILE=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FIRECRACKER is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+CONFIG_ARCH_PC302=y
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# PC302 platform type
+#
+CONFIG_MACH_PC7302=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+# CONFIG_OUTER_CACHE is not set
+# CONFIG_ARM_ERRATA_364296 is not set
+CONFIG_ARM_ERRATA_411920=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=1000
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="ip=172.17.13.247:172.17.1.131:172.17.0.1:255.255.0.0:picopc7302-248#:eth0 mem=128M console=ttyS0,115200 loglevel=8"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_XFRM_SUB_POLICY=y
+# CONFIG_XFRM_MIGRATE is not set
+CONFIG_XFRM_STATISTICS=y
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+CONFIG_NETFILTER_XTABLES=y
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_FIB_RULES=y
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_GEOMETRY is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_PICOHDP=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_PC7302=y
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+# CONFIG_BLK_DEV is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_PC302_FRACN=m
+CONFIG_PC302_FUSEBLOCK=m
+CONFIG_PC302_GPIO=y
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_PC302_EMAC=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_FIRECRACKER is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+CONFIG_SPI_PC302=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_PC302_WATCHDOG=m
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_PC302_DMA=y
+CONFIG_PC302_DMA_DEBUG_LEVEL=0
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# picoChip Drivers
+#
+CONFIG_PICOIF=y
+CONFIG_PICOIF_PC302=y
+CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL=1
+# CONFIG_PICOIF_DEBUG_TO_CONSOLE is not set
+CONFIG_PERFCOUNTERS=y
+CONFIG_ARMV6_PERFCOUNTER=m
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_RVIDCC is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR=0
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_KEYSTREAM=m
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_PC302=m
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/realview-nommu_defconfig b/arch/arm/configs/realview-nommu_defconfig
new file mode 100644
index 0000000..71596a5
--- /dev/null
+++ b/arch/arm/configs/realview-nommu_defconfig
@@ -0,0 +1,1373 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Thu Feb  5 12:10:15 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0x00000000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+# CONFIG_MMU is not set
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+CONFIG_ARCH_REALVIEW=y
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# RealView platform type
+#
+CONFIG_MACH_REALVIEW_EB=y
+# CONFIG_REALVIEW_EB_A9MP is not set
+CONFIG_REALVIEW_EB_ARM11MP=y
+# CONFIG_REALVIEW_EB_ARM11MP_REVB is not set
+CONFIG_MACH_REALVIEW_PB11MP=y
+CONFIG_MACH_REALVIEW_PB1176=y
+# CONFIG_MACH_REALVIEW_PBA8 is not set
+CONFIG_MACH_REALVIEW_PBX=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+# CONFIG_CPU_ARM7TDMI is not set
+# CONFIG_CPU_ARM9TDMI is not set
+# CONFIG_CPU_ARM926T is not set
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+# CONFIG_CPU_V7 is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_HIGH_VECTOR is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_TLS_REG_EMUL=y
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_L2X0=y
+CONFIG_SET_MEM_PARAM=y
+CONFIG_DRAM_BASE=0x00000000
+CONFIG_DRAM_SIZE=0x10000000
+CONFIG_FLASH_MEM_BASE=0x40000000
+CONFIG_FLASH_SIZE=0x04000000
+CONFIG_ARM_GIC=y
+CONFIG_ICST307=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_SMP is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs nfsroot=10.1.69.3:/work/nfsroot ip=dhcp console=ttyAMA0 mem=128M"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_FLAT=y
+CONFIG_BINFMT_ZFLAT=y
+CONFIG_BINFMT_SHARED_FLAT=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ARM_INTEGRATOR=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_MV is not set
+CONFIG_HAVE_PATA_PLATFORM=y
+CONFIG_PATA_PLATFORM=y
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+CONFIG_SMC91X=y
+# CONFIG_DM9000 is not set
+CONFIG_SMC911X=y
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+CONFIG_I2C_VERSATILE=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_AC97_CODEC=y
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_ARMAACI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_AC97_BUS=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_BRIGHT=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DELL=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_ISP1760_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=y
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_CONSOLE=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/realview-smp_defconfig b/arch/arm/configs/realview-smp_defconfig
index 0c09b23..f14a921 100644
--- a/arch/arm/configs/realview-smp_defconfig
+++ b/arch/arm/configs/realview-smp_defconfig
@@ -1,84 +1,119 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.19-rc3
-# Wed Oct 25 14:12:00 2006
+# Linux kernel version: 2.6.28
+# Thu Feb  5 11:59:22 2009
 #
 CONFIG_ARM=y
-# CONFIG_GENERIC_TIME is not set
-CONFIG_MMU=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_NO_IOPORT is not set
 CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 CONFIG_HARDIRQS_SW_RESEND=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
 #
-# Code maturity level options
+# General setup
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_LOCK_KERNEL=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
-
-#
-# General setup
-#
 CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_LOCALVERSION_AUTO is not set
 # CONFIG_SWAP is not set
 CONFIG_SYSVIPC=y
-# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_TASKSTATS is not set
-# CONFIG_UTS_NS is not set
 # CONFIG_AUDIT is not set
-# CONFIG_IKCONFIG is not set
-# CONFIG_CPUSETS is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_NS is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+CONFIG_CPUSETS=y
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+CONFIG_PROC_PID_CPUSET=y
 # CONFIG_RELAY is not set
-CONFIG_INITRAMFS_SOURCE=""
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_BLK_DEV_INITRD is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
 # CONFIG_EMBEDDED is not set
 CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
-CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_ALL is not set
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
 CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
 CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
-CONFIG_SLAB=y
+CONFIG_AIO=y
 CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
-# CONFIG_SLOB is not set
-
-#
-# Loadable module support
-#
 CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
 CONFIG_MODULE_UNLOAD=y
 # CONFIG_MODULE_FORCE_UNLOAD is not set
 # CONFIG_MODVERSIONS is not set
 # CONFIG_MODULE_SRCVERSION_ALL is not set
-# CONFIG_KMOD is not set
+CONFIG_KMOD=y
 CONFIG_STOP_MACHINE=y
-
-#
-# Block layer
-#
 CONFIG_BLOCK=y
+# CONFIG_LBD is not set
 # CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
 
 #
 # IO Schedulers
@@ -92,10 +127,13 @@ CONFIG_DEFAULT_DEADLINE=y
 # CONFIG_DEFAULT_CFQ is not set
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
 
 #
 # System Type
 #
+CONFIG_MMU=y
 # CONFIG_ARCH_AAEC2000 is not set
 # CONFIG_ARCH_INTEGRATOR is not set
 CONFIG_ARCH_REALVIEW=y
@@ -103,19 +141,26 @@ CONFIG_ARCH_REALVIEW=y
 # CONFIG_ARCH_AT91 is not set
 # CONFIG_ARCH_CLPS7500 is not set
 # CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
 # CONFIG_ARCH_EBSA110 is not set
 # CONFIG_ARCH_EP93XX is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
 # CONFIG_ARCH_NETX is not set
 # CONFIG_ARCH_H720X is not set
 # CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
 # CONFIG_ARCH_IOP32X is not set
 # CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_IXP2000 is not set
 # CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
 # CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_RPC is not set
@@ -123,13 +168,30 @@ CONFIG_ARCH_REALVIEW=y
 # CONFIG_ARCH_S3C2410 is not set
 # CONFIG_ARCH_SHARK is not set
 # CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
 
 #
 # RealView platform type
 #
 CONFIG_MACH_REALVIEW_EB=y
-CONFIG_REALVIEW_MPCORE=y
+# CONFIG_REALVIEW_EB_A9MP is not set
+CONFIG_REALVIEW_EB_ARM11MP=y
+# CONFIG_REALVIEW_EB_ARM11MP_REVB is not set
+CONFIG_MACH_REALVIEW_PB11MP=y
+# CONFIG_MACH_REALVIEW_PB1176 is not set
+# CONFIG_MACH_REALVIEW_PBA8 is not set
+CONFIG_MACH_REALVIEW_PBX=y
+CONFIG_REALVIEW_HIGH_PHYS_OFFSET=y
 
 #
 # Processor Type
@@ -138,12 +200,16 @@ CONFIG_CPU_32=y
 # CONFIG_CPU_ARM926T is not set
 CONFIG_CPU_V6=y
 CONFIG_CPU_32v6K=y
+# CONFIG_CPU_V7 is not set
 CONFIG_CPU_32v6=y
 CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
 CONFIG_CPU_CACHE_V6=y
 CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_NO_CACHE_BCAST=y
 CONFIG_CPU_COPY_V6=y
 CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
 CONFIG_CPU_CP15=y
 CONFIG_CPU_CP15_MMU=y
 
@@ -153,9 +219,10 @@ CONFIG_CPU_CP15_MMU=y
 CONFIG_ARM_THUMB=y
 # CONFIG_CPU_ICACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_CPU_BPREDICT_DISABLE is not set
 CONFIG_HAS_TLS_REG=y
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_L2X0=y
 CONFIG_ARM_GIC=y
 CONFIG_ICST307=y
 
@@ -163,32 +230,45 @@ CONFIG_ICST307=y
 # Bus support
 #
 CONFIG_ARM_AMBA=y
-
-#
-# PCCARD (PCMCIA/CardBus) support
-#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
 # CONFIG_PCCARD is not set
 
 #
 # Kernel Features
 #
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
 CONFIG_SMP=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
 CONFIG_NR_CPUS=4
 CONFIG_HOTPLUG_CPU=y
 CONFIG_LOCAL_TIMERS=y
 # CONFIG_PREEMPT is not set
 CONFIG_HZ=100
-# CONFIG_AEABI is not set
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
 CONFIG_SELECT_MEMORY_MODEL=y
 CONFIG_FLATMEM_MANUAL=y
 # CONFIG_DISCONTIGMEM_MANUAL is not set
 # CONFIG_SPARSEMEM_MANUAL is not set
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
 CONFIG_SPLIT_PTLOCK_CPUS=4
 # CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
 CONFIG_ALIGNMENT_TRAP=y
 
 #
@@ -198,6 +278,12 @@ CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_CMDLINE="root=/dev/nfs nfsroot=10.1.69.3:/work/nfsroot ip=dhcp console=ttyAMA0 mem=128M"
 # CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
 
 #
 # Floating point emulation
@@ -206,8 +292,7 @@ CONFIG_CMDLINE="root=/dev/nfs nfsroot=10.1.69.3:/work/nfsroot ip=dhcp console=tt
 #
 # At least one emulation must be selected
 #
-CONFIG_FPE_NWFPE=y
-# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_NWFPE is not set
 # CONFIG_FPE_FASTFPE is not set
 CONFIG_VFP=y
 
@@ -215,28 +300,29 @@ CONFIG_VFP=y
 # Userspace binary formats
 #
 CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
 # CONFIG_BINFMT_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_ARTHUR is not set
 
 #
 # Power management options
 #
 # CONFIG_PM is not set
-# CONFIG_APM is not set
-
-#
-# Networking
-#
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_NET=y
 
 #
 # Networking options
 #
-# CONFIG_NETDEBUG is not set
 CONFIG_PACKET=y
 # CONFIG_PACKET_MMAP is not set
 CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
 # CONFIG_IP_MULTICAST is not set
@@ -255,36 +341,25 @@ CONFIG_IP_PNP_BOOTP=y
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_XFRM_TUNNEL is not set
 # CONFIG_INET_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
 CONFIG_INET_DIAG=y
 CONFIG_INET_TCP_DIAG=y
 # CONFIG_TCP_CONG_ADVANCED is not set
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
 # CONFIG_IPV6 is not set
-# CONFIG_INET6_XFRM_TUNNEL is not set
-# CONFIG_INET6_TUNNEL is not set
 # CONFIG_NETWORK_SECMARK is not set
 # CONFIG_NETFILTER is not set
-
-#
-# DCCP Configuration (EXPERIMENTAL)
-#
 # CONFIG_IP_DCCP is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
 # CONFIG_IP_SCTP is not set
-
-#
-# TIPC Configuration (EXPERIMENTAL)
-#
 # CONFIG_TIPC is not set
 # CONFIG_ATM is not set
 # CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
 # CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
 # CONFIG_LLC2 is not set
@@ -294,10 +369,6 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_LAPB is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
 # CONFIG_NET_SCHED is not set
 
 #
@@ -305,9 +376,14 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 #
 # CONFIG_NET_PKTGEN is not set
 # CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
-# CONFIG_IEEE80211 is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
 
 #
 # Device Drivers
@@ -316,38 +392,37 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 #
 # Generic Driver Options
 #
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
 # CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
-
-#
-# Connector - unified userspace <-> kernelspace linker
-#
 # CONFIG_CONNECTOR is not set
-
-#
-# Memory Technology Devices (MTD)
-#
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_CONCAT=y
 CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 CONFIG_MTD_CMDLINE_PARTS=y
 # CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
 
 #
 # User Modules And Translation Layers
 #
 CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
 CONFIG_MTD_BLOCK=y
 # CONFIG_FTL is not set
 # CONFIG_NFTL is not set
 # CONFIG_INFTL is not set
 # CONFIG_RFD_FTL is not set
 # CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -373,7 +448,6 @@ CONFIG_MTD_CFI_UTIL=y
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
 # CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_OBSOLETE_CHIPS is not set
 
 #
 # Mapping drivers for chip access
@@ -397,115 +471,123 @@ CONFIG_MTD_ARM_INTEGRATOR=y
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOC2001PLUS is not set
-
-#
-# NAND Flash Device Drivers
-#
 # CONFIG_MTD_NAND is not set
-
-#
-# OneNAND Flash Device Drivers
-#
 # CONFIG_MTD_ONENAND is not set
 
 #
-# Parallel port support
+# UBI - Unsorted block images
 #
+# CONFIG_MTD_UBI is not set
 # CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-
-#
-# Block devices
-#
+CONFIG_BLK_DEV=y
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
 # CONFIG_BLK_DEV_RAM is not set
-CONFIG_BLK_DEV_INITRD=y
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
 
 #
 # SCSI device support
 #
 # CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
 # CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
 
 #
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# Fusion MPT device support
+# SCSI support type (disk, tape, CD-ROM)
 #
-# CONFIG_FUSION is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
 
 #
-# IEEE 1394 (FireWire) support
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
 
 #
-# I2O device support
-#
-
-#
-# Network device support
+# SCSI Transports
 #
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_MV is not set
+CONFIG_HAVE_PATA_PLATFORM=y
+CONFIG_PATA_PLATFORM=y
+# CONFIG_MD is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-
-#
-# PHY device support
-#
+# CONFIG_VETH is not set
 # CONFIG_PHYLIB is not set
-
-#
-# Ethernet (10 or 100Mbit)
-#
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
+# CONFIG_AX88796 is not set
 CONFIG_SMC91X=y
 # CONFIG_DM9000 is not set
+CONFIG_SMC911X=y
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
 
 #
-# Ethernet (1000 Mbit)
-#
-
-#
-# Ethernet (10000 Mbit)
-#
-
-#
-# Token Ring devices
-#
-
-#
-# Wireless LAN (non-hamradio)
+# Wireless LAN
 #
-# CONFIG_NET_RADIO is not set
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
 
 #
-# Wan interfaces
+# USB Network Adapters
 #
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
 # CONFIG_WAN is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
-
-#
-# ISDN subsystem
-#
 # CONFIG_ISDN is not set
 
 #
@@ -513,6 +595,7 @@ CONFIG_SMC91X=y
 #
 CONFIG_INPUT=y
 # CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
 
 #
 # Userland interfaces
@@ -522,7 +605,6 @@ CONFIG_INPUT_MOUSEDEV_PSAUX=y
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
 
@@ -538,9 +620,19 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_STOWAWAY is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
 # CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
 # CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
 
@@ -558,9 +650,11 @@ CONFIG_SERIO_LIBPS2=y
 # Character devices
 #
 CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
 CONFIG_VT_CONSOLE=y
 CONFIG_HW_CONSOLE=y
 # CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
 # CONFIG_SERIAL_NONSTANDARD is not set
 
 #
@@ -579,97 +673,139 @@ CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=16
-
-#
-# IPMI
-#
 # CONFIG_IPMI_HANDLER is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
 # CONFIG_HW_RANDOM is not set
 # CONFIG_NVRAM is not set
-# CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-
-#
-# Ftape, the floppy tape device driver
-#
 # CONFIG_RAW_DRIVER is not set
-
-#
-# TPM devices
-#
 # CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
 
 #
-# I2C support
+# I2C Hardware Bus support
 #
-# CONFIG_I2C is not set
 
 #
-# SPI support
+# I2C system bus drivers (mostly embedded / system-on-chip)
 #
-# CONFIG_SPI is not set
-# CONFIG_SPI_MASTER is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+CONFIG_I2C_VERSATILE=y
 
 #
-# Dallas's 1-wire bus
+# External I2C/SMBus adapter drivers
 #
-# CONFIG_W1 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
 
 #
-# Hardware Monitoring support
+# Other I2C/SMBus bus drivers
 #
-# CONFIG_HWMON is not set
-# CONFIG_HWMON_VID is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
 
 #
-# Misc devices
+# Miscellaneous I2C Chip support
 #
-# CONFIG_SGI_IOC4 is not set
-# CONFIG_TIFM_CORE is not set
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
 
 #
-# LED devices
+# Sonics Silicon Backplane
 #
-# CONFIG_NEW_LEDS is not set
+# CONFIG_SSB is not set
 
 #
-# LED drivers
+# Multifunction device drivers
 #
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
 
 #
-# LED Triggers
+# Multimedia devices
 #
 
 #
-# Multimedia devices
+# Multimedia core support
 #
 # CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
 
 #
-# Digital Video Broadcasting Devices
+# Multimedia drivers
 #
-# CONFIG_DVB is not set
+# CONFIG_DAB is not set
 
 #
 # Graphics support
 #
-# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
 CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
 # CONFIG_FB_BACKLIGHT is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
 CONFIG_FB_ARMCLCD=y
 # CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
 
 #
 # Console display driver support
@@ -677,28 +813,17 @@ CONFIG_FB_ARMCLCD=y
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
 # CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
 # CONFIG_FONTS is not set
 CONFIG_FONT_8x8=y
 CONFIG_FONT_8x16=y
-
-#
-# Logo configuration
-#
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
 CONFIG_LOGO_LINUX_CLUT224=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Sound
-#
 CONFIG_SOUND=y
-
-#
-# Advanced Linux Sound Architecture
-#
+CONFIG_SOUND_OSS_CORE=y
 CONFIG_SND=y
 CONFIG_SND_TIMER=y
 CONFIG_SND_PCM=y
@@ -712,56 +837,172 @@ CONFIG_SND_SUPPORT_OLD_API=y
 CONFIG_SND_VERBOSE_PROCFS=y
 # CONFIG_SND_VERBOSE_PRINTK is not set
 # CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_AC97_CODEC=y
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_ARMAACI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_AC97_BUS=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_BRIGHT=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DELL=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
 
 #
-# Generic devices
+# Miscellaneous USB options
 #
-CONFIG_SND_AC97_CODEC=m
-CONFIG_SND_AC97_BUS=m
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_MPU401 is not set
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
 
 #
-# ALSA ARM devices
+# USB Host Controller Drivers
 #
-CONFIG_SND_ARMAACI=m
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_ISP1760_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
 
 #
-# Open Sound System
+# USB Device Class drivers
 #
-# CONFIG_SOUND_PRIME is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
 
 #
-# USB support
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
 #
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+# see USB_STORAGE Help for more information
 #
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
 
 #
-# USB Gadget Support
+# USB Imaging devices
 #
-# CONFIG_USB_GADGET is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
 
 #
-# MMC/SD Card support
+# USB Miscellaneous drivers
 #
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
 CONFIG_MMC=y
 # CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
 CONFIG_MMC_BLOCK=y
-CONFIG_MMC_ARMMMCI=y
-# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
 
 #
-# Real Time Clock
+# MMC/SD/SDIO Host Controller Drivers
 #
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
 CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_HCTOSYS=y
@@ -774,38 +1015,74 @@ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
 CONFIG_RTC_INTF_SYSFS=y
 CONFIG_RTC_INTF_PROC=y
 CONFIG_RTC_INTF_DEV=y
-CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=y
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
 
 #
-# RTC drivers
+# SPI RTC drivers
+#
+
 #
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
 # CONFIG_RTC_DRV_DS1553 is not set
 # CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
 # CONFIG_RTC_DRV_M48T86 is not set
-CONFIG_RTC_DRV_PL031=y
-# CONFIG_RTC_DRV_TEST is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
 # CONFIG_RTC_DRV_V3020 is not set
 
 #
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
 # CONFIG_EXT2_FS_XIP is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_EXT4DEV_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 # CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
 # CONFIG_XFS_FS is not set
-# CONFIG_GFS2_FS is not set
 # CONFIG_OCFS2_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_ROMFS_FS is not set
+CONFIG_DNOTIFY=y
 CONFIG_INOTIFY=y
-# CONFIG_INOTIFY_USER is not set
+CONFIG_INOTIFY_USER=y
 # CONFIG_QUOTA is not set
-CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_FUSE_FS is not set
@@ -831,11 +1108,11 @@ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 #
 CONFIG_PROC_FS=y
 CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
 CONFIG_SYSFS=y
 CONFIG_TMPFS=y
 # CONFIG_TMPFS_POSIX_ACL is not set
 # CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
 # CONFIG_CONFIGFS_FS is not set
 
 #
@@ -848,29 +1125,38 @@ CONFIG_RAMFS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
-# CONFIG_JFFS_FS is not set
-# CONFIG_JFFS2_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
 CONFIG_CRAMFS=y
 # CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
-
-#
-# Network File Systems
-#
+CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
-# CONFIG_NFS_DIRECTIO is not set
-# CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
@@ -878,17 +1164,12 @@ CONFIG_SUNRPC=y
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
-# CONFIG_9P_FS is not set
 
 #
 # Partition Types
 #
 # CONFIG_PARTITION_ADVANCED is not set
 CONFIG_MSDOS_PARTITION=y
-
-#
-# Native Language Support
-#
 CONFIG_NLS=y
 CONFIG_NLS_DEFAULT="iso8859-1"
 CONFIG_NLS_CODEPAGE_437=y
@@ -929,45 +1210,75 @@ CONFIG_NLS_ISO8859_1=y
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
 # CONFIG_NLS_UTF8 is not set
-
-#
-# Profiling support
-#
-# CONFIG_PROFILING is not set
+# CONFIG_DLM is not set
 
 #
 # Kernel hacking
 #
 # CONFIG_PRINTK_TIME is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
 CONFIG_MAGIC_SYSRQ=y
 # CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
-CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_SHIRQ is not set
 CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
 # CONFIG_SCHEDSTATS is not set
-# CONFIG_DEBUG_SLAB is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
-CONFIG_DEBUG_SPINLOCK=y
-CONFIG_DEBUG_MUTEXES=y
-CONFIG_DEBUG_RWSEMS=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_FS is not set
 # CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
 # CONFIG_DEBUG_LIST is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_UNWIND_INFO is not set
-CONFIG_FORCED_INLINING=y
-# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
 # CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
 CONFIG_DEBUG_USER=y
 CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
 CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_CONSOLE=y
 # CONFIG_DEBUG_ICEDCC is not set
 
 #
@@ -975,18 +1286,108 @@ CONFIG_DEBUG_LL=y
 #
 # CONFIG_KEYS is not set
 # CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
 
 #
-# Cryptographic options
+# Random Number Generation
 #
-# CONFIG_CRYPTO is not set
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
 
 #
 # Library routines
 #
+CONFIG_BITREVERSE=y
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
 CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
 CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/realview_defconfig b/arch/arm/configs/realview_defconfig
index 907e543..08ad71b 100644
--- a/arch/arm/configs/realview_defconfig
+++ b/arch/arm/configs/realview_defconfig
@@ -1,105 +1,206 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.14-rc2
-# Thu Sep 29 14:50:10 2005
+# Linux kernel version: 2.6.28
+# Thu Feb  5 11:52:23 2009
 #
 CONFIG_ARM=y
-CONFIG_MMU=y
-CONFIG_UID16=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
 #
-# Code maturity level options
+# General setup
 #
-# CONFIG_EXPERIMENTAL is not set
-CONFIG_CLEAN_COMPILE=y
+CONFIG_EXPERIMENTAL=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
-
-#
-# General setup
-#
 CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_LOCALVERSION_AUTO is not set
 # CONFIG_SWAP is not set
 CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
-CONFIG_SYSCTL=y
+# CONFIG_TASKSTATS is not set
 # CONFIG_AUDIT is not set
-CONFIG_HOTPLUG=y
-CONFIG_KOBJECT_UEVENT=y
-# CONFIG_IKCONFIG is not set
-CONFIG_INITRAMFS_SOURCE=""
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
 # CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_ALL is not set
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
-CONFIG_CC_ALIGN_FUNCTIONS=0
-CONFIG_CC_ALIGN_LABELS=0
-CONFIG_CC_ALIGN_LOOPS=0
-CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
-
-#
-# Loadable module support
-#
 CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
 CONFIG_MODULE_UNLOAD=y
-CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
 # CONFIG_MODULE_SRCVERSION_ALL is not set
-# CONFIG_KMOD is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
 
 #
 # System Type
 #
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+CONFIG_ARCH_REALVIEW=y
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
 # CONFIG_ARCH_CLPS7500 is not set
 # CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
 # CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_IOP3XX is not set
-# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
 # CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_RPC is not set
 # CONFIG_ARCH_SA1100 is not set
 # CONFIG_ARCH_S3C2410 is not set
 # CONFIG_ARCH_SHARK is not set
 # CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_VERSATILE is not set
-CONFIG_ARCH_REALVIEW=y
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
 
 #
 # RealView platform type
 #
 CONFIG_MACH_REALVIEW_EB=y
+# CONFIG_REALVIEW_EB_A9MP is not set
+CONFIG_REALVIEW_EB_ARM11MP=y
+# CONFIG_REALVIEW_EB_ARM11MP_REVB is not set
+CONFIG_MACH_REALVIEW_PB11MP=y
+CONFIG_MACH_REALVIEW_PB1176=y
+# CONFIG_MACH_REALVIEW_PBA8 is not set
+CONFIG_MACH_REALVIEW_PBX=y
 
 #
 # Processor Type
 #
 CONFIG_CPU_32=y
-CONFIG_CPU_ARM926T=y
-# CONFIG_CPU_V6 is not set
-CONFIG_CPU_32v5=y
-CONFIG_CPU_ABRT_EV5TJ=y
-CONFIG_CPU_CACHE_VIVT=y
-CONFIG_CPU_COPY_V4WB=y
-CONFIG_CPU_TLB_V4WBI=y
+# CONFIG_CPU_ARM926T is not set
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+# CONFIG_CPU_V7 is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
 
 #
 # Processor Features
@@ -107,8 +208,9 @@ CONFIG_CPU_TLB_V4WBI=y
 CONFIG_ARM_THUMB=y
 # CONFIG_CPU_ICACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
-# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_L2X0=y
 CONFIG_ARM_GIC=y
 CONFIG_ICST307=y
 
@@ -116,20 +218,42 @@ CONFIG_ICST307=y
 # Bus support
 #
 CONFIG_ARM_AMBA=y
-CONFIG_ISA_DMA_API=y
-
-#
-# PCCARD (PCMCIA/CardBus) support
-#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
 # CONFIG_PCCARD is not set
 
 #
 # Kernel Features
 #
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_SMP is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
 CONFIG_ALIGNMENT_TRAP=y
 
 #
@@ -139,6 +263,12 @@ CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_CMDLINE="root=/dev/nfs nfsroot=10.1.69.3:/work/nfsroot ip=dhcp console=ttyAMA0 mem=128M"
 # CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
 
 #
 # Floating point emulation
@@ -147,26 +277,24 @@ CONFIG_CMDLINE="root=/dev/nfs nfsroot=10.1.69.3:/work/nfsroot ip=dhcp console=tt
 #
 # At least one emulation must be selected
 #
-CONFIG_FPE_NWFPE=y
-# CONFIG_FPE_NWFPE_XP is not set
-# CONFIG_VFP is not set
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
 
 #
 # Userspace binary formats
 #
 CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
 # CONFIG_BINFMT_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_ARTHUR is not set
 
 #
 # Power management options
 #
 # CONFIG_PM is not set
-
-#
-# Networking
-#
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_NET=y
 
 #
@@ -175,6 +303,11 @@ CONFIG_NET=y
 CONFIG_PACKET=y
 # CONFIG_PACKET_MMAP is not set
 CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
 # CONFIG_IP_MULTICAST is not set
@@ -186,34 +319,56 @@ CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
 # CONFIG_NET_IPIP is not set
 # CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
 # CONFIG_INET_AH is not set
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
 # CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
 CONFIG_INET_DIAG=y
 CONFIG_INET_TCP_DIAG=y
 # CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_BIC=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
 # CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
 # CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
 # CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
 # CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
 # CONFIG_LLC2 is not set
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
 # CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
 
 #
 # Network testing
 #
 # CONFIG_NET_PKTGEN is not set
 # CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
-# CONFIG_IEEE80211 is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
 
 #
 # Device Drivers
@@ -222,30 +377,37 @@ CONFIG_TCP_CONG_BIC=y
 #
 # Generic Driver Options
 #
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
 # CONFIG_DEBUG_DRIVER is not set
-
-#
-# Memory Technology Devices (MTD)
-#
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_CONCAT=y
 CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 CONFIG_MTD_CMDLINE_PARTS=y
 # CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
 
 #
 # User Modules And Translation Layers
 #
 CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
 CONFIG_MTD_BLOCK=y
 # CONFIG_FTL is not set
 # CONFIG_NFTL is not set
 # CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -266,7 +428,6 @@ CONFIG_MTD_CFI_I2=y
 # CONFIG_MTD_CFI_I8 is not set
 CONFIG_MTD_CFI_INTELEXT=y
 CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_CFI_AMDSTD_RETRY=0
 # CONFIG_MTD_CFI_STAA is not set
 CONFIG_MTD_CFI_UTIL=y
 # CONFIG_MTD_RAM is not set
@@ -279,7 +440,6 @@ CONFIG_MTD_CFI_UTIL=y
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 # CONFIG_MTD_PHYSMAP is not set
 CONFIG_MTD_ARM_INTEGRATOR=y
-# CONFIG_MTD_EDB7312 is not set
 # CONFIG_MTD_PLATRAM is not set
 
 #
@@ -288,7 +448,7 @@ CONFIG_MTD_ARM_INTEGRATOR=y
 # CONFIG_MTD_SLRAM is not set
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
 
 #
 # Disk-On-Chip Device Drivers
@@ -296,121 +456,131 @@ CONFIG_MTD_ARM_INTEGRATOR=y
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOC2001PLUS is not set
-
-#
-# NAND Flash Device Drivers
-#
 # CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
 
 #
-# Parallel port support
+# UBI - Unsorted block images
 #
+# CONFIG_MTD_UBI is not set
 # CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-
-#
-# Block devices
-#
+CONFIG_BLK_DEV=y
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
 # CONFIG_BLK_DEV_RAM is not set
-CONFIG_BLK_DEV_RAM_COUNT=16
 # CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-# CONFIG_IOSCHED_AS is not set
-CONFIG_IOSCHED_DEADLINE=y
-# CONFIG_IOSCHED_CFQ is not set
 # CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
 
 #
 # SCSI device support
 #
 # CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_MV is not set
+CONFIG_HAVE_PATA_PLATFORM=y
+CONFIG_PATA_PLATFORM=y
 # CONFIG_MD is not set
-
-#
-# Fusion MPT device support
-#
-# CONFIG_FUSION is not set
-
-#
-# IEEE 1394 (FireWire) support
-#
-
-#
-# I2O device support
-#
-
-#
-# Network device support
-#
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-
-#
-# PHY device support
-#
+# CONFIG_VETH is not set
 # CONFIG_PHYLIB is not set
-
-#
-# Ethernet (10 or 100Mbit)
-#
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
+# CONFIG_AX88796 is not set
 CONFIG_SMC91X=y
 # CONFIG_DM9000 is not set
+CONFIG_SMC911X=y
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
 
 #
-# Ethernet (1000 Mbit)
+# Wireless LAN
 #
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
 
 #
-# Ethernet (10000 Mbit)
-#
-
-#
-# Token Ring devices
-#
-
-#
-# Wireless LAN (non-hamradio)
-#
-# CONFIG_NET_RADIO is not set
-
-#
-# Wan interfaces
+# USB Network Adapters
 #
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
 # CONFIG_WAN is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
-
-#
-# ISDN subsystem
-#
 # CONFIG_ISDN is not set
 
 #
 # Input device support
 #
 CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
 
 #
 # Userland interfaces
@@ -420,7 +590,6 @@ CONFIG_INPUT_MOUSEDEV_PSAUX=y
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
 
@@ -433,11 +602,22 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_LKKBD is not set
 # CONFIG_KEYBOARD_XTKBD is not set
 # CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
 # CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
 # CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
 
@@ -455,8 +635,11 @@ CONFIG_SERIO_LIBPS2=y
 # Character devices
 #
 CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
 CONFIG_VT_CONSOLE=y
 CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
 # CONFIG_SERIAL_NONSTANDARD is not set
 
 #
@@ -475,73 +658,139 @@ CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=16
-
-#
-# IPMI
-#
 # CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
 
 #
-# Watchdog Cards
+# I2C Hardware Bus support
 #
-# CONFIG_WATCHDOG is not set
-# CONFIG_NVRAM is not set
-# CONFIG_RTC is not set
-# CONFIG_DTLK is not set
-# CONFIG_R3964 is not set
 
 #
-# Ftape, the floppy tape device driver
+# I2C system bus drivers (mostly embedded / system-on-chip)
 #
-# CONFIG_RAW_DRIVER is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+CONFIG_I2C_VERSATILE=y
 
 #
-# TPM devices
+# External I2C/SMBus adapter drivers
 #
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
 
 #
-# I2C support
+# Other I2C/SMBus bus drivers
 #
-# CONFIG_I2C is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
 
 #
-# Hardware Monitoring support
+# Miscellaneous I2C Chip support
 #
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
-# CONFIG_HWMON_VID is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
 
 #
-# Misc devices
+# Sonics Silicon Backplane
 #
+# CONFIG_SSB is not set
 
 #
-# Multimedia Capabilities Port drivers
+# Multifunction device drivers
 #
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
 
 #
 # Multimedia devices
 #
+
+#
+# Multimedia core support
+#
 # CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
 
 #
-# Digital Video Broadcasting Devices
+# Multimedia drivers
 #
-# CONFIG_DVB is not set
+# CONFIG_DAB is not set
 
 #
 # Graphics support
 #
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
 CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_IMAGEBLIT=y
-CONFIG_FB_SOFT_CURSOR=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
 CONFIG_FB_ARMCLCD=y
 # CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
 
 #
 # Console display driver support
@@ -549,27 +798,17 @@ CONFIG_FB_ARMCLCD=y
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
 # CONFIG_FONTS is not set
 CONFIG_FONT_8x8=y
 CONFIG_FONT_8x16=y
-
-#
-# Logo configuration
-#
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
 CONFIG_LOGO_LINUX_CLUT224=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Sound
-#
 CONFIG_SOUND=y
-
-#
-# Advanced Linux Sound Architecture
-#
+CONFIG_SOUND_OSS_CORE=y
 CONFIG_SND=y
 CONFIG_SND_TIMER=y
 CONFIG_SND_PCM=y
@@ -577,59 +816,258 @@ CONFIG_SND_PCM=y
 CONFIG_SND_OSSEMUL=y
 CONFIG_SND_MIXER_OSS=y
 CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
 # CONFIG_SND_VERBOSE_PRINTK is not set
 # CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_AC97_CODEC=y
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_ARMAACI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_AC97_BUS=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_BRIGHT=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DELL=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
 
 #
-# Generic devices
+# Miscellaneous USB options
 #
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_MPU401 is not set
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
 
 #
-# ALSA ARM devices
+# USB Host Controller Drivers
 #
-# CONFIG_SND_ARMAACI is not set
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_ISP1760_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
 
 #
-# Open Sound System
+# USB Device Class drivers
 #
-# CONFIG_SOUND_PRIME is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
 
 #
-# USB support
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
 #
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB is not set
 
 #
-# USB Gadget Support
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
 #
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
 # CONFIG_USB_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
 
 #
-# MMC/SD Card support
+# MMC/SD/SDIO Host Controller Drivers
 #
-# CONFIG_MMC is not set
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=y
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
 
 #
 # File systems
 #
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 # CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
 # CONFIG_XFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_ROMFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
 CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
 # CONFIG_QUOTA is not set
-CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_FUSE_FS is not set
@@ -654,51 +1092,69 @@ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
 CONFIG_SYSFS=y
 CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
 # CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
-# CONFIG_RELAYFS_FS is not set
+# CONFIG_CONFIGFS_FS is not set
 
 #
 # Miscellaneous filesystems
 #
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
 # CONFIG_HFSPLUS_FS is not set
-# CONFIG_JFFS_FS is not set
-# CONFIG_JFFS2_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
 CONFIG_CRAMFS=y
 # CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
-
-#
-# Network File Systems
-#
+CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFSD is not set
+# CONFIG_NFS_V4 is not set
 CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
 
 #
 # Partition Types
 #
 # CONFIG_PARTITION_ADVANCED is not set
 CONFIG_MSDOS_PARTITION=y
-
-#
-# Native Language Support
-#
 CONFIG_NLS=y
 CONFIG_NLS_DEFAULT="iso8859-1"
 CONFIG_NLS_CODEPAGE_437=y
@@ -739,48 +1195,185 @@ CONFIG_NLS_ISO8859_1=y
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
 # CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
 
 #
 # Kernel hacking
 #
 # CONFIG_PRINTK_TIME is not set
-CONFIG_DEBUG_KERNEL=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
 CONFIG_MAGIC_SYSRQ=y
-CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
 CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
 # CONFIG_SCHEDSTATS is not set
-# CONFIG_DEBUG_SLAB is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
 # CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_FS is not set
-CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
 CONFIG_DEBUG_USER=y
 CONFIG_DEBUG_ERRORS=y
-# CONFIG_DEBUG_LL is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_CONSOLE=y
+# CONFIG_DEBUG_ICEDCC is not set
 
 #
 # Security options
 #
 # CONFIG_KEYS is not set
 # CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
 
 #
-# Cryptographic options
+# Compression
 #
-# CONFIG_CRYPTO is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
 
 #
-# Hardware crypto devices
+# Random Number Generation
 #
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
 
 #
 # Library routines
 #
+CONFIG_BITREVERSE=y
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
 CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/versatile_defconfig b/arch/arm/configs/versatile_defconfig
index 8355f88..e9d80b8 100644
--- a/arch/arm/configs/versatile_defconfig
+++ b/arch/arm/configs/versatile_defconfig
@@ -1,39 +1,64 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.17-rc3
-# Mon May  8 20:15:57 2006
+# Linux kernel version: 2.6.28
+# Thu Feb  5 14:13:50 2009
 #
 CONFIG_ARM=y
-CONFIG_MMU=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
 CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
 #
-# Code maturity level options
+# General setup
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
-
-#
-# General setup
-#
 CONFIG_LOCALVERSION=""
 # CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
-CONFIG_SYSCTL=y
+# CONFIG_TASKSTATS is not set
 # CONFIG_AUDIT is not set
-# CONFIG_IKCONFIG is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
 # CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
-CONFIG_UID16=y
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
 # CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_ALL is not set
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
@@ -41,30 +66,46 @@ CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
 CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
-CONFIG_SLAB=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
-# CONFIG_SLOB is not set
-CONFIG_OBSOLETE_INTERMODULE=y
-
-#
-# Loadable module support
-#
 CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
 CONFIG_MODULE_UNLOAD=y
 # CONFIG_MODULE_FORCE_UNLOAD is not set
 # CONFIG_MODVERSIONS is not set
 # CONFIG_MODULE_SRCVERSION_ALL is not set
 CONFIG_KMOD=y
-
-#
-# Block layer
-#
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
 # CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
 
 #
 # IO Schedulers
@@ -78,35 +119,58 @@ CONFIG_DEFAULT_AS=y
 # CONFIG_DEFAULT_CFQ is not set
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
 
 #
 # System Type
 #
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+CONFIG_ARCH_VERSATILE=y
+# CONFIG_ARCH_AT91 is not set
 # CONFIG_ARCH_CLPS7500 is not set
 # CONFIG_ARCH_CLPS711X is not set
-# CONFIG_ARCH_CO285 is not set
 # CONFIG_ARCH_EBSA110 is not set
 # CONFIG_ARCH_EP93XX is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_IOP3XX is not set
-# CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
 # CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_RPC is not set
 # CONFIG_ARCH_SA1100 is not set
 # CONFIG_ARCH_S3C2410 is not set
 # CONFIG_ARCH_SHARK is not set
 # CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
-CONFIG_ARCH_VERSATILE=y
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_AAEC2000 is not set
-# CONFIG_ARCH_AT91RM9200 is not set
+# CONFIG_ARCH_MSM is not set
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
 
 #
 # Versatile platform type
@@ -121,9 +185,12 @@ CONFIG_CPU_32=y
 CONFIG_CPU_ARM926T=y
 CONFIG_CPU_32v5=y
 CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
 CONFIG_CPU_CACHE_VIVT=y
 CONFIG_CPU_COPY_V4WB=y
 CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
 
 #
 # Processor Features
@@ -133,6 +200,7 @@ CONFIG_ARM_THUMB=y
 # CONFIG_CPU_DCACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
 CONFIG_ARM_VIC=y
 CONFIG_ICST307=y
 
@@ -141,29 +209,42 @@ CONFIG_ICST307=y
 #
 CONFIG_ARM_AMBA=y
 # CONFIG_PCI is not set
-
-#
-# PCCARD (PCMCIA/CardBus) support
-#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
 # CONFIG_PCCARD is not set
 
 #
 # Kernel Features
 #
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
 # CONFIG_PREEMPT is not set
 CONFIG_HZ=100
-# CONFIG_AEABI is not set
-# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+# CONFIG_ARM_ASM_UNIFIED is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
 CONFIG_SELECT_MEMORY_MODEL=y
 CONFIG_FLATMEM_MANUAL=y
 # CONFIG_DISCONTIGMEM_MANUAL is not set
 # CONFIG_SPARSEMEM_MANUAL is not set
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
 CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
 CONFIG_LEDS=y
-CONFIG_LEDS_TIMER=y
 CONFIG_LEDS_CPU=y
 CONFIG_ALIGNMENT_TRAP=y
 
@@ -174,6 +255,12 @@ CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_CMDLINE="root=1f03 mem=32M"
 # CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
 
 #
 # Floating point emulation
@@ -182,8 +269,7 @@ CONFIG_CMDLINE="root=1f03 mem=32M"
 #
 # At least one emulation must be selected
 #
-CONFIG_FPE_NWFPE=y
-# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_NWFPE is not set
 # CONFIG_FPE_FASTFPE is not set
 CONFIG_VFP=y
 
@@ -191,42 +277,40 @@ CONFIG_VFP=y
 # Userspace binary formats
 #
 CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
 # CONFIG_BINFMT_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_ARTHUR is not set
 
 #
 # Power management options
 #
-CONFIG_PM=y
-# CONFIG_PM_LEGACY is not set
-# CONFIG_PM_DEBUG is not set
-# CONFIG_APM is not set
-
-#
-# Networking
-#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_NET=y
 
 #
 # Networking options
 #
-# CONFIG_NETDEBUG is not set
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
 CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
+# CONFIG_IP_MULTICAST is not set
 # CONFIG_IP_ADVANCED_ROUTER is not set
 CONFIG_IP_FIB_HASH=y
 CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
 # CONFIG_NET_IPIP is not set
 # CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
 # CONFIG_INET_AH is not set
@@ -234,31 +318,24 @@ CONFIG_IP_PNP_BOOTP=y
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_XFRM_TUNNEL is not set
 # CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
 # CONFIG_INET_DIAG is not set
-CONFIG_INET_TCP_DIAG=y
 # CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_BIC=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
 # CONFIG_IPV6 is not set
-# CONFIG_INET6_XFRM_TUNNEL is not set
-# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
 # CONFIG_NETFILTER is not set
-
-#
-# DCCP Configuration (EXPERIMENTAL)
-#
 # CONFIG_IP_DCCP is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
 # CONFIG_IP_SCTP is not set
-
-#
-# TIPC Configuration (EXPERIMENTAL)
-#
 # CONFIG_TIPC is not set
 # CONFIG_ATM is not set
 # CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
 # CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
 # CONFIG_LLC2 is not set
@@ -266,13 +343,8 @@ CONFIG_TCP_CONG_BIC=y
 # CONFIG_ATALK is not set
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
 # CONFIG_NET_SCHED is not set
 
 #
@@ -280,9 +352,14 @@ CONFIG_TCP_CONG_BIC=y
 #
 # CONFIG_NET_PKTGEN is not set
 # CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
-# CONFIG_IEEE80211 is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
 
 #
 # Device Drivers
@@ -291,19 +368,16 @@ CONFIG_TCP_CONG_BIC=y
 #
 # Generic Driver Options
 #
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
 # CONFIG_DEBUG_DRIVER is not set
-
-#
-# Connector - unified userspace <-> kernelspace linker
-#
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
 # CONFIG_CONNECTOR is not set
-
-#
-# Memory Technology Devices (MTD)
-#
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
 # CONFIG_MTD_CONCAT is not set
@@ -311,16 +385,20 @@ CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 CONFIG_MTD_CMDLINE_PARTS=y
 # CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
 
 #
 # User Modules And Translation Layers
 #
 CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
 CONFIG_MTD_BLOCK=y
 # CONFIG_FTL is not set
 # CONFIG_NFTL is not set
 # CONFIG_INFTL is not set
 # CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -328,11 +406,7 @@ CONFIG_MTD_BLOCK=y
 CONFIG_MTD_CFI=y
 # CONFIG_MTD_JEDECPROBE is not set
 CONFIG_MTD_GEN_PROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_NOSWAP=y
-# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
-# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
-# CONFIG_MTD_CFI_GEOMETRY is not set
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
 CONFIG_MTD_MAP_BANK_WIDTH_1=y
 CONFIG_MTD_MAP_BANK_WIDTH_2=y
 CONFIG_MTD_MAP_BANK_WIDTH_4=y
@@ -343,15 +417,13 @@ CONFIG_MTD_CFI_I1=y
 CONFIG_MTD_CFI_I2=y
 # CONFIG_MTD_CFI_I4 is not set
 # CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_OTP is not set
 CONFIG_MTD_CFI_INTELEXT=y
-# CONFIG_MTD_CFI_AMDSTD is not set
+CONFIG_MTD_CFI_AMDSTD=y
 # CONFIG_MTD_CFI_STAA is not set
 CONFIG_MTD_CFI_UTIL=y
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
 # CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_OBSOLETE_CHIPS is not set
 
 #
 # Mapping drivers for chip access
@@ -375,122 +447,73 @@ CONFIG_MTD_ARM_INTEGRATOR=y
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOC2001PLUS is not set
-
-#
-# NAND Flash Device Drivers
-#
 # CONFIG_MTD_NAND is not set
-
-#
-# OneNAND Flash Device Drivers
-#
 # CONFIG_MTD_ONENAND is not set
 
 #
-# Parallel port support
+# UBI - Unsorted block images
 #
+# CONFIG_MTD_UBI is not set
 # CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
 
 #
 # SCSI device support
 #
 # CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
 # CONFIG_MD is not set
-
-#
-# Fusion MPT device support
-#
-# CONFIG_FUSION is not set
-
-#
-# IEEE 1394 (FireWire) support
-#
-
-#
-# I2O device support
-#
-
-#
-# Network device support
-#
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-
-#
-# PHY device support
-#
+# CONFIG_VETH is not set
 # CONFIG_PHYLIB is not set
-
-#
-# Ethernet (10 or 100Mbit)
-#
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
+# CONFIG_AX88796 is not set
 CONFIG_SMC91X=y
 # CONFIG_DM9000 is not set
-
-#
-# Ethernet (1000 Mbit)
-#
-
-#
-# Ethernet (10000 Mbit)
-#
-
-#
-# Token Ring devices
-#
-
-#
-# Wireless LAN (non-hamradio)
-#
-# CONFIG_NET_RADIO is not set
-
-#
-# Wan interfaces
-#
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
 # CONFIG_WAN is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
-
-#
-# ISDN subsystem
-#
 # CONFIG_ISDN is not set
 
 #
 # Input device support
 #
 CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
 
 #
 # Userland interfaces
@@ -500,7 +523,6 @@ CONFIG_INPUT_MOUSEDEV_PSAUX=y
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
 
@@ -513,11 +535,20 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_LKKBD is not set
 # CONFIG_KEYBOARD_XTKBD is not set
 # CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
 # CONFIG_MOUSE_SERIAL is not set
 # CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
 
@@ -535,21 +566,17 @@ CONFIG_SERIO_LIBPS2=y
 # Character devices
 #
 CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
 CONFIG_VT_CONSOLE=y
 CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
 # CONFIG_SERIAL_NONSTANDARD is not set
 
 #
 # Serial drivers
 #
-CONFIG_SERIAL_8250=m
-CONFIG_SERIAL_8250_NR_UARTS=4
-CONFIG_SERIAL_8250_RUNTIME_UARTS=4
-CONFIG_SERIAL_8250_EXTENDED=y
-CONFIG_SERIAL_8250_MANY_PORTS=y
-CONFIG_SERIAL_8250_SHARE_IRQ=y
-# CONFIG_SERIAL_8250_DETECT_IRQ is not set
-CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250 is not set
 
 #
 # Non-8250 serial port support
@@ -561,221 +588,257 @@ CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=16
-
-#
-# IPMI
-#
 # CONFIG_IPMI_HANDLER is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
 # CONFIG_NVRAM is not set
-# CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
-
-#
-# Ftape, the floppy tape device driver
-#
 # CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
 
 #
-# TPM devices
+# I2C Hardware Bus support
 #
-# CONFIG_TCG_TPM is not set
-# CONFIG_TELCLOCK is not set
 
 #
-# I2C support
+# I2C system bus drivers (mostly embedded / system-on-chip)
 #
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=m
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+CONFIG_I2C_VERSATILE=y
 
 #
-# I2C Algorithms
+# External I2C/SMBus adapter drivers
 #
-CONFIG_I2C_ALGOBIT=y
-# CONFIG_I2C_ALGOPCF is not set
-# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
 
 #
-# I2C Hardware Bus support
+# Other I2C/SMBus bus drivers
 #
-# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
 # CONFIG_I2C_STUB is not set
-# CONFIG_I2C_PCA_ISA is not set
 
 #
 # Miscellaneous I2C Chip support
 #
-# CONFIG_SENSORS_DS1337 is not set
-# CONFIG_SENSORS_DS1374 is not set
-CONFIG_SENSORS_EEPROM=m
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
 # CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
 # CONFIG_SENSORS_PCA9539 is not set
 # CONFIG_SENSORS_PCF8591 is not set
 # CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
 # CONFIG_I2C_DEBUG_CORE is not set
 # CONFIG_I2C_DEBUG_ALGO is not set
 # CONFIG_I2C_DEBUG_BUS is not set
 # CONFIG_I2C_DEBUG_CHIP is not set
-
-#
-# SPI support
-#
 # CONFIG_SPI is not set
-# CONFIG_SPI_MASTER is not set
-
-#
-# Dallas's 1-wire bus
-#
 # CONFIG_W1 is not set
-
-#
-# Hardware Monitoring support
-#
+# CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
-# CONFIG_HWMON_VID is not set
-
-#
-# Misc devices
-#
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
 
 #
-# LED devices
+# Sonics Silicon Backplane
 #
-# CONFIG_NEW_LEDS is not set
+# CONFIG_SSB is not set
 
 #
-# LED drivers
+# Multifunction device drivers
 #
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
 
 #
-# LED Triggers
+# Multimedia devices
 #
 
 #
-# Multimedia devices
+# Multimedia core support
 #
 # CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
 
 #
-# Digital Video Broadcasting Devices
+# Multimedia drivers
 #
-# CONFIG_DVB is not set
+# CONFIG_DAB is not set
 
 #
 # Graphics support
 #
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
 CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
-# CONFIG_FB_FIRMWARE_EDID is not set
+# CONFIG_FB_BACKLIGHT is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
 CONFIG_FB_ARMCLCD=y
 # CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
 
 #
 # Console display driver support
 #
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
 # CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
-CONFIG_FONTS=y
-# CONFIG_FONT_8x8 is not set
-# CONFIG_FONT_8x16 is not set
-# CONFIG_FONT_6x11 is not set
-# CONFIG_FONT_7x14 is not set
-# CONFIG_FONT_PEARL_8x8 is not set
-CONFIG_FONT_ACORN_8x8=y
-# CONFIG_FONT_MINI_4x6 is not set
-# CONFIG_FONT_SUN8x16 is not set
-# CONFIG_FONT_SUN12x22 is not set
-# CONFIG_FONT_10x18 is not set
-
-#
-# Logo configuration
-#
-# CONFIG_LOGO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Sound
-#
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
 CONFIG_SOUND=y
-
-#
-# Advanced Linux Sound Architecture
-#
-CONFIG_SND=m
-CONFIG_SND_TIMER=m
-CONFIG_SND_PCM=m
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
 # CONFIG_SND_SEQUENCER is not set
 CONFIG_SND_OSSEMUL=y
-CONFIG_SND_MIXER_OSS=m
-CONFIG_SND_PCM_OSS=m
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
 CONFIG_SND_PCM_OSS_PLUGINS=y
 # CONFIG_SND_DYNAMIC_MINORS is not set
 CONFIG_SND_SUPPORT_OLD_API=y
 CONFIG_SND_VERBOSE_PROCFS=y
 # CONFIG_SND_VERBOSE_PRINTK is not set
 # CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_AC97_CODEC=y
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_ARMAACI=y
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_AC97_BUS=y
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
 
 #
-# Generic devices
-#
-CONFIG_SND_AC97_CODEC=m
-CONFIG_SND_AC97_BUS=m
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_MPU401 is not set
-
-#
-# ALSA ARM devices
+# MMC/SD/SDIO Card Drivers
 #
-CONFIG_SND_ARMAACI=m
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
 
 #
-# Open Sound System
+# MMC/SD/SDIO Host Controller Drivers
 #
-# CONFIG_SOUND_PRIME is not set
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
 
 #
-# USB support
+# RTC interfaces
 #
-CONFIG_USB_ARCH_HAS_HCD=y
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB is not set
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+# I2C RTC drivers
 #
+CONFIG_RTC_DRV_DS1307=y
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
 
 #
-# USB Gadget Support
+# SPI RTC drivers
 #
-# CONFIG_USB_GADGET is not set
 
 #
-# MMC/SD Card support
+# Platform RTC drivers
 #
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_BLOCK=y
-CONFIG_MMC_ARMMMCI=m
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
 
 #
-# Real Time Clock
+# on-CPU RTC drivers
 #
-CONFIG_RTC_LIB=y
-# CONFIG_RTC_CLASS is not set
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
 
 #
 # File systems
@@ -783,17 +846,20 @@ CONFIG_RTC_LIB=y
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
 # CONFIG_EXT2_FS_XIP is not set
-# CONFIG_EXT3_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 # CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
 # CONFIG_XFS_FS is not set
 # CONFIG_OCFS2_FS is not set
-CONFIG_MINIX_FS=y
-CONFIG_ROMFS_FS=y
-# CONFIG_INOTIFY is not set
-# CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_FUSE_FS is not set
@@ -807,9 +873,9 @@ CONFIG_DNOTIFY=y
 #
 # DOS/FAT/NT Filesystems
 #
-CONFIG_FAT_FS=m
+CONFIG_FAT_FS=y
 # CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=m
+CONFIG_VFAT_FS=y
 CONFIG_FAT_DEFAULT_CODEPAGE=437
 CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 # CONFIG_NTFS_FS is not set
@@ -818,10 +884,12 @@ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
 CONFIG_SYSFS=y
-# CONFIG_TMPFS is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
 # CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
 # CONFIG_CONFIGFS_FS is not set
 
 #
@@ -834,41 +902,38 @@ CONFIG_RAMFS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
-# CONFIG_JFFS_FS is not set
 CONFIG_JFFS2_FS=y
 CONFIG_JFFS2_FS_DEBUG=0
 CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
 # CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
 # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
 CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
 CONFIG_JFFS2_RTIME=y
 # CONFIG_JFFS2_RUBIN is not set
 CONFIG_CRAMFS=y
 # CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
-
-#
-# Network File Systems
-#
+CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
-# CONFIG_NFS_DIRECTIO is not set
-CONFIG_NFSD=y
-CONFIG_NFSD_V3=y
-# CONFIG_NFSD_V3_ACL is not set
-# CONFIG_NFSD_V4 is not set
-# CONFIG_NFSD_TCP is not set
 CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-CONFIG_EXPORTFS=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
@@ -876,38 +941,18 @@ CONFIG_SUNRPC=y
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
-# CONFIG_9P_FS is not set
 
 #
 # Partition Types
 #
-CONFIG_PARTITION_ADVANCED=y
-# CONFIG_ACORN_PARTITION is not set
-# CONFIG_OSF_PARTITION is not set
-# CONFIG_AMIGA_PARTITION is not set
-# CONFIG_ATARI_PARTITION is not set
-# CONFIG_MAC_PARTITION is not set
+# CONFIG_PARTITION_ADVANCED is not set
 CONFIG_MSDOS_PARTITION=y
-# CONFIG_BSD_DISKLABEL is not set
-# CONFIG_MINIX_SUBPARTITION is not set
-# CONFIG_SOLARIS_X86_PARTITION is not set
-# CONFIG_UNIXWARE_DISKLABEL is not set
-# CONFIG_LDM_PARTITION is not set
-# CONFIG_SGI_PARTITION is not set
-# CONFIG_ULTRIX_PARTITION is not set
-# CONFIG_SUN_PARTITION is not set
-# CONFIG_KARMA_PARTITION is not set
-# CONFIG_EFI_PARTITION is not set
-
-#
-# Native Language Support
-#
-CONFIG_NLS=m
+CONFIG_NLS=y
 CONFIG_NLS_DEFAULT="iso8859-1"
-# CONFIG_NLS_CODEPAGE_437 is not set
+CONFIG_NLS_CODEPAGE_437=y
 # CONFIG_NLS_CODEPAGE_737 is not set
 # CONFIG_NLS_CODEPAGE_775 is not set
-CONFIG_NLS_CODEPAGE_850=m
+# CONFIG_NLS_CODEPAGE_850 is not set
 # CONFIG_NLS_CODEPAGE_852 is not set
 # CONFIG_NLS_CODEPAGE_855 is not set
 # CONFIG_NLS_CODEPAGE_857 is not set
@@ -928,7 +973,7 @@ CONFIG_NLS_CODEPAGE_850=m
 # CONFIG_NLS_CODEPAGE_1250 is not set
 # CONFIG_NLS_CODEPAGE_1251 is not set
 # CONFIG_NLS_ASCII is not set
-CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_1=y
 # CONFIG_NLS_ISO8859_2 is not set
 # CONFIG_NLS_ISO8859_3 is not set
 # CONFIG_NLS_ISO8859_4 is not set
@@ -942,37 +987,76 @@ CONFIG_NLS_ISO8859_1=m
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
 # CONFIG_NLS_UTF8 is not set
-
-#
-# Profiling support
-#
-# CONFIG_PROFILING is not set
+# CONFIG_DLM is not set
 
 #
 # Kernel hacking
 #
 # CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
 CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
-CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_SHIRQ is not set
 CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
 # CONFIG_SCHEDSTATS is not set
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
 # CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_FS is not set
 # CONFIG_DEBUG_VM is not set
-CONFIG_FRAME_POINTER=y
-# CONFIG_UNWIND_INFO is not set
-CONFIG_FORCED_INLINING=y
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
 # CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
 CONFIG_DEBUG_USER=y
 CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
 CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_CONSOLE=y
 # CONFIG_DEBUG_ICEDCC is not set
 
 #
@@ -980,22 +1064,108 @@ CONFIG_DEBUG_LL=y
 #
 # CONFIG_KEYS is not set
 # CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
 
 #
-# Cryptographic options
+# Compression
 #
-# CONFIG_CRYPTO is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
 
 #
-# Hardware crypto devices
+# Random Number Generation
 #
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
 
 #
 # Library routines
 #
+CONFIG_BITREVERSE=y
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
 CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/include/asm/assembler.h b/arch/arm/include/asm/assembler.h
index 6116e48..550cdcf 100644
--- a/arch/arm/include/asm/assembler.h
+++ b/arch/arm/include/asm/assembler.h
@@ -114,3 +114,87 @@
 	.align	3;				\
 	.long	9999b,9001f;			\
 	.previous
+
+#ifdef CONFIG_THUMB2_KERNEL
+	.macro	setmode, mode, reg
+	mov	\reg, #\mode
+	msr	cpsr_c, \reg
+	.endm
+#else
+	.macro	setmode, mode, reg
+	msr	cpsr_c, #\mode
+	.endm
+#endif
+
+/*
+ * STRT/LDRT access macros with ARM and Thumb-2 variants
+ */
+#ifdef CONFIG_THUMB2_KERNEL
+
+	.macro	usraccoff, instr, reg, ptr, inc, off, cond, abort
+9999:
+	.if	\inc == 1
+	\instr\cond\()bt \reg, [\ptr, #\off]
+	.elseif	\inc == 4
+	\instr\cond\()t \reg, [\ptr, #\off]
+	.else
+	.error	"Unsupported inc macro argument"
+	.endif
+
+	.section __ex_table,"a"
+	.align	3
+	.long	9999b, \abort
+	.previous
+	.endm
+
+	.macro	usracc, instr, reg, ptr, inc, cond, rept, abort
+	@ explicit IT instruction needed because of the label
+	@ introduced by the USER macro
+	.ifnc	\cond,al
+	.if	\rept == 1
+	itt	\cond
+	.elseif	\rept == 2
+	ittt	\cond
+	.else
+	.error	"Unsupported rept macro argument"
+	.endif
+	.endif
+
+	@ Slightly optimised to avoid incrementing the pointer twice
+	usraccoff \instr, \reg, \ptr, \inc, 0, \cond, \abort
+	.if	\rept == 2
+	usraccoff \instr, \reg, \ptr, \inc, 4, \cond, \abort
+	.endif
+
+	add\cond \ptr, #\rept * \inc
+	.endm
+
+#else	/* !CONFIG_THUMB2_KERNEL */
+
+	.macro	usracc, instr, reg, ptr, inc, cond, rept, abort
+	.rept	\rept
+9999:
+	.if	\inc == 1
+	\instr\cond\()bt \reg, [\ptr], #\inc
+	.elseif	\inc == 4
+	\instr\cond\()t \reg, [\ptr], #\inc
+	.else
+	.error	"Unsupported inc macro argument"
+	.endif
+
+	.section __ex_table,"a"
+	.align	3
+	.long	9999b, \abort
+	.previous
+	.endr
+	.endm
+
+#endif	/* !CONFIG_THUMB2_KERNEL */
+
+	.macro	strusr, reg, ptr, inc, cond=al, rept=1, abort=9001f
+	usracc	str, \reg, \ptr, \inc, \cond, \rept, \abort
+	.endm
+
+	.macro	ldrusr, reg, ptr, inc, cond=al, rept=1, abort=9001f
+	usracc	ldr, \reg, \ptr, \inc, \cond, \rept, \abort
+	.endm
diff --git a/arch/arm/include/asm/atomic.h b/arch/arm/include/asm/atomic.h
index 325f881..9f65915 100644
--- a/arch/arm/include/asm/atomic.h
+++ b/arch/arm/include/asm/atomic.h
@@ -24,6 +24,26 @@ typedef struct { volatile int counter; } atomic_t;
 
 #if __LINUX_ARM_ARCH__ >= 6
 
+#ifdef CONFIG_ARM_ERRATA_351422
+static inline int atomic_backoff_delay(void)
+{
+	unsigned int delay;
+	__asm__ __volatile__(
+	"	mrc	p15, 0, %0, c0, c0, 5\n"
+	"	and	%0, %0, #0xf\n"
+	"	mov	%0, %0, lsl #8\n"
+	"1:	subs	%0, %0, #1\n"
+	"	bpl	1b\n"
+	: "=&r" (delay)
+	:
+	: "cc" );
+
+	return 1;
+}
+#else
+#define atomic_backoff_delay()	1
+#endif
+
 /*
  * ARMv6 UP and SMP safe atomic ops.  We use load exclusive and
  * store exclusive to ensure that these are atomic.  We may loop
@@ -35,14 +55,14 @@ static inline void atomic_set(atomic_t *v, int i)
 {
 	unsigned long tmp;
 
+	do {
 	__asm__ __volatile__("@ atomic_set\n"
 "1:	ldrex	%0, [%1]\n"
 "	strex	%0, %2, [%1]\n"
-"	teq	%0, #0\n"
-"	bne	1b"
 	: "=&r" (tmp)
 	: "r" (&v->counter), "r" (i)
 	: "cc");
+	} while (tmp && atomic_backoff_delay());
 }
 
 static inline int atomic_add_return(int i, atomic_t *v)
@@ -50,15 +70,15 @@ static inline int atomic_add_return(int i, atomic_t *v)
 	unsigned long tmp;
 	int result;
 
+	do {
 	__asm__ __volatile__("@ atomic_add_return\n"
 "1:	ldrex	%0, [%2]\n"
 "	add	%0, %0, %3\n"
 "	strex	%1, %0, [%2]\n"
-"	teq	%1, #0\n"
-"	bne	1b"
 	: "=&r" (result), "=&r" (tmp)
 	: "r" (&v->counter), "Ir" (i)
 	: "cc");
+	} while (tmp && atomic_backoff_delay());
 
 	return result;
 }
@@ -68,15 +88,15 @@ static inline int atomic_sub_return(int i, atomic_t *v)
 	unsigned long tmp;
 	int result;
 
+	do {
 	__asm__ __volatile__("@ atomic_sub_return\n"
 "1:	ldrex	%0, [%2]\n"
 "	sub	%0, %0, %3\n"
 "	strex	%1, %0, [%2]\n"
-"	teq	%1, #0\n"
-"	bne	1b"
 	: "=&r" (result), "=&r" (tmp)
 	: "r" (&v->counter), "Ir" (i)
 	: "cc");
+	} while (tmp && atomic_backoff_delay());
 
 	return result;
 }
@@ -90,11 +110,12 @@ static inline int atomic_cmpxchg(atomic_t *ptr, int old, int new)
 		"ldrex	%1, [%2]\n"
 		"mov	%0, #0\n"
 		"teq	%1, %3\n"
+		"it	eq\n"
 		"strexeq %0, %4, [%2]\n"
 		    : "=&r" (res), "=&r" (oldval)
 		    : "r" (&ptr->counter), "Ir" (old), "r" (new)
 		    : "cc");
-	} while (res);
+	} while (res && atomic_backoff_delay());
 
 	return oldval;
 }
@@ -103,15 +124,15 @@ static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)
 {
 	unsigned long tmp, tmp2;
 
+	do {
 	__asm__ __volatile__("@ atomic_clear_mask\n"
 "1:	ldrex	%0, [%2]\n"
 "	bic	%0, %0, %3\n"
 "	strex	%1, %0, [%2]\n"
-"	teq	%1, #0\n"
-"	bne	1b"
 	: "=&r" (tmp), "=&r" (tmp2)
 	: "r" (addr), "Ir" (mask)
 	: "cc");
+	} while (tmp && atomic_backoff_delay());
 }
 
 #else /* ARM_ARCH_6 */
diff --git a/arch/arm/include/asm/cacheflush.h b/arch/arm/include/asm/cacheflush.h
index de6c59f..a8076bf 100644
--- a/arch/arm/include/asm/cacheflush.h
+++ b/arch/arm/include/asm/cacheflush.h
@@ -15,6 +15,7 @@
 
 #include <asm/glue.h>
 #include <asm/shmparam.h>
+#include <asm/cachetype.h>
 
 #define CACHE_COLOUR(vaddr)	((vaddr & (SHMLBA - 1)) >> PAGE_SHIFT)
 
@@ -264,6 +265,22 @@ extern void dmac_flush_range(const void *, const void *);
 
 #endif
 
+#ifdef CONFIG_CPU_NO_CACHE_BCAST
+enum smp_dma_cache_type {
+	SMP_DMA_CACHE_INV,
+	SMP_DMA_CACHE_CLEAN,
+	SMP_DMA_CACHE_FLUSH,
+};
+extern void smp_dma_cache_op(int type, const void *start, const void *end);
+#define smp_dma_inv_range(s, e)		smp_dma_cache_op(SMP_DMA_CACHE_INV, s, e)
+#define smp_dma_clean_range(s, e)	smp_dma_cache_op(SMP_DMA_CACHE_CLEAN, s, e)
+#define smp_dma_flush_range(s, e)	smp_dma_cache_op(SMP_DMA_CACHE_FLUSH, s, e)
+#else
+#define smp_dma_inv_range		dmac_inv_range
+#define smp_dma_clean_range		dmac_clean_range
+#define smp_dma_flush_range		dmac_flush_range
+#endif
+
 #ifdef CONFIG_OUTER_CACHE
 
 extern struct outer_cache_fns outer_cache;
@@ -296,16 +313,6 @@ static inline void outer_flush_range(unsigned long start, unsigned long end)
 #endif
 
 /*
- * flush_cache_vmap() is used when creating mappings (eg, via vmap,
- * vmalloc, ioremap etc) in kernel space for pages.  Since the
- * direct-mappings of these pages may contain cached data, we need
- * to do a full cache flush to ensure that writebacks don't corrupt
- * data placed into these pages via the new mappings.
- */
-#define flush_cache_vmap(start, end)		flush_cache_all()
-#define flush_cache_vunmap(start, end)		flush_cache_all()
-
-/*
  * Copy user data from/to a page which is mapped into a different
  * processes address space.  Really, we want to allow our "user
  * space" model to handle this.
@@ -444,4 +451,29 @@ static inline void flush_ioremap_region(unsigned long phys, void __iomem *virt,
 	dmac_inv_range(start, start + size);
 }
 
+/*
+ * flush_cache_vmap() is used when creating mappings (eg, via vmap,
+ * vmalloc, ioremap etc) in kernel space for pages.  On non-VIPT
+ * caches, since the direct-mappings of these pages may contain cached
+ * data, we need to do a full cache flush to ensure that writebacks
+ * don't corrupt data placed into these pages via the new mappings.
+ */
+static inline void flush_cache_vmap(unsigned long start, unsigned long end)
+{
+	if (!cache_is_vipt_nonaliasing())
+		flush_cache_all();
+	else
+		/*
+		 * set_pte_at() called from vmap_pte_range() does not
+		 * have a DSB after cleaning the cache line.
+		 */
+		dsb();
+}
+
+static inline void flush_cache_vunmap(unsigned long start, unsigned long end)
+{
+	if (!cache_is_vipt_nonaliasing())
+		flush_cache_all();
+}
+
 #endif
diff --git a/arch/arm/include/asm/checksum.h b/arch/arm/include/asm/checksum.h
index 6dcc164..e4b9f6e 100644
--- a/arch/arm/include/asm/checksum.h
+++ b/arch/arm/include/asm/checksum.h
@@ -73,6 +73,7 @@ ip_fast_csum(const void *iph, unsigned int ihl)
 1:	adcs	%0, %0, %3					\n\
 	ldr	%3, [%1], #4					\n\
 	tst	%2, #15			@ do this carefully	\n\
+	it	ne						\n\
 	subne	%2, %2, #1		@ without destroying	\n\
 	bne	1b			@ the carry flag	\n\
 	adcs	%0, %0, %3					\n\
diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h
index 7b9d27e..b3e656c 100644
--- a/arch/arm/include/asm/cputype.h
+++ b/arch/arm/include/asm/cputype.h
@@ -8,6 +8,21 @@
 #define CPUID_TCM	2
 #define CPUID_TLBTYPE	3
 
+#define CPUID_EXT_PFR0	"c1, 0"
+#define CPUID_EXT_PFR1	"c1, 1"
+#define CPUID_EXT_DFR0	"c1, 2"
+#define CPUID_EXT_AFR0	"c1, 3"
+#define CPUID_EXT_MMFR0	"c1, 4"
+#define CPUID_EXT_MMFR1	"c1, 5"
+#define CPUID_EXT_MMFR2	"c1, 6"
+#define CPUID_EXT_MMFR3	"c1, 7"
+#define CPUID_EXT_ISAR0	"c2, 0"
+#define CPUID_EXT_ISAR1	"c2, 1"
+#define CPUID_EXT_ISAR2	"c2, 2"
+#define CPUID_EXT_ISAR3	"c2, 3"
+#define CPUID_EXT_ISAR4	"c2, 4"
+#define CPUID_EXT_ISAR5	"c2, 5"
+
 #ifdef CONFIG_CPU_CP15
 #define read_cpuid(reg)							\
 	({								\
@@ -18,9 +33,19 @@
 		    : "cc");						\
 		__val;							\
 	})
+#define read_cpuid_ext(ext_reg)						\
+	({								\
+		unsigned int __val;					\
+		asm("mrc	p15, 0, %0, c0, " ext_reg		\
+		    : "=r" (__val)					\
+		    :							\
+		    : "cc");						\
+		__val;							\
+	})
 #else
 extern unsigned int processor_id;
 #define read_cpuid(reg) (processor_id)
+#define read_cpuid_ext(reg) 0
 #endif
 
 /*
diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h
index 4ed149c..960422e 100644
--- a/arch/arm/include/asm/dma-mapping.h
+++ b/arch/arm/include/asm/dma-mapping.h
@@ -336,7 +336,9 @@ static inline dma_addr_t dma_map_page(struct device *dev, struct page *page,
 static inline void dma_unmap_single(struct device *dev, dma_addr_t handle,
 		size_t size, enum dma_data_direction dir)
 {
-	/* nothing to do */
+#ifdef CONFIG_ARCH_PC302
+        dma_cache_maint(dma_to_virt(dev, handle), size, dir);
+#endif
 }
 #endif /* CONFIG_DMABOUNCE */
 
@@ -384,7 +386,11 @@ static inline void dma_sync_single_range_for_cpu(struct device *dev,
 {
 	BUG_ON(!valid_dma_direction(dir));
 
-	dmabounce_sync_for_cpu(dev, handle, offset, size, dir);
+	if (!dmabounce_sync_for_cpu(dev, handle, offset, size, dir))
+		return;
+
+	if (!arch_is_coherent())
+		dma_cache_maint(dma_to_virt(dev, handle) + offset, size, dir);
 }
 
 static inline void dma_sync_single_range_for_device(struct device *dev,
diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h
index a58378c..e9b66a2 100644
--- a/arch/arm/include/asm/elf.h
+++ b/arch/arm/include/asm/elf.h
@@ -50,6 +50,10 @@ typedef struct user_fp elf_fpregset_t;
 #define R_ARM_ABS32	2
 #define R_ARM_CALL	28
 #define R_ARM_JUMP24	29
+#define R_ARM_PREL31	42
+
+#define R_ARM_THM_JUMP24	30
+#define R_ARM_THM_CALL		10
 
 /*
  * These are used to set parameters in the core dumps.
diff --git a/arch/arm/include/asm/futex.h b/arch/arm/include/asm/futex.h
index 9ee743b..0efee0f 100644
--- a/arch/arm/include/asm/futex.h
+++ b/arch/arm/include/asm/futex.h
@@ -99,6 +99,7 @@ futex_atomic_cmpxchg_inatomic(int __user *uaddr, int oldval, int newval)
 	__asm__ __volatile__("@futex_atomic_cmpxchg_inatomic\n"
 	"1:	ldrt	%0, [%3]\n"
 	"	teq	%0, %1\n"
+	"	it	eq\n"
 	"2:	streqt	%2, [%3]\n"
 	"3:\n"
 	"	.section __ex_table,\"a\"\n"
diff --git a/arch/arm/include/asm/hardware/cache-l2x0.h b/arch/arm/include/asm/hardware/cache-l2x0.h
index 64f2252..cdb9022 100644
--- a/arch/arm/include/asm/hardware/cache-l2x0.h
+++ b/arch/arm/include/asm/hardware/cache-l2x0.h
@@ -24,6 +24,8 @@
 #define L2X0_CACHE_TYPE			0x004
 #define L2X0_CTRL			0x100
 #define L2X0_AUX_CTRL			0x104
+#define L2X0_TAG_LATENCY_CTRL		0x108
+#define L2X0_DATA_LATENCY_CTRL		0x10C
 #define L2X0_EVENT_CNT_CTRL		0x200
 #define L2X0_EVENT_CNT1_CFG		0x204
 #define L2X0_EVENT_CNT0_CFG		0x208
diff --git a/arch/arm/include/asm/hardware/debug-8250.S b/arch/arm/include/asm/hardware/debug-8250.S
index 22c6892..3ae708d 100644
--- a/arch/arm/include/asm/hardware/debug-8250.S
+++ b/arch/arm/include/asm/hardware/debug-8250.S
@@ -10,11 +10,12 @@
 #include <linux/serial_reg.h>
 
 		.macro	senduart,rd,rx
-		strb	\rd, [\rx, #UART_TX << UART_SHIFT]
+                and     \rd, \rd, #0xff
+		str	\rd, [\rx, #UART_TX << UART_SHIFT]
 		.endm
 
 		.macro	busyuart,rd,rx
-1002:		ldrb	\rd, [\rx, #UART_LSR << UART_SHIFT]
+1002:		ldr	\rd, [\rx, #UART_LSR << UART_SHIFT]
 		and	\rd, \rd, #UART_LSR_TEMT | UART_LSR_THRE
 		teq	\rd, #UART_LSR_TEMT | UART_LSR_THRE
 		bne	1002b
@@ -22,7 +23,8 @@
 
 		.macro	waituart,rd,rx
 #ifdef FLOW_CONTROL
-1001:		ldrb	\rd, [\rx, #UART_MSR << UART_SHIFT]
+1001:		ldr	\rd, [\rx, #UART_MSR << UART_SHIFT]
+                and     \rd, \rd, 0xff
 		tst	\rd, #UART_MSR_CTS
 		beq	1001b
 #endif
diff --git a/arch/arm/include/asm/hwcap.h b/arch/arm/include/asm/hwcap.h
index 81f4c89..f7bd52b 100644
--- a/arch/arm/include/asm/hwcap.h
+++ b/arch/arm/include/asm/hwcap.h
@@ -16,6 +16,9 @@
 #define HWCAP_IWMMXT	512
 #define HWCAP_CRUNCH	1024
 #define HWCAP_THUMBEE	2048
+#define HWCAP_NEON	4096
+#define HWCAP_VFPv3	8192
+#define HWCAP_VFPv3D16	16384
 
 #if defined(__KERNEL__) && !defined(__ASSEMBLY__)
 /*
diff --git a/arch/arm/include/asm/locks.h b/arch/arm/include/asm/locks.h
index ef4c897..c6f0c93 100644
--- a/arch/arm/include/asm/locks.h
+++ b/arch/arm/include/asm/locks.h
@@ -24,6 +24,7 @@
 "	teq	ip, #0\n"			\
 "	bne	1b\n"				\
 "	teq	lr, #0\n"			\
+"	itt	mi\n"				\
 "	movmi	ip, %0\n"			\
 "	blmi	" #fail				\
 	:					\
@@ -43,6 +44,7 @@
 "	teq	ip, #0\n"			\
 "	bne	1b\n"				\
 "	teq	lr, #0\n"			\
+"	itet	mi\n"				\
 "	movmi	ip, %1\n"			\
 "	movpl	ip, #0\n"			\
 "	blmi	" #fail "\n"			\
@@ -65,6 +67,7 @@
 "	teq	ip, #0\n"			\
 "	bne	1b\n"				\
 "	cmp	lr, #0\n"			\
+"	itt	le\n"				\
 "	movle	ip, %0\n"			\
 "	blle	" #wake				\
 	:					\
@@ -91,6 +94,7 @@
 "	teq	ip, #0\n"			\
 "	bne	1b\n"				\
 "	teq	lr, #0\n"			\
+"	itt	ne\n"				\
 "	movne	ip, %0\n"			\
 "	blne	" #fail				\
 	:					\
@@ -150,6 +154,7 @@
 "	subs	lr, lr, %1\n"			\
 "	str	lr, [%0]\n"			\
 "	msr	cpsr_c, ip\n"			\
+"	itt	mi\n"				\
 "	movmi	ip, %0\n"			\
 "	blmi	" #fail				\
 	:					\
@@ -170,6 +175,7 @@
 "	subs	lr, lr, %2\n"			\
 "	str	lr, [%1]\n"			\
 "	msr	cpsr_c, ip\n"			\
+"	itet	mi\n"				\
 "	movmi	ip, %1\n"			\
 "	movpl	ip, #0\n"			\
 "	blmi	" #fail "\n"			\
@@ -193,6 +199,7 @@
 "	adds	lr, lr, %1\n"			\
 "	str	lr, [%0]\n"			\
 "	msr	cpsr_c, ip\n"			\
+"	itt	le\n"				\
 "	movle	ip, %0\n"			\
 "	blle	" #wake				\
 	:					\
@@ -220,6 +227,7 @@
 "	subs	lr, lr, %1\n"			\
 "	str	lr, [%0]\n"			\
 "	msr	cpsr_c, ip\n"			\
+"	itt	ne\n"				\
 "	movne	ip, %0\n"			\
 "	blne	" #fail				\
 	:					\
@@ -239,6 +247,7 @@
 "	adds	lr, lr, %1\n"			\
 "	str	lr, [%0]\n"			\
 "	msr	cpsr_c, ip\n"			\
+"	itt	cs\n"				\
 "	movcs	ip, %0\n"			\
 "	blcs	" #wake				\
 	:					\
@@ -262,6 +271,7 @@
 "	adds	lr, lr, %1\n"			\
 "	str	lr, [%0]\n"			\
 "	msr	cpsr_c, ip\n"			\
+"	itt	eq\n"				\
 "	moveq	ip, %0\n"			\
 "	bleq	" #wake				\
 	:					\
diff --git a/arch/arm/include/asm/memory.h b/arch/arm/include/asm/memory.h
index 7776430..38aee93 100644
--- a/arch/arm/include/asm/memory.h
+++ b/arch/arm/include/asm/memory.h
@@ -45,7 +45,12 @@
  * and PAGE_OFFSET - it must be within 32MB of the kernel text.
  */
 #define MODULES_END		(PAGE_OFFSET)
+#ifndef CONFIG_THUMB2_KERNEL
 #define MODULES_VADDR		(MODULES_END - 16*1048576)
+#else
+/* smaller range for Thumb-2 symbols relocation (2^24)*/
+#define MODULES_VADDR		(MODULES_END - 8*1048576)
+#endif
 
 #if TASK_SIZE > MODULES_VADDR
 #error Top of user space clashes with start of module space
diff --git a/arch/arm/include/asm/mmu.h b/arch/arm/include/asm/mmu.h
index 53099d4..f39c215 100644
--- a/arch/arm/include/asm/mmu.h
+++ b/arch/arm/include/asm/mmu.h
@@ -6,6 +6,7 @@
 typedef struct {
 #ifdef CONFIG_CPU_HAS_ASID
 	unsigned int id;
+	spinlock_t id_lock;
 #endif
 	unsigned int kvm_seq;
 } mm_context_t;
diff --git a/arch/arm/include/asm/mmu_context.h b/arch/arm/include/asm/mmu_context.h
index 0559f37..18fa88f 100644
--- a/arch/arm/include/asm/mmu_context.h
+++ b/arch/arm/include/asm/mmu_context.h
@@ -42,12 +42,23 @@ void __check_kvm_seq(struct mm_struct *mm);
 #define ASID_FIRST_VERSION	(1 << ASID_BITS)
 
 extern unsigned int cpu_last_asid;
+#ifdef CONFIG_SMP
+DECLARE_PER_CPU(struct mm_struct *, current_mm);
+#endif
 
 void __init_new_context(struct task_struct *tsk, struct mm_struct *mm);
 void __new_context(struct mm_struct *mm);
 
 static inline void check_context(struct mm_struct *mm)
 {
+	/*
+	 * This code is executed with interrupts enabled. Therefore,
+	 * mm->context.id cannot be updated to the latest ASID version
+	 * on a different CPU (and condition below not triggered)
+	 * without first getting an IPI to reset the context. The
+	 * alternative is to take a read_lock on mm->context.id_lock
+	 * (after changing its type to rwlock_t).
+	 */
 	if (unlikely((mm->context.id ^ cpu_last_asid) >> ASID_BITS))
 		__new_context(mm);
 
@@ -61,8 +72,10 @@ static inline void check_context(struct mm_struct *mm)
 
 static inline void check_context(struct mm_struct *mm)
 {
+#ifdef CONFIG_MMU
 	if (unlikely(mm->context.kvm_seq != init_mm.context.kvm_seq))
 		__check_kvm_seq(mm);
+#endif
 }
 
 #define init_new_context(tsk,mm)	0
@@ -104,6 +117,10 @@ switch_mm(struct mm_struct *prev, struct mm_struct *next,
 		__flush_icache_all();
 #endif
 	if (!cpu_test_and_set(cpu, next->cpu_vm_mask) || prev != next) {
+#ifdef CONFIG_SMP
+		struct mm_struct **crt_mm = &per_cpu(current_mm, cpu);
+		*crt_mm = next;
+#endif
 		check_context(next);
 		cpu_switch_mm(next->pgd, next);
 		if (cache_is_vivt())
diff --git a/arch/arm/include/asm/module.h b/arch/arm/include/asm/module.h
index 24b168d..e4dfa69 100644
--- a/arch/arm/include/asm/module.h
+++ b/arch/arm/include/asm/module.h
@@ -1,15 +1,27 @@
 #ifndef _ASM_ARM_MODULE_H
 #define _ASM_ARM_MODULE_H
 
-struct mod_arch_specific
-{
-	int foo;
-};
-
 #define Elf_Shdr	Elf32_Shdr
 #define Elf_Sym		Elf32_Sym
 #define Elf_Ehdr	Elf32_Ehdr
 
+struct unwind_table;
+
+struct mod_arch_specific
+{
+#ifdef CONFIG_ARM_UNWIND
+	Elf_Shdr *unw_sec_init;
+	Elf_Shdr *unw_sec_devinit;
+	Elf_Shdr *unw_sec_core;
+	Elf_Shdr *sec_init_text;
+	Elf_Shdr *sec_devinit_text;
+	Elf_Shdr *sec_core_text;
+	struct unwind_table *unwind_init;
+	struct unwind_table *unwind_devinit;
+	struct unwind_table *unwind_core;
+#endif
+};
+
 /*
  * Include the ARM architecture version.
  */
diff --git a/arch/arm/include/asm/mutex.h b/arch/arm/include/asm/mutex.h
index 93226cf..5c3ede8 100644
--- a/arch/arm/include/asm/mutex.h
+++ b/arch/arm/include/asm/mutex.h
@@ -111,8 +111,11 @@ __mutex_fastpath_trylock(atomic_t *count, int (*fail_fn)(atomic_t *))
 
 		"1: ldrex	%0, [%3]	\n\t"
 		"subs		%1, %0, #1	\n\t"
+		"it		eq\n\t"
 		"strexeq	%2, %1, [%3]	\n\t"
+		"it		lt\n\t"
 		"movlt		%0, #0		\n\t"
+		"it		eq\n\t"
 		"cmpeq		%2, #0		\n\t"
 		"bgt		1b		"
 
diff --git a/arch/arm/include/asm/page-nommu.h b/arch/arm/include/asm/page-nommu.h
index 3574c0d..d1b162a 100644
--- a/arch/arm/include/asm/page-nommu.h
+++ b/arch/arm/include/asm/page-nommu.h
@@ -43,7 +43,4 @@ typedef unsigned long pgprot_t;
 #define __pmd(x)        (x)
 #define __pgprot(x)     (x)
 
-extern unsigned long memory_start;
-extern unsigned long memory_end;
-
 #endif
diff --git a/arch/arm/include/asm/processor.h b/arch/arm/include/asm/processor.h
index 6ff3379..0b3478c 100644
--- a/arch/arm/include/asm/processor.h
+++ b/arch/arm/include/asm/processor.h
@@ -71,6 +71,7 @@ struct thread_struct {
 		regs->ARM_cpsr = USR26_MODE;				\
 	if (elf_hwcap & HWCAP_THUMB && pc & 1)				\
 		regs->ARM_cpsr |= PSR_T_BIT;				\
+	regs->ARM_cpsr |= PSR_ENDSTATE;					\
 	regs->ARM_pc = pc & ~1;		/* pc */			\
 	regs->ARM_sp = sp;		/* sp */			\
 	regs->ARM_r2 = stack[2];	/* r2 (envp) */			\
diff --git a/arch/arm/include/asm/ptrace.h b/arch/arm/include/asm/ptrace.h
index 7319261..0a9d27d 100644
--- a/arch/arm/include/asm/ptrace.h
+++ b/arch/arm/include/asm/ptrace.h
@@ -27,6 +27,8 @@
 /* PTRACE_SYSCALL is 24 */
 #define PTRACE_GETCRUNCHREGS	25
 #define PTRACE_SETCRUNCHREGS	26
+#define PTRACE_GETVFPREGS	27
+#define PTRACE_SETVFPREGS	28
 
 /*
  * PSR bits
@@ -48,6 +50,7 @@
 #define PSR_F_BIT	0x00000040
 #define PSR_I_BIT	0x00000080
 #define PSR_A_BIT	0x00000100
+#define PSR_E_BIT	0x00000200
 #define PSR_J_BIT	0x01000000
 #define PSR_Q_BIT	0x08000000
 #define PSR_V_BIT	0x10000000
@@ -63,6 +66,30 @@
 #define PSR_x		0x0000ff00	/* Extension		*/
 #define PSR_c		0x000000ff	/* Control		*/
 
+/*
+ * ARMv7 groups of APSR bits
+ */
+#define PSR_ISET_MASK	0x01000010	/* Instruction Set state (J, T) mask */
+#define PSR_IT_MASK	0x0600fc00	/* If-Then execution state mask */
+#define PSR_ENDIAN_MASK	0x00000200	/* Endianness state mask */
+
+/*
+ * Default endianness state
+ */
+#ifdef CONFIG_CPU_ENDIAN_BE8
+#define PSR_ENDSTATE	PSR_E_BIT
+#else
+#define PSR_ENDSTATE	0
+#endif
+
+/* 
+ * These are 'magic' values for PTRACE_PEEKUSR that return info about where a
+ * process is located in memory.
+ */
+#define PT_TEXT_ADDR		0x10000
+#define PT_DATA_ADDR		0x10004
+#define PT_TEXT_END_ADDR	0x10008
+
 #ifndef __ASSEMBLY__
 
 /*
diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 727b5c0..fad70da 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -114,7 +114,7 @@ extern void local_timer_interrupt(void);
 /*
  * Stop a local timer interrupt.
  */
-extern void local_timer_stop(unsigned int cpu);
+extern void local_timer_stop(void);
 
 /*
  * Platform provides this to acknowledge a local timer IRQ
@@ -123,7 +123,7 @@ extern int local_timer_ack(void);
 
 #else
 
-static inline void local_timer_stop(unsigned int cpu)
+static inline void local_timer_stop(void)
 {
 }
 
@@ -132,7 +132,7 @@ static inline void local_timer_stop(unsigned int cpu)
 /*
  * Setup a local timer interrupt for a CPU.
  */
-extern void local_timer_setup(unsigned int cpu);
+extern void local_timer_setup(void);
 
 /*
  * show local interrupt info
diff --git a/arch/arm/include/asm/socket.h b/arch/arm/include/asm/socket.h
index 6817be9..a1c3574 100644
--- a/arch/arm/include/asm/socket.h
+++ b/arch/arm/include/asm/socket.h
@@ -54,4 +54,7 @@
 
 #define SO_MARK			36
 
+#define SO_TIMESTAMPING         37
+#define SCM_TIMESTAMPING        SO_TIMESTAMPING
+
 #endif /* _ASM_SOCKET_H */
diff --git a/arch/arm/include/asm/spinlock.h b/arch/arm/include/asm/spinlock.h
index 2b41ebb..cfc6f6d 100644
--- a/arch/arm/include/asm/spinlock.h
+++ b/arch/arm/include/asm/spinlock.h
@@ -23,15 +23,38 @@
 
 #define __raw_spin_lock_flags(lock, flags) __raw_spin_lock(lock)
 
+#ifdef CONFIG_ARM_ERRATA_351422
+#define spinlock_backoff_delay()			\
+{							\
+	unsigned int delay;				\
+	__asm__ __volatile__(				\
+	"1:	mrc     p15, 0, %0, c0, c0, 5\n"	\
+	"	and	%0, %0, #0xf\n"			\
+	"	mov	%0, %0, lsl #8\n"		\
+	"2:	subs	%0, %0, #1\n"			\
+	"	bpl	2b\n"				\
+	: "=&r" (delay)					\
+	:						\
+	: "cc" );					\
+}
+#else
+#define spinlock_backoff_delay()			\
+	__asm__ __volatile__("1:	\n");
+#endif
+
 static inline void __raw_spin_lock(raw_spinlock_t *lock)
 {
 	unsigned long tmp;
 
+	spinlock_backoff_delay();
 	__asm__ __volatile__(
-"1:	ldrex	%0, [%1]\n"
+"	ldrex	%0, [%1]\n"
 "	teq	%0, #0\n"
 #ifdef CONFIG_CPU_32v6K
+"	itee	ne\n"
 "	wfene\n"
+#else
+"	itt	eq\n"
 #endif
 "	strexeq	%0, %2, [%1]\n"
 "	teqeq	%0, #0\n"
@@ -47,9 +70,11 @@ static inline int __raw_spin_trylock(raw_spinlock_t *lock)
 {
 	unsigned long tmp;
 
+	spinlock_backoff_delay();
 	__asm__ __volatile__(
 "	ldrex	%0, [%1]\n"
 "	teq	%0, #0\n"
+"	it	eq\n"
 "	strexeq	%0, %2, [%1]"
 	: "=&r" (tmp)
 	: "r" (&lock->lock), "r" (1)
@@ -90,11 +115,15 @@ static inline void __raw_write_lock(raw_rwlock_t *rw)
 {
 	unsigned long tmp;
 
+	spinlock_backoff_delay();
 	__asm__ __volatile__(
-"1:	ldrex	%0, [%1]\n"
+"	ldrex	%0, [%1]\n"
 "	teq	%0, #0\n"
 #ifdef CONFIG_CPU_32v6K
+"	ite	ne\n"
 "	wfene\n"
+#else
+"	it	eq\n"
 #endif
 "	strexeq	%0, %2, [%1]\n"
 "	teq	%0, #0\n"
@@ -110,9 +139,11 @@ static inline int __raw_write_trylock(raw_rwlock_t *rw)
 {
 	unsigned long tmp;
 
+	spinlock_backoff_delay();
 	__asm__ __volatile__(
 "1:	ldrex	%0, [%1]\n"
 "	teq	%0, #0\n"
+"	it	eq\n"
 "	strexeq	%0, %2, [%1]"
 	: "=&r" (tmp)
 	: "r" (&rw->lock), "r" (0x80000000)
@@ -160,9 +191,15 @@ static inline void __raw_read_lock(raw_rwlock_t *rw)
 {
 	unsigned long tmp, tmp2;
 
+	spinlock_backoff_delay();
 	__asm__ __volatile__(
-"1:	ldrex	%0, [%2]\n"
+"	ldrex	%0, [%2]\n"
 "	adds	%0, %0, #1\n"
+#ifdef CONFIG_CPU_32v6K
+"	itet	pl\n"
+#else
+"	itt	pl\n"
+#endif
 "	strexpl	%1, %0, [%2]\n"
 #ifdef CONFIG_CPU_32v6K
 "	wfemi\n"
@@ -182,14 +219,16 @@ static inline void __raw_read_unlock(raw_rwlock_t *rw)
 
 	smp_mb();
 
+	spinlock_backoff_delay();
 	__asm__ __volatile__(
-"1:	ldrex	%0, [%2]\n"
+"	ldrex	%0, [%2]\n"
 "	sub	%0, %0, #1\n"
 "	strex	%1, %0, [%2]\n"
 "	teq	%1, #0\n"
 "	bne	1b"
 #ifdef CONFIG_CPU_32v6K
 "\n	cmp	%0, #0\n"
+"	itt	eq\n"
 "	mcreq   p15, 0, %0, c7, c10, 4\n"
 "	seveq"
 #endif
@@ -205,6 +244,7 @@ static inline int __raw_read_trylock(raw_rwlock_t *rw)
 	__asm__ __volatile__(
 "1:	ldrex	%0, [%2]\n"
 "	adds	%0, %0, #1\n"
+"	it	pl\n"
 "	strexpl	%1, %0, [%2]\n"
 	: "=&r" (tmp), "+r" (tmp2)
 	: "r" (&rw->lock)
diff --git a/arch/arm/include/asm/stacktrace.h b/arch/arm/include/asm/stacktrace.h
new file mode 100644
index 0000000..4d0a164
--- /dev/null
+++ b/arch/arm/include/asm/stacktrace.h
@@ -0,0 +1,15 @@
+#ifndef __ASM_STACKTRACE_H
+#define __ASM_STACKTRACE_H
+
+struct stackframe {
+	unsigned long fp;
+	unsigned long sp;
+	unsigned long lr;
+	unsigned long pc;
+};
+
+extern int unwind_frame(struct stackframe *frame);
+extern void walk_stackframe(struct stackframe *frame,
+			    int (*fn)(struct stackframe *, void *), void *data);
+
+#endif	/* __ASM_STACKTRACE_H */
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index 568020b..a636761 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -323,6 +323,56 @@ extern void enable_hlt(void);
 
 #ifndef CONFIG_SMP
 #include <asm-generic/cmpxchg.h>
+#elif __LINUX_ARM_ARCH__ >= 6
+extern void __bad_cmpxchg(volatile void *ptr, int size);
+
+static inline unsigned long __cmpxchg(volatile void *ptr, unsigned long old,
+				      unsigned long new, int size)
+{
+	unsigned long oldval, res;
+
+	switch (size) {
+	case 1:
+		do {
+			asm volatile("@ __cmpxchg1\n"
+			"	ldrexb	%1, [%2]\n"
+			"	mov	%0, #0\n"
+			"	teq	%1, %3\n"
+			"	it	eq\n"
+			"	strexeqb %0, %4, [%2]\n"
+				: "=&r" (res), "=&r" (oldval)
+				: "r" (ptr), "Ir" (old), "r" (new)
+				: "cc");
+		} while (res);
+		break;
+
+	case 4:
+		do {
+			asm volatile("@ __cmpxchg4\n"
+			"	ldrex	%1, [%2]\n"
+			"	mov	%0, #0\n"
+			"	teq	%1, %3\n"
+			"	it	eq\n"
+			"	strexeq %0, %4, [%2]\n"
+				: "=&r" (res), "=&r" (oldval)
+				: "r" (ptr), "Ir" (old), "r" (new)
+				: "cc");
+		} while (res);
+		break;
+
+	default:
+		__bad_cmpxchg(ptr, size);
+		oldval = 0;
+	}
+
+	return oldval;
+}
+
+#define cmpxchg(ptr,o,n)					\
+	((__typeof__(*(ptr)))__cmpxchg((ptr),			\
+				       (unsigned long)(o),	\
+				       (unsigned long)(n),	\
+				       sizeof(*(ptr))))
 #endif
 
 #endif /* __ASSEMBLY__ */
diff --git a/arch/arm/include/asm/thread_info.h b/arch/arm/include/asm/thread_info.h
index 68b9ec8..4f88482 100644
--- a/arch/arm/include/asm/thread_info.h
+++ b/arch/arm/include/asm/thread_info.h
@@ -99,6 +99,8 @@ static inline struct thread_info *current_thread_info(void)
 
 #define thread_saved_pc(tsk)	\
 	((unsigned long)(task_thread_info(tsk)->cpu_context.pc))
+#define thread_saved_sp(tsk)	\
+	((unsigned long)(task_thread_info(tsk)->cpu_context.sp))
 #define thread_saved_fp(tsk)	\
 	((unsigned long)(task_thread_info(tsk)->cpu_context.fp))
 
@@ -113,6 +115,8 @@ extern void iwmmxt_task_restore(struct thread_info *, void *);
 extern void iwmmxt_task_release(struct thread_info *);
 extern void iwmmxt_task_switch(struct thread_info *);
 
+extern void vfp_sync_state(struct thread_info *thread);
+
 #endif
 
 /*
diff --git a/arch/arm/include/asm/tlbflush.h b/arch/arm/include/asm/tlbflush.h
index b543a05..214c650 100644
--- a/arch/arm/include/asm/tlbflush.h
+++ b/arch/arm/include/asm/tlbflush.h
@@ -39,6 +39,11 @@
 #define TLB_V6_D_ASID	(1 << 17)
 #define TLB_V6_I_ASID	(1 << 18)
 
+/* Unified Inner Shareable TLB operations (ARMv7 MP extensions) */
+#define TLB_V7_UIS_PAGE	(1 << 19)
+#define TLB_V7_UIS_FULL (1 << 20)
+#define TLB_V7_UIS_ASID (1 << 21)
+
 #define TLB_L2CLEAN_FR	(1 << 29)		/* Feroceon */
 #define TLB_DCLEAN	(1 << 30)
 #define TLB_WB		(1 << 31)
@@ -158,9 +163,17 @@
 # define v6wbi_always_flags	(-1UL)
 #endif
 
+#ifdef CONFIG_SMP
+#define v7wbi_tlb_flags (TLB_WB | TLB_DCLEAN | \
+			 TLB_V7_UIS_FULL | TLB_V7_UIS_PAGE | TLB_V7_UIS_ASID)
+#else
+#define v7wbi_tlb_flags (TLB_WB | TLB_DCLEAN | \
+			 TLB_V6_U_FULL | TLB_V6_U_PAGE | TLB_V6_U_ASID)
+#endif
+
 #ifdef CONFIG_CPU_TLB_V7
-# define v7wbi_possible_flags	v6wbi_tlb_flags
-# define v7wbi_always_flags	v6wbi_tlb_flags
+# define v7wbi_possible_flags	v7wbi_tlb_flags
+# define v7wbi_always_flags	v7wbi_tlb_flags
 # ifdef _TLB
 #  define MULTI_TLB 1
 # else
@@ -178,6 +191,7 @@
 #ifndef __ASSEMBLY__
 
 #include <linux/sched.h>
+#include <asm/cputype.h>
 
 struct cpu_tlb_fns {
 	void (*flush_user_range)(unsigned long, unsigned long, struct vm_area_struct *);
@@ -296,10 +310,11 @@ static inline void local_flush_tlb_all(void)
 		asm("mcr p15, 0, %0, c8, c6, 0" : : "r" (zero) : "cc");
 	if (tlb_flag(TLB_V4_I_FULL | TLB_V6_I_FULL))
 		asm("mcr p15, 0, %0, c8, c5, 0" : : "r" (zero) : "cc");
+	if (tlb_flag(TLB_V7_UIS_FULL))
+		asm("mcr p15, 0, %0, c8, c3, 0" : : "r" (zero) : "cc");
 
-	if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
-		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
-		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+	if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL | TLB_V6_U_FULL |
+		     TLB_V7_UIS_FULL)) {
 		/* flush the branch target cache */
 		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
 		dsb();
@@ -333,10 +348,11 @@ static inline void local_flush_tlb_mm(struct mm_struct *mm)
 		asm("mcr p15, 0, %0, c8, c6, 2" : : "r" (asid) : "cc");
 	if (tlb_flag(TLB_V6_I_ASID))
 		asm("mcr p15, 0, %0, c8, c5, 2" : : "r" (asid) : "cc");
+	if (tlb_flag(TLB_V7_UIS_ASID))
+		asm("mcr p15, 0, %0, c8, c3, 2" : : "r" (asid) : "cc");
 
-	if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
-		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
-		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+	if (tlb_flag(TLB_V6_I_ASID | TLB_V6_D_ASID | TLB_V6_U_ASID |
+		     TLB_V7_UIS_ASID)) {
 		/* flush the branch target cache */
 		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
 		dsb();
@@ -373,10 +389,11 @@ local_flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr)
 		asm("mcr p15, 0, %0, c8, c6, 1" : : "r" (uaddr) : "cc");
 	if (tlb_flag(TLB_V6_I_PAGE))
 		asm("mcr p15, 0, %0, c8, c5, 1" : : "r" (uaddr) : "cc");
+	if (tlb_flag(TLB_V7_UIS_PAGE))
+		asm("mcr p15, 0, %0, c8, c3, 1" : : "r" (uaddr) : "cc");
 
-	if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
-		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
-		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+	if (tlb_flag(TLB_V6_I_PAGE | TLB_V6_D_PAGE | TLB_V6_U_PAGE |
+		     TLB_V7_UIS_PAGE)) {
 		/* flush the branch target cache */
 		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
 		dsb();
@@ -410,10 +427,11 @@ static inline void local_flush_tlb_kernel_page(unsigned long kaddr)
 		asm("mcr p15, 0, %0, c8, c6, 1" : : "r" (kaddr) : "cc");
 	if (tlb_flag(TLB_V6_I_PAGE))
 		asm("mcr p15, 0, %0, c8, c5, 1" : : "r" (kaddr) : "cc");
+	if (tlb_flag(TLB_V7_UIS_PAGE))
+		asm("mcr p15, 0, %0, c8, c3, 1" : : "r" (kaddr) : "cc");
 
-	if (tlb_flag(TLB_V6_I_FULL | TLB_V6_D_FULL |
-		     TLB_V6_I_PAGE | TLB_V6_D_PAGE |
-		     TLB_V6_I_ASID | TLB_V6_D_ASID)) {
+	if (tlb_flag(TLB_V6_I_PAGE | TLB_V6_D_PAGE | TLB_V6_U_PAGE |
+		     TLB_V7_UIS_PAGE)) {
 		/* flush the branch target cache */
 		asm("mcr p15, 0, %0, c7, c5, 6" : : "r" (zero) : "cc");
 		dsb();
@@ -474,21 +492,70 @@ static inline void clean_pmd_entry(pmd_t *pmd)
 #define local_flush_tlb_kernel_range(s,e)	__cpu_flush_kern_tlb_range(s,e)
 
 #ifndef CONFIG_SMP
-#define flush_tlb_all		local_flush_tlb_all
-#define flush_tlb_mm		local_flush_tlb_mm
-#define flush_tlb_page		local_flush_tlb_page
-#define flush_tlb_kernel_page	local_flush_tlb_kernel_page
-#define flush_tlb_range		local_flush_tlb_range
-#define flush_tlb_kernel_range	local_flush_tlb_kernel_range
+#define tlb_ops_need_broadcast()	0
 #else
-extern void flush_tlb_all(void);
-extern void flush_tlb_mm(struct mm_struct *mm);
-extern void flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr);
-extern void flush_tlb_kernel_page(unsigned long kaddr);
-extern void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end);
-extern void flush_tlb_kernel_range(unsigned long start, unsigned long end);
+/* all SMP configurations have the extended CPUID registers */
+static inline int tlb_ops_need_broadcast(void)
+{
+	return ((read_cpuid_ext(CPUID_EXT_MMFR3) >> 12) & 0xf) < 2;
+}
 #endif
 
+extern void smp_flush_tlb_all(void);
+extern void smp_flush_tlb_mm(struct mm_struct *mm);
+extern void smp_flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr);
+extern void smp_flush_tlb_kernel_page(unsigned long kaddr);
+extern void smp_flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end);
+extern void smp_flush_tlb_kernel_range(unsigned long start, unsigned long end);
+
+static inline void flush_tlb_all(void)
+{
+	if (tlb_ops_need_broadcast())
+		smp_flush_tlb_all();
+	else
+		local_flush_tlb_all();
+}
+
+static inline void flush_tlb_mm(struct mm_struct *mm)
+{
+	if (tlb_ops_need_broadcast())
+		smp_flush_tlb_mm(mm);
+	else
+		local_flush_tlb_mm(mm);
+}
+
+static inline void flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr)
+{
+	if (tlb_ops_need_broadcast())
+		smp_flush_tlb_page(vma, uaddr);
+	else
+		local_flush_tlb_page(vma, uaddr);
+}
+
+static inline void flush_tlb_kernel_page(unsigned long kaddr)
+{
+	if (tlb_ops_need_broadcast())
+		smp_flush_tlb_kernel_page(kaddr);
+	else
+		local_flush_tlb_kernel_page(kaddr);
+}
+
+static inline void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)
+{
+	if (tlb_ops_need_broadcast())
+		smp_flush_tlb_range(vma, start, end);
+	else
+		local_flush_tlb_range(vma, start, end);
+}
+
+static inline void flush_tlb_kernel_range(unsigned long start, unsigned long end)
+{
+	if (tlb_ops_need_broadcast())
+		smp_flush_tlb_kernel_range(start, end);
+	else
+		local_flush_tlb_kernel_range(start, end);
+}
+
 /*
  * if PG_dcache_dirty is set for the page, we need to ensure that any
  * cache entries for the kernels virtual memory range are written
diff --git a/arch/arm/include/asm/traps.h b/arch/arm/include/asm/traps.h
index aa399ae..491960b 100644
--- a/arch/arm/include/asm/traps.h
+++ b/arch/arm/include/asm/traps.h
@@ -25,5 +25,6 @@ static inline int in_exception_text(unsigned long ptr)
 }
 
 extern void __init early_trap_init(void);
+extern void dump_backtrace_entry(unsigned long where, unsigned long from, unsigned long frame);
 
 #endif
diff --git a/arch/arm/include/asm/uaccess.h b/arch/arm/include/asm/uaccess.h
index e98ec60..4c4295a 100644
--- a/arch/arm/include/asm/uaccess.h
+++ b/arch/arm/include/asm/uaccess.h
@@ -12,6 +12,7 @@
  * User space memory access functions
  */
 #include <linux/sched.h>
+#include <asm/unified.h>
 #include <asm/errno.h>
 #include <asm/memory.h>
 #include <asm/domain.h>
@@ -68,7 +69,7 @@ static inline void set_fs(mm_segment_t fs)
 
 #define __addr_ok(addr) ({ \
 	unsigned long flag; \
-	__asm__("cmp %2, %0; movlo %0, #0" \
+	__asm__("cmp %2, %0; it lo; movlo %0, #0" \
 		: "=&r" (flag) \
 		: "0" (current_thread_info()->addr_limit), "r" (addr) \
 		: "cc"); \
@@ -78,7 +79,7 @@ static inline void set_fs(mm_segment_t fs)
 #define __range_ok(addr,size) ({ \
 	unsigned long flag, roksum; \
 	__chk_user_ptr(addr);	\
-	__asm__("adds %1, %2, %3; sbcccs %1, %1, %0; movcc %0, #0" \
+	__asm__("adds %1, %2, %3; it cc; sbcccs %1, %1, %0; it cc; movcc %0, #0" \
 		: "=&r" (flag), "=&r" (roksum) \
 		: "r" (addr), "Ir" (size), "0" (current_thread_info()->addr_limit) \
 		: "cc"); \
@@ -364,8 +365,10 @@ do {									\
 
 #define __put_user_asm_dword(x,__pu_addr,err)			\
 	__asm__ __volatile__(					\
-	"1:	strt	" __reg_oper1 ", [%1], #4\n"		\
-	"2:	strt	" __reg_oper0 ", [%1]\n"		\
+ ARM(	"1:	strt	" __reg_oper1 ", [%1], #4\n"	)	\
+ ARM(	"2:	strt	" __reg_oper0 ", [%1]\n"	)	\
+ THUMB(	"1:	strt	" __reg_oper1 ", [%1]\n"	)	\
+ THUMB(	"2:	strt	" __reg_oper0 ", [%1, #4]\n"	)	\
 	"3:\n"							\
 	"	.section .fixup,\"ax\"\n"			\
 	"	.align	2\n"					\
diff --git a/arch/arm/include/asm/unified.h b/arch/arm/include/asm/unified.h
new file mode 100644
index 0000000..82194c0
--- /dev/null
+++ b/arch/arm/include/asm/unified.h
@@ -0,0 +1,126 @@
+/*
+ * include/asm-arm/unified.h - Unified Assembler Syntax helper macros
+ *
+ * Copyright (C) 2008 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_UNIFIED_H
+#define __ASM_UNIFIED_H
+
+#if defined(__ASSEMBLY__) && defined(CONFIG_ARM_ASM_UNIFIED)
+	.syntax unified
+#endif
+
+#ifdef CONFIG_THUMB2_KERNEL
+
+#if __GNUC__ < 4
+#error Thumb-2 kernel requires gcc >= 4
+#endif
+
+/* The CPSR bit describing the instruction set (Thumb) */
+#define PSR_ISETSTATE	PSR_T_BIT
+
+#define ARM(x...)
+#define THUMB(x...)	x
+#define W(instr)	instr.w
+#define BSYM(sym)	sym + 1
+
+#else	/* !CONFIG_THUMB2_KERNEL */
+
+/* The CPSR bit describing the instruction set (ARM) */
+#define PSR_ISETSTATE	0
+
+#define ARM(x...)	x
+#define THUMB(x...)
+#define W(instr)	instr
+#define BSYM(sym)	sym
+
+#endif	/* CONFIG_THUMB2_KERNEL */
+
+#ifndef CONFIG_ARM_ASM_UNIFIED
+
+/*
+ * If the unified assembly syntax isn't used (in ARM mode), these
+ * macros expand to an empty string
+ */
+#ifdef __ASSEMBLY__
+	.macro	it, cond
+	.endm
+	.macro	itt, cond
+	.endm
+	.macro	ite, cond
+	.endm
+	.macro	ittt, cond
+	.endm
+	.macro	itte, cond
+	.endm
+	.macro	itet, cond
+	.endm
+	.macro	itee, cond
+	.endm
+	.macro	itttt, cond
+	.endm
+	.macro	ittte, cond
+	.endm
+	.macro	ittet, cond
+	.endm
+	.macro	ittee, cond
+	.endm
+	.macro	itett, cond
+	.endm
+	.macro	itete, cond
+	.endm
+	.macro	iteet, cond
+	.endm
+	.macro	iteee, cond
+	.endm
+#else	/* !__ASSEMBLY__ */
+__asm__(
+"	.macro	it, cond\n"
+"	.endm\n"
+"	.macro	itt, cond\n"
+"	.endm\n"
+"	.macro	ite, cond\n"
+"	.endm\n"
+"	.macro	ittt, cond\n"
+"	.endm\n"
+"	.macro	itte, cond\n"
+"	.endm\n"
+"	.macro	itet, cond\n"
+"	.endm\n"
+"	.macro	itee, cond\n"
+"	.endm\n"
+"	.macro	itttt, cond\n"
+"	.endm\n"
+"	.macro	ittte, cond\n"
+"	.endm\n"
+"	.macro	ittet, cond\n"
+"	.endm\n"
+"	.macro	ittee, cond\n"
+"	.endm\n"
+"	.macro	itett, cond\n"
+"	.endm\n"
+"	.macro	itete, cond\n"
+"	.endm\n"
+"	.macro	iteet, cond\n"
+"	.endm\n"
+"	.macro	iteee, cond\n"
+"	.endm\n");
+#endif	/* __ASSEMBLY__ */
+
+#endif	/* CONFIG_ARM_ASM_UNIFIED */
+
+#endif	/* !CONFIG_ARM_ASM_UNIFIED */
diff --git a/arch/arm/include/asm/unwind.h b/arch/arm/include/asm/unwind.h
new file mode 100644
index 0000000..a5edf42
--- /dev/null
+++ b/arch/arm/include/asm/unwind.h
@@ -0,0 +1,69 @@
+/*
+ * arch/arm/include/asm/unwind.h
+ *
+ * Copyright (C) 2008 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_UNWIND_H
+#define __ASM_UNWIND_H
+
+#ifndef __ASSEMBLY__
+
+/* Unwind reason code according the the ARM EABI documents */
+enum unwind_reason_code {
+	URC_OK = 0,			/* operation completed successfully */
+	URC_CONTINUE_UNWIND = 8,
+	URC_FAILURE = 9			/* unspecified failure of some kind */
+};
+
+struct unwind_idx {
+	unsigned long addr;
+	unsigned long insn;
+};
+
+struct unwind_table {
+	struct list_head list;
+	struct unwind_idx *start;
+	struct unwind_idx *stop;
+	unsigned long begin_addr;
+	unsigned long end_addr;
+};
+
+extern struct unwind_table *unwind_table_add(unsigned long start,
+					     unsigned long size,
+					     unsigned long text_addr,
+					     unsigned long text_size);
+extern void unwind_table_del(struct unwind_table *tab);
+extern void unwind_backtrace(struct pt_regs *regs, struct task_struct *tsk);
+
+#ifdef CONFIG_ARM_UNWIND
+extern int __init unwind_init(void);
+#else
+static inline int __init unwind_init(void)
+{
+	return 0;
+}
+#endif
+
+#endif	/* !__ASSEMBLY__ */
+
+#ifdef CONFIG_ARM_UNWIND
+#define UNWIND(code...)		code
+#else
+#define UNWIND(code...)
+#endif
+
+#endif	/* __ASM_UNWIND_H */
diff --git a/arch/arm/include/asm/user.h b/arch/arm/include/asm/user.h
index 825c1e7..df95e05 100644
--- a/arch/arm/include/asm/user.h
+++ b/arch/arm/include/asm/user.h
@@ -81,4 +81,13 @@ struct user{
 #define HOST_TEXT_START_ADDR (u.start_code)
 #define HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)
 
+/*
+ * User specific VFP registers. If only VFPv2 is present, registers 16 to 31
+ * are ignored by the ptrace system call.
+ */
+struct user_vfp {
+	unsigned long long fpregs[32];
+	unsigned long fpscr;
+};
+
 #endif /* _ARM_USER_H */
diff --git a/arch/arm/include/asm/vfpmacros.h b/arch/arm/include/asm/vfpmacros.h
index 422f3cc..79ccd6c 100644
--- a/arch/arm/include/asm/vfpmacros.h
+++ b/arch/arm/include/asm/vfpmacros.h
@@ -25,6 +25,7 @@
 	VFPFMRX	\tmp, MVFR0			    @ Media and VFP Feature Register 0
 	and	\tmp, \tmp, #MVFR0_A_SIMD_MASK	    @ A_SIMD field
 	cmp	\tmp, #2			    @ 32 x 64bit registers?
+	ite	eq
 	ldceql	p11, cr0, [\base],#32*4		    @ FLDMIAD \base!, {d16-d31}
 	addne	\base, \base, #32*4		    @ step over unused register space
 #endif
@@ -32,6 +33,9 @@
 
 	@ write all the working registers out of the VFP
 	.macro	VFPFSTMIA, base, tmp
+#ifdef CONFIG_ARM_ERRATUM_451034
+	dmb
+#endif
 #if __LINUX_ARM_ARCH__ < 6
 	STC	p11, cr0, [\base],#33*4		    @ FSTMIAX \base!, {d0-d15}
 #else
@@ -41,6 +45,7 @@
 	VFPFMRX	\tmp, MVFR0			    @ Media and VFP Feature Register 0
 	and	\tmp, \tmp, #MVFR0_A_SIMD_MASK	    @ A_SIMD field
 	cmp	\tmp, #2			    @ 32 x 64bit registers?
+	ite	eq
 	stceql	p11, cr0, [\base],#32*4		    @ FSTMIAD \base!, {d16-d31}
 	addne	\base, \base, #32*4		    @ step over unused register space
 #endif
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index 4305345..ad0d9f2 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_ATAGS_PROC)	+= atags.o
 obj-$(CONFIG_OABI_COMPAT)	+= sys_oabi-compat.o
 obj-$(CONFIG_ARM_THUMBEE)	+= thumbee.o
 obj-$(CONFIG_KGDB)		+= kgdb.o
+obj-$(CONFIG_ARM_UNWIND)	+= unwind.o
 
 obj-$(CONFIG_CRUNCH)		+= crunch.o crunch-bits.o
 AFLAGS_crunch-bits.o		:= -Wa,-mcpu=ep9312
@@ -44,5 +45,6 @@ endif
 
 head-y			:= head$(MMUEXT).o
 obj-$(CONFIG_DEBUG_LL)	+= debug.o
+obj-$(CONFIG_DEBUG_LL_CONSOLE)	+= early_printk.o
 
 extra-y := $(head-y) init_task.o vmlinux.lds
diff --git a/arch/arm/kernel/debug.S b/arch/arm/kernel/debug.S
index f53c582..e95a5b6 100644
--- a/arch/arm/kernel/debug.S
+++ b/arch/arm/kernel/debug.S
@@ -105,6 +105,7 @@ printhex:	adr	r2, hexbuf
 1:		and	r1, r0, #15
 		mov	r0, r0, lsr #4
 		cmp	r1, #10
+		ite	lt
 		addlt	r1, r1, #'0'
 		addge	r1, r1, #'a' - 10
 		strb	r1, [r3, #-1]!
@@ -123,9 +124,11 @@ ENTRY(printascii)
 		senduart r1, r3
 		busyuart r2, r3
 		teq	r1, #'\n'
+		itt	eq
 		moveq	r1, #'\r'
 		beq	1b
 2:		teq	r0, #0
+		itt	ne
 		ldrneb	r1, [r0], #1
 		teqne	r1, #0
 		bne	1b
diff --git a/arch/arm/kernel/early_printk.c b/arch/arm/kernel/early_printk.c
new file mode 100644
index 0000000..a0aea0a
--- /dev/null
+++ b/arch/arm/kernel/early_printk.c
@@ -0,0 +1,38 @@
+/*
+ *  linux/arch/arm/kernel/early_printk.c
+ *
+ *  Copyright (C) 2009 Sascha Hauer <s.hauer@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/console.h>
+#include <linux/init.h>
+
+extern void printch(int);
+
+static void early_serial_write(struct console *con, const char *s, unsigned n)
+{
+	while (*s && n-- > 0) {
+		if (*s == '\n')
+			printch('\r');
+		printch(*s);
+		s++;
+	}
+}
+
+static struct console early_serial_console = {
+	.name =		"earlyser",
+	.write =	early_serial_write,
+	.flags =	CON_PRINTBUFFER | CON_BOOT,
+	.index =	-1,
+};
+
+static int __init setup_early_printk(char *buf)
+{
+	register_console(&early_serial_console);
+	return 0;
+}
+
+early_param("earlyprintk", setup_early_printk);
diff --git a/arch/arm/kernel/entry-armv.S b/arch/arm/kernel/entry-armv.S
index 77b0474..9970015 100644
--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -20,6 +20,7 @@
 #include <asm/vfpmacros.h>
 #include <mach/entry-macro.S>
 #include <asm/thread_notify.h>
+#include <asm/unwind.h>
 
 #include "entry-header.S"
 
@@ -29,12 +30,19 @@
 	.macro	irq_handler
 	get_irqnr_preamble r5, lr
 1:	get_irqnr_and_base r0, r6, r5, lr
+	ittt	ne
 	movne	r1, sp
 	@
 	@ routine called with r0 = irq number, r1 = struct pt_regs *
 	@
-	adrne	lr, 1b
+#if defined(CONFIG_MACH_REALVIEW_EB) && \
+		defined(CONFIG_CPU_V6) && !defined(CONFIG_SMP)
+	@ GIC bug on RealView EB not allowing register polling
+	blne	asm_do_IRQ
+#else
+	adrne	lr, BSYM(1b)
 	bne	asm_do_IRQ
+#endif
 
 #ifdef CONFIG_SMP
 	/*
@@ -44,14 +52,16 @@
 	 * preserved from get_irqnr_and_base above
 	 */
 	test_for_ipi r0, r6, r5, lr
+	ittt	ne
 	movne	r0, sp
-	adrne	lr, 1b
+	adrne	lr, BSYM(1b)
 	bne	do_IPI
 
 #ifdef CONFIG_LOCAL_TIMERS
 	test_for_ltirq r0, r6, r5, lr
+	ittt	ne
 	movne	r0, sp
-	adrne	lr, 1b
+	adrne	lr, BSYM(1b)
 	bne	do_local_timer
 #endif
 #endif
@@ -69,7 +79,10 @@
  */
 	.macro	inv_entry, reason
 	sub	sp, sp, #S_FRAME_SIZE
-	stmib	sp, {r1 - lr}
+ ARM(	stmib	sp, {r1 - lr}		)
+ THUMB(	stmia	sp, {r0 - r12}		)
+ THUMB(	str	sp, [sp, #S_SP]		)
+ THUMB(	str	lr, [sp, #S_LR]		)
 	mov	r1, #\reason
 	.endm
 
@@ -123,17 +136,28 @@ ENDPROC(__und_invalid)
 #endif
 
 	.macro	svc_entry, stack_hole=0
-	sub	sp, sp, #(S_FRAME_SIZE + \stack_hole)
+ UNWIND(.fnstart		)
+ UNWIND(.save {r0 - pc}		)
+	sub	sp, sp, #(S_FRAME_SIZE + \stack_hole - 4)
+#ifdef CONFIG_THUMB2_KERNEL
+ SPFIX(	str	r0, [sp]	)	@ temporarily saved
+ SPFIX(	mov	r0, sp		)
+ SPFIX(	tst	r0, #4		)	@ test original stack alignment
+ SPFIX(	ldr	r0, [sp]	)	@ restored
+#else
  SPFIX(	tst	sp, #4		)
- SPFIX(	bicne	sp, sp, #4	)
-	stmib	sp, {r1 - r12}
+#endif
+ SPFIX(	it	eq		)
+ SPFIX(	subeq	sp, sp, #4	)
+ 	stmia	sp, {r1 - r12}
 
 	ldmia	r0, {r1 - r3}
-	add	r5, sp, #S_SP		@ here for interlock avoidance
+	add	r5, sp, #S_SP - 4	@ here for interlock avoidance
 	mov	r4, #-1			@  ""  ""      ""       ""
-	add	r0, sp, #(S_FRAME_SIZE + \stack_hole)
- SPFIX(	addne	r0, r0, #4	)
-	str	r1, [sp]		@ save the "real" r0 copied
+	add	r0, sp, #(S_FRAME_SIZE + \stack_hole - 4)
+ SPFIX(	it	eq		)
+ SPFIX(	addeq	r0, r0, #4	)
+	str	r1, [sp, #-4]!		@ save the "real" r0 copied
 					@ from the exception stack
 
 	mov	r1, lr
@@ -159,6 +183,7 @@ __dabt_svc:
 	@
 	mrs	r9, cpsr
 	tst	r3, #PSR_I_BIT
+	it	eq
 	biceq	r9, r9, #PSR_I_BIT
 
 	@
@@ -193,9 +218,9 @@ __dabt_svc:
 	@
 	@ restore SPSR and restart the instruction
 	@
-	ldr	r0, [sp, #S_PSR]
-	msr	spsr_cxsf, r0
-	ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+	ldr	r2, [sp, #S_PSR]
+	svc_exit r2				@ return from exception
+ UNWIND(.fnend		)
 ENDPROC(__dabt_svc)
 
 	.align	5
@@ -217,17 +242,19 @@ __irq_svc:
 	str	r8, [tsk, #TI_PREEMPT]		@ restore preempt count
 	ldr	r0, [tsk, #TI_FLAGS]		@ get flags
 	teq	r8, #0				@ if preempt count != 0
+	it	ne
 	movne	r0, #0				@ force flags to 0
 	tst	r0, #_TIF_NEED_RESCHED
+	it	ne
 	blne	svc_preempt
 #endif
-	ldr	r0, [sp, #S_PSR]		@ irqs are already disabled
-	msr	spsr_cxsf, r0
+	ldr	r2, [sp, #S_PSR]		@ irqs are already disabled
 #ifdef CONFIG_TRACE_IRQFLAGS
-	tst	r0, #PSR_I_BIT
+	tst	r2, #PSR_I_BIT
 	bleq	trace_hardirqs_on
 #endif
-	ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+	svc_exit r2				@ return from exception
+ UNWIND(.fnend		)
 ENDPROC(__irq_svc)
 
 	.ltorg
@@ -238,6 +265,7 @@ svc_preempt:
 1:	bl	preempt_schedule_irq		@ irq en/disable is done inside
 	ldr	r0, [tsk, #TI_FLAGS]		@ get new tasks TI_FLAGS
 	tst	r0, #_TIF_NEED_RESCHED
+	it	eq
 	moveq	pc, r8				@ go again
 	b	1b
 #endif
@@ -261,7 +289,7 @@ __und_svc:
 	@  r0 - instruction
 	@
 	ldr	r0, [r2, #-4]
-	adr	r9, 1f
+	adr	r9, BSYM(1f)
 	bl	call_fpe
 
 	mov	r0, sp				@ struct pt_regs *regs
@@ -275,9 +303,9 @@ __und_svc:
 	@
 	@ restore SPSR and restart the instruction
 	@
-	ldr	lr, [sp, #S_PSR]		@ Get SVC cpsr
-	msr	spsr_cxsf, lr
-	ldmia	sp, {r0 - pc}^			@ Restore SVC registers
+	ldr	r2, [sp, #S_PSR]		@ Get SVC cpsr
+	svc_exit r2				@ return from exception
+ UNWIND(.fnend		)
 ENDPROC(__und_svc)
 
 	.align	5
@@ -289,6 +317,7 @@ __pabt_svc:
 	@
 	mrs	r9, cpsr
 	tst	r3, #PSR_I_BIT
+	it	eq
 	biceq	r9, r9, #PSR_I_BIT
 
 	@
@@ -317,9 +346,9 @@ __pabt_svc:
 	@
 	@ restore SPSR and restart the instruction
 	@
-	ldr	r0, [sp, #S_PSR]
-	msr	spsr_cxsf, r0
-	ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+	ldr	r2, [sp, #S_PSR]
+	svc_exit r2				@ return from exception
+ UNWIND(.fnend		)
 ENDPROC(__pabt_svc)
 
 	.align	5
@@ -343,8 +372,11 @@ ENDPROC(__pabt_svc)
 #endif
 
 	.macro	usr_entry
+ UNWIND(.fnstart	)
+ UNWIND(.cantunwind	)	@ don't unwind the user space
 	sub	sp, sp, #S_FRAME_SIZE
-	stmib	sp, {r1 - r12}
+ ARM(	stmib	sp, {r1 - r12}	)
+ THUMB(	stmia	sp, {r0 - r12}	)
 
 	ldmia	r0, {r1 - r3}
 	add	r0, sp, #S_PC		@ here for interlock avoidance
@@ -363,7 +395,8 @@ ENDPROC(__pabt_svc)
 	@ Also, separately save sp_usr and lr_usr
 	@
 	stmia	r0, {r2 - r4}
-	stmdb	r0, {sp, lr}^
+ ARM(	stmdb	r0, {sp, lr}^			)
+ THUMB(	store_user_sp_lr r0, r1, S_SP - S_PC	)
 
 	@
 	@ Enable the alignment trap while in kernel mode
@@ -418,8 +451,9 @@ __dabt_usr:
 	@
 	enable_irq
 	mov	r2, sp
-	adr	lr, ret_from_exception
+	adr	lr, BSYM(ret_from_exception)
 	b	do_DataAbort
+ UNWIND(.fnend		)
 ENDPROC(__dabt_usr)
 
 	.align	5
@@ -442,7 +476,10 @@ __irq_usr:
 	ldr	r0, [tsk, #TI_PREEMPT]
 	str	r8, [tsk, #TI_PREEMPT]
 	teq	r0, r7
-	strne	r0, [r0, -r0]
+	itt	ne
+ ARM(	strne	r0, [r0, -r0]	)
+ THUMB(	movne	r0, #0		)
+ THUMB(	strne	r0, [r0]	)
 #endif
 #ifdef CONFIG_TRACE_IRQFLAGS
 	bl	trace_hardirqs_on
@@ -450,6 +487,7 @@ __irq_usr:
 
 	mov	why, #0
 	b	ret_to_user
+ UNWIND(.fnend		)
 ENDPROC(__irq_usr)
 
 	.ltorg
@@ -465,16 +503,23 @@ __und_usr:
 	@
 	@  r0 - instruction
 	@
-	adr	r9, ret_from_exception
-	adr	lr, __und_usr_unknown
+	adr	r9, BSYM(ret_from_exception)
+	adr	lr, BSYM(__und_usr_unknown)
 	tst	r3, #PSR_T_BIT			@ Thumb mode?
+	itet	eq
 	subeq	r4, r2, #4			@ ARM instr at LR - 4
 	subne	r4, r2, #2			@ Thumb instr at LR - 2
 1:	ldreqt	r0, [r4]
+#ifdef CONFIG_CPU_ENDIAN_BE8
+	rev	r0, r0				@ little endian instruction
+#endif
 	beq	call_fpe
 	@ Thumb instruction
 #if __LINUX_ARM_ARCH__ >= 7
-2:	ldrht	r5, [r4], #2
+2:
+ ARM(	ldrht	r5, [r4], #2	)
+ THUMB(	ldrht	r5, [r4]	)
+ THUMB(	add	r4, r4, #2	)
 	and	r0, r5, #0xf800			@ mask bits 111x x... .... ....
 	cmp	r0, #0xe800			@ 32bit instruction if xx != 0
 	blo	__und_usr_unknown
@@ -484,6 +529,7 @@ __und_usr:
 #else
 	b	__und_usr_unknown
 #endif
+ UNWIND(.fnend		)
 ENDPROC(__und_usr)
 
 	@
@@ -554,6 +600,7 @@ call_fpe:
 1:
 #endif
 	tst	r0, #0x08000000			@ only CDP/CPRT/LDC/STC have bit 27
+	ite	ne
 	tstne	r0, #0x04000000			@ bit 26 set on both ARM and Thumb-2
 #if defined(CONFIG_CPU_ARM610) || defined(CONFIG_CPU_ARM710)
 	and	r8, r0, #0x0f000000		@ mask out op-code bits
@@ -562,9 +609,11 @@ call_fpe:
 	moveq	pc, lr
 	get_thread_info r10			@ get current thread
 	and	r8, r0, #0x00000f00		@ mask out CP number
+ THUMB(	lsr	r8, r8, #8		)
 	mov	r7, #1
 	add	r6, r10, #TI_USED_CP
-	strb	r7, [r6, r8, lsr #8]		@ set appropriate used_cp[]
+ ARM(	strb	r7, [r6, r8, lsr #8]	)	@ set appropriate used_cp[]
+ THUMB(	strb	r7, [r6, r8]		)	@ set appropriate used_cp[]
 #ifdef CONFIG_IWMMXT
 	@ Test if we need to give access to iWMMXt coprocessors
 	ldr	r5, [r10, #TI_FLAGS]
@@ -572,36 +621,38 @@ call_fpe:
 	movcss	r7, r5, lsr #(TIF_USING_IWMMXT + 1)
 	bcs	iwmmxt_task_enable
 #endif
-	add	pc, pc, r8, lsr #6
-	mov	r0, r0
-
-	mov	pc, lr				@ CP#0
-	b	do_fpe				@ CP#1 (FPE)
-	b	do_fpe				@ CP#2 (FPE)
-	mov	pc, lr				@ CP#3
+ ARM(	add	pc, pc, r8, lsr #6	)
+ THUMB(	lsl	r8, r8, #2		)
+ THUMB(	add	pc, r8			)
+	nop
+
+	W(mov)	pc, lr				@ CP#0
+	W(b)	do_fpe				@ CP#1 (FPE)
+	W(b)	do_fpe				@ CP#2 (FPE)
+	W(mov)	pc, lr				@ CP#3
 #ifdef CONFIG_CRUNCH
 	b	crunch_task_enable		@ CP#4 (MaverickCrunch)
 	b	crunch_task_enable		@ CP#5 (MaverickCrunch)
 	b	crunch_task_enable		@ CP#6 (MaverickCrunch)
 #else
-	mov	pc, lr				@ CP#4
-	mov	pc, lr				@ CP#5
-	mov	pc, lr				@ CP#6
+	W(mov)	pc, lr				@ CP#4
+	W(mov)	pc, lr				@ CP#5
+	W(mov)	pc, lr				@ CP#6
 #endif
-	mov	pc, lr				@ CP#7
-	mov	pc, lr				@ CP#8
-	mov	pc, lr				@ CP#9
+	W(mov)	pc, lr				@ CP#7
+	W(mov)	pc, lr				@ CP#8
+	W(mov)	pc, lr				@ CP#9
 #ifdef CONFIG_VFP
-	b	do_vfp				@ CP#10 (VFP)
-	b	do_vfp				@ CP#11 (VFP)
+	W(b)	do_vfp				@ CP#10 (VFP)
+	W(b)	do_vfp				@ CP#11 (VFP)
 #else
-	mov	pc, lr				@ CP#10 (VFP)
-	mov	pc, lr				@ CP#11 (VFP)
+	W(mov)	pc, lr				@ CP#10 (VFP)
+	W(mov)	pc, lr				@ CP#11 (VFP)
 #endif
-	mov	pc, lr				@ CP#12
-	mov	pc, lr				@ CP#13
-	mov	pc, lr				@ CP#14 (Debug)
-	mov	pc, lr				@ CP#15 (Control)
+	W(mov)	pc, lr				@ CP#12
+	W(mov)	pc, lr				@ CP#13
+	W(mov)	pc, lr				@ CP#14 (Debug)
+	W(mov)	pc, lr				@ CP#15 (Control)
 
 #ifdef CONFIG_NEON
 	.align	6
@@ -651,7 +702,7 @@ no_fp:	mov	pc, lr
 
 __und_usr_unknown:
 	mov	r0, sp
-	adr	lr, ret_from_exception
+	adr	lr, BSYM(ret_from_exception)
 	b	do_undefinstr
 ENDPROC(__und_usr_unknown)
 
@@ -670,14 +721,18 @@ __pabt_usr:
 	enable_irq				@ Enable interrupts
 	mov	r1, sp				@ regs
 	bl	do_PrefetchAbort		@ call abort handler
+ UNWIND(.fnend		)
 	/* fall through */
 /*
  * This is the return code to user mode for abort handlers
  */
 ENTRY(ret_from_exception)
+ UNWIND(.fnstart	)
+ UNWIND(.cantunwind	)
 	get_thread_info tsk
 	mov	why, #0
 	b	ret_to_user
+ UNWIND(.fnend		)
 ENDPROC(__pabt_usr)
 ENDPROC(ret_from_exception)
 
@@ -687,9 +742,14 @@ ENDPROC(ret_from_exception)
  * previous and next are guaranteed not to be the same.
  */
 ENTRY(__switch_to)
+ UNWIND(.fnstart	)
+ UNWIND(.cantunwind	)
 	add	ip, r1, #TI_CPU_SAVE
 	ldr	r3, [r2, #TI_TP_VALUE]
-	stmia	ip!, {r4 - sl, fp, sp, lr}	@ Store most regs on stack
+ ARM(	stmia	ip!, {r4 - sl, fp, sp, lr} )	@ Store most regs on stack
+ THUMB(	stmia	ip!, {r4 - sl, fp}	   )	@ Store most regs on stack
+ THUMB(	str	sp, [ip], #4		   )
+ THUMB(	str	lr, [ip], #4		   )
 #ifdef CONFIG_MMU
 	ldr	r6, [r2, #TI_CPU_DOMAIN]
 #endif
@@ -714,8 +774,13 @@ ENTRY(__switch_to)
 	ldr	r0, =thread_notify_head
 	mov	r1, #THREAD_NOTIFY_SWITCH
 	bl	atomic_notifier_call_chain
+ THUMB(	mov	ip, r4			   )
 	mov	r0, r5
-	ldmia	r4, {r4 - sl, fp, sp, pc}	@ Load all regs saved previously
+ ARM(	ldmia	r4, {r4 - sl, fp, sp, pc}  )	@ Load all regs saved previously
+ THUMB(	ldmia	ip!, {r4 - sl, fp}	   )	@ Load all regs saved previously
+ THUMB(	ldr	sp, [ip], #4		   )
+ THUMB(	ldr	pc, [ip]		   )
+ UNWIND(.fnend		)
 ENDPROC(__switch_to)
 
 	__INIT
@@ -749,6 +814,7 @@ ENDPROC(__switch_to)
  * if your compiled code is not going to use the new instructions for other
  * purpose.
  */
+ THUMB(	.arm	)
 
 	.macro	usr_ret, reg
 #ifdef CONFIG_ARM_THUMB
@@ -920,6 +986,7 @@ kuser_cmpxchg_fixup:
 #endif
 1:	ldrex	r3, [r2]
 	subs	r3, r3, r0
+	it	eq
 	strexeq	r3, r1, [r2]
 	teqeq	r3, #1
 	beq	1b
@@ -1000,6 +1067,7 @@ __kuser_helper_version:				@ 0xffff0ffc
 	.globl	__kuser_helper_end
 __kuser_helper_end:
 
+ THUMB(	.thumb	)
 
 /*
  * Vector stubs.
@@ -1034,17 +1102,23 @@ vector_\name:
 	@ Prepare for SVC32 mode.  IRQs remain disabled.
 	@
 	mrs	r0, cpsr
-	eor	r0, r0, #(\mode ^ SVC_MODE)
+	eor	r0, r0, #(\mode ^ SVC_MODE | PSR_ISETSTATE)
 	msr	spsr_cxsf, r0
 
 	@
 	@ the branch table must immediately follow this code
 	@
 	and	lr, lr, #0x0f
+ THUMB(	adr	r0, 1f			)
+ THUMB(	ldr	lr, [r0, lr, lsl #2]	)
 	mov	r0, sp
-	ldr	lr, [pc, lr, lsl #2]
+ ARM(	ldr	lr, [pc, lr, lsl #2]	)
 	movs	pc, lr			@ branch to handler in SVC mode
 ENDPROC(vector_\name)
+
+	.align	2
+	@ handler addresses follow this label
+1:
 	.endm
 
 	.globl	__stubs_start
@@ -1182,14 +1256,16 @@ __stubs_end:
 
 	.globl	__vectors_start
 __vectors_start:
-	swi	SYS_ERROR0
-	b	vector_und + stubs_offset
-	ldr	pc, .LCvswi + stubs_offset
-	b	vector_pabt + stubs_offset
-	b	vector_dabt + stubs_offset
-	b	vector_addrexcptn + stubs_offset
-	b	vector_irq + stubs_offset
-	b	vector_fiq + stubs_offset
+ ARM(	swi	SYS_ERROR0	)
+ THUMB(	svc	#0		)
+ THUMB(	nop			)
+	W(b)	vector_und + stubs_offset
+	W(ldr)	pc, .LCvswi + stubs_offset
+	W(b)	vector_pabt + stubs_offset
+	W(b)	vector_dabt + stubs_offset
+	W(b)	vector_addrexcptn + stubs_offset
+	W(b)	vector_irq + stubs_offset
+	W(b)	vector_fiq + stubs_offset
 
 	.globl	__vectors_end
 __vectors_end:
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index 06269ea..6c41587 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -11,6 +11,7 @@
 #include <asm/unistd.h>
 #include <asm/ftrace.h>
 #include <mach/entry-macro.S>
+#include <asm/unwind.h>
 
 #include "entry-header.S"
 
@@ -22,6 +23,8 @@
  * stack.
  */
 ret_fast_syscall:
+ UNWIND(.fnstart	)
+ UNWIND(.cantunwind	)
 	disable_irq				@ disable interrupts
 	ldr	r1, [tsk, #TI_FLAGS]
 	tst	r1, #_TIF_WORK_MASK
@@ -30,14 +33,8 @@ ret_fast_syscall:
 	/* perform architecture specific actions before user return */
 	arch_ret_to_user r1, lr
 
-	@ fast_restore_user_regs
-	ldr	r1, [sp, #S_OFF + S_PSR]	@ get calling cpsr
-	ldr	lr, [sp, #S_OFF + S_PC]!	@ get pc
-	msr	spsr_cxsf, r1			@ save in spsr_svc
-	ldmdb	sp, {r1 - lr}^			@ get calling r1 - lr
-	mov	r0, r0
-	add	sp, sp, #S_FRAME_SIZE - S_PC
-	movs	pc, lr				@ return & move spsr_svc into cpsr
+	restore_user_regs fast = 1, offset = S_OFF
+ UNWIND(.fnend		)
 
 /*
  * Ok, we need to do extra processing, enter the slow path.
@@ -69,14 +66,11 @@ no_work_pending:
 	/* perform architecture specific actions before user return */
 	arch_ret_to_user r1, lr
 
-	@ slow_restore_user_regs
-	ldr	r1, [sp, #S_PSR]		@ get calling cpsr
-	ldr	lr, [sp, #S_PC]!		@ get pc
-	msr	spsr_cxsf, r1			@ save in spsr_svc
-	ldmdb	sp, {r0 - lr}^			@ get calling r0 - lr
-	mov	r0, r0
-	add	sp, sp, #S_FRAME_SIZE - S_PC
-	movs	pc, lr				@ return & move spsr_svc into cpsr
+#ifdef CONFIG_ARM_ERRATUM_451034
+	dmb
+#endif
+
+	restore_user_regs fast = 0, offset = 0
 ENDPROC(ret_to_user)
 
 /*
@@ -174,8 +168,10 @@ ftrace_stub:
 ENTRY(vector_swi)
 	sub	sp, sp, #S_FRAME_SIZE
 	stmia	sp, {r0 - r12}			@ Calling r0 - r12
-	add	r8, sp, #S_PC
-	stmdb	r8, {sp, lr}^			@ Calling sp, lr
+ ARM(	add	r8, sp, #S_PC		)
+ ARM(	stmdb	r8, {sp, lr}^		)	@ Calling sp, lr
+ THUMB(	mov	r8, sp			)
+ THUMB(	store_user_sp_lr r8, r10, S_SP	)	@ calling sp, lr
 	mrs	r8, spsr			@ called from non-FIQ mode, so ok.
 	str	lr, [sp, #S_PC]			@ Save calling PC
 	str	r8, [sp, #S_PSR]		@ Save CPSR
@@ -194,6 +190,7 @@ ENTRY(vector_swi)
 	 */
 #ifdef CONFIG_ARM_THUMB
 	tst	r8, #PSR_T_BIT
+	ite	ne
 	movne	r10, #0				@ no thumb OABI emulation
 	ldreq	r10, [lr, #-4]			@ get SWI instruction
 #else
@@ -202,6 +199,9 @@ ENTRY(vector_swi)
   A710(	teq	ip, #0x0f000000						)
   A710(	bne	.Larm710bug						)
 #endif
+#ifdef CONFIG_CPU_ENDIAN_BE8
+	rev	r10, r10			@ little endian instruction
+#endif
 
 #elif defined(CONFIG_AEABI)
 
@@ -249,6 +249,7 @@ ENTRY(vector_swi)
 	 * get the old ABI syscall table address.
 	 */
 	bics	r10, r10, #0xff000000
+	itt	ne
 	eorne	scno, r10, #__NR_OABI_SYSCALL_BASE
 	ldrne	tbl, =sys_oabi_call_table
 #elif !defined(CONFIG_AEABI)
@@ -261,7 +262,8 @@ ENTRY(vector_swi)
 	bne	__sys_trace
 
 	cmp	scno, #NR_syscalls		@ check upper syscall limit
-	adr	lr, ret_fast_syscall		@ return address
+	adr	lr, BSYM(ret_fast_syscall)	@ return address
+	it	cc
 	ldrcc	pc, [tbl, scno, lsl #2]		@ call sys_* routine
 
 	add	r1, sp, #S_OFF
@@ -282,10 +284,11 @@ __sys_trace:
 	mov	r0, #0				@ trace entry [IP = 0]
 	bl	syscall_trace
 
-	adr	lr, __sys_trace_return		@ return address
+	adr	lr, BSYM(__sys_trace_return)	@ return address
 	mov	scno, r0			@ syscall number (possibly new)
 	add	r1, sp, #S_R0 + S_OFF		@ pointer to regs
 	cmp	scno, #NR_syscalls		@ check upper syscall limit
+	itt	cc
 	ldmccia	r1, {r0 - r3}			@ have to reload r0 - r3
 	ldrcc	pc, [tbl, scno, lsl #2]		@ call sys_* routine
 	b	2b
@@ -331,11 +334,14 @@ ENTRY(sys_call_table)
 sys_syscall:
 		bic	scno, r0, #__NR_OABI_SYSCALL_BASE
 		cmp	scno, #__NR_syscall - __NR_SYSCALL_BASE
+		it	ne
 		cmpne	scno, #NR_syscalls	@ check range
+		itttt	lo
 		stmloia	sp, {r5, r6}		@ shuffle args
 		movlo	r0, r1
 		movlo	r1, r2
 		movlo	r2, r3
+		itt	lo
 		movlo	r3, r4
 		ldrlo	pc, [tbl, scno, lsl #2]
 		b	sys_ni_syscall
@@ -389,12 +395,14 @@ ENDPROC(sys_sigaltstack_wrapper)
 
 sys_statfs64_wrapper:
 		teq	r1, #88
+		it	eq
 		moveq	r1, #84
 		b	sys_statfs64
 ENDPROC(sys_statfs64_wrapper)
 
 sys_fstatfs64_wrapper:
 		teq	r1, #88
+		it	eq
 		moveq	r1, #84
 		b	sys_fstatfs64
 ENDPROC(sys_fstatfs64_wrapper)
@@ -406,6 +414,7 @@ ENDPROC(sys_fstatfs64_wrapper)
 sys_mmap2:
 #if PAGE_SHIFT > 12
 		tst	r5, #PGOFF_MASK
+		ittt	eq
 		moveq	r5, r5, lsr #PAGE_SHIFT - 12
 		streq	r5, [sp, #4]
 		beq	do_mmap2
diff --git a/arch/arm/kernel/entry-header.S b/arch/arm/kernel/entry-header.S
index 87ab4e1..84c16d2 100644
--- a/arch/arm/kernel/entry-header.S
+++ b/arch/arm/kernel/entry-header.S
@@ -36,11 +36,6 @@
 #endif
 	.endm
 
-	.macro	get_thread_info, rd
-	mov	\rd, sp, lsr #13
-	mov	\rd, \rd, lsl #13
-	.endm
-
 	.macro	alignment_trap, rtemp
 #ifdef CONFIG_ALIGNMENT_TRAP
 	ldr	\rtemp, .LCcralign
@@ -49,6 +44,94 @@
 #endif
 	.endm
 
+	@
+	@ Store/load the USER SP and LR registers by switching to the SYS
+	@ mode. Useful in Thumb-2 mode where "stm/ldm rd, {sp, lr}^" is not
+	@ available. Should only be called from SVC mode
+	@
+	.macro	store_user_sp_lr, rd, rtemp, offset = 0
+	mrs	\rtemp, cpsr
+	eor	\rtemp, \rtemp, #(SVC_MODE ^ SYSTEM_MODE)
+	msr	cpsr_c, \rtemp			@ switch to the SYS mode
+
+	str	sp, [\rd, #\offset]		@ save sp_usr
+	str	lr, [\rd, #\offset + 4]		@ save lr_usr
+
+	eor	\rtemp, \rtemp, #(SVC_MODE ^ SYSTEM_MODE)
+	msr	cpsr_c, \rtemp			@ switch back to the SVC mode
+	.endm
+
+	.macro	load_user_sp_lr, rd, rtemp, offset = 0
+	mrs	\rtemp, cpsr
+	eor	\rtemp, \rtemp, #(SVC_MODE ^ SYSTEM_MODE)
+	msr	cpsr_c, \rtemp			@ switch to the SYS mode
+
+	ldr	sp, [\rd, #\offset]		@ load sp_usr
+	ldr	lr, [\rd, #\offset + 4]		@ load lr_usr
+
+	eor	\rtemp, \rtemp, #(SVC_MODE ^ SYSTEM_MODE)
+	msr	cpsr_c, \rtemp			@ switch back to the SVC mode
+	.endm
+
+#ifndef CONFIG_THUMB2_KERNEL
+	.macro	svc_exit, rpsr
+	msr	spsr_cxsf, \rpsr
+	ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
+	.endm
+	
+	.macro	restore_user_regs, fast = 0, offset = 0
+	ldr	r1, [sp, #\offset + S_PSR]	@ get calling cpsr
+	ldr	lr, [sp, #\offset + S_PC]!	@ get pc
+	msr	spsr_cxsf, r1			@ save in spsr_svc
+	.if	\fast
+	ldmdb	sp, {r1 - lr}^			@ get calling r1 - lr
+	.else
+	ldmdb	sp, {r0 - lr}^			@ get calling r0 - lr
+	.endif
+	add	sp, sp, #S_FRAME_SIZE - S_PC
+	movs	pc, lr				@ return & move spsr_svc into cpsr
+	.endm
+
+	.macro	get_thread_info, rd
+	mov	\rd, sp, lsr #13
+	mov	\rd, \rd, lsl #13
+	.endm
+#else	/* CONFIG_THUMB2_KERNEL */
+	.macro	svc_exit, rpsr
+	ldr	r0, [sp, #S_SP]			@ top of the stack
+	ldr	r1, [sp, #S_PC]			@ return address
+	tst	r0, #4				@ orig stack 8-byte aligned?
+	stmdb	r0, {r1, \rpsr}			@ rfe context
+	ldmia	sp, {r0 - r12}
+	ldr	lr, [sp, #S_LR]
+	ite	eq
+	addeq	sp, sp, #S_FRAME_SIZE - 8	@ aligned
+	addne	sp, sp, #S_FRAME_SIZE - 4	@ not aligned
+	rfeia	sp!
+	.endm
+	
+	.macro	restore_user_regs, fast = 0, offset = 0
+	mov	r2, sp
+	load_user_sp_lr r2, r3, \offset + S_SP	@ calling sp, lr
+	ldr	r1, [sp, #\offset + S_PSR]	@ get calling cpsr
+	ldr	lr, [sp, #\offset + S_PC]	@ get pc
+	add	sp, sp, #\offset + S_SP
+	msr	spsr_cxsf, r1			@ save in spsr_svc
+	.if	\fast
+	ldmdb	sp, {r1 - r12}			@ get calling r1 - r12
+	.else
+	ldmdb	sp, {r0 - r12}			@ get calling r0 - r12
+	.endif
+	add	sp, sp, #S_FRAME_SIZE - S_SP
+	movs	pc, lr				@ return & move spsr_svc into cpsr
+	.endm
+
+	.macro	get_thread_info, rd
+	mov	\rd, sp
+	lsr	\rd, \rd, #13
+	mov	\rd, \rd, lsl #13
+	.endm
+#endif	/* CONFIG_THUMB2_KERNEL */
 
 /*
  * These are the registers used in the syscall handler, and allow us to
diff --git a/arch/arm/kernel/head-common.S b/arch/arm/kernel/head-common.S
index bde52df..81be5d6 100644
--- a/arch/arm/kernel/head-common.S
+++ b/arch/arm/kernel/head-common.S
@@ -14,6 +14,7 @@
 #define ATAG_CORE 0x54410001
 #define ATAG_CORE_SIZE ((2*4 + 3*4) >> 2)
 
+	.align	2
 	.type	__switch_data, %object
 __switch_data:
 	.long	__mmap_switched
@@ -41,6 +42,7 @@ __mmap_switched:
 
 	ldmia	r3!, {r4, r5, r6, r7}
 	cmp	r4, r5				@ Copy data segment if needed
+	itttt	ne
 1:	cmpne	r5, r6
 	ldrne	fp, [r4], #4
 	strne	fp, [r5], #4
@@ -48,10 +50,13 @@ __mmap_switched:
 
 	mov	fp, #0				@ Clear BSS (and zero fp)
 1:	cmp	r6, r7
+	itt	cc
 	strcc	fp, [r6],#4
 	bcc	1b
 
-	ldmia	r3, {r4, r5, r6, r7, sp}
+ ARM(	ldmia	r3, {r4, r5, r6, r7, sp})
+ THUMB(	ldmia	r3, {r4, r5, r6, r7}	)
+ THUMB(	ldr	sp, [r3, #16]		)
 	str	r9, [r4]			@ Save processor ID
 	str	r1, [r5]			@ Save machine type
 	str	r2, [r6]			@ Save atags pointer
@@ -155,7 +160,8 @@ ENDPROC(__error)
  */
 __lookup_processor_type:
 	adr	r3, 3f
-	ldmda	r3, {r5 - r7}
+	ldmia	r3, {r5 - r7}
+	add	r3, r3, #8
 	sub	r3, r3, r7			@ get offset between virt&phys
 	add	r5, r5, r3			@ convert virt addresses to
 	add	r6, r6, r3			@ physical address space
@@ -185,9 +191,10 @@ ENDPROC(lookup_processor_type)
  * Look in <asm/procinfo.h> and arch/arm/kernel/arch.[ch] for
  * more information about the __proc_info and __arch_info structures.
  */
-	.long	__proc_info_begin
+	.align	2
+3:	.long	__proc_info_begin
 	.long	__proc_info_end
-3:	.long	.
+4:	.long	.
 	.long	__arch_info_begin
 	.long	__arch_info_end
 
@@ -203,7 +210,7 @@ ENDPROC(lookup_processor_type)
  *  r5 = mach_info pointer in physical address space
  */
 __lookup_machine_type:
-	adr	r3, 3b
+	adr	r3, 4b
 	ldmia	r3, {r4, r5, r6}
 	sub	r3, r3, r4			@ get offset between virt&phys
 	add	r5, r5, r3			@ convert virt addresses to
diff --git a/arch/arm/kernel/head-nommu.S b/arch/arm/kernel/head-nommu.S
index cc87e17..e5dfc28 100644
--- a/arch/arm/kernel/head-nommu.S
+++ b/arch/arm/kernel/head-nommu.S
@@ -34,7 +34,7 @@
  */
 	.section ".text.head", "ax"
 ENTRY(stext)
-	msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode
+	setmode	PSR_F_BIT | PSR_I_BIT | SVC_MODE, r9 @ ensure svc mode
 						@ and irqs disabled
 #ifndef CONFIG_CPU_CP15
 	ldr	r9, =CONFIG_PROCESSOR_ID
@@ -50,8 +50,10 @@ ENTRY(stext)
 
 	ldr	r13, __switch_data		@ address to jump to after
 						@ the initialization is done
-	adr	lr, __after_proc_init		@ return (PIC) address
-	add	pc, r10, #PROCINFO_INITFUNC
+	adr	lr, BSYM(__after_proc_init)	@ return (PIC) address
+ ARM(	add	pc, r10, #PROCINFO_INITFUNC	)
+ THUMB(	add	r12, r10, #PROCINFO_INITFUNC	)
+ THUMB(	mov	pc, r12				)
 ENDPROC(stext)
 
 /*
@@ -59,7 +61,10 @@ ENDPROC(stext)
  */
 __after_proc_init:
 #ifdef CONFIG_CPU_CP15
-	mrc	p15, 0, r0, c1, c0, 0		@ read control reg
+	/*
+	 * CP15 system control register value returned in r0 from
+	 * the CPU init function.
+	 */
 #ifdef CONFIG_ALIGNMENT_TRAP
 	orr	r0, r0, #CR_A
 #else
@@ -82,7 +87,8 @@ __after_proc_init:
 	mcr	p15, 0, r0, c1, c0, 0		@ write control reg
 #endif /* CONFIG_CPU_CP15 */
 
-	mov	pc, r13				@ clear the BSS and jump
+	mov	r3, r13
+	mov	pc, r3				@ clear the BSS and jump
 						@ to start_kernel
 ENDPROC(__after_proc_init)
 	.ltorg
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index 21e17dc..167bb4e 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -76,7 +76,7 @@
  */
 	.section ".text.head", "ax"
 ENTRY(stext)
-	msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode
+	setmode	PSR_F_BIT | PSR_I_BIT | SVC_MODE, r9 @ ensure svc mode
 						@ and irqs disabled
 	mrc	p15, 0, r9, c0, c0		@ get processor id
 	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
@@ -97,8 +97,10 @@ ENTRY(stext)
 	 */
 	ldr	r13, __switch_data		@ address to jump to after
 						@ mmu has been enabled
-	adr	lr, __enable_mmu		@ return (PIC) address
-	add	pc, r10, #PROCINFO_INITFUNC
+	adr	lr, BSYM(__enable_mmu)		@ return (PIC) address
+ ARM(	add	pc, r10, #PROCINFO_INITFUNC	)
+ THUMB(	add	r12, r10, #PROCINFO_INITFUNC	)
+ THUMB(	mov	pc, r12				)
 ENDPROC(stext)
 
 #if defined(CONFIG_SMP)
@@ -110,10 +112,11 @@ ENTRY(secondary_startup)
 	 * the processor type - there is no need to check the machine type
 	 * as it has already been validated by the primary processor.
 	 */
-	msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
+	setmode	PSR_F_BIT | PSR_I_BIT | SVC_MODE, r9
 	mrc	p15, 0, r9, c0, c0		@ get processor id
 	bl	__lookup_processor_type
 	movs	r10, r5				@ invalid processor?
+	it	eq
 	moveq	r0, #'p'			@ yes, error 'p'
 	beq	__error
 
@@ -121,12 +124,15 @@ ENTRY(secondary_startup)
 	 * Use the page tables supplied from  __cpu_up.
 	 */
 	adr	r4, __secondary_data
-	ldmia	r4, {r5, r7, r13}		@ address to jump to after
+	ldmia	r4, {r5, r7, r12}		@ address to jump to after
 	sub	r4, r4, r5			@ mmu has been enabled
 	ldr	r4, [r7, r4]			@ get secondary_data.pgdir
-	adr	lr, __enable_mmu		@ return address
-	add	pc, r10, #PROCINFO_INITFUNC	@ initialise processor
-						@ (return control reg)
+	adr	lr, BSYM(__enable_mmu)		@ return address
+	mov	r13, r12			@ __secondary_switched address
+ ARM(	add	pc, r10, #PROCINFO_INITFUNC	) @ initialise processor
+						  @ (return control reg)
+ THUMB(	add	r12, r10, #PROCINFO_INITFUNC	)
+ THUMB(	mov	pc, r12				)
 ENDPROC(secondary_startup)
 
 	/*
@@ -193,8 +199,8 @@ __turn_mmu_on:
 	mcr	p15, 0, r0, c1, c0, 0		@ write control reg
 	mrc	p15, 0, r3, c0, c0, 0		@ read id reg
 	mov	r3, r3
-	mov	r3, r3
-	mov	pc, r13
+	mov	r3, r13
+	mov	pc, r3
 ENDPROC(__turn_mmu_on)
 
 
@@ -250,6 +256,7 @@ __create_page_tables:
 	add	r6, r4, r6, lsr #18
 1:	cmp	r0, r6
 	add	r3, r3, #1 << 20
+	it	ls
 	strls	r3, [r0], #4
 	bls	1b
 
@@ -293,6 +300,7 @@ __create_page_tables:
 	add	r0, r4, r3
 	rsb	r3, r3, #0x4000			@ PTRS_PER_PGD*sizeof(long)
 	cmp	r3, #0x0800			@ limit to 512MB
+	it	hi
 	movhi	r3, #0x0800
 	add	r6, r0, r3
 	ldr	r3, [r8, #MACHINFO_PHYSIO]
diff --git a/arch/arm/kernel/module.c b/arch/arm/kernel/module.c
index b8d965d..9ebf608 100644
--- a/arch/arm/kernel/module.c
+++ b/arch/arm/kernel/module.c
@@ -21,6 +21,7 @@
 #include <linux/string.h>
 
 #include <asm/pgtable.h>
+#include <asm/unwind.h>
 
 #ifdef CONFIG_XIP_KERNEL
 /*
@@ -66,6 +67,24 @@ int module_frob_arch_sections(Elf_Ehdr *hdr,
 			      char *secstrings,
 			      struct module *mod)
 {
+#ifdef CONFIG_ARM_UNWIND
+	Elf_Shdr *s, *sechdrs_end = sechdrs + hdr->e_shnum;
+
+	for (s = sechdrs; s < sechdrs_end; s++) {
+		if (strcmp(".ARM.exidx.init.text", secstrings + s->sh_name) == 0)
+			mod->arch.unw_sec_init = s;
+		else if (strcmp(".ARM.exidx.devinit.text", secstrings + s->sh_name) == 0)
+			mod->arch.unw_sec_devinit = s;
+		else if (strcmp(".ARM.exidx", secstrings + s->sh_name) == 0)
+			mod->arch.unw_sec_core = s;
+		else if (strcmp(".init.text", secstrings + s->sh_name) == 0)
+			mod->arch.sec_init_text = s;
+		else if (strcmp(".devinit.text", secstrings + s->sh_name) == 0)
+			mod->arch.sec_devinit_text = s;
+		else if (strcmp(".text", secstrings + s->sh_name) == 0)
+			mod->arch.sec_core_text = s;
+	}
+#endif
 	return 0;
 }
 
@@ -83,6 +102,7 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 		unsigned long loc;
 		Elf32_Sym *sym;
 		s32 offset;
+		u32 upper, lower, sign, j1, j2;
 
 		offset = ELF32_R_SYM(rel->r_info);
 		if (offset < 0 || offset > (symsec->sh_size / sizeof(Elf32_Sym))) {
@@ -104,6 +124,10 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 		loc = dstsec->sh_addr + rel->r_offset;
 
 		switch (ELF32_R_TYPE(rel->r_info)) {
+		case R_ARM_NONE:
+			/* ignore */
+			break;
+
 		case R_ARM_ABS32:
 			*(u32 *)loc += sym->st_value;
 			break;
@@ -132,6 +156,63 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 			*(u32 *)loc |= offset & 0x00ffffff;
 			break;
 
+		case R_ARM_PREL31:
+			offset = *(u32 *)loc + sym->st_value - loc;
+			*(u32 *)loc = offset & 0x7fffffff;
+			break;
+
+		case R_ARM_THM_CALL:
+		case R_ARM_THM_JUMP24:
+			upper = *(u16 *)loc;
+			lower = *(u16 *)(loc + 2);
+
+			/*
+			 * 25 bit signed address range (Thumb-2 BL and B.W
+			 * instructions):
+			 *   S:I1:I2:imm10:imm11:0
+			 * where:
+			 *   S     = upper[10]   = offset[24]
+			 *   I1    = ~(J1 ^ S)   = offset[23]
+			 *   I2    = ~(J2 ^ S)   = offset[22]
+			 *   imm10 = upper[9:0]  = offset[21:12]
+			 *   imm11 = lower[10:0] = offset[11:1]
+			 *   J1    = lower[13]
+			 *   J2    = lower[11]
+			 */
+			sign = (upper >> 10) & 1;
+			j1 = (lower >> 13) & 1;
+			j2 = (lower >> 11) & 1;
+			offset = (sign << 24) | ((~(j1 ^ sign) & 1) << 23) |
+				((~(j2 ^ sign) & 1) << 22) |
+				((upper & 0x03ff) << 12) |
+				((lower & 0x07ff) << 1);
+			if (offset & 0x01000000)
+				offset -= 0x02000000;
+			offset += sym->st_value - loc;
+
+			/* only Thumb addresses allowed (no interworking) */
+			if (!(offset & 1) ||
+			    offset <= (s32)0xff000000 ||
+			    offset >= (s32)0x01000000) {
+				printk(KERN_ERR
+				       "%s: relocation out of range, section "
+				       "%d reloc %d sym '%s'\n", module->name,
+				       relindex, i, strtab + sym->st_name);
+				return -ENOEXEC;
+			}
+
+			sign = (offset >> 24) & 1;
+			j1 = sign ^ (~(offset >> 23) & 1);
+			j2 = sign ^ (~(offset >> 22) & 1);
+			*(u16 *)loc = (u16)((upper & 0xf800) | (sign << 10) |
+					    ((offset >> 12) & 0x03ff));
+			*(u16 *)(loc + 2) = (u16)((lower & 0xd000) |
+						  (j1 << 13) | (j2 << 11) |
+						  ((offset >> 1) & 0x07ff));
+			upper = *(u16 *)loc;
+			lower = *(u16 *)(loc + 2);
+			break;
+
 		default:
 			printk(KERN_ERR "%s: unknown relocation: %u\n",
 			       module->name, ELF32_R_TYPE(rel->r_info));
@@ -150,14 +231,50 @@ apply_relocate_add(Elf32_Shdr *sechdrs, const char *strtab,
 	return -ENOEXEC;
 }
 
+#ifdef CONFIG_ARM_UNWIND
+static void register_unwind_tables(struct module *mod)
+{
+	if (mod->arch.unw_sec_init && mod->arch.sec_init_text)
+		mod->arch.unwind_init =
+			unwind_table_add(mod->arch.unw_sec_init->sh_addr,
+					 mod->arch.unw_sec_init->sh_size,
+					 mod->arch.sec_init_text->sh_addr,
+					 mod->arch.sec_init_text->sh_size);
+	if (mod->arch.unw_sec_devinit && mod->arch.sec_devinit_text)
+		mod->arch.unwind_devinit =
+			unwind_table_add(mod->arch.unw_sec_devinit->sh_addr,
+					 mod->arch.unw_sec_devinit->sh_size,
+					 mod->arch.sec_devinit_text->sh_addr,
+					 mod->arch.sec_devinit_text->sh_size);
+	if (mod->arch.unw_sec_core && mod->arch.sec_core_text)
+		mod->arch.unwind_core =
+			unwind_table_add(mod->arch.unw_sec_core->sh_addr,
+					 mod->arch.unw_sec_core->sh_size,
+					 mod->arch.sec_core_text->sh_addr,
+					 mod->arch.sec_core_text->sh_size);
+}
+
+static void unregister_unwind_tables(struct module *mod)
+{
+	unwind_table_del(mod->arch.unwind_init);
+	unwind_table_del(mod->arch.unwind_devinit);
+	unwind_table_del(mod->arch.unwind_core);
+}
+#else
+static inline void register_unwind_tables(struct module *mod) { }
+static inline void unregister_unwind_tables(struct module *mod) { }
+#endif
+
 int
 module_finalize(const Elf32_Ehdr *hdr, const Elf_Shdr *sechdrs,
 		struct module *module)
 {
+	register_unwind_tables(module);
 	return 0;
 }
 
 void
 module_arch_cleanup(struct module *mod)
 {
+	unregister_unwind_tables(mod);
 }
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d3ea6fa..a157a06 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -34,6 +34,7 @@
 #include <asm/processor.h>
 #include <asm/system.h>
 #include <asm/thread_notify.h>
+#include <asm/stacktrace.h>
 #include <asm/mach/time.h>
 
 static const char *processor_modes[] = {
@@ -364,7 +365,7 @@ pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 	regs.ARM_r2 = (unsigned long)fn;
 	regs.ARM_r3 = (unsigned long)do_exit;
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
-	regs.ARM_cpsr = SVC_MODE;
+	regs.ARM_cpsr = SVC_MODE | PSR_ENDSTATE | PSR_ISETSTATE;
 
 	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
@@ -372,23 +373,21 @@ EXPORT_SYMBOL(kernel_thread);
 
 unsigned long get_wchan(struct task_struct *p)
 {
-	unsigned long fp, lr;
-	unsigned long stack_start, stack_end;
+	struct stackframe frame;
 	int count = 0;
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	stack_start = (unsigned long)end_of_stack(p);
-	stack_end = (unsigned long)task_stack_page(p) + THREAD_SIZE;
-
-	fp = thread_saved_fp(p);
+	frame.fp = thread_saved_fp(p);
+	frame.sp = thread_saved_sp(p);
+	frame.lr = 0;			/* recovered from the stack */
+	frame.pc = thread_saved_pc(p);
 	do {
-		if (fp < stack_start || fp > stack_end)
+		int ret = unwind_frame(&frame);
+		if (ret < 0)
 			return 0;
-		lr = ((unsigned long *)fp)[-1];
-		if (!in_sched_functions(lr))
-			return lr;
-		fp = *(unsigned long *) (fp - 12);
+		if (!in_sched_functions(frame.pc))
+			return frame.pc;
 	} while (count ++ < 16);
 	return 0;
 }
diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index df653ea..a2ea385 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -521,7 +521,13 @@ static int ptrace_read_user(struct task_struct *tsk, unsigned long off,
 		return -EIO;
 
 	tmp = 0;
-	if (off < sizeof(struct pt_regs))
+	if (off == PT_TEXT_ADDR)
+		tmp = tsk->mm->start_code;
+	else if (off == PT_DATA_ADDR)
+		tmp = tsk->mm->start_data;
+	else if (off == PT_TEXT_END_ADDR)
+		tmp = tsk->mm->end_code;
+	else if (off < sizeof(struct pt_regs))
 		tmp = get_user_reg(tsk, off >> 2);
 
 	return put_user(tmp, ret);
@@ -653,6 +659,54 @@ static int ptrace_setcrunchregs(struct task_struct *tsk, void __user *ufp)
 }
 #endif
 
+#ifdef CONFIG_VFP
+/*
+ * Get the child VFP state.
+ */
+static int ptrace_getvfpregs(struct task_struct *tsk, void __user *data)
+{
+	struct thread_info *thread = task_thread_info(tsk);
+	union vfp_state *vfp = &thread->vfpstate;
+	struct user_vfp __user *ufp = data;
+
+	vfp_sync_state(thread);
+
+	/* copy the floating point registers */
+	if (copy_to_user(&ufp->fpregs, &vfp->hard.fpregs,
+			 sizeof(vfp->hard.fpregs)))
+		return -EFAULT;
+
+	/* copy the status and control register */
+	if (put_user(vfp->hard.fpscr, &ufp->fpscr))
+		return -EFAULT;
+
+	return 0;
+}
+
+/*
+ * Set the child VFP state.
+ */
+static int ptrace_setvfpregs(struct task_struct *tsk, void __user *data)
+{
+	struct thread_info *thread = task_thread_info(tsk);
+	union vfp_state *vfp = &thread->vfpstate;
+	struct user_vfp __user *ufp = data;
+
+	vfp_sync_state(thread);
+
+	/* copy the floating point registers */
+	if (copy_from_user(&vfp->hard.fpregs, &ufp->fpregs,
+			   sizeof(vfp->hard.fpregs)))
+		return -EFAULT;
+
+	/* copy the status and control register */
+	if (get_user(vfp->hard.fpscr, &ufp->fpscr))
+		return -EFAULT;
+
+	return 0;
+}
+#endif
+
 long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 {
 	int ret;
@@ -775,6 +829,16 @@ long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 			break;
 #endif
 
+#ifdef CONFIG_VFP
+		case PTRACE_GETVFPREGS:
+			ret = ptrace_getvfpregs(child, (void __user *)data);
+			break;
+
+		case PTRACE_SETVFPREGS:
+			ret = ptrace_setvfpregs(child, (void __user *)data);
+			break;
+#endif
+
 		default:
 			ret = ptrace_request(child, request, addr, data);
 			break;
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1f1eecc..57f894e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -25,6 +25,7 @@
 #include <linux/smp.h>
 #include <linux/fs.h>
 
+#include <asm/unified.h>
 #include <asm/cpu.h>
 #include <asm/cputype.h>
 #include <asm/elf.h>
@@ -39,6 +40,7 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 #include <asm/traps.h>
+#include <asm/unwind.h>
 
 #include "compat.h"
 #include "atags.h"
@@ -234,12 +236,13 @@ static void __init cacheid_init(void)
 	unsigned int cachetype = read_cpuid_cachetype();
 	unsigned int arch = cpu_architecture();
 
-	if (arch >= CPU_ARCH_ARMv7) {
-		cacheid = CACHEID_VIPT_NONALIASING;
-		if ((cachetype & (3 << 14)) == 1 << 14)
-			cacheid |= CACHEID_ASID_TAGGED;
-	} else if (arch >= CPU_ARCH_ARMv6) {
-		if (cachetype & (1 << 23))
+	if (arch >= CPU_ARCH_ARMv6) {
+		if ((cachetype & (7 << 29)) == 4 << 29) {
+			/* ARMv7 register format */
+			cacheid = CACHEID_VIPT_NONALIASING;
+			if ((cachetype & (3 << 14)) == 1 << 14)
+				cacheid |= CACHEID_ASID_TAGGED;
+		} else if (cachetype & (1 << 23))
 			cacheid = CACHEID_VIPT_ALIASING;
 		else
 			cacheid = CACHEID_VIPT_NONALIASING;
@@ -326,25 +329,38 @@ void cpu_init(void)
 	}
 
 	/*
+	 * Define the placement constraint for the inline asm directive below.
+	 * In Thumb-2, msr with an immediate value is not allowed.
+	 */
+#ifdef CONFIG_THUMB2_KERNEL
+#define PLC	"r"
+#else
+#define PLC	"I"
+#endif
+
+	/*
 	 * setup stacks for re-entrant exception handlers
 	 */
 	__asm__ (
 	"msr	cpsr_c, %1\n\t"
-	"add	sp, %0, %2\n\t"
+	"add	r14, %0, %2\n\t"
+	"mov	sp, r14\n\t"
 	"msr	cpsr_c, %3\n\t"
-	"add	sp, %0, %4\n\t"
+	"add	r14, %0, %4\n\t"
+	"mov	sp, r14\n\t"
 	"msr	cpsr_c, %5\n\t"
-	"add	sp, %0, %6\n\t"
+	"add	r14, %0, %6\n\t"
+	"mov	sp, r14\n\t"
 	"msr	cpsr_c, %7"
 	    :
 	    : "r" (stk),
-	      "I" (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
+	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
 	      "I" (offsetof(struct stack, irq[0])),
-	      "I" (PSR_F_BIT | PSR_I_BIT | ABT_MODE),
+	      PLC (PSR_F_BIT | PSR_I_BIT | ABT_MODE),
 	      "I" (offsetof(struct stack, abt[0])),
-	      "I" (PSR_F_BIT | PSR_I_BIT | UND_MODE),
+	      PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),
 	      "I" (offsetof(struct stack, und[0])),
-	      "I" (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
+	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
 	    : "r14");
 }
 
@@ -679,6 +695,8 @@ void __init setup_arch(char **cmdline_p)
 	struct machine_desc *mdesc;
 	char *from = default_command_line;
 
+	unwind_init();
+
 	setup_processor();
 	mdesc = setup_machine(machine_arch_type);
 	machine_name = mdesc->name;
@@ -772,6 +790,10 @@ static const char *hwcap_str[] = {
 	"java",
 	"iwmmxt",
 	"crunch",
+	"thumbee",
+	"neon",
+	"vfpv3",
+	"vfpv3d16",
 	NULL
 };
 
diff --git a/arch/arm/kernel/signal.c b/arch/arm/kernel/signal.c
index 80b8b5c..442b874 100644
--- a/arch/arm/kernel/signal.c
+++ b/arch/arm/kernel/signal.c
@@ -426,9 +426,13 @@ setup_return(struct pt_regs *regs, struct k_sigaction *ka,
 		 */
 		thumb = handler & 1;
 
-		if (thumb)
+		if (thumb) {
 			cpsr |= PSR_T_BIT;
-		else
+#if __LINUX_ARM_ARCH__ >= 7
+			/* clear the If-Then Thumb-2 execution state */
+			cpsr &= ~PSR_IT_MASK;
+#endif
+		} else
 			cpsr &= ~PSR_T_BIT;
 	}
 #endif
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index e42a749..6859769 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -70,6 +70,9 @@ enum ipi_msg_type {
 	IPI_CALL_FUNC,
 	IPI_CALL_FUNC_SINGLE,
 	IPI_CPU_STOP,
+#ifdef CONFIG_CPU_NO_CACHE_BCAST
+	IPI_DMA_CACHE,
+#endif
 };
 
 int __cpuinit __cpu_up(unsigned int cpu)
@@ -103,6 +106,7 @@ int __cpuinit __cpu_up(unsigned int cpu)
 	pmd = pmd_offset(pgd + pgd_index(PHYS_OFFSET), PHYS_OFFSET);
 	*pmd = __pmd((PHYS_OFFSET & PGDIR_MASK) |
 		     PMD_TYPE_SECT | PMD_SECT_AP_WRITE);
+	flush_pmd_entry(pmd);
 
 	/*
 	 * We need to tell the secondary core where to find
@@ -140,6 +144,7 @@ int __cpuinit __cpu_up(unsigned int cpu)
 	secondary_data.pgdir = 0;
 
 	*pmd = __pmd(0);
+	clean_pmd_entry(pmd);
 	pgd_free(&init_mm, pgd);
 
 	if (ret) {
@@ -181,7 +186,7 @@ int __cpuexit __cpu_disable(void)
 	/*
 	 * Stop the local timer for this CPU.
 	 */
-	local_timer_stop(cpu);
+	local_timer_stop();
 
 	/*
 	 * Flush user cache and TLB mappings, and then remove this CPU
@@ -284,7 +289,7 @@ asmlinkage void __cpuinit secondary_start_kernel(void)
 	/*
 	 * Setup local timer for this CPU.
 	 */
-	local_timer_setup(cpu);
+	local_timer_setup();
 
 	calibrate_delay();
 
@@ -434,6 +439,10 @@ static void ipi_cpu_stop(unsigned int cpu)
 		cpu_relax();
 }
 
+#ifdef CONFIG_CPU_NO_CACHE_BCAST
+static void ipi_dma_cache_op(unsigned int cpu);
+#endif
+
 /*
  * Main handler for inter-processor interrupts
  *
@@ -493,6 +502,12 @@ asmlinkage void __exception do_IPI(struct pt_regs *regs)
 				ipi_cpu_stop(cpu);
 				break;
 
+#ifdef CONFIG_CPU_NO_CACHE_BCAST
+			case IPI_DMA_CACHE:
+				ipi_dma_cache_op(cpu);
+				break;
+#endif
+
 			default:
 				printk(KERN_CRIT "CPU%u: Unknown IPI message 0x%x\n",
 				       cpu, nextmsg);
@@ -603,19 +618,19 @@ static inline void ipi_flush_tlb_kernel_range(void *arg)
 	local_flush_tlb_kernel_range(ta->ta_start, ta->ta_end);
 }
 
-void flush_tlb_all(void)
+void smp_flush_tlb_all(void)
 {
 	on_each_cpu(ipi_flush_tlb_all, NULL, 1);
 }
 
-void flush_tlb_mm(struct mm_struct *mm)
+void smp_flush_tlb_mm(struct mm_struct *mm)
 {
 	cpumask_t mask = mm->cpu_vm_mask;
 
 	on_each_cpu_mask(ipi_flush_tlb_mm, mm, 1, mask);
 }
 
-void flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr)
+void smp_flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr)
 {
 	cpumask_t mask = vma->vm_mm->cpu_vm_mask;
 	struct tlb_args ta;
@@ -626,7 +641,7 @@ void flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr)
 	on_each_cpu_mask(ipi_flush_tlb_page, &ta, 1, mask);
 }
 
-void flush_tlb_kernel_page(unsigned long kaddr)
+void smp_flush_tlb_kernel_page(unsigned long kaddr)
 {
 	struct tlb_args ta;
 
@@ -635,7 +650,7 @@ void flush_tlb_kernel_page(unsigned long kaddr)
 	on_each_cpu(ipi_flush_tlb_kernel_page, &ta, 1);
 }
 
-void flush_tlb_range(struct vm_area_struct *vma,
+void smp_flush_tlb_range(struct vm_area_struct *vma,
                      unsigned long start, unsigned long end)
 {
 	cpumask_t mask = vma->vm_mm->cpu_vm_mask;
@@ -648,7 +663,7 @@ void flush_tlb_range(struct vm_area_struct *vma,
 	on_each_cpu_mask(ipi_flush_tlb_range, &ta, 1, mask);
 }
 
-void flush_tlb_kernel_range(unsigned long start, unsigned long end)
+void smp_flush_tlb_kernel_range(unsigned long start, unsigned long end)
 {
 	struct tlb_args ta;
 
@@ -657,3 +672,123 @@ void flush_tlb_kernel_range(unsigned long start, unsigned long end)
 
 	on_each_cpu(ipi_flush_tlb_kernel_range, &ta, 1);
 }
+
+#ifdef CONFIG_CPU_NO_CACHE_BCAST
+/*
+ * DMA cache maintenance operations on SMP if the automatic hardware
+ * broadcasting is not available
+ */
+struct smp_dma_cache_struct {
+	int type;
+	const void *start;
+	const void *end;
+	cpumask_t unfinished;
+};
+
+static struct smp_dma_cache_struct *smp_dma_cache_data;
+static DEFINE_RWLOCK(smp_dma_cache_data_lock);
+static DEFINE_SPINLOCK(smp_dma_cache_lock);
+
+static void local_dma_cache_op(int type, const void *start, const void *end)
+{
+	switch (type) {
+	case SMP_DMA_CACHE_INV:
+		dmac_inv_range(start, end);
+		break;
+	case SMP_DMA_CACHE_CLEAN:
+		dmac_clean_range(start, end);
+		break;
+	case SMP_DMA_CACHE_FLUSH:
+		dmac_flush_range(start, end);
+		break;
+	default:
+		printk(KERN_CRIT "CPU%u: Unknown SMP DMA cache type %d\n",
+		       smp_processor_id(), type);
+	}
+}
+
+/*
+ * This function must be executed with interrupts disabled.
+ */
+static void ipi_dma_cache_op(unsigned int cpu)
+{
+	read_lock(&smp_dma_cache_data_lock);
+
+	/* check for spurious IPI */
+	if ((smp_dma_cache_data == NULL) ||
+	    (!cpu_isset(cpu, smp_dma_cache_data->unfinished)))
+		goto out;
+	local_dma_cache_op(smp_dma_cache_data->type,
+			   smp_dma_cache_data->start, smp_dma_cache_data->end);
+	cpu_clear(cpu, smp_dma_cache_data->unfinished);
+ out:
+	read_unlock(&smp_dma_cache_data_lock);
+}
+
+/*
+ * Execute the DMA cache operations on all online CPUs. This function
+ * can be called with interrupts disabled or from interrupt context.
+ */
+static void __smp_dma_cache_op(int type, const void *start, const void *end)
+{
+	struct smp_dma_cache_struct data;
+	cpumask_t callmap = cpu_online_map;
+	unsigned int cpu = get_cpu();
+	unsigned long flags;
+
+	cpu_clear(cpu, callmap);
+	data.type = type;
+	data.start = start;
+	data.end = end;
+	data.unfinished = callmap;
+
+	/*
+	 * If the spinlock cannot be acquired, other CPU is trying to
+	 * send an IPI. If the interrupts are disabled, we have to
+	 * poll for an incoming IPI.
+	 */
+	while (!spin_trylock_irqsave(&smp_dma_cache_lock, flags)) {
+		if (irqs_disabled())
+			ipi_dma_cache_op(cpu);
+	}
+
+	write_lock(&smp_dma_cache_data_lock);
+	smp_dma_cache_data = &data;
+	write_unlock(&smp_dma_cache_data_lock);
+
+	if (!cpus_empty(callmap))
+		send_ipi_message(callmap, IPI_DMA_CACHE);
+	/* run the local operation in parallel with the other CPUs */
+	local_dma_cache_op(type, start, end);
+
+	while (!cpus_empty(data.unfinished))
+		barrier();
+
+	write_lock(&smp_dma_cache_data_lock);
+	smp_dma_cache_data = NULL;
+	write_unlock(&smp_dma_cache_data_lock);
+
+	spin_unlock_irqrestore(&smp_dma_cache_lock, flags);
+	put_cpu();
+}
+
+#define DMA_MAX_RANGE		SZ_4K
+
+/*
+ * Split the cache range in smaller pieces if interrupts are enabled
+ * to reduce the latency caused by disabling the interrupts during the
+ * broadcast.
+ */
+void smp_dma_cache_op(int type, const void *start, const void *end)
+{
+	if (irqs_disabled() || (end - start <= DMA_MAX_RANGE))
+		__smp_dma_cache_op(type, start, end);
+	else {
+		const void *ptr;
+		for (ptr = start; ptr < end - DMA_MAX_RANGE;
+		     ptr += DMA_MAX_RANGE)
+			__smp_dma_cache_op(type, ptr, ptr + DMA_MAX_RANGE);
+		__smp_dma_cache_op(type, ptr, end);
+	}
+}
+#endif
diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index fc650f6..b371c54 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -2,35 +2,60 @@
 #include <linux/sched.h>
 #include <linux/stacktrace.h>
 
-#include "stacktrace.h"
-
-int walk_stackframe(unsigned long fp, unsigned long low, unsigned long high,
-		    int (*fn)(struct stackframe *, void *), void *data)
+#include <asm/stacktrace.h>
+
+#if defined(CONFIG_FRAME_POINTER) && !defined(CONFIG_ARM_UNWIND)
+/*
+ * Unwind the current stack frame and store the new register values in the
+ * structure passed as argument. Unwinding is equivalent to a function return,
+ * hence the new PC value rather than LR should be used for backtrace.
+ *
+ * With framepointer enabled, a simple function prologue looks like this:
+ *	mov	ip, sp
+ *	stmdb	sp!, {fp, ip, lr, pc}
+ *	sub	fp, ip, #4
+ *
+ * A simple function epilogue looks like this:
+ *	ldm	sp, {fp, sp, pc}
+ *
+ * Note that with framepointer enabled, even the leaf functions have the same
+ * prologue and epilogue, therefore we can ignore the LR value in this case.
+ */
+int unwind_frame(struct stackframe *frame)
 {
-	struct stackframe *frame;
+	unsigned long high, low;
+	unsigned long fp = frame->fp;
 
-	do {
-		/*
-		 * Check current frame pointer is within bounds
-		 */
-		if (fp < (low + 12) || fp + 4 >= high)
-			break;
+	/* only go to a higher address on the stack */
+	low = frame->sp;
+	high = ALIGN(low, THREAD_SIZE) + THREAD_SIZE;
 
-		frame = (struct stackframe *)(fp - 12);
+	/* check current frame pointer is within bounds */
+	if (fp < (low + 12) || fp + 4 >= high)
+		return -EINVAL;
 
-		if (fn(frame, data))
-			break;
-
-		/*
-		 * Update the low bound - the next frame must always
-		 * be at a higher address than the current frame.
-		 */
-		low = fp + 4;
-		fp = frame->fp;
-	} while (fp);
+	/* restore the registers from the stack frame */
+	frame->fp = *(unsigned long *)(fp - 12);
+	frame->sp = *(unsigned long *)(fp - 8);
+	frame->pc = *(unsigned long *)(fp - 4);
 
 	return 0;
 }
+#endif
+
+void walk_stackframe(struct stackframe *frame,
+		     int (*fn)(struct stackframe *, void *), void *data)
+{
+	while (1) {
+		int ret;
+
+		if (fn(frame, data))
+			break;
+		ret = unwind_frame(frame);
+		if (ret < 0)
+			break;
+	}
+}
 EXPORT_SYMBOL(walk_stackframe);
 
 #ifdef CONFIG_STACKTRACE
@@ -44,7 +69,7 @@ static int save_trace(struct stackframe *frame, void *d)
 {
 	struct stack_trace_data *data = d;
 	struct stack_trace *trace = data->trace;
-	unsigned long addr = frame->lr;
+	unsigned long addr = frame->pc;
 
 	if (data->no_sched_functions && in_sched_functions(addr))
 		return 0;
@@ -61,11 +86,10 @@ static int save_trace(struct stackframe *frame, void *d)
 void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
 	struct stack_trace_data data;
-	unsigned long fp, base;
+	struct stackframe frame;
 
 	data.trace = trace;
 	data.skip = trace->skip;
-	base = (unsigned long)task_stack_page(tsk);
 
 	if (tsk != current) {
 #ifdef CONFIG_SMP
@@ -76,14 +100,22 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 		BUG();
 #else
 		data.no_sched_functions = 1;
-		fp = thread_saved_fp(tsk);
+		frame.fp = thread_saved_fp(tsk);
+		frame.sp = thread_saved_sp(tsk);
+		frame.lr = 0;		/* recovered from the stack */
+		frame.pc = thread_saved_pc(tsk);
 #endif
 	} else {
+		register unsigned long current_sp asm ("sp");
+		
 		data.no_sched_functions = 0;
-		asm("mov %0, fp" : "=r" (fp));
+		frame.fp = (unsigned long)__builtin_frame_address(0);
+		frame.sp = current_sp;
+		frame.lr = (unsigned long)__builtin_return_address(0);
+		frame.pc = (unsigned long)save_stack_trace_tsk;
 	}
 
-	walk_stackframe(fp, base, base + THREAD_SIZE, save_trace, &data);
+	walk_stackframe(&frame, save_trace, &data);
 	if (trace->nr_entries < trace->max_entries)
 		trace->entries[trace->nr_entries++] = ULONG_MAX;
 }
diff --git a/arch/arm/kernel/stacktrace.h b/arch/arm/kernel/stacktrace.h
deleted file mode 100644
index e9fd20c..0000000
--- a/arch/arm/kernel/stacktrace.h
+++ /dev/null
@@ -1,9 +0,0 @@
-struct stackframe {
-	unsigned long fp;
-	unsigned long sp;
-	unsigned long lr;
-	unsigned long pc;
-};
-
-int walk_stackframe(unsigned long fp, unsigned long low, unsigned long high,
-		    int (*fn)(struct stackframe *, void *), void *data);
diff --git a/arch/arm/kernel/thumbee.c b/arch/arm/kernel/thumbee.c
index df3f6b7..9cb7aac 100644
--- a/arch/arm/kernel/thumbee.c
+++ b/arch/arm/kernel/thumbee.c
@@ -25,7 +25,7 @@
 /*
  * Access to the ThumbEE Handler Base register
  */
-static inline unsigned long teehbr_read()
+static inline unsigned long teehbr_read(void)
 {
 	unsigned long v;
 	asm("mrc	p14, 6, %0, c1, c0, 0\n" : "=r" (v));
diff --git a/arch/arm/kernel/time.c b/arch/arm/kernel/time.c
index c68b44a..4cdc4a0 100644
--- a/arch/arm/kernel/time.c
+++ b/arch/arm/kernel/time.c
@@ -33,6 +33,7 @@
 
 #include <asm/leds.h>
 #include <asm/thread_info.h>
+#include <asm/stacktrace.h>
 #include <asm/mach/time.h>
 
 /*
@@ -55,14 +56,22 @@ EXPORT_SYMBOL(rtc_lock);
 #ifdef CONFIG_SMP
 unsigned long profile_pc(struct pt_regs *regs)
 {
-	unsigned long fp, pc = instruction_pointer(regs);
+	struct stackframe frame;
 
-	if (in_lock_functions(pc)) {
-		fp = regs->ARM_fp;
-		pc = ((unsigned long *)fp)[-1];
-	}
+	if (!in_lock_functions(regs->ARM_pc))
+		return regs->ARM_pc;
+
+	frame.fp = regs->ARM_fp;
+	frame.sp = regs->ARM_sp;
+	frame.lr = regs->ARM_lr;
+	frame.pc = regs->ARM_pc;
+	do {
+		int ret = unwind_frame(&frame);
+		if (ret < 0)
+			return 0;
+	} while (in_lock_functions(frame.pc));
 
-	return pc;
+	return frame.pc;
 }
 EXPORT_SYMBOL(profile_pc);
 #endif
diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c
index 79abc4d..219fc28 100644
--- a/arch/arm/kernel/traps.c
+++ b/arch/arm/kernel/traps.c
@@ -27,6 +27,7 @@
 #include <asm/system.h>
 #include <asm/unistd.h>
 #include <asm/traps.h>
+#include <asm/unwind.h>
 
 #include "ptrace.h"
 #include "signal.h"
@@ -61,6 +62,7 @@ void dump_backtrace_entry(unsigned long where, unsigned long from, unsigned long
 		dump_mem("Exception stack", frame + 4, frame + 4 + sizeof(struct pt_regs));
 }
 
+#ifndef CONFIG_ARM_UNWIND
 /*
  * Stack pointers should always be within the kernels view of
  * physical memory.  If it is not there, then we can't dump
@@ -74,6 +76,7 @@ static int verify_stack(unsigned long sp)
 
 	return 0;
 }
+#endif
 
 /*
  * Dump out the contents of some memory nicely...
@@ -150,13 +153,33 @@ static void dump_instr(struct pt_regs *regs)
 	set_fs(fs);
 }
 
+#ifdef CONFIG_ARM_UNWIND
+static inline void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)
+{
+	unwind_backtrace(regs, tsk);
+}
+#else
 static void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)
 {
-	unsigned int fp;
+	unsigned int fp, mode;
 	int ok = 1;
 
 	printk("Backtrace: ");
-	fp = regs->ARM_fp;
+
+	if (!tsk)
+		tsk = current;
+
+	if (regs) {
+		fp = regs->ARM_fp;
+		mode = processor_mode(regs);
+	} else if (tsk != current) {
+		fp = thread_saved_fp(tsk);
+		mode = 0x10;
+	} else {
+		asm("mov %0, fp" : "=r" (fp) : : "cc");
+		mode = 0x10;
+	}
+
 	if (!fp) {
 		printk("no frame pointer");
 		ok = 0;
@@ -168,29 +191,20 @@ static void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)
 	printk("\n");
 
 	if (ok)
-		c_backtrace(fp, processor_mode(regs));
+		c_backtrace(fp, mode);
 }
+#endif
 
 void dump_stack(void)
 {
-	__backtrace();
+	dump_backtrace(NULL, NULL);
 }
 
 EXPORT_SYMBOL(dump_stack);
 
 void show_stack(struct task_struct *tsk, unsigned long *sp)
 {
-	unsigned long fp;
-
-	if (!tsk)
-		tsk = current;
-
-	if (tsk != current)
-		fp = thread_saved_fp(tsk);
-	else
-		asm("mov %0, fp" : "=r" (fp) : : "cc");
-
-	c_backtrace(fp, 0x10);
+	dump_backtrace(NULL, tsk);
 	barrier();
 }
 
@@ -625,6 +639,14 @@ void __bad_xchg(volatile void *ptr, int size)
 }
 EXPORT_SYMBOL(__bad_xchg);
 
+void __bad_cmpxchg(volatile void *ptr, int size)
+{
+	printk("cmpxchg: bad data size: pc 0x%p, ptr 0x%p, size %d\n",
+		__builtin_return_address(0), ptr, size);
+	BUG();
+}
+EXPORT_SYMBOL(__bad_cmpxchg);
+
 /*
  * A data abort trap was taken, but we did not handle the instruction.
  * Try to abort the user program, or panic if it was the kernel.
diff --git a/arch/arm/kernel/unwind.c b/arch/arm/kernel/unwind.c
new file mode 100644
index 0000000..1dedc2c
--- /dev/null
+++ b/arch/arm/kernel/unwind.c
@@ -0,0 +1,434 @@
+/*
+ * arch/arm/kernel/unwind.c
+ *
+ * Copyright (C) 2008 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *
+ * Stack unwinding support for ARM
+ *
+ * An ARM EABI version of gcc is required to generate the unwind
+ * tables. For information about the structure of the unwind tables,
+ * see "Exception Handling ABI for the ARM Architecture" at:
+ *
+ * http://infocenter.arm.com/help/topic/com.arm.doc.subset.swdev.abi/index.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+
+#include <asm/stacktrace.h>
+#include <asm/traps.h>
+#include <asm/unwind.h>
+
+/* Dummy functions to avoid linker complaints */
+void __aeabi_unwind_cpp_pr0(void)
+{
+};
+EXPORT_SYMBOL(__aeabi_unwind_cpp_pr0);
+
+void __aeabi_unwind_cpp_pr1(void)
+{
+};
+EXPORT_SYMBOL(__aeabi_unwind_cpp_pr1);
+
+void __aeabi_unwind_cpp_pr2(void)
+{
+};
+EXPORT_SYMBOL(__aeabi_unwind_cpp_pr2);
+
+struct unwind_ctrl_block {
+	unsigned long vrs[16];		/* virtual register set */
+	unsigned long *insn;		/* pointer to the current instructions word */
+	int entries;			/* number of entries left to interpret */
+	int byte;			/* current byte number in the instructions word */
+};
+
+enum regs {
+	FP = 11,
+	SP = 13,
+	LR = 14,
+	PC = 15
+};
+
+extern struct unwind_idx __start_unwind_idx[];
+extern struct unwind_idx __stop_unwind_idx[];
+
+static DEFINE_SPINLOCK(unwind_lock);
+static LIST_HEAD(unwind_tables);
+
+/* Convert a prel31 symbol to an absolute address */
+#define prel31_to_addr(ptr)				\
+({							\
+	/* sign-extend to 32 bits */			\
+	long offset = (((long)*(ptr)) << 1) >> 1;	\
+	(unsigned long)(ptr) + offset;			\
+})
+
+/*
+ * Binary search in the unwind index. The entries entries are
+ * guaranteed to be sorted in ascending order by the linker.
+ */
+static struct unwind_idx *search_index(unsigned long addr,
+				       struct unwind_idx *first,
+				       struct unwind_idx *last)
+{
+	pr_debug("%s(%08lx, %p, %p)\n", __func__, addr, first, last);
+
+	if (addr < first->addr) {
+		pr_warning("unwind: Unknown symbol address %08lx\n", addr);
+		return NULL;
+	} else if (addr >= last->addr)
+		return last;
+
+	while (first < last - 1) {
+		struct unwind_idx *mid = first + ((last - first + 1) >> 1);
+
+		if (addr < mid->addr)
+			last = mid;
+		else
+			first = mid;
+	}
+
+	return first;
+}
+
+static struct unwind_idx *unwind_find_idx(unsigned long addr)
+{
+	struct unwind_idx *idx = NULL;
+	unsigned long flags;
+
+	pr_debug("%s(%08lx)\n", __func__, addr);
+
+	if (core_kernel_text(addr))
+		/* main unwind table */
+		idx = search_index(addr, __start_unwind_idx,
+				   __stop_unwind_idx - 1);
+	else {
+		/* module unwind tables */
+		struct unwind_table *table;
+
+		spin_lock_irqsave(&unwind_lock, flags);
+		list_for_each_entry(table, &unwind_tables, list) {
+			if (addr >= table->begin_addr &&
+			    addr < table->end_addr) {
+				idx = search_index(addr, table->start,
+						   table->stop - 1);
+				break;
+			}
+		}
+		spin_unlock_irqrestore(&unwind_lock, flags);
+	}
+
+	pr_debug("%s: idx = %p\n", __func__, idx);
+	return idx;
+}
+
+static unsigned long unwind_get_byte(struct unwind_ctrl_block *ctrl)
+{
+	unsigned long ret;
+
+	if (ctrl->entries <= 0) {
+		pr_warning("unwind: Corrupt unwind table\n");
+		return 0;
+	}
+
+	ret = (*ctrl->insn >> (ctrl->byte * 8)) & 0xff;
+
+	if (ctrl->byte == 0) {
+		ctrl->insn++;
+		ctrl->entries--;
+		ctrl->byte = 3;
+	} else
+		ctrl->byte--;
+
+	return ret;
+}
+
+/*
+ * Execute the current unwind instruction.
+ */
+static int unwind_exec_insn(struct unwind_ctrl_block *ctrl)
+{
+	unsigned long insn = unwind_get_byte(ctrl);
+
+	pr_debug("%s: insn = %08lx\n", __func__, insn);
+
+	if ((insn & 0xc0) == 0x00)
+		ctrl->vrs[SP] += ((insn & 0x3f) << 2) + 4;
+	else if ((insn & 0xc0) == 0x40)
+		ctrl->vrs[SP] -= ((insn & 0x3f) << 2) + 4;
+	else if ((insn & 0xf0) == 0x80) {
+		unsigned long mask;
+		unsigned long *vsp = (unsigned long *)ctrl->vrs[SP];
+		int load_sp, reg = 4;
+
+		insn = (insn << 8) | unwind_get_byte(ctrl);
+		mask = insn & 0x0fff;
+		if (mask == 0) {
+			pr_warning("unwind: 'Refuse to unwind' instruction %04lx\n",
+				   insn);
+			return -URC_FAILURE;
+		}
+
+		/* pop R4-R15 according to mask */
+		load_sp = mask & (1 << (13 - 4));
+		while (mask) {
+			if (mask & 1)
+				ctrl->vrs[reg] = *vsp++;
+			mask >>= 1;
+			reg++;
+		}
+		if (!load_sp)
+			ctrl->vrs[SP] = (unsigned long)vsp;
+	} else if ((insn & 0xf0) == 0x90 &&
+		   (insn & 0x0d) != 0x0d)
+		ctrl->vrs[SP] = ctrl->vrs[insn & 0x0f];
+	else if ((insn & 0xf0) == 0xa0) {
+		unsigned long *vsp = (unsigned long *)ctrl->vrs[SP];
+		int reg;
+
+		/* pop R4-R[4+bbb] */
+		for (reg = 4; reg <= 4 + (insn & 7); reg++)
+			ctrl->vrs[reg] = *vsp++;
+		if (insn & 0x80)
+			ctrl->vrs[14] = *vsp++;
+		ctrl->vrs[SP] = (unsigned long)vsp;
+	} else if (insn == 0xb0) {
+		ctrl->vrs[PC] = ctrl->vrs[LR];
+		/* no further processing */
+		ctrl->entries = 0;
+	} else if (insn == 0xb1) {
+		unsigned long mask = unwind_get_byte(ctrl);
+		unsigned long *vsp = (unsigned long *)ctrl->vrs[SP];
+		int reg = 0;
+
+		if (mask == 0 || mask & 0xf0) {
+			pr_warning("unwind: Spare encoding %04lx\n",
+			       (insn << 8) | mask);
+			return -URC_FAILURE;
+		}
+
+		/* pop R0-R3 according to mask */
+		while (mask) {
+			if (mask & 1)
+				ctrl->vrs[reg] = *vsp++;
+			mask >>= 1;
+			reg++;
+		}
+		ctrl->vrs[SP] = (unsigned long)vsp;
+	} else if (insn == 0xb2) {
+		unsigned long uleb128 = unwind_get_byte(ctrl);
+
+		ctrl->vrs[SP] += 0x204 + (uleb128 << 2);
+	} else {
+		pr_warning("unwind: Unhandled instruction %02lx\n", insn);
+		return -URC_FAILURE;
+	}
+
+	pr_debug("%s: fp = %08lx sp = %08lx lr = %08lx pc = %08lx\n", __func__,
+		 ctrl->vrs[FP], ctrl->vrs[SP], ctrl->vrs[LR], ctrl->vrs[PC]);
+
+	return URC_OK;
+}
+
+/*
+ * Unwind a single frame starting with *sp for the symbol at *pc. It
+ * updates the *pc and *sp with the new values.
+ */
+int unwind_frame(struct stackframe *frame)
+{
+	unsigned long high, low;
+	struct unwind_idx *idx;
+	struct unwind_ctrl_block ctrl;
+
+	/* only go to a higher address on the stack */
+	low = frame->sp;
+	high = ALIGN(low, THREAD_SIZE) + THREAD_SIZE;
+
+	pr_debug("%s(pc = %08lx lr = %08lx sp = %08lx)\n", __func__,
+		 frame->pc, frame->lr, frame->sp);
+
+	if (!kernel_text_address(frame->pc))
+		return -URC_FAILURE;
+
+	idx = unwind_find_idx(frame->pc);
+	if (!idx) {
+		pr_warning("unwind: Index not found %08lx\n", frame->pc);
+		return -URC_FAILURE;
+	}
+
+	ctrl.vrs[FP] = frame->fp;
+	ctrl.vrs[SP] = frame->sp;
+	ctrl.vrs[LR] = frame->lr;
+	ctrl.vrs[PC] = 0;
+
+	if (idx->insn == 1)
+		/* can't unwind */
+		return -URC_FAILURE;
+	else if ((idx->insn & 0x80000000) == 0)
+		/* prel31 to the unwind table */
+		ctrl.insn = (unsigned long *)prel31_to_addr(&idx->insn);
+	else if ((idx->insn & 0xff000000) == 0x80000000)
+		/* only personality routine 0 supported in the index */
+		ctrl.insn = &idx->insn;
+	else {
+		pr_warning("unwind: Unsupported personality routine %08lx in the index at %p\n",
+			   idx->insn, idx);
+		return -URC_FAILURE;
+	}
+
+	/* check the personality routine */
+	if ((*ctrl.insn & 0xff000000) == 0x80000000) {
+		ctrl.byte = 2;
+		ctrl.entries = 1;
+	} else if ((*ctrl.insn & 0xff000000) == 0x81000000) {
+		ctrl.byte = 1;
+		ctrl.entries = 1 + ((*ctrl.insn & 0x00ff0000) >> 16);
+	} else {
+		pr_warning("unwind: Unsupported personality routine %08lx at %p\n",
+			   *ctrl.insn, ctrl.insn);
+		return -URC_FAILURE;
+	}
+
+	while (ctrl.entries > 0) {
+		int urc;
+
+		if (ctrl.vrs[SP] < low || ctrl.vrs[SP] >= high)
+			return -URC_FAILURE;
+		urc = unwind_exec_insn(&ctrl);
+		if (urc < 0)
+			return urc;
+	}
+
+	if (ctrl.vrs[PC] == 0)
+		ctrl.vrs[PC] = ctrl.vrs[LR];
+
+	frame->fp = ctrl.vrs[FP];
+	frame->sp = ctrl.vrs[SP];
+	frame->lr = ctrl.vrs[LR];
+	frame->pc = ctrl.vrs[PC];
+
+	return URC_OK;
+}
+
+void unwind_backtrace(struct pt_regs *regs, struct task_struct *tsk)
+{
+	struct stackframe frame;
+	unsigned long high, low;
+	register unsigned long current_sp asm ("sp");
+
+	pr_debug("%s(regs = %p tsk = %p)\n", __func__, regs, tsk);
+
+	if (!tsk)
+		tsk = current;
+
+	if (regs) {
+		frame.fp = regs->ARM_fp;
+		frame.sp = regs->ARM_sp;
+		frame.lr = regs->ARM_lr;
+		frame.pc = regs->ARM_pc;
+	} else if (tsk == current) {
+		frame.fp = (unsigned long)__builtin_frame_address(0);
+		frame.sp = current_sp;
+		frame.lr = (unsigned long)__builtin_return_address(0);
+		frame.pc = (unsigned long)unwind_backtrace;
+	} else {
+		/* task blocked in __switch_to */
+		frame.fp = thread_saved_fp(tsk);
+		frame.sp = thread_saved_sp(tsk);
+		/*
+		 * The function calling __switch_to cannot be a leaf function
+		 * so LR is recovered from the stack.
+		 */
+		frame.lr = 0;
+		frame.pc = thread_saved_pc(tsk);
+	}
+
+	low = frame.sp & ~(THREAD_SIZE - 1);
+	high = low + THREAD_SIZE;
+
+	while (1) {
+		int urc;
+		unsigned long where = frame.pc;
+
+		urc = unwind_frame(&frame);
+		if (urc < 0)
+			break;
+		dump_backtrace_entry(where, frame.pc, frame.sp - 4);
+	}
+}
+
+struct unwind_table *unwind_table_add(unsigned long start, unsigned long size,
+				      unsigned long text_addr,
+				      unsigned long text_size)
+{
+	unsigned long flags;
+	struct unwind_idx *idx;
+	struct unwind_table *tab = kmalloc(sizeof(*tab), GFP_KERNEL);
+
+	pr_debug("%s(%08lx, %08lx, %08lx, %08lx)\n", __func__, start, size,
+		 text_addr, text_size);
+
+	if (!tab)
+		return tab;
+
+	tab->start = (struct unwind_idx *)start;
+	tab->stop = (struct unwind_idx *)(start + size);
+	tab->begin_addr = text_addr;
+	tab->end_addr = text_addr + text_size;
+
+	/* Convert the symbol addresses to absolute values */
+	for (idx = tab->start; idx < tab->stop; idx++)
+		idx->addr = prel31_to_addr(&idx->addr);
+
+	spin_lock_irqsave(&unwind_lock, flags);
+	list_add_tail(&tab->list, &unwind_tables);
+	spin_unlock_irqrestore(&unwind_lock, flags);
+
+	return tab;
+}
+
+void unwind_table_del(struct unwind_table *tab)
+{
+	unsigned long flags;
+
+	if (!tab)
+		return;
+
+	spin_lock_irqsave(&unwind_lock, flags);
+	list_del(&tab->list);
+	spin_unlock_irqrestore(&unwind_lock, flags);
+
+	kfree(tab);
+}
+
+int __init unwind_init(void)
+{
+	struct unwind_idx *idx;
+
+	/* Convert the symbol addresses to absolute values */
+	for (idx = __start_unwind_idx; idx < __stop_unwind_idx; idx++)
+		idx->addr = prel31_to_addr(&idx->addr);
+
+	pr_debug("unwind: ARM stack unwinding initialised\n");
+
+	return 0;
+}
diff --git a/arch/arm/kernel/vmlinux.lds.S b/arch/arm/kernel/vmlinux.lds.S
index 4898bdc..5235417 100644
--- a/arch/arm/kernel/vmlinux.lds.S
+++ b/arch/arm/kernel/vmlinux.lds.S
@@ -80,6 +80,8 @@ SECTIONS
 		EXIT_TEXT
 		EXIT_DATA
 		*(.exitcall.exit)
+		*(.ARM.exidx.exit.text)
+		*(.ARM.extab.exit.text)
 #ifndef CONFIG_MMU
 		*(.fixup)
 		*(__ex_table)
@@ -110,6 +112,23 @@ SECTIONS
 
 	_etext = .;			/* End of text and rodata section */
 
+#ifdef CONFIG_ARM_UNWIND
+	/*
+	 * Stack unwinding tables
+	 */
+	. = ALIGN(8);
+	.ARM.unwind_idx : {
+		__start_unwind_idx = .;
+		*(.ARM.exidx*)
+		__stop_unwind_idx = .;
+	}
+	.ARM.unwind_tab : {
+		__start_unwind_tab = .;
+		*(.ARM.extab*)
+		__stop_unwind_tab = .;
+	}
+#endif
+
 #ifdef CONFIG_XIP_KERNEL
 	__data_loc = ALIGN(4);		/* location in binary */
 	. = PAGE_OFFSET + TEXT_OFFSET;
diff --git a/arch/arm/lib/ashldi3.S b/arch/arm/lib/ashldi3.S
index 1154d92..b18944b 100644
--- a/arch/arm/lib/ashldi3.S
+++ b/arch/arm/lib/ashldi3.S
@@ -41,9 +41,12 @@ ENTRY(__aeabi_llsl)
 
 	subs	r3, r2, #32
 	rsb	ip, r2, #32
+	itett	mi
 	movmi	ah, ah, lsl r2
 	movpl	ah, al, lsl r3
-	orrmi	ah, ah, al, lsr ip
+ ARM(	orrmi	ah, ah, al, lsr ip	)
+ THUMB(	lsrmi	r3, al, ip		)
+ THUMB(	orrmi	ah, ah, r3		)
 	mov	al, al, lsl r2
 	mov	pc, lr
 
diff --git a/arch/arm/lib/ashrdi3.S b/arch/arm/lib/ashrdi3.S
index 9f8b355..0d5ace7 100644
--- a/arch/arm/lib/ashrdi3.S
+++ b/arch/arm/lib/ashrdi3.S
@@ -41,9 +41,12 @@ ENTRY(__aeabi_lasr)
 
 	subs	r3, r2, #32
 	rsb	ip, r2, #32
+	itett	mi
 	movmi	al, al, lsr r2
 	movpl	al, ah, asr r3
-	orrmi	al, al, ah, lsl ip
+ ARM(	orrmi	al, al, ah, lsl ip	)
+ THUMB(	lslmi	r3, ah, ip		)
+ THUMB(	orrmi	al, al, r3		)
 	mov	ah, ah, asr r2
 	mov	pc, lr
 
diff --git a/arch/arm/lib/backtrace.S b/arch/arm/lib/backtrace.S
index b0951d0..42e62dd 100644
--- a/arch/arm/lib/backtrace.S
+++ b/arch/arm/lib/backtrace.S
@@ -38,7 +38,10 @@ ENDPROC(c_backtrace)
 		beq	no_frame		@ we have no stack frames
 
 		tst	r1, #0x10		@ 26 or 32-bit mode?
-		moveq	mask, #0xfc000003	@ mask for 26-bit
+		itte	eq
+ ARM(		moveq	mask, #0xfc000003	)
+ THUMB(		moveq	mask, #0xfc000000	)
+ THUMB(		orreq	mask, #0x03		)
 		movne	mask, #0		@ mask for 32-bit
 
 1:		stmfd	sp!, {pc}		@ calculate offset of PC stored
@@ -73,6 +76,7 @@ for_each_frame:	tst	frame, mask		@ Check for address exceptions
 1003:		ldr	r2, [sv_pc, #-4]	@ if stmfd sp!, {args} exists,
 		ldr	r3, .Ldsi+4		@ adjust saved 'pc' back one
 		teq	r3, r2, lsr #10		@ instruction
+		ite	ne
 		subne	r0, sv_pc, #4		@ allow for mov
 		subeq	r0, sv_pc, #8		@ allow for mov + stmia
 
@@ -84,6 +88,7 @@ for_each_frame:	tst	frame, mask		@ Check for address exceptions
 		ldr	r1, [sv_pc, #-4]	@ if stmfd sp!, {args} exists,
 		ldr	r3, .Ldsi+4
 		teq	r3, r1, lsr #10
+		ittt	eq
 		ldreq	r0, [frame, #-8]	@ get sp
 		subeq	r0, r0, #4		@ point at the last arg
 		bleq	.Ldumpstm		@ dump saved registers
@@ -91,6 +96,7 @@ for_each_frame:	tst	frame, mask		@ Check for address exceptions
 1004:		ldr	r1, [sv_pc, #0]		@ if stmfd sp!, {..., fp, ip, lr, pc}
 		ldr	r3, .Ldsi		@ instruction exists,
 		teq	r3, r1, lsr #10
+		itt	eq
 		subeq	r0, frame, #16
 		bleq	.Ldumpstm		@ dump saved registers
 
@@ -126,10 +132,13 @@ ENDPROC(c_backtrace)
 		mov	reg, #10
 		mov	r7, #0
 1:		mov	r3, #1
-		tst	instr, r3, lsl reg
+ ARM(		tst	instr, r3, lsl reg	)
+ THUMB(		lsl	r3, reg			)
+ THUMB(		tst	instr, r3		)
 		beq	2f
 		add	r7, r7, #1
 		teq	r7, #6
+		itte	eq
 		moveq	r7, #1
 		moveq	r1, #'\n'
 		movne	r1, #' '
@@ -140,6 +149,7 @@ ENDPROC(c_backtrace)
 2:		subs	reg, reg, #1
 		bpl	1b
 		teq	r7, #0
+		itt	ne
 		adrne	r0, .Lcr
 		blne	printk
 		ldmfd	sp!, {instr, reg, stack, r7, pc}
diff --git a/arch/arm/lib/bitops.h b/arch/arm/lib/bitops.h
index 2e787d4..28c7e4e 100644
--- a/arch/arm/lib/bitops.h
+++ b/arch/arm/lib/bitops.h
@@ -5,6 +5,13 @@
 	and	r3, r0, #7		@ Get bit offset
 	add	r1, r1, r0, lsr #3	@ Get byte offset
 	mov	r3, r2, lsl r3
+#ifdef CONFIG_ARM_ERRATA_351422
+	mrc     p15, 0, r0, c0, c0, 5
+	and	r0, r0, #0xf
+	mov	r0, r0, lsl #8
+3:	subs	r0, r0, #1
+	bpl	3b
+#endif
 1:	ldrexb	r2, [r1]
 	\instr	r2, r2, r3
 	strexb	r0, r2, [r1]
@@ -13,18 +20,29 @@
 	mov	pc, lr
 	.endm
 
-	.macro	testop, instr, store
+	.macro	testop, instr, store, cond=al
 	and	r3, r0, #7		@ Get bit offset
 	mov	r2, #1
 	add	r1, r1, r0, lsr #3	@ Get byte offset
 	mov	r3, r2, lsl r3		@ create mask
+#ifdef CONFIG_ARM_ERRATA_351422
+	mrc     p15, 0, r0, c0, c0, 5
+	and	r0, r0, #0xf
+	mov	r0, r0, lsl #8
+3:	subs	r0, r0, #1
+	bpl	3b
+#endif
 1:	ldrexb	r2, [r1]
 	ands	r0, r2, r3		@ save old value of bit
-	\instr	r2, r2, r3			@ toggle bit
+	.ifnc	\cond,al
+	it	\cond
+	.endif
+	\instr	r2, r2, r3		@ toggle bit
 	strexb	ip, r2, [r1]
 	cmp	ip, #0
 	bne	1b
 	cmp	r0, #0
+	it	ne
 	movne	r0, #1
 2:	mov	pc, lr
 	.endm
@@ -49,7 +67,7 @@
  * Note: we can trivially conditionalise the store instruction
  * to avoid dirtying the data cache.
  */
-	.macro	testop, instr, store
+	.macro	testop, instr, store, cond=al
 	add	r1, r1, r0, lsr #3
 	and	r3, r0, #7
 	mov	r0, #1
diff --git a/arch/arm/lib/clear_user.S b/arch/arm/lib/clear_user.S
index 4d6bc71..2147bec 100644
--- a/arch/arm/lib/clear_user.S
+++ b/arch/arm/lib/clear_user.S
@@ -26,21 +26,20 @@ ENTRY(__clear_user)
 		ands	ip, r0, #3
 		beq	1f
 		cmp	ip, #2
-USER(		strbt	r2, [r0], #1)
-USER(		strlebt	r2, [r0], #1)
-USER(		strltbt	r2, [r0], #1)
+		strusr	r2, r0, 1
+		strusr	r2, r0, 1, le
+		strusr	r2, r0, 1, lt
 		rsb	ip, ip, #4
 		sub	r1, r1, ip		@  7  6  5  4  3  2  1
 1:		subs	r1, r1, #8		@ -1 -2 -3 -4 -5 -6 -7
-USER(		strplt	r2, [r0], #4)
-USER(		strplt	r2, [r0], #4)
+		strusr	r2, r0, 4, pl, rept=2
 		bpl	1b
 		adds	r1, r1, #4		@  3  2  1  0 -1 -2 -3
-USER(		strplt	r2, [r0], #4)
+		strusr	r2, r0, 4, pl
 2:		tst	r1, #2			@ 1x 1x 0x 0x 1x 1x 0x
-USER(		strnebt	r2, [r0], #1)
-USER(		strnebt	r2, [r0], #1)
+		strusr	r2, r0, 1, ne, rept=2
 		tst	r1, #1			@ x1 x0 x1 x0 x1 x0 x1
+		it	ne			@ explicit IT needed for the label
 USER(		strnebt	r2, [r0])
 		mov	r0, #0
 		ldmfd	sp!, {r1, pc}
diff --git a/arch/arm/lib/copy_from_user.S b/arch/arm/lib/copy_from_user.S
index 56799a1..9a7a164 100644
--- a/arch/arm/lib/copy_from_user.S
+++ b/arch/arm/lib/copy_from_user.S
@@ -33,11 +33,15 @@
  *	Number of bytes NOT copied.
  */
 
+#ifndef CONFIG_THUMB2_KERNEL
+#define LDR1W_SHIFT	0
+#else
+#define LDR1W_SHIFT	1
+#endif
+#define STR1W_SHIFT	0
+
 	.macro ldr1w ptr reg abort
-100:	ldrt \reg, [\ptr], #4
-	.section __ex_table, "a"
-	.long 100b, \abort
-	.previous
+	ldrusr	\reg, \ptr, 4, abort=\abort
 	.endm
 
 	.macro ldr4w ptr reg1 reg2 reg3 reg4 abort
@@ -53,14 +57,11 @@
 	.endm
 
 	.macro ldr1b ptr reg cond=al abort
-100:	ldr\cond\()bt \reg, [\ptr], #1
-	.section __ex_table, "a"
-	.long 100b, \abort
-	.previous
+	ldrusr	\reg, \ptr, 1, \cond, abort=\abort
 	.endm
 
 	.macro str1w ptr reg abort
-	str \reg, [\ptr], #4
+	W(str) \reg, [\ptr], #4
 	.endm
 
 	.macro str8w ptr reg1 reg2 reg3 reg4 reg5 reg6 reg7 reg8 abort
@@ -68,6 +69,9 @@
 	.endm
 
 	.macro str1b ptr reg cond=al abort
+	.ifnc \cond,al
+	it \cond
+	.endif
 	str\cond\()b \reg, [\ptr], #1
 	.endm
 
diff --git a/arch/arm/lib/copy_page.S b/arch/arm/lib/copy_page.S
index 6ae04db..1c57a03 100644
--- a/arch/arm/lib/copy_page.S
+++ b/arch/arm/lib/copy_page.S
@@ -39,8 +39,10 @@ ENTRY(copy_page)
 		ldmia	r1!, {r3, r4, ip, lr}		@	4
 		subs	r2, r2, #1			@	1
 		stmia	r0!, {r3, r4, ip, lr}		@	4
+		itt	gt
 		ldmgtia	r1!, {r3, r4, ip, lr}		@	4
 		bgt	1b				@	1
+	PLD(	itt	eq			)
 	PLD(	ldmeqia r1!, {r3, r4, ip, lr}	)
 	PLD(	beq	2b			)
 		ldmfd	sp!, {r4, pc}			@	3
diff --git a/arch/arm/lib/copy_template.S b/arch/arm/lib/copy_template.S
index 139cce6..8e8fc03 100644
--- a/arch/arm/lib/copy_template.S
+++ b/arch/arm/lib/copy_template.S
@@ -57,6 +57,13 @@
  *
  *	Restore registers with the values previously saved with the
  *	'preserv' macro. Called upon code termination.
+ *
+ * LDR1W_SHIFT
+ * STR1W_SHIFT
+ *
+ *	Correction to be applied to the "ip" register when branching into
+ *	the ldr1w or str1w instructions (some of these macros may expand to
+ *	than one 32bit instruction in Thumb-2)
  */
 
 
@@ -99,9 +106,16 @@
 
 5:		ands	ip, r2, #28
 		rsb	ip, ip, #32
+#if LDR1W_SHIFT > 0
+		lsl	ip, ip, #LDR1W_SHIFT
+#endif
+		it	ne
 		addne	pc, pc, ip		@ C is always clear here
 		b	7f
-6:		nop
+6:
+		.rept	(1 << LDR1W_SHIFT)
+		W(nop)
+		.endr
 		ldr1w	r1, r3, abort=20f
 		ldr1w	r1, r4, abort=20f
 		ldr1w	r1, r5, abort=20f
@@ -110,9 +124,16 @@
 		ldr1w	r1, r8, abort=20f
 		ldr1w	r1, lr, abort=20f
 
+#if LDR1W_SHIFT < STR1W_SHIFT
+		lsl	ip, ip, #STR1W_SHIFT - LDR1W_SHIFT
+#elif LDR1W_SHIFT > STR1W_SHIFT
+		lsr	ip, ip, #LDR1W_SHIFT - STR1W_SHIFT
+#endif
 		add	pc, pc, ip
 		nop
-		nop
+		.rept	(1 << STR1W_SHIFT)
+		W(nop)
+		.endr
 		str1w	r0, r3, abort=20f
 		str1w	r0, r4, abort=20f
 		str1w	r0, r5, abort=20f
diff --git a/arch/arm/lib/copy_to_user.S b/arch/arm/lib/copy_to_user.S
index 22f968b..dc0fe73 100644
--- a/arch/arm/lib/copy_to_user.S
+++ b/arch/arm/lib/copy_to_user.S
@@ -33,8 +33,15 @@
  *	Number of bytes NOT copied.
  */
 
+#define LDR1W_SHIFT	0
+#ifndef CONFIG_THUMB2_KERNEL
+#define STR1W_SHIFT	0
+#else
+#define STR1W_SHIFT	1
+#endif
+
 	.macro ldr1w ptr reg abort
-	ldr \reg, [\ptr], #4
+	W(ldr) \reg, [\ptr], #4
 	.endm
 
 	.macro ldr4w ptr reg1 reg2 reg3 reg4 abort
@@ -46,14 +53,14 @@
 	.endm
 
 	.macro ldr1b ptr reg cond=al abort
+	.ifnc \cond,al
+	it \cond
+	.endif
 	ldr\cond\()b \reg, [\ptr], #1
 	.endm
 
 	.macro str1w ptr reg abort
-100:	strt \reg, [\ptr], #4
-	.section __ex_table, "a"
-	.long 100b, \abort
-	.previous
+	strusr	\reg, \ptr, 4, abort=\abort
 	.endm
 
 	.macro str8w ptr reg1 reg2 reg3 reg4 reg5 reg6 reg7 reg8 abort
@@ -68,10 +75,7 @@
 	.endm
 
 	.macro str1b ptr reg cond=al abort
-100:	str\cond\()bt \reg, [\ptr], #1
-	.section __ex_table, "a"
-	.long 100b, \abort
-	.previous
+	strusr	\reg, \ptr, 1, \cond, abort=\abort
 	.endm
 
 	.macro enter reg1 reg2
diff --git a/arch/arm/lib/csumpartial.S b/arch/arm/lib/csumpartial.S
index 31d3cb3..e9a504e 100644
--- a/arch/arm/lib/csumpartial.S
+++ b/arch/arm/lib/csumpartial.S
@@ -39,6 +39,7 @@ td3	.req	lr
 
 		/* we must have at least one byte. */
 		tst	buf, #1			@ odd address?
+		itttt	ne
 		movne	sum, sum, ror #8
 		ldrneb	td0, [buf], #1
 		subne	len, len, #1
@@ -68,25 +69,30 @@ td3	.req	lr
 		bne	.Lless8_wordlp
 
 .Lless8_byte:	tst	len, #1			@ odd number of bytes
+		itt	ne
 		ldrneb	td0, [buf], #1		@ include last byte
 		adcnes	sum, sum, td0, put_byte_0	@ update checksum
 
 .Ldone:		adc	r0, sum, #0		@ collect up the last carry
 		ldr	td0, [sp], #4
 		tst	td0, #1			@ check buffer alignment
+		it	ne
 		movne	r0, r0, ror #8		@ rotate checksum by 8 bits
 		ldr	pc, [sp], #4		@ return
 
 .Lnot_aligned:	tst	buf, #1			@ odd address
+		ittt	ne
 		ldrneb	td0, [buf], #1		@ make even
 		subne	len, len, #1
 		adcnes	sum, sum, td0, put_byte_1	@ update checksum
 
 		tst	buf, #2			@ 32-bit aligned?
 #if __LINUX_ARM_ARCH__ >= 4
+		itt	ne
 		ldrneh	td0, [buf], #2		@ make 32-bit aligned
 		subne	len, len, #2
 #else
+		itttt	ne
 		ldrneb	td0, [buf], #1
 		ldrneb	ip, [buf], #1
 		subne	len, len, #2
@@ -96,6 +102,7 @@ td3	.req	lr
 		orrne	td0, ip, td0, lsl #8
 #endif
 #endif
+		it	ne
 		adcnes	sum, sum, td0		@ update checksum
 		mov	pc, lr
 
@@ -105,10 +112,12 @@ ENTRY(csum_partial)
 		blo	.Lless8			@ 8 bytes to copy.
 
 		tst	buf, #1
+		it	ne
 		movne	sum, sum, ror #8
 
 		adds	sum, sum, #0		@ C = 0
 		tst	buf, #3			@ Test destination alignment
+		it	ne
 		blne	.Lnot_aligned		@ align destination, return here
 
 1:		bics	ip, len, #31
diff --git a/arch/arm/lib/csumpartialcopygeneric.S b/arch/arm/lib/csumpartialcopygeneric.S
index d620a5f..8e1c141 100644
--- a/arch/arm/lib/csumpartialcopygeneric.S
+++ b/arch/arm/lib/csumpartialcopygeneric.S
@@ -40,6 +40,7 @@ sum	.req	r3
 		adcs	sum, sum, ip, put_byte_1	@ update checksum
 		strb	ip, [dst], #1
 		tst	dst, #2
+		it	eq
 		moveq	pc, lr			@ dst is now 32bit aligned
 
 .Ldst_16bit:	load2b	r8, ip
@@ -94,6 +95,7 @@ FN_ENTRY
 
 		adds	sum, sum, #0		@ C = 0
 		tst	dst, #3			@ Test destination alignment
+		it	ne
 		blne	.Ldst_unaligned		@ align destination, return here
 
 		/*
@@ -147,6 +149,7 @@ FN_ENTRY
 		strb	r5, [dst], #1
 		mov	r5, r4, get_byte_2
 .Lexit:		tst	len, #1
+		ittt	ne
 		strneb	r5, [dst], #1
 		andne	r5, r5, #255
 		adcnes	sum, sum, r5, put_byte_0
@@ -160,6 +163,7 @@ FN_ENTRY
 .Ldone:		adc	r0, sum, #0
 		ldr	sum, [sp, #0]		@ dst
 		tst	sum, #1
+		it	ne
 		movne	r0, r0, ror #8
 		load_regs
 
diff --git a/arch/arm/lib/csumpartialcopyuser.S b/arch/arm/lib/csumpartialcopyuser.S
index 14677fb..152ed83 100644
--- a/arch/arm/lib/csumpartialcopyuser.S
+++ b/arch/arm/lib/csumpartialcopyuser.S
@@ -26,50 +26,28 @@
 		.endm
 
 		.macro	load1b,	reg1
-9999:		ldrbt	\reg1, [r0], $1
-		.section __ex_table, "a"
-		.align	3
-		.long	9999b, 6001f
-		.previous
+		ldrusr	\reg1, r0, 1
 		.endm
 
 		.macro	load2b, reg1, reg2
-9999:		ldrbt	\reg1, [r0], $1
-9998:		ldrbt	\reg2, [r0], $1
-		.section __ex_table, "a"
-		.long	9999b, 6001f
-		.long	9998b, 6001f
-		.previous
+		ldrusr	\reg1, r0, 1
+		ldrusr	\reg2, r0, 1
 		.endm
 
 		.macro	load1l, reg1
-9999:		ldrt	\reg1, [r0], $4
-		.section __ex_table, "a"
-		.align	3
-		.long	9999b, 6001f
-		.previous
+		ldrusr	\reg1, r0, 4
 		.endm
 
 		.macro	load2l, reg1, reg2
-9999:		ldrt	\reg1, [r0], $4
-9998:		ldrt	\reg2, [r0], $4
-		.section __ex_table, "a"
-		.long	9999b, 6001f
-		.long	9998b, 6001f
-		.previous
+		ldrusr	\reg1, r0, 4
+		ldrusr	\reg2, r0, 4
 		.endm
 
 		.macro	load4l, reg1, reg2, reg3, reg4
-9999:		ldrt	\reg1, [r0], $4
-9998:		ldrt	\reg2, [r0], $4
-9997:		ldrt	\reg3, [r0], $4
-9996:		ldrt	\reg4, [r0], $4
-		.section __ex_table, "a"
-		.long	9999b, 6001f
-		.long	9998b, 6001f
-		.long	9997b, 6001f
-		.long	9996b, 6001f
-		.previous
+		ldrusr	\reg1, r0, 4
+		ldrusr	\reg2, r0, 4
+		ldrusr	\reg3, r0, 4
+		ldrusr	\reg4, r0, 4
 		.endm
 
 /*
@@ -92,14 +70,15 @@
  */
 		.section .fixup,"ax"
 		.align	4
-6001:		mov	r4, #-EFAULT
+9001:		mov	r4, #-EFAULT
 		ldr	r5, [fp, #4]		@ *err_ptr
 		str	r4, [r5]
 		ldmia	sp, {r1, r2}		@ retrieve dst, len
 		add	r2, r2, r1
 		mov	r0, #0			@ zero the buffer
-6002:		teq	r2, r1
+9002:		teq	r2, r1
+		it	ne
 		strneb	r0, [r1], #1
-		bne	6002b
+		bne	9002b
 		load_regs
 		.previous
diff --git a/arch/arm/lib/delay.S b/arch/arm/lib/delay.S
index 8d6a876..fcd87ff 100644
--- a/arch/arm/lib/delay.S
+++ b/arch/arm/lib/delay.S
@@ -31,6 +31,7 @@ ENTRY(__const_udelay)				@ 0 <= r0 <= 0x7fffff06
 		mov	r2, r2, lsr #10		@ max = 0x00007fff
 		mul	r0, r2, r0		@ max = 2^32-1
 		movs	r0, r0, lsr #6
+		it	eq
 		moveq	pc, lr
 
 /*
@@ -58,6 +59,7 @@ ENTRY(__delay)
 		movls	pc, lr
 		subs	r0, r0, #1
 #endif
+		it	hi
 		bhi	__delay
 		mov	pc, lr
 ENDPROC(__udelay)
diff --git a/arch/arm/lib/div64.S b/arch/arm/lib/div64.S
index 1425e78..d02268a 100644
--- a/arch/arm/lib/div64.S
+++ b/arch/arm/lib/div64.S
@@ -84,8 +84,10 @@ ENTRY(__do_div64)
 	@ The division loop for needed upper bit positions.
  	@ Break out early if dividend reaches 0.
 2:	cmp	xh, yl
+	itt	cs
 	orrcs	yh, yh, ip
 	subcss	xh, xh, yl
+	it	ne
 	movnes	ip, ip, lsr #1
 	mov	yl, yl, lsr #1
 	bne	2b
@@ -93,7 +95,9 @@ ENTRY(__do_div64)
 	@ See if we need to handle lower 32-bit result.
 3:	cmp	xh, #0
 	mov	yl, #0
+	it	eq
 	cmpeq	xl, r4
+	itt	lo
 	movlo	xh, xl
 	movlo	pc, lr
 
@@ -104,7 +108,9 @@ ENTRY(__do_div64)
 4:	movs	xl, xl, lsl #1
 	adcs	xh, xh, xh
 	beq	6f
+	it	cc
 	cmpcc	xh, r4
+	itt	cs
 5:	orrcs	yl, yl, ip
 	subcs	xh, xh, r4
 	movs	ip, ip, lsr #1
@@ -116,6 +122,7 @@ ENTRY(__do_div64)
 	@ Otherwise, if lower part is also null then we are done.
 6:	bcs	5b
 	cmp	xl, #0
+	it	eq
 	moveq	pc, lr
 
 	@ We still have remainer bits in the low part.  Bring them up.
@@ -177,13 +184,16 @@ ENTRY(__do_div64)
 	mov	yh, xh, lsr ip
 	mov	yl, xl, lsr ip
 	rsb	ip, ip, #32
-	orr	yl, yl, xh, lsl ip
+ ARM(	orr	yl, yl, xh, lsl ip	)
+ THUMB(	lsl	xh, xh, ip		)
+ THUMB(	orr	yl, yl, xh		)
 	mov	xh, xl, lsl ip
 	mov	xh, xh, lsr ip
 	mov	pc, lr
 
 	@ eq -> division by 1: obvious enough...
-9:	moveq	yl, xl
+9:	itttt	eq
+	moveq	yl, xl
 	moveq	yh, xh
 	moveq	xh, #0
 	moveq	pc, lr
diff --git a/arch/arm/lib/findbit.S b/arch/arm/lib/findbit.S
index 8c4defc..1e4cbd4 100644
--- a/arch/arm/lib/findbit.S
+++ b/arch/arm/lib/findbit.S
@@ -25,7 +25,10 @@ ENTRY(_find_first_zero_bit_le)
 		teq	r1, #0	
 		beq	3f
 		mov	r2, #0
-1:		ldrb	r3, [r0, r2, lsr #3]
+1:
+ ARM(		ldrb	r3, [r0, r2, lsr #3]	)
+ THUMB(		lsr	r3, r2, #3		)
+ THUMB(		ldrb	r3, [r0, r3]		)
 		eors	r3, r3, #0xff		@ invert bits
 		bne	.L_found		@ any now set - found zero bit
 		add	r2, r2, #8		@ next bit pointer
@@ -44,7 +47,9 @@ ENTRY(_find_next_zero_bit_le)
 		beq	3b
 		ands	ip, r2, #7
 		beq	1b			@ If new byte, goto old routine
-		ldrb	r3, [r0, r2, lsr #3]
+ ARM(		ldrb	r3, [r0, r2, lsr #3]	)
+ THUMB(		lsr	r3, r2, #3		)
+ THUMB(		ldrb	r3, [r0, r3]		)
 		eor	r3, r3, #0xff		@ now looking for a 1 bit
 		movs	r3, r3, lsr ip		@ shift off unused bits
 		bne	.L_found
@@ -61,7 +66,10 @@ ENTRY(_find_first_bit_le)
 		teq	r1, #0	
 		beq	3f
 		mov	r2, #0
-1:		ldrb	r3, [r0, r2, lsr #3]
+1:
+ ARM(		ldrb	r3, [r0, r2, lsr #3]	)
+ THUMB(		lsr	r3, r2, #3		)
+ THUMB(		ldrb	r3, [r0, r3]		)
 		movs	r3, r3
 		bne	.L_found		@ any now set - found zero bit
 		add	r2, r2, #8		@ next bit pointer
@@ -80,7 +88,9 @@ ENTRY(_find_next_bit_le)
 		beq	3b
 		ands	ip, r2, #7
 		beq	1b			@ If new byte, goto old routine
-		ldrb	r3, [r0, r2, lsr #3]
+ ARM(		ldrb	r3, [r0, r2, lsr #3]	)
+ THUMB(		lsr	r3, r2, #3		)
+ THUMB(		ldrb	r3, [r0, r3]		)
 		movs	r3, r3, lsr ip		@ shift off unused bits
 		bne	.L_found
 		orr	r2, r2, #7		@ if zero, then no bits here
@@ -95,7 +105,9 @@ ENTRY(_find_first_zero_bit_be)
 		beq	3f
 		mov	r2, #0
 1:		eor	r3, r2, #0x18		@ big endian byte ordering
-		ldrb	r3, [r0, r3, lsr #3]
+ ARM(		ldrb	r3, [r0, r3, lsr #3]	)
+ THUMB(		lsr	r3, #3			)
+ THUMB(		ldrb	r3, [r0, r3]		)
 		eors	r3, r3, #0xff		@ invert bits
 		bne	.L_found		@ any now set - found zero bit
 		add	r2, r2, #8		@ next bit pointer
@@ -111,7 +123,9 @@ ENTRY(_find_next_zero_bit_be)
 		ands	ip, r2, #7
 		beq	1b			@ If new byte, goto old routine
 		eor	r3, r2, #0x18		@ big endian byte ordering
-		ldrb	r3, [r0, r3, lsr #3]
+ ARM(		ldrb	r3, [r0, r3, lsr #3]	)
+ THUMB(		lsr	r3, #3			)
+ THUMB(		ldrb	r3, [r0, r3]		)
 		eor	r3, r3, #0xff		@ now looking for a 1 bit
 		movs	r3, r3, lsr ip		@ shift off unused bits
 		bne	.L_found
@@ -125,7 +139,9 @@ ENTRY(_find_first_bit_be)
 		beq	3f
 		mov	r2, #0
 1:		eor	r3, r2, #0x18		@ big endian byte ordering
-		ldrb	r3, [r0, r3, lsr #3]
+ ARM(		ldrb	r3, [r0, r3, lsr #3]	)
+ THUMB(		lsr	r3, #3			)
+ THUMB(		ldrb	r3, [r0, r3]		)
 		movs	r3, r3
 		bne	.L_found		@ any now set - found zero bit
 		add	r2, r2, #8		@ next bit pointer
@@ -141,7 +157,9 @@ ENTRY(_find_next_bit_be)
 		ands	ip, r2, #7
 		beq	1b			@ If new byte, goto old routine
 		eor	r3, r2, #0x18		@ big endian byte ordering
-		ldrb	r3, [r0, r3, lsr #3]
+ ARM(		ldrb	r3, [r0, r3, lsr #3]	)
+ THUMB(		lsr	r3, #3			)
+ THUMB(		ldrb	r3, [r0, r3]		)
 		movs	r3, r3, lsr ip		@ shift off unused bits
 		bne	.L_found
 		orr	r2, r2, #7		@ if zero, then no bits here
diff --git a/arch/arm/lib/getuser.S b/arch/arm/lib/getuser.S
index 6763088..3e1b980 100644
--- a/arch/arm/lib/getuser.S
+++ b/arch/arm/lib/getuser.S
@@ -36,7 +36,10 @@ ENTRY(__get_user_1)
 ENDPROC(__get_user_1)
 
 ENTRY(__get_user_2)
-2:	ldrbt	r2, [r0], #1
+2:
+ ARM(	ldrbt	r2, [r0], #1	)
+ THUMB(	ldrbt	r2, [r0]	)
+ THUMB(	add	r0, #1		)
 3:	ldrbt	r3, [r0]
 #ifndef __ARMEB__
 	orr	r2, r2, r3, lsl #8
diff --git a/arch/arm/lib/io-readsb.S b/arch/arm/lib/io-readsb.S
index 9f42389..45229e4 100644
--- a/arch/arm/lib/io-readsb.S
+++ b/arch/arm/lib/io-readsb.S
@@ -12,12 +12,15 @@
 
 .Linsb_align:	rsb	ip, ip, #4
 		cmp	ip, r2
+		it	gt
 		movgt	ip, r2
 		cmp	ip, #2
 		ldrb	r3, [r0]
 		strb	r3, [r1], #1
+		itt	ge
 		ldrgeb	r3, [r0]
 		strgeb	r3, [r1], #1
+		itt	gt
 		ldrgtb	r3, [r0]
 		strgtb	r3, [r1], #1
 		subs	r2, r2, ip
@@ -25,6 +28,7 @@
 
 ENTRY(__raw_readsb)
 		teq	r2, #0		@ do we have to check for the zero len?
+		it	eq
 		moveq	pc, lr
 		ands	ip, r1, #3
 		bne	.Linsb_align
@@ -72,6 +76,7 @@ ENTRY(__raw_readsb)
 		bpl	.Linsb_16_lp
 
 		tst	r2, #15
+		it	eq
 		ldmeqfd	sp!, {r4 - r6, pc}
 
 .Linsb_no_16:	tst	r2, #8
@@ -109,13 +114,16 @@ ENTRY(__raw_readsb)
 		str	r3, [r1], #4
 
 .Linsb_no_4:	ands	r2, r2, #3
+		it	eq
 		ldmeqfd	sp!, {r4 - r6, pc}
 
 		cmp	r2, #2
 		ldrb	r3, [r0]
 		strb	r3, [r1], #1
+		itt	ge
 		ldrgeb	r3, [r0]
 		strgeb	r3, [r1], #1
+		itt	gt
 		ldrgtb	r3, [r0]
 		strgtb	r3, [r1]
 
diff --git a/arch/arm/lib/io-readsl.S b/arch/arm/lib/io-readsl.S
index 5fb97e7..1f02e66 100644
--- a/arch/arm/lib/io-readsl.S
+++ b/arch/arm/lib/io-readsl.S
@@ -12,6 +12,7 @@
 
 ENTRY(__raw_readsl)
 		teq	r2, #0		@ do we have to check for the zero len?
+		it	eq
 		moveq	pc, lr
 		ands	ip, r1, #3
 		bne	3f
@@ -28,9 +29,11 @@ ENTRY(__raw_readsl)
 		bpl	1b
 		ldmfd	sp!, {r4, lr}
 2:		movs	r2, r2, lsl #31
+		ittt	cs
 		ldrcs	r3, [r0, #0]
 		ldrcs	ip, [r0, #0]
 		stmcsia	r1!, {r3, ip}
+		itt	ne
 		ldrne	r3, [r0, #0]
 		strne	r3, [r1, #0]
 		mov	pc, lr
@@ -48,6 +51,7 @@ ENTRY(__raw_readsl)
 
 4:		subs	r2, r2, #1
 		mov	ip, r3, pull #24
+		itttt	ne
 		ldrne	r3, [r0]
 		orrne	ip, ip, r3, push #8
 		strne	ip, [r1], #4
@@ -56,6 +60,7 @@ ENTRY(__raw_readsl)
 
 5:		subs	r2, r2, #1
 		mov	ip, r3, pull #16
+		itttt	ne
 		ldrne	r3, [r0]
 		orrne	ip, ip, r3, push #16
 		strne	ip, [r1], #4
@@ -64,6 +69,7 @@ ENTRY(__raw_readsl)
 
 6:		subs	r2, r2, #1
 		mov	ip, r3, pull #8
+		itttt	ne
 		ldrne	r3, [r0]
 		orrne	ip, ip, r3, push #24
 		strne	ip, [r1], #4
diff --git a/arch/arm/lib/io-readsw-armv4.S b/arch/arm/lib/io-readsw-armv4.S
index 1f393d4..9db32f0 100644
--- a/arch/arm/lib/io-readsw-armv4.S
+++ b/arch/arm/lib/io-readsw-armv4.S
@@ -26,6 +26,7 @@
 
 ENTRY(__raw_readsw)
 		teq	r2, #0
+		it	eq
 		moveq	pc, lr
 		tst	r1, #3
 		bne	.Linsw_align
@@ -76,7 +77,8 @@ ENTRY(__raw_readsw)
 		pack	r3, r3, ip
 		str	r3, [r1], #4
 
-.Lno_insw_2:	ldrneh	r3, [r0]
+.Lno_insw_2:	itt	ne
+		ldrneh	r3, [r0]
 		strneh	r3, [r1]
 
 		ldmfd	sp!, {r4, r5, pc}
@@ -94,6 +96,7 @@ ENTRY(__raw_readsw)
 #endif
 
 .Linsw_noalign:	stmfd	sp!, {r4, lr}
+		it	cc
 		ldrccb	ip, [r1, #-1]!
 		bcc	1f
 
@@ -121,6 +124,7 @@ ENTRY(__raw_readsw)
 
 3:		tst	r2, #1
 		strb	ip, [r1], #1
+		itttt	ne
 		ldrneh	ip, [r0]
    _BE_ONLY_(	movne	ip, ip, ror #8		)
 		strneb	ip, [r1], #1
diff --git a/arch/arm/lib/io-writesb.S b/arch/arm/lib/io-writesb.S
index 68b92f4..5fad6b0 100644
--- a/arch/arm/lib/io-writesb.S
+++ b/arch/arm/lib/io-writesb.S
@@ -32,12 +32,15 @@
 
 .Loutsb_align:	rsb	ip, ip, #4
 		cmp	ip, r2
+		it	gt
 		movgt	ip, r2
 		cmp	ip, #2
 		ldrb	r3, [r1], #1
 		strb	r3, [r0]
+		itt	ge
 		ldrgeb	r3, [r1], #1
 		strgeb	r3, [r0]
+		itt	gt
 		ldrgtb	r3, [r1], #1
 		strgtb	r3, [r0]
 		subs	r2, r2, ip
@@ -45,6 +48,7 @@
 
 ENTRY(__raw_writesb)
 		teq	r2, #0		@ do we have to check for the zero len?
+		it	eq
 		moveq	pc, lr
 		ands	ip, r1, #3
 		bne	.Loutsb_align
@@ -64,6 +68,7 @@ ENTRY(__raw_writesb)
 		bpl	.Loutsb_16_lp
 
 		tst	r2, #15
+		it	eq
 		ldmeqfd	sp!, {r4, r5, pc}
 
 .Loutsb_no_16:	tst	r2, #8
@@ -80,13 +85,16 @@ ENTRY(__raw_writesb)
 		outword	r3
 
 .Loutsb_no_4:	ands	r2, r2, #3
+		it	eq
 		ldmeqfd	sp!, {r4, r5, pc}
 
 		cmp	r2, #2
 		ldrb	r3, [r1], #1
 		strb	r3, [r0]
+		itt	ge
 		ldrgeb	r3, [r1], #1
 		strgeb	r3, [r0]
+		itt	gt
 		ldrgtb	r3, [r1]
 		strgtb	r3, [r0]
 
diff --git a/arch/arm/lib/io-writesl.S b/arch/arm/lib/io-writesl.S
index 8d3b781..ced1d91 100644
--- a/arch/arm/lib/io-writesl.S
+++ b/arch/arm/lib/io-writesl.S
@@ -12,6 +12,7 @@
 
 ENTRY(__raw_writesl)
 		teq	r2, #0		@ do we have to check for the zero len?
+		it	eq
 		moveq	pc, lr
 		ands	ip, r1, #3
 		bne	3f
@@ -28,10 +29,14 @@ ENTRY(__raw_writesl)
 		bpl	1b
 		ldmfd	sp!, {r4, lr}
 2:		movs	r2, r2, lsl #31
+		itt	cs
 		ldmcsia	r1!, {r3, ip}
 		strcs	r3, [r0, #0]
+		it	ne
 		ldrne	r3, [r1, #0]
+		it	cs
 		strcs	ip, [r0, #0]
+		it	ne
 		strne	r3, [r0, #0]
 		mov	pc, lr
 
diff --git a/arch/arm/lib/io-writesw-armv4.S b/arch/arm/lib/io-writesw-armv4.S
index d658561..bb85303 100644
--- a/arch/arm/lib/io-writesw-armv4.S
+++ b/arch/arm/lib/io-writesw-armv4.S
@@ -31,6 +31,7 @@
 
 ENTRY(__raw_writesw)
 		teq	r2, #0
+		it	eq
 		moveq	pc, lr
 		ands	r3, r1, #3
 		bne	.Loutsw_align
@@ -61,7 +62,8 @@ ENTRY(__raw_writesw)
 		ldr	r3, [r1], #4
 		outword	r3
 
-.Lno_outsw_2:	ldrneh	r3, [r1]
+.Lno_outsw_2:	itt	ne
+		ldrneh	r3, [r1]
 		strneh	r3, [r0]
 
 		ldmfd	sp!, {r4, r5, pc}
@@ -75,7 +77,11 @@ ENTRY(__raw_writesw)
 #endif
 
 .Loutsw_noalign:
-		ldr	r3, [r1, -r3]!
+ ARM(		ldr	r3, [r1, -r3]!	)
+ THUMB(		rsb	r3, r3, #0	)
+ THUMB(		ldr	r3, [r1, r3]	)
+ THUMB(		sub	r1, r3		)
+		it	cs
 		subcs	r2, r2, #1
 		bcs	2f
 		subs	r2, r2, #2
@@ -91,7 +97,8 @@ ENTRY(__raw_writesw)
 		bpl	1b
 
 		tst	r2, #1
-3:		movne	ip, r3, lsr #8
+3:		itt	ne
+		movne	ip, r3, lsr #8
 		strneh	ip, [r0]
 		mov	pc, lr
 ENDPROC(__raw_writesw)
diff --git a/arch/arm/lib/lib1funcs.S b/arch/arm/lib/lib1funcs.S
index 67964bc..1eb73e7 100644
--- a/arch/arm/lib/lib1funcs.S
+++ b/arch/arm/lib/lib1funcs.S
@@ -56,6 +56,7 @@ Boston, MA 02111-1307, USA.  */
 	@ at the left end of each 4 bit nibbles in the division loop
 	@ to save one loop in most cases.
 	tst	\divisor, #0xe0000000
+	itte	eq
 	moveq	\divisor, \divisor, lsl #3
 	moveq	\curbit, #8
 	movne	\curbit, #1
@@ -65,6 +66,7 @@ Boston, MA 02111-1307, USA.  */
 	@ division loop.  Continue shifting until the divisor is 
 	@ larger than the dividend.
 1:	cmp	\divisor, #0x10000000
+	ittt	lo
 	cmplo	\divisor, \dividend
 	movlo	\divisor, \divisor, lsl #4
 	movlo	\curbit, \curbit, lsl #4
@@ -73,6 +75,7 @@ Boston, MA 02111-1307, USA.  */
 	@ For very big divisors, we must shift it a bit at a time, or
 	@ we will be in danger of overflowing.
 1:	cmp	\divisor, #0x80000000
+	ittt	lo
 	cmplo	\divisor, \dividend
 	movlo	\divisor, \divisor, lsl #1
 	movlo	\curbit, \curbit, lsl #1
@@ -84,19 +87,25 @@ Boston, MA 02111-1307, USA.  */
 
 	@ Division loop
 1:	cmp	\dividend, \divisor
+	itt	hs
 	subhs	\dividend, \dividend, \divisor
 	orrhs	\result,   \result,   \curbit
 	cmp	\dividend, \divisor,  lsr #1
+	itt	hs
 	subhs	\dividend, \dividend, \divisor, lsr #1
 	orrhs	\result,   \result,   \curbit,  lsr #1
 	cmp	\dividend, \divisor,  lsr #2
+	itt	hs
 	subhs	\dividend, \dividend, \divisor, lsr #2
 	orrhs	\result,   \result,   \curbit,  lsr #2
 	cmp	\dividend, \divisor,  lsr #3
+	itt	hs
 	subhs	\dividend, \dividend, \divisor, lsr #3
 	orrhs	\result,   \result,   \curbit,  lsr #3
 	cmp	\dividend, #0			@ Early termination?
+	it	ne
 	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
+	it	ne
 	movne	\divisor,  \divisor, lsr #4
 	bne	1b
 
@@ -113,19 +122,24 @@ Boston, MA 02111-1307, USA.  */
 #else
 
 	cmp	\divisor, #(1 << 16)
+	itt	hs
 	movhs	\divisor, \divisor, lsr #16
 	movhs	\order, #16
+	it	lo
 	movlo	\order, #0
 
 	cmp	\divisor, #(1 << 8)
+	itt	hs
 	movhs	\divisor, \divisor, lsr #8
 	addhs	\order, \order, #8
 
 	cmp	\divisor, #(1 << 4)
+	itt	hs
 	movhs	\divisor, \divisor, lsr #4
 	addhs	\order, \order, #4
 
 	cmp	\divisor, #(1 << 2)
+	ite	hi
 	addhi	\order, \order, #3
 	addls	\order, \order, \divisor, lsr #1
 
@@ -152,6 +166,7 @@ Boston, MA 02111-1307, USA.  */
 	@ division loop.  Continue shifting until the divisor is 
 	@ larger than the dividend.
 1:	cmp	\divisor, #0x10000000
+	ittt	lo
 	cmplo	\divisor, \dividend
 	movlo	\divisor, \divisor, lsl #4
 	addlo	\order, \order, #4
@@ -160,6 +175,7 @@ Boston, MA 02111-1307, USA.  */
 	@ For very big divisors, we must shift it a bit at a time, or
 	@ we will be in danger of overflowing.
 1:	cmp	\divisor, #0x80000000
+	ittt	lo
 	cmplo	\divisor, \dividend
 	movlo	\divisor, \divisor, lsl #1
 	addlo	\order, \order, #1
@@ -173,19 +189,25 @@ Boston, MA 02111-1307, USA.  */
 	blt	2f
 
 1:	cmp	\dividend, \divisor
+	it	hs
 	subhs	\dividend, \dividend, \divisor
 	cmp	\dividend, \divisor,  lsr #1
+	it	hs
 	subhs	\dividend, \dividend, \divisor, lsr #1
 	cmp	\dividend, \divisor,  lsr #2
+	it	hs
 	subhs	\dividend, \dividend, \divisor, lsr #2
 	cmp	\dividend, \divisor,  lsr #3
+	it	hs
 	subhs	\dividend, \dividend, \divisor, lsr #3
 	cmp	\dividend, #1
 	mov	\divisor, \divisor, lsr #4
+	it	ge
 	subges	\order, \order, #4
 	bge	1b
 
 	tst	\order, #3
+	it	ne
 	teqne	\dividend, #0
 	beq	5f
 
@@ -194,12 +216,15 @@ Boston, MA 02111-1307, USA.  */
 	blt	4f
 	beq	3f
 	cmp	\dividend, \divisor
+	it	hs
 	subhs	\dividend, \dividend, \divisor
 	mov	\divisor,  \divisor,  lsr #1
 3:	cmp	\dividend, \divisor
+	it	hs
 	subhs	\dividend, \dividend, \divisor
 	mov	\divisor,  \divisor,  lsr #1
 4:	cmp	\dividend, \divisor
+	it	hs
 	subhs	\dividend, \dividend, \divisor
 5:
 .endm
@@ -209,6 +234,7 @@ ENTRY(__udivsi3)
 ENTRY(__aeabi_uidiv)
 
 	subs	r2, r1, #1
+	it	eq
 	moveq	pc, lr
 	bcc	Ldiv0
 	cmp	r0, r1
@@ -221,7 +247,8 @@ ENTRY(__aeabi_uidiv)
 	mov	r0, r2
 	mov	pc, lr
 
-11:	moveq	r0, #1
+11:	ite	eq
+	moveq	r0, #1
 	movne	r0, #0
 	mov	pc, lr
 
@@ -237,10 +264,14 @@ ENTRY(__umodsi3)
 
 	subs	r2, r1, #1			@ compare divisor with 1
 	bcc	Ldiv0
+	ite	ne
 	cmpne	r0, r1				@ compare dividend with divisor
 	moveq   r0, #0
+	it	hi
 	tsthi	r1, r2				@ see if divisor is power of 2
+	it	eq
 	andeq	r0, r0, r2
+	it	ls
 	movls	pc, lr
 
 	ARM_MOD_BODY r0, r1, r2, r3
@@ -255,10 +286,12 @@ ENTRY(__aeabi_idiv)
 	cmp	r1, #0
 	eor	ip, r0, r1			@ save the sign of the result.
 	beq	Ldiv0
+	it	mi
 	rsbmi	r1, r1, #0			@ loops below use unsigned.
 	subs	r2, r1, #1			@ division by 1 or -1 ?
 	beq	10f
 	movs	r3, r0
+	it	mi
 	rsbmi	r3, r0, #0			@ positive dividend value
 	cmp	r3, r1
 	bls	11f
@@ -268,14 +301,18 @@ ENTRY(__aeabi_idiv)
 	ARM_DIV_BODY r3, r1, r0, r2
 
 	cmp	ip, #0
+	it	mi
 	rsbmi	r0, r0, #0
 	mov	pc, lr
 
 10:	teq	ip, r0				@ same sign ?
+	it	mi
 	rsbmi	r0, r0, #0
 	mov	pc, lr
 
-11:	movlo	r0, #0
+11:	it	lo
+	movlo	r0, #0
+	itt	eq
 	moveq	r0, ip, asr #31
 	orreq	r0, r0, #1
 	mov	pc, lr
@@ -284,6 +321,7 @@ ENTRY(__aeabi_idiv)
 
 	cmp	ip, #0
 	mov	r0, r3, lsr r2
+	it	mi
 	rsbmi	r0, r0, #0
 	mov	pc, lr
 
@@ -294,19 +332,25 @@ ENTRY(__modsi3)
 
 	cmp	r1, #0
 	beq	Ldiv0
+	it	mi
 	rsbmi	r1, r1, #0			@ loops below use unsigned.
 	movs	ip, r0				@ preserve sign of dividend
+	it	mi
 	rsbmi	r0, r0, #0			@ if negative make positive
 	subs	r2, r1, #1			@ compare divisor with 1
+	ite	ne
 	cmpne	r0, r1				@ compare dividend with divisor
 	moveq	r0, #0
+	it	hi
 	tsthi	r1, r2				@ see if divisor is power of 2
+	it	eq
 	andeq	r0, r0, r2
 	bls	10f
 
 	ARM_MOD_BODY r0, r1, r2, r3
 
 10:	cmp	ip, #0
+	it	mi
 	rsbmi	r0, r0, #0
 	mov	pc, lr
 
diff --git a/arch/arm/lib/lshrdi3.S b/arch/arm/lib/lshrdi3.S
index 99ea338..57db3a2 100644
--- a/arch/arm/lib/lshrdi3.S
+++ b/arch/arm/lib/lshrdi3.S
@@ -41,9 +41,12 @@ ENTRY(__aeabi_llsr)
 
 	subs	r3, r2, #32
 	rsb	ip, r2, #32
+	itett	mi
 	movmi	al, al, lsr r2
 	movpl	al, ah, lsr r3
-	orrmi	al, al, ah, lsl ip
+ ARM(	orrmi	al, al, ah, lsl ip	)
+ THUMB(	lslmi	r3, ah, ip		)
+ THUMB(	orrmi	al, al, r3		)
 	mov	ah, ah, lsr r2
 	mov	pc, lr
 
diff --git a/arch/arm/lib/memchr.S b/arch/arm/lib/memchr.S
index 1da8699..0d1d596 100644
--- a/arch/arm/lib/memchr.S
+++ b/arch/arm/lib/memchr.S
@@ -21,6 +21,7 @@ ENTRY(memchr)
 	teq	r3, r1
 	bne	1b
 	sub	r0, r0, #1
-2:	movne	r0, #0
+2:	it	ne
+	movne	r0, #0
 	mov	pc, lr
 ENDPROC(memchr)
diff --git a/arch/arm/lib/memcpy.S b/arch/arm/lib/memcpy.S
index e0d0026..c7a810d 100644
--- a/arch/arm/lib/memcpy.S
+++ b/arch/arm/lib/memcpy.S
@@ -13,8 +13,11 @@
 #include <linux/linkage.h>
 #include <asm/assembler.h>
 
+#define LDR1W_SHIFT	0
+#define STR1W_SHIFT	0
+
 	.macro ldr1w ptr reg abort
-	ldr \reg, [\ptr], #4
+	W(ldr) \reg, [\ptr], #4
 	.endm
 
 	.macro ldr4w ptr reg1 reg2 reg3 reg4 abort
@@ -26,11 +29,16 @@
 	.endm
 
 	.macro ldr1b ptr reg cond=al abort
+	.ifnc \cond,al
+	it \cond
 	ldr\cond\()b \reg, [\ptr], #1
+	.else
+	ldrb \reg, [\ptr], #1
+	.endif
 	.endm
 
 	.macro str1w ptr reg abort
-	str \reg, [\ptr], #4
+	W(str) \reg, [\ptr], #4
 	.endm
 
 	.macro str8w ptr reg1 reg2 reg3 reg4 reg5 reg6 reg7 reg8 abort
@@ -38,7 +46,12 @@
 	.endm
 
 	.macro str1b ptr reg cond=al abort
+	.ifnc \cond,al
+	it \cond
 	str\cond\()b \reg, [\ptr], #1
+	.else
+	strb \reg, [\ptr], #1
+	.endif
 	.endm
 
 	.macro enter reg1 reg2
diff --git a/arch/arm/lib/memmove.S b/arch/arm/lib/memmove.S
index 1254918..191a5dc 100644
--- a/arch/arm/lib/memmove.S
+++ b/arch/arm/lib/memmove.S
@@ -29,7 +29,9 @@
 ENTRY(memmove)
 
 		subs	ip, r0, r1
+		it	hi
 		cmphi	r2, ip
+		it	ls
 		bls	memcpy
 
 		stmfd	sp!, {r0, r4, lr}
@@ -72,46 +74,55 @@ ENTRY(memmove)
 
 5:		ands	ip, r2, #28
 		rsb	ip, ip, #32
+		it	ne
 		addne	pc, pc, ip		@ C is always clear here
 		b	7f
 6:		nop
-		ldr	r3, [r1, #-4]!
-		ldr	r4, [r1, #-4]!
-		ldr	r5, [r1, #-4]!
-		ldr	r6, [r1, #-4]!
-		ldr	r7, [r1, #-4]!
-		ldr	r8, [r1, #-4]!
-		ldr	lr, [r1, #-4]!
+		W(ldr)	r3, [r1, #-4]!
+		W(ldr)	r4, [r1, #-4]!
+		W(ldr)	r5, [r1, #-4]!
+		W(ldr)	r6, [r1, #-4]!
+		W(ldr)	r7, [r1, #-4]!
+		W(ldr)	r8, [r1, #-4]!
+		W(ldr)	lr, [r1, #-4]!
 
 		add	pc, pc, ip
 		nop
 		nop
-		str	r3, [r0, #-4]!
-		str	r4, [r0, #-4]!
-		str	r5, [r0, #-4]!
-		str	r6, [r0, #-4]!
-		str	r7, [r0, #-4]!
-		str	r8, [r0, #-4]!
-		str	lr, [r0, #-4]!
+		W(str)	r3, [r0, #-4]!
+		W(str)	r4, [r0, #-4]!
+		W(str)	r5, [r0, #-4]!
+		W(str)	r6, [r0, #-4]!
+		W(str)	r7, [r0, #-4]!
+		W(str)	r8, [r0, #-4]!
+		W(str)	lr, [r0, #-4]!
 
 	CALGN(	bcs	2b			)
 
 7:		ldmfd	sp!, {r5 - r8}
 
 8:		movs	r2, r2, lsl #31
+		it	ne
 		ldrneb	r3, [r1, #-1]!
+		itt	cs
 		ldrcsb	r4, [r1, #-1]!
 		ldrcsb	ip, [r1, #-1]
+		it	ne
 		strneb	r3, [r0, #-1]!
+		itt	cs
 		strcsb	r4, [r0, #-1]!
 		strcsb	ip, [r0, #-1]
 		ldmfd	sp!, {r0, r4, pc}
 
 9:		cmp	ip, #2
+		it	gt
 		ldrgtb	r3, [r1, #-1]!
+		it	ge
 		ldrgeb	r4, [r1, #-1]!
 		ldrb	lr, [r1, #-1]!
+		it	gt
 		strgtb	r3, [r0, #-1]!
+		it	ge
 		strgeb	r4, [r0, #-1]!
 		subs	r2, r2, ip
 		strb	lr, [r0, #-1]!
diff --git a/arch/arm/lib/memset.S b/arch/arm/lib/memset.S
index 761eefa..ef022bd 100644
--- a/arch/arm/lib/memset.S
+++ b/arch/arm/lib/memset.S
@@ -19,7 +19,9 @@
 1:	subs	r2, r2, #4		@ 1 do we have enough
 	blt	5f			@ 1 bytes to align with?
 	cmp	r3, #2			@ 1
+	it	lt
 	strltb	r1, [r0], #1		@ 1
+	it	le
 	strleb	r1, [r0], #1		@ 1
 	strb	r1, [r0], #1		@ 1
 	add	r2, r2, r3		@ 1 (r2 = r2 - (4 - r3))
@@ -51,19 +53,23 @@ ENTRY(memset)
 	mov	lr, r1
 
 2:	subs	r2, r2, #64
+	itttt	ge
 	stmgeia	r0!, {r1, r3, ip, lr}	@ 64 bytes at a time.
 	stmgeia	r0!, {r1, r3, ip, lr}
 	stmgeia	r0!, {r1, r3, ip, lr}
 	stmgeia	r0!, {r1, r3, ip, lr}
 	bgt	2b
+	it	eq
 	ldmeqfd	sp!, {pc}		@ Now <64 bytes to go.
 /*
  * No need to correct the count; we're only testing bits from now on
  */
 	tst	r2, #32
+	itt	ne
 	stmneia	r0!, {r1, r3, ip, lr}
 	stmneia	r0!, {r1, r3, ip, lr}
 	tst	r2, #16
+	it	ne
 	stmneia	r0!, {r1, r3, ip, lr}
 	ldr	lr, [sp], #4
 
@@ -111,17 +117,21 @@ ENTRY(memset)
 #endif
 
 4:	tst	r2, #8
+	it	ne
 	stmneia	r0!, {r1, r3}
 	tst	r2, #4
+	it	ne
 	strne	r1, [r0], #4
 /*
  * When we get here, we've got less than 4 bytes to zero.  We
  * may have an unaligned pointer as well.
  */
 5:	tst	r2, #2
+	itt	ne
 	strneb	r1, [r0], #1
 	strneb	r1, [r0], #1
 	tst	r2, #1
+	it	ne
 	strneb	r1, [r0], #1
 	mov	pc, lr
 ENDPROC(memset)
diff --git a/arch/arm/lib/memzero.S b/arch/arm/lib/memzero.S
index 3fbdef5..a0e319a 100644
--- a/arch/arm/lib/memzero.S
+++ b/arch/arm/lib/memzero.S
@@ -21,7 +21,9 @@
 1:	subs	r1, r1, #4		@ 1 do we have enough
 	blt	5f			@ 1 bytes to align with?
 	cmp	r3, #2			@ 1
+	it	lt
 	strltb	r2, [r0], #1		@ 1
+	it	le
 	strleb	r2, [r0], #1		@ 1
 	strb	r2, [r0], #1		@ 1
 	add	r1, r1, r3		@ 1 (r1 = r1 - (4 - r3))
@@ -51,19 +53,23 @@ ENTRY(__memzero)
 	mov	lr, r2			@ 1
 
 3:	subs	r1, r1, #64		@ 1 write 32 bytes out per loop
+	itttt	ge
 	stmgeia	r0!, {r2, r3, ip, lr}	@ 4
 	stmgeia	r0!, {r2, r3, ip, lr}	@ 4
 	stmgeia	r0!, {r2, r3, ip, lr}	@ 4
 	stmgeia	r0!, {r2, r3, ip, lr}	@ 4
 	bgt	3b			@ 1
+	it	eq
 	ldmeqfd	sp!, {pc}		@ 1/2 quick exit
 /*
  * No need to correct the count; we're only testing bits from now on
  */
 	tst	r1, #32			@ 1
+	itt	ne
 	stmneia	r0!, {r2, r3, ip, lr}	@ 4
 	stmneia	r0!, {r2, r3, ip, lr}	@ 4
 	tst	r1, #16			@ 1 16 bytes or more?
+	it	ne
 	stmneia	r0!, {r2, r3, ip, lr}	@ 4
 	ldr	lr, [sp], #4		@ 1
 
@@ -109,17 +115,21 @@ ENTRY(__memzero)
 #endif
 
 4:	tst	r1, #8			@ 1 8 bytes or more?
+	it	ne
 	stmneia	r0!, {r2, r3}		@ 2
 	tst	r1, #4			@ 1 4 bytes or more?
+	it	ne
 	strne	r2, [r0], #4		@ 1
 /*
  * When we get here, we've got less than 4 bytes to zero.  We
  * may have an unaligned pointer as well.
  */
 5:	tst	r1, #2			@ 1 2 bytes or more?
+	itt	ne
 	strneb	r2, [r0], #1		@ 1
 	strneb	r2, [r0], #1		@ 1
 	tst	r1, #1			@ 1 a byte left over
+	it	ne
 	strneb	r2, [r0], #1		@ 1
 	mov	pc, lr			@ 1
 ENDPROC(__memzero)
diff --git a/arch/arm/lib/putuser.S b/arch/arm/lib/putuser.S
index 864f3c1..4d9dc1a 100644
--- a/arch/arm/lib/putuser.S
+++ b/arch/arm/lib/putuser.S
@@ -38,10 +38,16 @@ ENDPROC(__put_user_1)
 ENTRY(__put_user_2)
 	mov	ip, r2, lsr #8
 #ifndef __ARMEB__
-2:	strbt	r2, [r0], #1
+2:
+ ARM(	strbt	r2, [r0], #1	)
+ THUMB(	strbt	r2, [r0]	)
+ THUMB(	add	r0, #1		)
 3:	strbt	ip, [r0]
 #else
-2:	strbt	ip, [r0], #1
+2:
+ ARM(	strbt	ip, [r0], #1	)
+ THUMB(	strbt	ip, [r0]	)
+ THUMB(	add	r0, #1		)
 3:	strbt	r2, [r0]
 #endif
 	mov	r0, #0
@@ -55,7 +61,10 @@ ENTRY(__put_user_4)
 ENDPROC(__put_user_4)
 
 ENTRY(__put_user_8)
-5:	strt	r2, [r0], #4
+5:
+ ARM(	strt	r2, [r0], #4	)
+ THUMB(	strt	r2, [r0]	)
+ THUMB(	add	r0, #4		)
 6:	strt	r3, [r0]
 	mov	r0, #0
 	mov	pc, lr
diff --git a/arch/arm/lib/sha1.S b/arch/arm/lib/sha1.S
index a16fb20..09b548c 100644
--- a/arch/arm/lib/sha1.S
+++ b/arch/arm/lib/sha1.S
@@ -187,6 +187,7 @@ ENTRY(sha_transform)
 
 ENDPROC(sha_transform)
 
+	.align	2
 .L_sha_K:
 	.word	0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6
 
@@ -195,6 +196,7 @@ ENDPROC(sha_transform)
  * void sha_init(__u32 *buf)
  */
 
+	.align	2
 .L_sha_initial_digest:
 	.word	0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0
 
diff --git a/arch/arm/lib/strchr.S b/arch/arm/lib/strchr.S
index d8f2a1c..fd4014e 100644
--- a/arch/arm/lib/strchr.S
+++ b/arch/arm/lib/strchr.S
@@ -18,9 +18,11 @@ ENTRY(strchr)
 		and	r1, r1, #0xff
 1:		ldrb	r2, [r0], #1
 		teq	r2, r1
+		it	ne
 		teqne	r2, #0
 		bne	1b
 		teq	r2, r1
+		ite	ne
 		movne	r0, #0
 		subeq	r0, r0, #1
 		mov	pc, lr
diff --git a/arch/arm/lib/strncpy_from_user.S b/arch/arm/lib/strncpy_from_user.S
index 330373c..1c9814f 100644
--- a/arch/arm/lib/strncpy_from_user.S
+++ b/arch/arm/lib/strncpy_from_user.S
@@ -23,7 +23,7 @@
 ENTRY(__strncpy_from_user)
 	mov	ip, r1
 1:	subs	r2, r2, #1
-USER(	ldrplbt	r3, [r1], #1)
+	ldrusr	r3, r1, 1, pl
 	bmi	2f
 	strb	r3, [r0], #1
 	teq	r3, #0
diff --git a/arch/arm/lib/strnlen_user.S b/arch/arm/lib/strnlen_user.S
index 90bb9d0..7855b29 100644
--- a/arch/arm/lib/strnlen_user.S
+++ b/arch/arm/lib/strnlen_user.S
@@ -23,7 +23,7 @@
 ENTRY(__strnlen_user)
 	mov	r2, r0
 1:
-USER(	ldrbt	r3, [r0], #1)
+	ldrusr	r3, r0, 1
 	teq	r3, #0
 	beq	2f
 	subs	r1, r1, #1
diff --git a/arch/arm/lib/strrchr.S b/arch/arm/lib/strrchr.S
index 302f20c..d7a9440 100644
--- a/arch/arm/lib/strrchr.S
+++ b/arch/arm/lib/strrchr.S
@@ -18,6 +18,7 @@ ENTRY(strrchr)
 		mov	r3, #0
 1:		ldrb	r2, [r0], #1
 		teq	r2, r1
+		it	eq
 		subeq	r3, r0, #1
 		teq	r2, #0
 		bne	1b
diff --git a/arch/arm/lib/testclearbit.S b/arch/arm/lib/testclearbit.S
index 543d709..df66c76 100644
--- a/arch/arm/lib/testclearbit.S
+++ b/arch/arm/lib/testclearbit.S
@@ -15,6 +15,6 @@
 ENTRY(_test_and_clear_bit_be)
 		eor	r0, r0, #0x18		@ big endian byte ordering
 ENTRY(_test_and_clear_bit_le)
-	testop	bicne, strneb
+	testop	bicne, strneb, ne
 ENDPROC(_test_and_clear_bit_be)
 ENDPROC(_test_and_clear_bit_le)
diff --git a/arch/arm/lib/testsetbit.S b/arch/arm/lib/testsetbit.S
index 0b3f390..3938bdf 100644
--- a/arch/arm/lib/testsetbit.S
+++ b/arch/arm/lib/testsetbit.S
@@ -15,6 +15,6 @@
 ENTRY(_test_and_set_bit_be)
 		eor	r0, r0, #0x18		@ big endian byte ordering
 ENTRY(_test_and_set_bit_le)
-	testop	orreq, streqb
+	testop	orreq, streqb, eq
 ENDPROC(_test_and_set_bit_be)
 ENDPROC(_test_and_set_bit_le)
diff --git a/arch/arm/lib/ucmpdi2.S b/arch/arm/lib/ucmpdi2.S
index f0df6a9..5032889 100644
--- a/arch/arm/lib/ucmpdi2.S
+++ b/arch/arm/lib/ucmpdi2.S
@@ -27,9 +27,13 @@
 ENTRY(__ucmpdi2)
 
 	cmp	xh, yh
+	it	eq
 	cmpeq	xl, yl
+	it	lo
 	movlo	r0, #0
+	it	eq
 	moveq	r0, #1
+	it	hi
 	movhi	r0, #2
 	mov	pc, lr
 
@@ -40,9 +44,13 @@ ENDPROC(__ucmpdi2)
 ENTRY(__aeabi_ulcmp)
 
 	cmp	xh, yh
+	it	eq
 	cmpeq	xl, yl
+	it	lo
 	movlo	r0, #-1
+	it	eq
 	moveq	r0, #0
+	it	hi
 	movhi	r0, #1
 	mov	pc, lr
 
diff --git a/arch/arm/mach-firecracker/Kconfig b/arch/arm/mach-firecracker/Kconfig
new file mode 100644
index 0000000..2a1b536
--- /dev/null
+++ b/arch/arm/mach-firecracker/Kconfig
@@ -0,0 +1,37 @@
+# $picoChipHeaderSubst$
+
+menu "Firecracker platform type"
+	depends on ARCH_FIRECRACKER
+
+config MACH_PC72052_I10_REVB
+	bool "Support the picoChip PC7202/PC7205 Platforms"
+	help
+	  Include support for the picoChip PC7202/PC7205 Platforms.
+
+config MACH_PC7802
+	bool "Support the picoChip PC7802 Platform"
+	help
+	  Include support for the picoChip PC7802 Platform.
+
+config FIRECRACKER_DMA_TEST
+	bool "Firecracker DMA driver test module (dma_test)"
+	help
+	  Include the firecracker DMA test module.
+
+config FIRECRACKER_DMA_DEBUG
+	int "Firecracker DMA driver debugging verbosity (0 = quiet, 9 = noisy)"
+	default "0"
+	help
+	  This controls the amount of debugging messages produced by the
+	  firecracker DMA driver. A value of zero builds a driver without
+	  debug code.
+
+config FIRECRACKER_EMAC_DEBUG
+	int "Firecracker EMAC driver debugging verbosity (0 = quiet, 9 = noisy)"
+	default "0"
+	help
+	  This controls the amount of debugging messages produced by the
+	  firecracker EMAC driver. A value of zero builds a driver without
+	  debug code.
+
+endmenu
diff --git a/arch/arm/mach-firecracker/Makefile b/arch/arm/mach-firecracker/Makefile
new file mode 100644
index 0000000..2cd61dd
--- /dev/null
+++ b/arch/arm/mach-firecracker/Makefile
@@ -0,0 +1,9 @@
+# BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+#
+# Makefile for the linux kernel.
+#
+
+obj-y						:= firecracker_core.o firecracker_dma.o firecracker_emac.o firecracker_reset.o
+obj-$(CONFIG_MACH_PC72052_I10_REVB)		+= firecracker_cpe.o
+
+obj-$(CONFIG_FIRECRACKER_DMA_TEST)		+= dma_test.o
diff --git a/arch/arm/mach-firecracker/Makefile.boot b/arch/arm/mach-firecracker/Makefile.boot
new file mode 100644
index 0000000..c7e75ac
--- /dev/null
+++ b/arch/arm/mach-firecracker/Makefile.boot
@@ -0,0 +1,4 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
+
diff --git a/arch/arm/mach-firecracker/core.h b/arch/arm/mach-firecracker/core.h
new file mode 100644
index 0000000..0c57e79
--- /dev/null
+++ b/arch/arm/mach-firecracker/core.h
@@ -0,0 +1,33 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05 
+ *****************************************************************************/
+
+/*
+ *  linux/arch/arm/mach-firecracker/core.h
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#ifndef __ASM_ARCH_FIRECRACKER_H__
+#define __ASM_ARCH_FIRECRACKER_H__
+
+#include <linux/amba/bus.h>
+
+extern void __init firecracker_init(void);
+extern void __init firecracker_init_irq(void);
+extern void __init firecracker_map_io(void);
+extern void __init firecracker_fixup(
+        struct machine_desc *md,
+        struct tag *tag,
+        char ** from,
+        struct meminfo *mi);
+extern struct sys_timer firecracker_timer;
+
+
+#endif /* __ASM_ARCH_FIRECRACKER_H__ */
diff --git a/arch/arm/mach-firecracker/dma_test.c b/arch/arm/mach-firecracker/dma_test.c
new file mode 100644
index 0000000..370061c
--- /dev/null
+++ b/arch/arm/mach-firecracker/dma_test.c
@@ -0,0 +1,2278 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ *  linux/arch/arm/mach-firecracker/dma_test.c
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Description:
+ *
+ * This module tests the firecracker DMA driver API.
+ *
+ * References:
+ *
+ * dma_api.txt contains details on the programming interface functions.
+ * Synopsys DesignWare DW_ahb_dmac Databook Version 2.07a December 14, 2005.
+ * 
+ * See linux/arch/arm/mach-firecracker/dma.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+
+#include <mach/io.h>
+#include <mach/hardware.h>
+#include <mach/dma.h>
+
+/* Simply do the DMA tests in the module init function and return the test 
+ * status when the module exits.
+ * The insmod call will return the test result.
+ */
+
+#define PASS 0
+#define FAIL -1
+
+#define FAIL_TEST(_why)                                                     \
+{                                                                           \
+    test_state |= FAIL;                                                     \
+    printk("<%u> TEST FAILURE: "_why"\n", testnumi);                        \
+}
+
+#define RESET_TEST_RES()    test_state = PASS;
+#define TEST_FAILED         (test_state == FAIL)
+
+static volatile int test_state;
+
+static struct device *device;
+
+int testnumi;
+
+/* Helper functions */
+static firecracker_dma_t get_dmac(int num)
+{
+    firecracker_dma_t dma;
+    dma = firecracker_dma_get_dmac_handle(num);
+    if (!dma) FAIL_TEST("firecracker_dma_get_dmac_handle");
+
+    return dma;
+}
+
+static void rand_fill(void *vaddr, unsigned int size)
+{
+    unsigned int i;
+    unsigned int *p;
+
+    for (i = 0; i < size; i += 4) {
+        p = (unsigned int *)(((unsigned char *)vaddr) + i);
+
+        *p = *(&i + i);     /* any random data on stack */
+    }
+}
+
+static unsigned int checksum(void *vaddr, unsigned int size)
+{
+    unsigned int i;
+    unsigned int *p;
+    unsigned int chk = 0;
+    unsigned int bits = 0;
+
+    for (i = 0; i < size; i += 4) {
+        p = (unsigned int *)(((unsigned char *)vaddr) + i);
+
+        chk = chk + *p;     /* Checksum */
+        bits = bits | *p;
+    }
+
+    /* if all data is zero, return nonzero */
+    if (bits == 0) {
+        return -1;
+    }
+
+    return chk;
+}
+
+static dma_addr_t get_dma_buffer(void **ret_vaddr, unsigned int size, int do_checksum)
+{
+    dma_addr_t paddr;
+    void *vaddr;
+    unsigned int *p;
+
+    vaddr = dma_alloc_coherent(device, size, &paddr, GFP_ATOMIC);
+
+    if (!vaddr) {
+        FAIL_TEST("dma_alloc_coherent");
+        return 0;
+    }
+
+    if (do_checksum) {
+        rand_fill(vaddr, size);
+        /* Put the -ve checksum at the end */
+        p = (unsigned int *)(((unsigned char *)vaddr) + size-4);
+        *p = -checksum(vaddr, size - 4);
+    }
+    else {
+        memset(vaddr, 0xbe, size);
+    }
+
+    if (ret_vaddr) {
+        *ret_vaddr = vaddr;
+    }
+
+    return paddr;
+}
+
+static void wait_a_bit(void)
+{
+    set_current_state( TASK_INTERRUPTIBLE );
+    schedule_timeout( 50 );
+}
+
+/* Test functions... */
+static void test_direct_xfr(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024*4, 1);
+    src.ahb_master_select = AHB_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_1_TRW;
+    src.auto_reload = 0;
+
+    dst = src;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024*4, 0);
+
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, 1024*4, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+ //   firecracker_dma_dump_regs(dma);
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    udelay(100);
+
+    if (checksum(dest_vaddr, 1024*4) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+    
+    firecracker_dma_release(xfr);
+}
+
+
+/* Direct transfer using hardware handshaking. This does not actually transfer
+ * any data as the hardware to drive the handshaking is not setup.
+ * This test is only for checking the register settings.
+ */
+static void test_direct_xfr_hw_handshaking(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+    firecracker_dma_handshake_t src_hs;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src hardware handshaking parameters */
+    src_hs.interface = 1;
+    src_hs.active_low = 0;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024*4, 1);
+    src.ahb_master_select = AHB_MASTER4;
+    src.periph_not_mem = 1;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = NO_CHANGE;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_4_TRW;
+    src.auto_reload = 0;
+
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024*4, 0);
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_4_TRW;
+    dst.auto_reload = 0;
+    
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, &src_hs, NULL, 1024*2, PROTCTL_1, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    firecracker_dma_dump_regs(dma);
+
+    udelay(100);
+
+    /* This test does not actually transfer any data as it relies on hardware
+     * handshaking.
+     */
+#if 0
+    if (checksum(dest_vaddr, 1024*4) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+#endif
+    
+    firecracker_dma_release(xfr);
+}
+
+
+static void test_xfr_block_sizes(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+    void *src_vaddr;
+    unsigned int bsize;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, 1024*4, 1);
+    src.ahb_master_select = AHB_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst = src;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024*4, 0);
+
+    /* Test block sizes 1 to 512 */
+    for (bsize = 4; bsize < 512; bsize += 4) {
+
+        memset(dest_vaddr, 0xbe, 1024*4);
+
+        xfr = firecracker_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL);
+
+        if (!xfr) {
+            FAIL_TEST("firecracker_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (firecracker_dma_start(xfr) != 0) {
+            FAIL_TEST("firecracker_dma_start");
+            break;
+        }
+
+        udelay(100);
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0) {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        firecracker_dma_release(xfr);
+    }
+
+    if (bsize < 512) {
+        printk("Failed at block size %u\n", bsize);
+    }
+}
+
+static void test_list_list_xfr(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    firecracker_dma_list_t list;
+    void *dest_vaddr[10];
+    int i;
+    int elms = 10;
+    unsigned int buf_sz = 1024 * 4;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    list = firecracker_dma_list_create(dma, elms);
+    if (!list) {
+        FAIL_TEST("firecracker_dma_list_create");
+        return;
+    }
+
+    /* Setup 10 elements of the list */
+    for (i = 0; i < elms; i++) {
+
+        /* Setup src/dst parameters */
+        src.dma_addr = get_dma_buffer(NULL, buf_sz, 1);
+        src.ahb_master_select = AHB_MASTER1;
+        src.periph_not_mem = 0;
+        src.flow_controller = 0;
+        src.enable_sg = 0;
+        src.addr_inc = INCREMENT;
+        src.tr_width = TR_WIDTH32;
+        src.msize = MS_1_TRW;
+        src.auto_reload = 0;
+
+        dst = src;
+        dst.dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (firecracker_dma_list_add(list, &src, &dst, buf_sz) != 0) {
+            FAIL_TEST("firecracker_dma_list_add");
+            return;
+        }
+    }
+
+    xfr = firecracker_dma_setup_list_xfr(
+            list, NULL, NULL, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_list_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    wait_a_bit();
+
+#if 0   /* Now the list will stop automatically when it gets to the end */
+    /* List transfer will continue until it is aborted */
+    if (firecracker_dma_abort(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_abort");
+        return;
+    }
+#endif
+
+    for (i = 0; i < elms; i++) {
+        if (checksum(dest_vaddr[i], buf_sz) != 0) {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    /* Destroy the transfer */
+    firecracker_dma_release(xfr);
+
+    /* Destroy the list */
+    if (firecracker_dma_list_destroy(list) != 0) {
+        FAIL_TEST("firecracker_dma_list_destroy");
+        return;
+    }
+}
+
+
+static void test_single_element_list_list_xfr(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    firecracker_dma_list_t list;
+    void *dest_vaddr[10];
+    int i;
+    int elms = 1;
+    unsigned int buf_sz = 1024 * 4;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    list = firecracker_dma_list_create(dma, elms);
+    if (!list) {
+        FAIL_TEST("firecracker_dma_list_create");
+        return;
+    }
+
+    /* Setup 1 element of the list */
+    for (i = 0; i < elms; i++) {
+
+        /* Setup src/dst parameters */
+        src.dma_addr = get_dma_buffer(NULL, buf_sz, 1);
+        src.ahb_master_select = AHB_MASTER1;
+        src.periph_not_mem = 0;
+        src.flow_controller = 0;
+        src.enable_sg = 0;
+        src.addr_inc = INCREMENT;
+        src.tr_width = TR_WIDTH32;
+        src.msize = MS_1_TRW;
+        src.auto_reload = 0;
+
+        dst = src;
+        dst.dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (firecracker_dma_list_add(list, &src, &dst, buf_sz) != 0) {
+            FAIL_TEST("firecracker_dma_list_add");
+            return;
+        }
+    }
+
+    xfr = firecracker_dma_setup_list_xfr(
+            list, NULL, NULL, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_list_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    wait_a_bit();
+
+#if 0   /* Now the list will stop automatically when it gets to the end */
+    /* List transfer will continue until it is aborted */
+    if (firecracker_dma_abort(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_abort");
+        return;
+    }
+#endif
+
+    for (i = 0; i < elms; i++) {
+        if (checksum(dest_vaddr[i], buf_sz) != 0) {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    /* Destroy the transfer */
+    firecracker_dma_release(xfr);
+
+    /* Destroy the list */
+    if (firecracker_dma_list_destroy(list) != 0) {
+        FAIL_TEST("firecracker_dma_list_destroy");
+        return;
+    }
+}
+
+
+static void test_list_list_xfr_reuse_list(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    firecracker_dma_list_t list;
+    void *dest_vaddr[10];
+    int i;
+    int elms = 10;
+    unsigned int buf_sz = 1024 * 4;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    list = firecracker_dma_list_create(dma, elms);
+    if (!list) {
+        FAIL_TEST("firecracker_dma_list_create");
+        return;
+    }
+
+    xfr = firecracker_dma_setup_list_xfr(
+            list, NULL, NULL, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_list_xfr");
+        return;
+    }
+
+    /* Setup 10 elements of the list */
+    for (i = 0; i < elms; i++) {
+
+        /* Setup src/dst parameters */
+        src.dma_addr = get_dma_buffer(NULL, buf_sz, 1);
+        src.ahb_master_select = AHB_MASTER1;
+        src.periph_not_mem = 0;
+        src.flow_controller = 0;
+        src.enable_sg = 0;
+        src.addr_inc = INCREMENT;
+        src.tr_width = TR_WIDTH32;
+        src.msize = MS_1_TRW;
+        src.auto_reload = 0;
+
+        dst = src;
+        dst.dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (firecracker_dma_list_add(list, &src, &dst, buf_sz) != 0) {
+            FAIL_TEST("firecracker_dma_list_add");
+            return;
+        }
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    wait_a_bit();
+
+#if 0   /* List xfr will stop automatically when it gets to the end */
+    /* List transfer will continue until it is aborted */
+    if (firecracker_dma_abort(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_abort");
+        return;
+    }
+#endif
+
+    for (i = 0; i < elms; i++) {
+        if (checksum(dest_vaddr[i], buf_sz) != 0) {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    /* Reset the list and reuse it */
+    if (firecracker_dma_list_clear(list) != 0) {
+        FAIL_TEST("firecracker_dma_list_clear");
+        return;
+    }
+
+    /* Setup 5 elements of the list */
+    elms = 5;
+    for (i = 0; i < elms; i++) {
+
+        /* Setup src/dst parameters */
+        src.dma_addr = get_dma_buffer(NULL, buf_sz, 1);
+        src.ahb_master_select = AHB_MASTER1;
+        src.periph_not_mem = 0;
+        src.flow_controller = 0;
+        src.enable_sg = 0;
+        src.addr_inc = INCREMENT;
+        src.tr_width = TR_WIDTH32;
+        src.msize = MS_1_TRW;
+        src.auto_reload = 0;
+
+        dst = src;
+        dst.dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (firecracker_dma_list_add(list, &src, &dst, buf_sz) != 0) {
+            FAIL_TEST("firecracker_dma_list_add");
+            return;
+        }
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    wait_a_bit();
+
+#if 0   /* List xfr will stop automatically when it gets to the end */
+    /* List transfer will continue until it is aborted */
+    if (firecracker_dma_abort(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_abort");
+        return;
+    }
+#endif
+
+    for (i = 0; i < elms; i++) {
+        if (checksum(dest_vaddr[i], buf_sz) != 0) {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    /* Destroy the transfer */
+    firecracker_dma_release(xfr);
+
+    /* Destroy the list */
+    if (firecracker_dma_list_destroy(list) != 0) {
+        FAIL_TEST("firecracker_dma_list_destroy");
+        return;
+    }
+}
+
+
+
+static void test_reload_to_list_xfr(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    firecracker_dma_list_t list;
+    void *dest_vaddr[10];
+    int i;
+    int elms = 10;
+    unsigned int buf_sz = 1024 * 4;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    list = firecracker_dma_list_create(dma, elms);
+    if (!list) {
+        FAIL_TEST("firecracker_dma_list_create");
+        return;
+    }
+
+    /* Setup src/dst parameters */
+    src.ahb_master_select = AHB_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_1_TRW;
+
+    /* Reload the source block so that the source block get copied to all
+     * list elements of the destination
+     */
+    src.auto_reload = 1;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_1_TRW;
+    dst.auto_reload = 0;
+
+    src.dma_addr = get_dma_buffer(NULL, buf_sz, 1);
+    dst.dma_addr = get_dma_buffer(&dest_vaddr[0], buf_sz, 0);
+
+    /* Setup first element of the list */
+    if (firecracker_dma_list_add(list, &src, &dst, buf_sz) != 0) {
+        FAIL_TEST("firecracker_dma_list_add");
+        return;
+    }
+
+    /* Setup elements 2 to 10 of the list */
+    for (i = 1; i < elms; i++) {
+
+        dst.dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        /* No source endpoint for subsequent elements */
+        if (firecracker_dma_list_add(list, NULL, &dst, buf_sz) != 0) {
+            FAIL_TEST("firecracker_dma_list_add");
+            return;
+        }
+    }
+
+    xfr = firecracker_dma_setup_list_xfr(
+            list, NULL, NULL, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_list_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    wait_a_bit();
+
+#if 0   /* Transfer will stop when it reaches the end of the list */
+    /* Auto-reload transfer will continue until it is aborted */
+    if (firecracker_dma_abort(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_abort");
+        return;
+    }
+#endif
+
+    for (i = 0; i < elms; i++) {
+        if (checksum(dest_vaddr[i], buf_sz) != 0) {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    /* Destroy the transfer */
+    firecracker_dma_release(xfr);
+
+    /* Destroy the list */
+    if (firecracker_dma_list_destroy(list) != 0) {
+        FAIL_TEST("firecracker_dma_list_destroy");
+        return;
+    }
+}
+
+
+static int test_direct_xfr_with_interrupts_irq_state = 0;
+static unsigned int test_cookie = 0xbebebebe;
+
+static irqreturn_t test_direct_xfr_with_interrupts_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+    firecracker_dma_t dma = (firecracker_dma_t) dev_id; 
+    firecracker_dma_xfr_t xfr;
+    dma_int_type_t int_type;
+    unsigned int *cookie_addr;
+
+    /* Get the handle of the transfer that caused the interrupt */
+    int_type = INT_ALL;
+    xfr = firecracker_dma_int_get_xfr(dma, &int_type, (void **)&cookie_addr);
+    if (xfr == NULL) {
+        FAIL_TEST("firecracker_dma_int_get_xfr");
+        return IRQ_HANDLED;
+    }
+
+    if (cookie_addr != &test_cookie) {
+        FAIL_TEST("Incorrect cookie not passed to interrupt");
+    }
+
+    test_direct_xfr_with_interrupts_irq_state++;
+
+    /* Reset the interrupt we are servicing */
+    firecracker_dma_clear_int(xfr, int_type);
+
+    /* Handle any other interrupts that may have occurred at the same 
+     * time
+     */
+    while (1) {
+
+        int_type = INT_ALL;
+        xfr = firecracker_dma_int_get_xfr(dma, &int_type, NULL);
+        if (xfr == NULL) {
+            break;
+        }
+
+        test_direct_xfr_with_interrupts_irq_state++;
+
+        firecracker_dma_clear_int(xfr, int_type);
+    }
+
+    return IRQ_HANDLED;
+}
+
+
+static void test_direct_xfr_with_interrupts(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Get the interrupt */
+    if (request_irq(
+            IRQ_DMA_1, &test_direct_xfr_with_interrupts_irq,
+            SA_INTERRUPT, "test_direct_xfr_with_interrupts", dma) != 0) {
+        FAIL_TEST("request_irq");
+        return;
+    }
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024*4, 1);
+    src.ahb_master_select = AHB_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_1_TRW;
+    src.auto_reload = 0;
+
+    dst = src;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024*4, 0);
+
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, 1024*4, 0, &test_cookie);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+    firecracker_dma_enable_int(xfr, INT_BLOCK | INT_ERROR | INT_TRANSFER);
+
+    test_direct_xfr_with_interrupts_irq_state = 0;
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    udelay(100);
+
+    if (checksum(dest_vaddr, 1024*4) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+
+    if (test_direct_xfr_with_interrupts_irq_state == 0) {
+        FAIL_TEST("No interrupt occurred");
+    }
+
+    printk("%u interrupts received\n", test_direct_xfr_with_interrupts_irq_state);
+
+    free_irq(IRQ_DMA_1, dma);
+    firecracker_dma_release(xfr);
+}
+
+
+static int test_list_xfr_with_interrupts_irq_state = 0;
+
+static irqreturn_t test_list_xfr_with_interrupts_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+    firecracker_dma_t dma = (firecracker_dma_t) dev_id; 
+    firecracker_dma_xfr_t xfr;
+    dma_int_type_t int_type = INT_ALL;
+
+    while (1) {
+
+        /* Get the handle of the transfer that caused the interrupt */
+        int_type = INT_ALL;
+        xfr = firecracker_dma_int_get_xfr(dma, &int_type, NULL);
+        if (xfr == NULL) {
+            break;
+        }
+
+        test_list_xfr_with_interrupts_irq_state++;
+
+        /* Reset the interrupt we are servicing */
+        firecracker_dma_clear_int(xfr, int_type);
+    }
+
+    return IRQ_HANDLED;
+}
+
+
+static void test_list_xfr_with_interrupts(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    firecracker_dma_list_t list;
+    void *dest_vaddr[10];
+    int i;
+    int elms = 10;
+    unsigned int buf_sz = 1024 * 4;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Get the interrupt */
+    if (request_irq(
+            IRQ_DMA_1, &test_list_xfr_with_interrupts_irq,
+            SA_INTERRUPT, "test_list_xfr_with_interrupts", dma) != 0) {
+        FAIL_TEST("request_irq");
+        return;
+    }
+
+    list = firecracker_dma_list_create(dma, elms);
+    if (!list) {
+        FAIL_TEST("firecracker_dma_list_create");
+        return;
+    }
+
+    /* Setup src/dst parameters */
+    src.ahb_master_select = AHB_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_1_TRW;
+    src.auto_reload = 0;
+
+    dst = src;
+
+    /* Setup 10 elements of the list */
+    for (i = 0; i < elms; i++) {
+
+        src.dma_addr = get_dma_buffer(NULL, buf_sz, 1);
+        dst.dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (firecracker_dma_list_add(list, &src, &dst, buf_sz) != 0) {
+            FAIL_TEST("firecracker_dma_list_add");
+            return;
+        }
+    }
+
+    xfr = firecracker_dma_setup_list_xfr(
+            list, NULL, NULL, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_list_xfr");
+        return;
+    }
+
+    firecracker_dma_enable_int(xfr, INT_BLOCK | INT_ERROR | INT_TRANSFER);
+
+    test_list_xfr_with_interrupts_irq_state = 0;
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    wait_a_bit();
+
+#if 0       /* List will stop at the end */
+    if (firecracker_dma_abort(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_abort");
+        return;
+    }
+#endif
+
+    for (i = 0; i < elms; i++) {
+        if (checksum(dest_vaddr[i], buf_sz) != 0) {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    if (test_list_xfr_with_interrupts_irq_state == 0) {
+        FAIL_TEST("No interrupt occurred");
+    }
+
+    /* Destroy the transfer */
+    firecracker_dma_release(xfr);
+
+    /* Destroy the list */
+    if (firecracker_dma_list_destroy(list) != 0) {
+        FAIL_TEST("firecracker_dma_list_destroy");
+        return;
+    }
+
+    free_irq(IRQ_DMA_1, dma);
+
+    printk("%u interrupts received\n", test_list_xfr_with_interrupts_irq_state);
+}
+
+
+static int test_list_xfr_with_interrupts2_irq_state = 0;
+static int tlxwi2_trf_ints = 0;
+static int tlxwi2_block_ints = 0;
+static int tlxwi2_srctrx_ints = 0;
+static int tlxwi2_dsttrx_ints = 0;
+static int tlxwi2_err_ints = 0;
+static unsigned int blocks_left;
+
+static irqreturn_t test_list_xfr_with_interrupts2_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+    firecracker_dma_t dma = (firecracker_dma_t) dev_id; 
+    firecracker_dma_xfr_t xfr;
+    dma_int_type_t int_type;
+
+    /* Repeat the following, for each interrupt type */
+    while (1) {
+
+        /* Get the handle of the transfer that caused the interrupt */
+        int_type = INT_ALL;
+        xfr = firecracker_dma_int_get_xfr(dma, &int_type, NULL);
+        if (xfr == NULL) {
+            break;
+        }
+
+        test_list_xfr_with_interrupts2_irq_state++;
+
+        switch (int_type) {
+            case INT_BLOCK:
+                tlxwi2_block_ints++;
+
+#if 0   /* No-longer needs to handle block interrupts for list->list multi
+           block transfers. Only need to do this when auto-reload or continuous
+           type transfers are involved. */
+            
+                /* The DMA driver needs to handle the block interrupt for 
+                 * proper termination of the list transfer 
+                 */
+                firecracker_dma_handle_block_int(xfr, &blocks_left);
+#else
+                /* track the blocks remaining count to keep the test happy as
+                 * we do not do the firecracker_dma_handle_block_int any more
+                 */
+                blocks_left--;
+#endif
+                break;
+
+            case INT_DST_TRANSACTION:
+                tlxwi2_dsttrx_ints++;
+                break;
+
+            case INT_ERROR:
+                tlxwi2_err_ints++;
+                break;
+
+            case INT_SRC_TRANSACTION:
+                tlxwi2_srctrx_ints++;
+                break;
+
+            case INT_TRANSFER:
+                tlxwi2_trf_ints++;
+                break;
+
+            default:
+                FAIL_TEST("BAD INT TYPE");
+        }
+
+        /* Reset the interrupt we are servicing */
+        firecracker_dma_clear_int(xfr, int_type);
+    }
+
+    return IRQ_HANDLED;
+}
+
+
+static void test_list_xfr_with_interrupts2(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    firecracker_dma_list_t list;
+    void *dest_vaddr[10];
+    int i;
+    int elms = 3;
+    unsigned int buf_sz = 1024 * 4;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Get the interrupt */
+    if (request_irq(
+            IRQ_DMA_1, &test_list_xfr_with_interrupts2_irq,
+            SA_INTERRUPT, "test_list_xfr_with_interrupts2", dma) != 0) {
+        FAIL_TEST("request_irq");
+        return;
+    }
+
+    list = firecracker_dma_list_create(dma, elms);
+    if (!list) {
+        FAIL_TEST("firecracker_dma_list_create");
+        return;
+    }
+
+    /* Setup src/dst parameters */
+    src.ahb_master_select = AHB_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_1_TRW;
+    src.auto_reload = 0;
+
+    dst = src;
+
+    /* Setup 10 elements of the list */
+    for (i = 0; i < elms; i++) {
+
+        src.dma_addr = get_dma_buffer(NULL, buf_sz, 1);
+        dst.dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (firecracker_dma_list_add(list, &src, &dst, buf_sz) != 0) {
+            FAIL_TEST("firecracker_dma_list_add");
+            return;
+        }
+    }
+
+    xfr = firecracker_dma_setup_list_xfr(
+            list, NULL, NULL, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_list_xfr");
+        return;
+    }
+
+    firecracker_dma_enable_int(xfr, INT_BLOCK | INT_ERROR | INT_TRANSFER);
+
+    test_list_xfr_with_interrupts2_irq_state = 0;
+
+    /* Set the blocks counter so that the driver can stop the transfer
+     * when we get to the end of the block list.
+     */
+    blocks_left = elms;
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    wait_a_bit();
+
+    /* The transfer should have stopped by itself. Check that the
+     * remaining blocks counter reached zero.
+     */
+    if (blocks_left != 0) {
+        FAIL_TEST("Blocks left not zero!");
+    }
+
+    for (i = 0; i < elms; i++) {
+        if (checksum(dest_vaddr[i], buf_sz) != 0) {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    if (test_list_xfr_with_interrupts2_irq_state == 0) {
+        FAIL_TEST("No interrupt occurred");
+    }
+
+    if (tlxwi2_srctrx_ints != 0 || tlxwi2_dsttrx_ints != 0) {
+        FAIL_TEST("Unexpected transaction interrupts");
+    }
+
+    if (tlxwi2_trf_ints != 1) {
+        FAIL_TEST("Expected a single transfer complete interrupt");
+    }
+
+    /* Destroy the transfer */
+    firecracker_dma_release(xfr);
+
+    /* Destroy the list */
+    if (firecracker_dma_list_destroy(list) != 0) {
+        FAIL_TEST("firecracker_dma_list_destroy");
+        return;
+    }
+
+    free_irq(IRQ_DMA_1, dma);
+
+    printk("%u total interrupts received\n", test_list_xfr_with_interrupts2_irq_state);
+    printk("%u TRF interrupts received\n", tlxwi2_trf_ints);
+    printk("%u BLOCK interrupts received\n", tlxwi2_block_ints);
+    printk("%u SRC Trans interrupts received\n", tlxwi2_srctrx_ints);
+    printk("%u DST Trans interrupts received\n", tlxwi2_dsttrx_ints);
+    printk("%u ERR interrupts received\n", tlxwi2_err_ints);
+    printk("%u blocks left\n", blocks_left);
+
+}
+
+
+
+static void test_src_sw_handshaking(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024*4, 1);
+    src.ahb_master_select = AHB_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024*4, 0);
+
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, 1024*4, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    /* Request transactions until the transfer stops */
+    while (firecracker_dma_request_transaction(xfr, SRC, NULL) != EINVAL) ;
+
+    if (checksum(dest_vaddr, 1024*4) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+
+
+    firecracker_dma_release(xfr);
+}
+
+
+
+static void test_dst_sw_handshaking(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024*4, 1);
+    src.ahb_master_select = AHB_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024*4, 0);
+
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, 1024*4, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    /* Request transactions until the transfer stops */
+    while (firecracker_dma_request_transaction(xfr, DST, NULL) != EINVAL) ;
+
+    if (checksum(dest_vaddr, 1024*4) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+
+
+    firecracker_dma_release(xfr);
+}
+
+
+static void test_src_dst_sw_handshaking(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024*4, 1);
+    src.ahb_master_select = AHB_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024*4, 0);
+
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, 1024*4, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    /* Request transactions until the transfer stops */
+    while (1) {
+        int rc_s, rc_d;
+        rc_s = firecracker_dma_request_transaction(xfr, SRC, NULL);
+        rc_d = firecracker_dma_request_transaction(xfr, DST, NULL);
+        if (rc_s == EINVAL && rc_d == EINVAL) {
+            break;
+        }
+    }
+
+    if (checksum(dest_vaddr, 1024*4) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+
+
+    firecracker_dma_release(xfr);
+}
+
+
+static void test_src_dst_sw_hand_src_flow_controller(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+    unsigned int bytes_left = 1024;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024, 1);
+    src.ahb_master_select = AHB_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    /* Make the source the flow controller. This means that the source endpoint
+     * will control when the end of a block arrives through the bytes_left 
+     * parameter of the firecracker_dma_request_transaction function.
+     */
+    src.flow_controller = 1;
+    
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, bytes_left, 0);
+
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, bytes_left, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    /* Request transactions until the transfer stops */
+    while (1) {
+        int rc_s, rc_d;
+        rc_s = firecracker_dma_request_transaction(xfr, SRC, &bytes_left);
+        rc_d = firecracker_dma_request_transaction(xfr, DST, NULL);
+        if (rc_s == EINVAL && rc_d == EINVAL) {
+            break;
+        }
+    }
+
+    if (checksum(dest_vaddr, 1024) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+
+
+    firecracker_dma_release(xfr);
+}
+
+
+static void test_src_dst_sw_hand_dst_flow_controller(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+    unsigned int bytes_left;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024, 1);
+    src.ahb_master_select = AHB_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    /* Make the source the flow controller. This means that the source endpoint
+     * will control when the end of a block arrives through the bytes_left 
+     * parameter of the firecracker_dma_request_transaction function.
+     */
+    dst.flow_controller = 1;
+
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024, 0);
+
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, bytes_left, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    /* Request transactions until the transfer stops */
+    bytes_left = 1024;
+    while (1) {
+        int rc_s, rc_d;
+        rc_s = firecracker_dma_request_transaction(xfr, SRC, NULL);
+        rc_d = firecracker_dma_request_transaction(xfr, DST, &bytes_left);
+        if (rc_s == EINVAL && rc_d == EINVAL) {
+            break;
+        }
+    }
+
+    if (checksum(dest_vaddr, 1024) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+
+
+    firecracker_dma_release(xfr);
+}
+
+
+
+static void test_dst_sw_hand_dst_flow_controller(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+    unsigned int bytes_left;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024, 1);
+    src.ahb_master_select = AHB_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    /* Make the source the flow controller. This means that the source endpoint
+     * will control when the end of a block arrives through the bytes_left 
+     * parameter of the firecracker_dma_request_transaction function.
+     */
+    dst.flow_controller = 1;
+
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024, 0);
+
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, bytes_left, 0, NULL);
+
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    /* Request transactions until the transfer stops */
+    bytes_left = 1024;
+    while (1) {
+        int rc_d;
+        rc_d = firecracker_dma_request_transaction(xfr, DST, &bytes_left);
+        if (rc_d == EINVAL) {
+            break;
+        }
+    }
+
+    if (checksum(dest_vaddr, 1024) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+
+
+    firecracker_dma_release(xfr);
+}
+
+
+static void test_src_dst_sw_handshaking_block_sizes(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+    void *src_vaddr;
+    unsigned int bsize;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, 1024*4, 1);
+    src.ahb_master_select = AHB_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024*4, 0);
+
+    /* Test block sizes 1 to 512 */
+    for (bsize = 4; bsize < 512; bsize += 4) {
+
+        memset(dest_vaddr, 0xbe, 1024*4);
+
+        xfr = firecracker_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL);
+
+        if (!xfr) {
+            FAIL_TEST("firecracker_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (firecracker_dma_start(xfr) != 0) {
+            FAIL_TEST("firecracker_dma_start");
+            break;
+        }
+
+        /* Request transactions until the transfer stops */
+        while (1) {
+            int rc_s, rc_d;
+            rc_s = firecracker_dma_request_transaction(xfr, SRC, NULL);
+            rc_d = firecracker_dma_request_transaction(xfr, DST, NULL);
+            if (rc_s == EINVAL && rc_d == EINVAL) {
+                break;
+            }
+        }
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0) {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        firecracker_dma_release(xfr);
+    }
+
+    if (bsize < 512) {
+        printk("Failed at block size %u\n", bsize);
+    }
+}
+
+
+
+
+static void test_src_dst_sw_handshaking_src_fc_block_sizes(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+    void *src_vaddr;
+    unsigned int bsize;
+    unsigned int bytes_left;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, 1024, 1);
+    src.ahb_master_select = AHB_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    /* Make the source the flow controller. This means that the source endpoint
+     * will control when the end of a block arrives through the bytes_left 
+     * parameter of the firecracker_dma_request_transaction function.
+     */
+    src.flow_controller = 1;
+    
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024, 0);
+
+    /* Test block sizes 1 to 512 */
+    for (bsize = 4; bsize < 512; bsize += 4) {
+
+        memset(dest_vaddr, 0xbe, 1024*4);
+
+        xfr = firecracker_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL);
+
+        if (!xfr) {
+            FAIL_TEST("firecracker_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (firecracker_dma_start(xfr) != 0) {
+            FAIL_TEST("firecracker_dma_start");
+            break;
+        }
+
+        /* Request transactions until the transfer stops */
+        bytes_left = bsize;
+        while (1) {
+            int rc_s, rc_d;
+            rc_s = firecracker_dma_request_transaction(xfr, SRC, &bytes_left);
+            rc_d = firecracker_dma_request_transaction(xfr, DST, NULL);
+            if (rc_s == EINVAL && rc_d == EINVAL) {
+                break;
+            }
+        }
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0) {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        firecracker_dma_release(xfr);
+    }
+
+    if (bsize < 512) {
+        printk("Failed at block size %u\n", bsize);
+    }
+}
+
+
+
+
+static void test_src_sw_handshaking_src_fc_block_sizes(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+    void *src_vaddr;
+    unsigned int bsize;
+    unsigned int bytes_left;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, 1024, 1);
+    src.ahb_master_select = AHB_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    /* Make the source the flow controller. This means that the source endpoint
+     * will control when the end of a block arrives through the bytes_left 
+     * parameter of the firecracker_dma_request_transaction function.
+     */
+    src.flow_controller = 1;
+    
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+    dst.periph_not_mem = 0;
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024, 0);
+
+    /* Test block sizes 1 to 512 */
+    for (bsize = 4; bsize < 512; bsize += 4) {
+
+        memset(dest_vaddr, 0xbe, 1024*4);
+
+        xfr = firecracker_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL);
+
+        if (!xfr) {
+            FAIL_TEST("firecracker_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (firecracker_dma_start(xfr) != 0) {
+            FAIL_TEST("firecracker_dma_start");
+            break;
+        }
+
+        /* Request transactions until the transfer stops */
+        bytes_left = bsize;
+        while (1) {
+            int rc_s;
+            rc_s = firecracker_dma_request_transaction(xfr, SRC, &bytes_left);
+            if (rc_s == EINVAL) {
+                break;
+            }
+        }
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0) {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        firecracker_dma_release(xfr);
+    }
+
+    if (bsize < 512) {
+        printk("Failed at block size %u\n", bsize);
+    }
+}
+
+
+
+
+static void test_src_dst_sw_handshaking_dst_fc_block_sizes(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+    void *src_vaddr;
+    unsigned int bsize;
+    unsigned int bytes_left;
+        
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, 1024, 1);
+    src.ahb_master_select = AHB_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    /* Make the source the flow controller. This means that the source endpoint
+     * will control when the end of a block arrives through the bytes_left 
+     * parameter of the firecracker_dma_request_transaction function.
+     */
+    dst.flow_controller = 1;
+    
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024, 0);
+
+    /* Test block sizes 1 to 512 */
+    for (bsize = 4; bsize < 512; bsize += 4) {
+
+        memset(dest_vaddr, 0xbe, 1024*4);
+
+        xfr = firecracker_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL);
+
+        if (!xfr) {
+            FAIL_TEST("firecracker_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (firecracker_dma_start(xfr) != 0) {
+            FAIL_TEST("firecracker_dma_start");
+            break;
+        }
+
+        /* Request transactions until the transfer stops */
+        bytes_left = bsize;
+        while (1) {
+            int rc_s, rc_d;
+            rc_s = firecracker_dma_request_transaction(xfr, SRC, NULL);
+            rc_d = firecracker_dma_request_transaction(xfr, DST, &bytes_left);
+            if (rc_s == EINVAL && rc_d == EINVAL) {
+                break;
+            }
+        }
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0) {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        firecracker_dma_release(xfr);
+    }
+
+    if (bsize < 512) {
+        printk("Failed at block size %u\n", bsize);
+    }
+}
+
+
+
+static int test_src_dst_sw_handshaking_int_state = 0;
+
+static irqreturn_t test_src_dst_sw_handshaking_int_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+    firecracker_dma_t dma = (firecracker_dma_t) dev_id; 
+    firecracker_dma_xfr_t xfr;
+    dma_int_type_t int_type = INT_ALL;
+
+    /* Repeat the following, for each interrupt type */
+    while (1) {
+
+        /* Get the handle of the transfer that caused the interrupt */
+        int_type = INT_ALL;
+        xfr = firecracker_dma_int_get_xfr(dma, &int_type, NULL);
+        if (xfr == NULL) {
+            /* No more interrupts to service, exit */
+            break;
+        }
+
+        test_src_dst_sw_handshaking_int_state++;
+
+        switch (int_type) {
+            case INT_BLOCK:
+                tlxwi2_block_ints++;
+                break;
+
+            case INT_DST_TRANSACTION:
+                tlxwi2_dsttrx_ints++;
+                /* Service the destination transaction complete interrupt
+                 * by requesting a new transaction
+                 */
+                if (firecracker_dma_request_transaction(xfr, DST, NULL) == EBUSY) {
+                    FAIL_TEST("firecracker_dma_request_transaction Busy");
+                }
+                
+                break;
+
+            case INT_ERROR:
+                tlxwi2_err_ints++;
+                break;
+
+            case INT_SRC_TRANSACTION:
+                tlxwi2_srctrx_ints++;
+                /* Service the source transaction complete interrupt
+                 * by requesting a new transaction
+                 */
+                if (firecracker_dma_request_transaction(xfr, SRC, NULL) == EBUSY) {
+                    FAIL_TEST("firecracker_dma_request_transaction Busy");
+                }
+                
+                break;
+
+            case INT_TRANSFER:
+                tlxwi2_trf_ints++;
+                break;
+
+            default:
+                FAIL_TEST("BAD INT TYPE");
+        }
+
+        /* Reset the interrupt we are servicing */
+        firecracker_dma_clear_int(xfr, int_type);
+    }
+
+    return IRQ_HANDLED;
+}
+
+
+static void test_src_dst_sw_handshaking_int(void)
+{
+    firecracker_dma_t dma;
+    firecracker_dma_xfr_t xfr;
+    firecracker_dma_endpoint_t src, dst;
+    void *dest_vaddr;
+        
+    tlxwi2_trf_ints = 0;
+    tlxwi2_block_ints = 0;
+    tlxwi2_srctrx_ints = 0;
+    tlxwi2_dsttrx_ints = 0;
+    tlxwi2_err_ints = 0;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(0);
+    if (TEST_FAILED) return;
+
+    /* Get the interrupt */
+    if (request_irq(
+            IRQ_DMA_1, &test_src_dst_sw_handshaking_int_irq,
+            SA_INTERRUPT, "test_src_dst_sw_handshaking_int_irq", dma) != 0) {
+        FAIL_TEST("request_irq");
+        return;
+    }
+
+    /* Setup src/dst parameters */
+    src.dma_addr = get_dma_buffer(NULL, 1024*4, 1);
+    src.ahb_master_select = AHB_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = INCREMENT;
+    src.tr_width = TR_WIDTH32;
+    src.msize = MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.ahb_master_select = AHB_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = INCREMENT;
+    dst.tr_width = TR_WIDTH32;
+    dst.msize = MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, 1024*4, 0);
+
+    xfr = firecracker_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, 1024*4, 0, NULL);
+    if (!xfr) {
+        FAIL_TEST("firecracker_dma_setup_direct_xfr");
+        return;
+    }
+
+    firecracker_dma_enable_int(xfr, 
+            INT_DST_TRANSACTION | INT_SRC_TRANSACTION | INT_ERROR | INT_TRANSFER);
+
+    if (firecracker_dma_start(xfr) != 0) {
+        FAIL_TEST("firecracker_dma_start");
+        return;
+    }
+
+    /* Start the process by requesting the first transactions, When these
+     * are complete, the interrupt will trigger subsequent ones
+     */
+    firecracker_dma_request_transaction(xfr, SRC, NULL);
+    firecracker_dma_request_transaction(xfr, DST, NULL);
+
+    wait_a_bit();
+
+    if (checksum(dest_vaddr, 1024*4) != 0) {
+        FAIL_TEST("Checksum destination");
+    }
+
+    if (tlxwi2_trf_ints != 1) {
+        FAIL_TEST("Expected a single transfer complete interrupt");
+    }
+
+    free_irq(IRQ_DMA_1, dma);
+    firecracker_dma_release(xfr);
+
+    printk("%u total interrupts received\n", test_src_dst_sw_handshaking_int_state);
+    printk("%u TRF interrupts received\n", tlxwi2_trf_ints);
+    printk("%u BLOCK interrupts received\n", tlxwi2_block_ints);
+    printk("%u SRC Trans interrupts received\n", tlxwi2_srctrx_ints);
+    printk("%u DST Trans interrupts received\n", tlxwi2_dsttrx_ints);
+    printk("%u ERR interrupts received\n", tlxwi2_err_ints);
+
+
+}
+
+
+typedef void (*tf)(void);
+
+/* Array of tests */
+static struct test_tag {
+    char name[200];
+    tf test_fn;
+} tests[] = {
+    {"Simple direct transfer test", test_direct_xfr},
+    {"List to list transfer test", test_list_list_xfr},
+    {"Simple direct transfer test with interrupts", test_direct_xfr_with_interrupts},
+    {"List to list transfer test with interrupts", test_list_xfr_with_interrupts},
+    {"List to list transfer test with interrupts and block control", test_list_xfr_with_interrupts2},
+    {"Simple direct transfers of various block sizes", test_xfr_block_sizes},
+    {"Simple direct transfer using source software handshaking", test_src_sw_handshaking},
+    {"Simple direct transfer using destination software handshaking", test_dst_sw_handshaking},
+    {"Simple direct transfer using source and destination software handshaking", test_src_dst_sw_handshaking},
+    {"Simple direct transfer using source and destination software handshaking controlled by interrupts", test_src_dst_sw_handshaking_int},
+    {"Simple direct transfer, src/dst sw handshaking, various block sizes", test_src_dst_sw_handshaking_block_sizes},
+    {"Simple direct transfer, src/dst sw handshaking, source flow controller", test_src_dst_sw_hand_src_flow_controller},
+    {"Simple direct transfer, src/dst sw handshaking, dest flow controller", test_src_dst_sw_hand_dst_flow_controller},
+    {"Simple direct transfer, src/dst sw handshaking, source FC & various block sizes", test_src_dst_sw_handshaking_src_fc_block_sizes},
+    {"Simple direct transfer, src/dst sw handshaking, desc FC & various block sizes", test_src_dst_sw_handshaking_dst_fc_block_sizes},
+    {"Simple direct transfer, dst sw handshaking, dest flow controller", test_dst_sw_hand_dst_flow_controller},
+    {"Simple direct transfer, src sw handshaking, source FC & various block sizes", test_src_sw_handshaking_src_fc_block_sizes},
+    {"Reload Block to list transfer test", test_reload_to_list_xfr},
+    {"List to list transfer test, reuse list", test_list_list_xfr_reuse_list},
+    {"Simple direct transfer test using hardware handshaking", test_direct_xfr_hw_handshaking},
+    {"Single element list to list transfer test", test_single_element_list_list_xfr},
+};
+
+#define NUM_TESTS (sizeof(tests) / sizeof(struct test_tag))
+
+
+int run_tests(void)
+{
+    int res = PASS;
+
+    for (testnumi = 0; testnumi < NUM_TESTS; testnumi++) {
+        printk(KERN_INFO "dmat: <%u> START %s\n", testnumi, tests[testnumi].name);
+
+        RESET_TEST_RES();
+        
+        tests[testnumi].test_fn();
+
+        printk(KERN_INFO "dmat: TEST <%u> %s\n", testnumi,
+                (test_state == FAIL) ? "FAILED" : "PASSED");
+
+        if (test_state == FAIL) {
+            res = FAIL;
+        }
+            
+    }
+
+    if (res == PASS) {
+        printk(KERN_INFO "dmat: Passed all tests.\n");
+    }
+    else {
+        printk(KERN_INFO "dmat: FAILED SOME TESTS!!\n");
+    }
+
+    return PASS;
+}
+
+
+
+
+static int dmac_test_drv_probe(struct platform_device *pdev)
+{
+    device = &pdev->dev;
+
+    run_tests();
+
+    return 0;
+}
+
+
+static int dmac_test_drv_remove(struct platform_device *pdev)
+{
+    return 0;
+}
+
+
+#define CARDNAME "pc20x-dmac-test"
+static struct platform_driver dmac_test_driver = {
+    .probe      = dmac_test_drv_probe,
+    .remove     = dmac_test_drv_remove,
+    .driver     = {
+        .name   = CARDNAME,
+    }
+};
+
+
+static int firecracker_dma_test_module_init(void)
+{
+    int ret;
+
+    ret = platform_driver_register(&dmac_test_driver);
+    if (ret != 0) {
+        printk("Failed to register DMAC test driver\n");
+        return ret;
+    }
+
+    printk(KERN_INFO "DMAC test loaded\n");
+
+    return ret;
+}
+
+
+static void firecracker_dma_test_module_exit(void)
+{
+    platform_driver_unregister(&dmac_test_driver);
+}
+
+module_init(firecracker_dma_test_module_init);
+module_exit(firecracker_dma_test_module_exit);
+
+
+
diff --git a/arch/arm/mach-firecracker/firecracker_core.c b/arch/arm/mach-firecracker/firecracker_core.c
new file mode 100644
index 0000000..5bd09ea
--- /dev/null
+++ b/arch/arm/mach-firecracker/firecracker_core.c
@@ -0,0 +1,565 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ *  linux/arch/arm/mach-firecracker/firecracker_core.c
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <mach/dma.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/div64.h>
+#include <linux/cnt32_to_63.h>
+#include <linux/mm.h>
+#include <linux/sched.h>	/* just for sched_clock() - funny that */
+#include <linux/bug.h>
+
+#include "core.h"
+
+
+/* Converts a physical address number into a pointer to the virtual location */
+#define _ioa(n)     __io(IO_ADDRESS(n))
+
+
+/* INTERRUPTS:
+ */
+static void firecracker_mask_irq(u32 irq)
+{
+    u32 mask = ioread32(_ioa(PC20X_VIC_BASE + VIC_ENABLE_REG_OFFSET));
+
+    mask &= ~(1 << irq);
+
+    iowrite32(mask, _ioa(PC20X_VIC_BASE + VIC_ENABLE_REG_OFFSET));
+}
+
+static void firecracker_unmask_irq(u32 irq)
+{
+    u32 mask = ioread32(_ioa(PC20X_VIC_BASE + VIC_ENABLE_REG_OFFSET));
+
+    mask |= (1 << irq);
+
+    iowrite32(mask, _ioa(PC20X_VIC_BASE + VIC_ENABLE_REG_OFFSET));
+}
+
+static struct irq_chip firecracker_vic_chip = {
+    .ack    = firecracker_mask_irq, /* Level triggering -> mask is ack */
+    .mask   = firecracker_mask_irq,
+    .unmask = firecracker_unmask_irq,
+    /* NOTE - We have the opportunity to use the retrigger method by setting
+     * a bit in the force register. No other platforms do this and I am not
+     * sure of its value so I will leave it.
+     */
+};
+
+
+void __init firecracker_init_irq(void)
+{
+    unsigned int irq;
+
+    /* Disable all interrupts initially. */
+    iowrite32(0, _ioa(PC20X_VIC_BASE + VIC_ENABLE_REG_OFFSET));
+
+    /* Unmask all, and use the enable bits to control */
+    iowrite32(0, _ioa(PC20X_VIC_BASE + VIC_MASK_REG_OFFSET));
+
+    /*
+     * Make sure we clear all existing interrupts...
+     * As interrupts are asserted by peripherals, individual driver code
+     * should ensure the interrupts are initially cleared.
+     */
+
+    /*
+     * Set up the interrupt helper functions for the interrupts
+     */
+    for (irq = 0; irq < NR_IRQS; irq++) {
+
+        set_irq_chip(irq, &firecracker_vic_chip);
+
+        /* Skip interrupts that are unused */
+        if (VIC_USED_IRQ_MASK & (1 << irq)) {
+            set_irq_handler(irq, handle_level_irq);
+            set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+        }
+    }
+}
+
+
+/* IO MAPPING:
+ */
+
+static struct map_desc firecracker_io_desc[] __initdata = {
+
+    /* For simplicity, create one big mapping that covers all the peripherals 
+     * at PA range 0xffe00000 - 0xffffffff to VA range 0xfee00000 - 0xfeffffff 
+     */
+    {
+        .virtual    =  IO_ADDRESS(PC20X_PERIPH_BASE),
+        .pfn        = __phys_to_pfn(PC20X_PERIPH_BASE),
+        .length     = PC20X_PERIPH_LENGTH,
+        .type       = MT_DEVICE
+    }
+};
+
+void __init firecracker_map_io(void)
+{
+    iotable_init(firecracker_io_desc, ARRAY_SIZE(firecracker_io_desc));
+}
+
+
+/* EMAC/PHY:
+ */
+static void emac_platform_release(struct device *dev)
+{
+    /* This function is intentionally left blank. */
+}
+
+static struct resource emac_resources[] =
+{
+    {
+        .start  = PC20X_EMAC_BASE,
+        .end    = PC20X_EMAC_BASE + 0x1FFF,
+        .flags  = IORESOURCE_MEM,
+    },
+    {
+        .start  = IRQ_EMAC,
+        .end    = IRQ_EMAC,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device emac_device = 
+{
+    .name = "pc20x-emac",
+    .id = 0,
+    .dev =
+    {
+        .coherent_dma_mask = 0xffffffff,
+        .release = emac_platform_release,
+    },
+    .num_resources = ARRAY_SIZE(emac_resources),
+    .resource = emac_resources,
+};
+
+static struct platform_device mii_device = {
+    .name       = "pc20x-mii",
+    .id         = -1,
+};
+
+
+/* UARTS:
+ */
+static struct plat_serial8250_port serial_platform_data[] = {
+    {
+        .membase    = (char*)IO_ADDRESS(PC20X_UART1_BASE),
+        .mapbase    = (unsigned long)PC20X_UART1_BASE,
+        .irq        = IRQ_UART_0,
+        .flags      = UPF_BOOT_AUTOCONF,
+        .iotype     = UPIO_MEM32,
+        .regshift   = 2,
+        .uartclk    = FIRECRACKER_BASE_BAUD,
+    },
+    {
+        .membase    = (char*)IO_ADDRESS(PC20X_UART2_BASE),
+        .mapbase    = (unsigned long)PC20X_UART2_BASE,
+        .irq        = IRQ_UART_1,
+        .flags      = UPF_BOOT_AUTOCONF,
+        .iotype     = UPIO_MEM32,
+        .regshift   = 2,
+        .uartclk    = FIRECRACKER_BASE_BAUD,
+    },
+    { },
+};
+
+static struct platform_device serial_device = {
+    .name           = "serial8250",
+    .id             = 0,
+    .dev            = {
+        .platform_data = serial_platform_data,
+    },
+};
+
+
+/* DMA:
+ */
+
+static struct plat_firecracker_dma dmac_platform_data[] = {
+    {
+        .membase    = (char*)IO_ADDRESS(PC20X_DMAC1_BASE),
+    },
+    {
+        .membase    = (char*)IO_ADDRESS(PC20X_DMAC2_BASE),
+    },
+    { },
+};
+
+
+static struct platform_device dmac_device0 = {
+    .name           = "pc20x-dmac",
+    .id             = 0,
+    .dev            = {
+		.coherent_dma_mask = 0xffffffff,
+        .platform_data = &dmac_platform_data[0],
+    },
+};
+
+static struct platform_device dmac_device1 = {
+    .name           = "pc20x-dmac",
+    .id             = 1,
+    .dev            = {
+		.coherent_dma_mask = 0xffffffff,
+        .platform_data = &dmac_platform_data[1],
+    },
+};
+
+
+#ifdef CONFIG_FIRECRACKER_DMA_TEST
+static struct platform_device dmac_test_device = {
+    .name           = "pc20x-dmac-test",
+    .id             = 0,
+    .dev            = {
+		.coherent_dma_mask = 0xffffffff,
+    },
+};
+#endif
+
+struct resource pa0_resources[] = {
+    {
+        .start = PC20X_PROCIF_BASEP,
+        .end = PC20X_PROCIF_BASEP + 0x7f,
+        .flags = IORESOURCE_MEM,
+        .name = "procif",
+    },
+    {
+        .start = 0xfff80000,
+        .end = 0xfff80000 + 0x3ffff,
+        .flags = IORESOURCE_MEM,
+        .name = "dma_base",
+    },
+    {
+        .start = PC20X_AHB_2_PICO_BASE,
+        .end = PC20X_AHB_2_PICO_BASE + 0x1ff,
+        .flags = IORESOURCE_MEM,
+        .name = "ahb2pico_axi2pico",
+    },
+    {
+        .start = PC02X_CHIP_CONTROL,
+        .end = PC02X_CHIP_CONTROL + 0x3,
+        .flags = IORESOURCE_MEM,
+        .name = "ccr_base",
+    },
+    {
+        .start = IRQ_PROCIF,
+        .end = IRQ_PROCIF,
+        .flags = IORESOURCE_IRQ,
+        .name = "procif_irq",
+    },
+    {
+        .start = IRQ_PICOARRAY_GPR,
+        .end = IRQ_PICOARRAY_GPR,
+        .flags = IORESOURCE_IRQ,
+        .name = "gpr_irq",
+    },
+    {
+        .start = IRQ_DMA_1,
+        .end = IRQ_DMA_1,
+        .flags = IORESOURCE_IRQ,
+        .name = "dma1_irq",
+    },
+    {
+        .start = IRQ_DMA_2,
+        .end = IRQ_DMA_2,
+        .flags = IORESOURCE_IRQ,
+        .name = "dma2_irq",
+    },
+};
+
+static struct platform_device pa0 = {
+    .name           = "picoArray",
+    .id             = 0,
+    .dev            = {
+                .coherent_dma_mask = 0xffffffff,
+    },
+    .resource       = pa0_resources,
+    .num_resources  = ARRAY_SIZE(pa0_resources),
+};
+
+/* GPIO */
+static void
+pc202gpio_platform_release( struct device *dev )
+{
+    /* This function is intentionally left blank. */
+}
+
+static struct resource pc202gpio_resources[] = {
+    {
+        .start = PC20X_GPIO_BASE,
+        .end   = PC20X_GPIO_BASE + 0xFFFF,
+        .flags = IORESOURCE_MEM,
+    },
+};
+
+static struct platform_device pc202gpio_device = {
+    .name = "pc202gpio",
+    .id = -1,
+    .dev = {
+        .release = pc202gpio_platform_release,
+    },
+    .resource = pc202gpio_resources,
+    .num_resources = ARRAY_SIZE( pc202gpio_resources ),
+};
+
+void __init firecracker_init(void)
+{
+    platform_device_register(&serial_device);
+    platform_device_register(&mii_device);
+    platform_device_register(&emac_device);
+    platform_device_register(&dmac_device0);
+    platform_device_register(&dmac_device1);
+    platform_device_register(&pc202gpio_device);
+    platform_device_register(&pa0);
+
+#ifdef CONFIG_FIRECRACKER_DMA_TEST
+    platform_device_register(&dmac_test_device);
+#endif
+}
+
+/* TIMERS: */
+
+/* clock_tick_rate is the tick rate set at runtime. RT_LATCH is the derived timer reload
+ * latch value.
+ */
+static unsigned long clock_tick_rate = PC72052_I10_REVB_TIMER_FREQ;
+#define RT_LATCH() ((clock_tick_rate + HZ/2) / HZ)
+
+/* Use timer 0 for the linux tick */
+#define TICK_TIMER 0
+#define TICK_TIMER_IRQ IRQ_TIMER_0
+
+/* Default values suit the 140MHz RevB clock. These are adjusted by the initialisation 
+ * code below.
+ */
+/* the <<1 gets rid of the cnt_32_to_63 top bit saving on a bic insn
+ * in the sched_clock function
+ */
+static unsigned long sched_clock_rtc_multiplier = 50<<1;
+static unsigned long sched_clock_rtc_divisor = 7<<1;
+
+/*
+ * This is the Firecracker sched_clock implementation.  
+ *
+ * RevB uses a 140MHz timer which gives us
+ * a resolution of 7.1ns, and a maximum value of about  ?? (Many years!)
+ *
+ * The return value is guaranteed to be monotonic in that range as long as
+ * there is always less than 15 seconds for RevB between successive calls to
+ * this function.
+ */
+unsigned long long sched_clock(void)
+{
+	unsigned long long v = 
+        cnt32_to_63(ioread32(_ioa(PC20X_RTC_CLK_BASE + 
+                        RTC_CURRECT_COUNTER_VALUE_REG_OFFSET)));
+
+	/* the <<1 gets rid of the cnt_32_to_63 top bit saving on a bic insn */
+	v *= sched_clock_rtc_multiplier;
+	do_div(v, sched_clock_rtc_divisor);
+
+	return v;
+}
+
+/*
+ * Returns number of microseconds since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset().
+ *
+ */
+static unsigned long firecracker_gettimeoffset(void)
+{
+    u32 cur_ticks, last_ticks, status;
+
+    /*
+     * Get the current number of ticks since the reload.  
+     * Note that there is a race condition between us reading the timer and checking for
+     * an interrupt.  We get around this by ensuring that the counter has not reloaded
+     * between our two reads.
+     */
+    cur_ticks = RT_LATCH() - ioread32(
+            _ioa(PC20X_TIMERS_BASE + TIMER_N_CURRENT_VALUE_REG_OFFSET(TICK_TIMER)));
+    do {
+        last_ticks = cur_ticks;
+
+        status = ioread32(
+                _ioa(PC20X_TIMERS_BASE + TIMER_N_INTERRUPT_STATUS_REG_OFFSET(TICK_TIMER)));
+
+        cur_ticks = RT_LATCH() - ioread32(
+                _ioa(PC20X_TIMERS_BASE + TIMER_N_CURRENT_VALUE_REG_OFFSET(TICK_TIMER)));
+
+    } while (last_ticks > cur_ticks);
+
+    /* We should have the number of ticks since the last interrupt in cur_ticks.
+     * Adjust the value if a roll-over occurred while interrupts have been disabled.
+     * Return the resultant time since the last tick.
+     */
+    if (status)
+    {
+        cur_ticks += RT_LATCH();
+    }
+
+    return (cur_ticks / (clock_tick_rate / 1000000));
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t firecracker_timer_interrupt(int irq, void *dev_id)
+{
+    // ...clear the interrupt
+    ioread32(_ioa(PC20X_TIMERS_BASE + TIMER_N_EOI_REG_OFFSET(TICK_TIMER)));
+
+    timer_tick();
+
+    return IRQ_HANDLED;
+}
+
+static struct irqaction firecracker_timer_irq = {
+    .name       = "pc20x Timer Tick",
+    .flags      = IRQF_DISABLED | IRQF_TIMER,
+    .handler    = firecracker_timer_interrupt,
+};
+
+/*
+ * Set up the timer and interrupt.
+ */
+static void __init firecracker_timer_init(void)
+{
+    clock_tick_rate = PC72052_I10_REVB_TIMER_FREQ;
+    sched_clock_rtc_multiplier = 50<<1;
+    sched_clock_rtc_divisor = 7<<1;
+
+    /* Start with the timer disabled */
+    iowrite32(0, 
+            _ioa(PC20X_TIMERS_BASE + TIMER_N_CONTROL_REG_OFFSET(TICK_TIMER)));
+
+    /* Set the reload count that gives us the desired interrupt frequency */
+    iowrite32(RT_LATCH(), 
+            _ioa(PC20X_TIMERS_BASE + TIMER_N_LOAD_COUNT_REG_OFFSET(TICK_TIMER)));
+    
+    /* Set user defined count mode, unmask interrupt and enable the timer */
+    iowrite32((TIMER_ENABLE | TIMER_MODE), 
+            _ioa(PC20X_TIMERS_BASE + TIMER_N_CONTROL_REG_OFFSET(TICK_TIMER)));
+
+    /* Make irqs happen for the system timer */
+    setup_irq(TICK_TIMER_IRQ, &firecracker_timer_irq);
+}
+
+struct sys_timer firecracker_timer = {
+    .init       = firecracker_timer_init,
+    .offset     = firecracker_gettimeoffset,
+};
+
+
+/* Pointer to the memory info held here so that we have access from the 
+ * command line parsing. NOTE: This is horrid.
+ */
+static struct meminfo *meminfo __initdata;
+
+/* Reset the memory information to the specified firecracker fragmented
+ * memory map.  The memory map is specified as a size and a start address.
+ *
+ * The start address should be one of:
+ *
+ * 0x00000000 - DDR Bank 0
+ * 0x04000000 - DDR Bank 1
+ * 0x08000000 - DDR Bank 2
+ * 0x0c000000 - DDR Bank 3 
+ */
+static void __init set_firecracker_frag_mem(u32 size, u32 start)
+{
+    meminfo->bank[meminfo->nr_banks].start = PAGE_ALIGN(start);
+    meminfo->bank[meminfo->nr_banks].size = size & PAGE_MASK;
+    meminfo->bank[meminfo->nr_banks].node = PHYS_TO_NID(start);
+    meminfo->nr_banks++;               
+}
+
+/*
+ * Pick out the memory size.  We look for pc20x_mem=size@startAddress,
+ * where size is "size[KkMm]".
+ */
+static void __init early_firecracker_mem(char **p)
+{
+    static int usermem __initdata = 0;
+        
+    u32 size, start;
+    
+    /* Default value */
+    start = FIRECRACKER_RAM_START;
+	
+    /*
+     * If the user specifies memory size, we
+     * blow away any automatically generated
+     * size.
+     */
+    if (usermem == 0) {
+        usermem = 1;
+	meminfo->nr_banks = 0;
+    }
+        
+    size  = memparse(*p, p);
+
+    if (**p == '@')
+        start = memparse(*p + 1, p);
+       
+    set_firecracker_frag_mem(size, start);
+}
+__early_param("pc20x_mem=", early_firecracker_mem);
+
+
+/* Fixup function that is implemented so that we have a chance to pass the
+ * sparse physical ram memory mapping to the kernel at bootup.
+ */
+void __init firecracker_fixup(
+        struct machine_desc *md,
+        struct tag *tag,
+        char ** from,
+        struct meminfo *mi)
+{
+
+    u32 startAddress, i;
+    
+    /* Record the pointer to the meminfo for the command line parsing later */
+    meminfo = mi;
+    
+    /* At kernel boot up we initialise all four DDR RAM Banks.
+     * If the user is utilising a 2 Bank DDR design or a design that requires different 
+     * DDR Bank sizes for the kernel, then the memory requirements will need to be
+     * specified on the command line at kernel boot time.
+     *
+     * Check out the pc20x_mem command line option for more information.
+     */
+       
+    startAddress = FIRECRACKER_RAM_START;
+
+    for (i = 0; i < FIRECRACKER_RAM_BANKS; i++)
+    {
+        set_firecracker_frag_mem(SZ_16M, startAddress); 
+        startAddress += FIRECRACKER_RAM_BANK_STRIDE;
+    }
+                           
+}
+
diff --git a/arch/arm/mach-firecracker/firecracker_cpe.c b/arch/arm/mach-firecracker/firecracker_cpe.c
new file mode 100644
index 0000000..be93334
--- /dev/null
+++ b/arch/arm/mach-firecracker/firecracker_cpe.c
@@ -0,0 +1,158 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ *  linux/arch/arm/mach-firecracker/firecracker_cpe.c
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/amba/bus.h>
+#include <linux/picochip/fpga_cpe20x.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+#include <mach/spi-gpio.h>
+#include <mach/pc20x/gpio.h>
+#include <mach/gpio_assignment.h>
+
+/* PC20x gpio assignments */
+#include <linux/picochip/devices/pc202.h>
+
+#include <asm/mach/arch.h>
+
+#include <linux/i2c-gpio.h>
+
+#include "core.h"
+
+
+/* SPI:
+*/
+
+static struct fpga_platform_data rc_fpga_pdata = {
+    .fpga_device_id     = FPGA_RC_ID,
+};
+
+static struct fpga_platform_data ad_fpga_pdata = {
+    .fpga_device_id     = FPGA_AD_ID,
+};
+
+/* Note: The FPGA SPI can go up to 40MHz in theory but our bit-banged
+ * driver will never get as fast as that. I set 20MHz for safety, the
+ * bit-banged driver will go as fast as it can (zero delay).
+ */
+static struct spi_board_info firecracker_cpe_spi_board_info[] = {
+    [0] = { /* AD FPGA */
+        .modalias       = "fpga_cpe20x",
+        .bus_num        = 0,
+        .chip_select    = 0,
+        .max_speed_hz   = 20000000,
+        .platform_data  = &ad_fpga_pdata,
+    },
+    [1] = { /* RC_FPGA */
+        .modalias       = "fpga_cpe20x",
+        .bus_num        = 0,
+        .chip_select    = 1,
+        .max_speed_hz   = 20000000,
+        .platform_data  = &rc_fpga_pdata,
+    },
+};
+
+
+static struct firecracker_spigpio_info spi_platform_data = {
+    /* Pin mapping taken from PC7205-2 Register Map */
+    .pin_clk        = ARM_GPIO_SPI_CLK,
+    .pin_mosi       = ARM_GPIO_SPI_MOSI,
+    .pin_miso       = ARM_GPIO_SPI_MISO,
+    .pin_cs         = ARM_GPIO_SPI_CS0 | ARM_GPIO_SPI_CS1,
+    .board_size     = ARRAY_SIZE(firecracker_cpe_spi_board_info),
+    .board_info     = firecracker_cpe_spi_board_info,
+};
+
+
+static struct platform_device spi_device = {
+    .name           = "pc20x-spi-gpio",
+    .id             = 0,
+    .dev            = {
+        .coherent_dma_mask = 0xffffffff,
+        .platform_data = &spi_platform_data,
+    },
+};
+
+/* I2C:
+ */
+
+static struct i2c_gpio_platform_data i2c_gpio_data = {
+        .sda_pin	= PC202_GPIO_PIN_SDGPIO_14,
+        .scl_pin	= PC202_GPIO_PIN_SDGPIO_15,
+        .sda_is_open_drain  = 0,
+        .scl_is_open_drain  = 1,
+        .scl_is_output_only = 1,
+        .udelay = 1,
+};
+
+static struct platform_device pc202_i2c_device = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &i2c_gpio_data,
+	},
+};
+
+static int __init firecracker_cpe_init(void)
+{
+    if ( machine_is_pc72052_i10_revb() || machine_is_pc7802() ) {
+
+        platform_device_register(&spi_device);
+    }
+
+    if ( machine_is_pc7802() ) {
+        platform_device_register(&pc202_i2c_device);
+    }
+
+        return 0;
+}
+
+arch_initcall(firecracker_cpe_init);
+
+#if defined(CONFIG_MACH_PC72052_I10_REVB)
+/* MACH_TYPE_PC72052_I10_REVB */
+MACHINE_START(PC72052_I10_REVB, "pc7205-2 1.0. Rev B BOM")
+    /* Maintainer: picoChip */
+    .phys_io        = 0xffe00000,
+    .io_pg_offst    = ((0xfee00000) >> 18) & 0xfffc,
+    .boot_params    = 0x00000100,
+    .map_io         = firecracker_map_io,
+    .init_irq       = firecracker_init_irq,
+    .timer          = &firecracker_timer,
+    .init_machine   = firecracker_init,
+    .fixup          = firecracker_fixup,
+MACHINE_END
+#endif
+
+#if defined(CONFIG_MACH_PC7802)
+/* MACH_TYPE_PC7802 */
+MACHINE_START(PC7802, "pc7802 Platform")
+    /* Maintainer: picoChip */
+    .phys_io        = 0xffe00000,
+    .io_pg_offst    = ((0xfee00000) >> 18) & 0xfffc,
+    .boot_params    = 0x00000100,
+    .map_io         = firecracker_map_io,
+    .init_irq       = firecracker_init_irq,
+    .timer          = &firecracker_timer,
+    .init_machine   = firecracker_init,
+    .fixup          = firecracker_fixup,
+MACHINE_END
+#endif
diff --git a/arch/arm/mach-firecracker/firecracker_dma.c b/arch/arm/mach-firecracker/firecracker_dma.c
new file mode 100644
index 0000000..a41a404
--- /dev/null
+++ b/arch/arm/mach-firecracker/firecracker_dma.c
@@ -0,0 +1,3215 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ *  linux/arch/arm/mach-firecracker/dma.c
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Description:
+ *
+ * This module provides the interface to the firecracker low level DMA
+ * functionality.
+ *
+ * References:
+ *
+ * Synopsys DesignWare DW_ahb_dmac Databook Version 2.07a December 14, 2005.
+ * 
+ * See linux/arch/arm/mach-firecracker/dma.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*****************************************************************************
+
+                        Firecracker DMA API Specification
+                             Ben Tucker 28sept2006
+                                version 0.05
+
+1. Introduction
+===============
+
+This is an informal description of the software interfaces exposed by the 
+Firecracker DMA driver.
+This API allows kernel modules to access the DMA capabilities of the
+Firecracker. No user space interface to the DMA driver is provided.
+This API is loosely based on the PC102 8560 DMA driver interfaces with the 
+addition of the standard Linux ARM framework support.
+
+
+1.1. Glossary
+-------------
+
+Transfer - A DMA transfer is the entire operation of moving data from
+            one place to another, from start to finish. It is made up
+            of 1 or more blocks, i.e. single vs multi-block.
+
+Block    - The transfer of a number of data items. The size of the block
+            can be controlled either by the sending or receiving end or
+            by the DMA controller itself. Blocks can be scatter/gather.
+            A DMA transfer can be multi-block if either a multi-block
+            transfer list is used or if auto-reloading of one end of the
+            transfer is employed.
+
+Transaction - For efficiency, a number of data items can be moved at one
+            time. This is also called Burst Transaction. A Block (or
+            scatter/gather region) can be a whole number of transactions
+            in size in which case it fits neatly into the number of
+            burst transactions. Otherwise, smaller transactions are
+            needed at the end of the block. These single transactions
+            transfer a single data item at one time.
+
+Transfer Width - The number of bytes in a data item.
+
+Handshaking - In order to progress the movement of data, handshaking
+            signals to the DMA hardware tell it to start a new 
+            transaction. The handshaking signal can be generated in
+            hardware (by a peripheral and hardware siganl), or by 
+            software (by setting a bit in a register).
+
+The 8560 DMA controller uses the tern 'Striding' where we refer to 
+scatter/gather in this document. The 8560 term for 'Scatter/Gather' is similar
+to the linked list multi-block transfers in this document. These differences
+are inherited from the Synopsys documentation.
+
+
+1.2. References
+---------------
+
+The information in this document needs to be read along side the 
+DesignWare DW_ahb_dmac Databook Version 2.07a December 14, 2005 Synopsys 
+
+
+2. High Level interfaces
+========================
+
+The driver software is layered as follows:
+                ---------------------------     -----------------
+                | ARM Linux DMA Framework |     | Pico.c driver |
+                -------------------------------------------------
+                 | Firecracker DMA API (loosely based on 8560) |
+                 -----------------------------------------------
+                           | Firecracker Hardware |
+                           ------------------------
+
+
+The Firecracker DMA API provides access to the capabilities of the Firecracker.
+Thus mirrors loosely the 8560 API allowing software to be ported
+to the new DMA hardware.
+
+The ARM Linux DMA Framework is implemented using the Firecracker DMA API and 
+provides the standard Linux DMA capabilities, allowing existing Linux drivers
+to use the Firecracker DMA capabilities.
+*****************************************************************************/
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <linux/dma-mapping.h>
+
+#include <mach/io.h>
+#include <mach/hardware.h>
+#include <mach/dma.h>
+
+/* ENABLE_TR_WIDTH allows the setting of the transfer width to values other 
+ * than 32 bits.
+ */
+#undef ENABLE_TR_WIDTH
+
+#if CONFIG_FIRECRACKER_DMA_DEBUG > 0
+
+/* Define ENABLE_DEBUGGING to include code for debugging via printk. 
+ * The firecracker_dma_dump_regs will always be included.
+ * The value of ENABLE_DEBUGGING specifies the default debug level.
+ */
+#define ENABLE_DEBUGGING CONFIG_FIRECRACKER_DMA_DEBUG
+
+#else
+
+#undef ENABLE_DEBUGGING
+
+#endif
+
+/* Internal state associated with a DMA transfer */
+struct firecracker_dma_xfr_tag {
+    void *cookie;                       /* Client context */
+    firecracker_dma_list_t list;        /* Multi-block list 
+                                           or NULL if direct xfr */
+    firecracker_dma_t dma;              /* Link to the engine context */
+    unsigned int channel;               /* The channel number used for this
+                                           transfer */
+    enum {
+        STOPPED,
+        RUNNING,
+        STOPPING,
+    } state;                            /* The current state of the transfer */
+    u32 config_low;                     /* Mirror of low CFGx register */
+    u32 config_high;                    /* Mirror of high CFGx register */
+    firecracker_dma_endpoint_t src;     /* The source endpoint */
+    firecracker_dma_endpoint_t dst;     /* The destination endpoint */
+    unsigned int flags;                 /* The transfer flags */
+    unsigned int count;                 /* bytes to transfer */
+    firecracker_dma_handshake_t src_handshake;  /* Params for src */
+    firecracker_dma_handshake_t dst_handshake;  /* Params for dst */
+    int src_handshaking;                /* Is src hardware handshaking */
+    int dst_handshaking;                /* Is dst hardware handshaking */
+    firecracker_dma_sg_t gather;        /* Source gather parameters */
+    firecracker_dma_sg_t scatter;       /* Destination scatter parameters */
+};
+
+/* Definition of the internal state (context, object whatever). One of these
+ * exists for each DMA engine in the system
+ */
+struct firecracker_dma_tag {
+    void __iomem	*membase;           /* Virtual base address of the DMA */
+    struct channel_tag {
+        int allocated;                  /* Channel allocated */
+        struct firecracker_dma_xfr_tag transfer; /* Channel transfer */
+    } channel[DMA_CHANNELS];            /* Channel information */
+    spinlock_t spinlock;                /* Thread synchronisation */
+    unsigned long spinlock_flags;
+    unsigned int last_int_channel;      /* The last interrupt channel found */
+    int handshaking_inuse[DMA_HANDSHAKING_IFS]; /* 1 if a handshaking 
+                                                   interface is in use */
+#ifdef ENABLE_DEBUGGING
+    int lvl;                            /* The Debug level */
+#endif
+    struct device *device;              /* For dma_alloc_coherent */
+};
+
+
+/* Structure of internal DMA hardware list element */
+typedef struct hw_block_descriptor_tag {
+    u32 source_addr;                    /* LLI.SARx */
+    u32 dest_addr;                      /* LLI.DARx */
+    u32 link;                           /* LLI.LLPx */
+    u32 control;                        /* LLI.CTLx[31:0] */
+    u32 block_ts;                       /* LLI.CTLx[63:32] */
+    u32 reserved1;
+    u32 reserved2;
+} hw_block_descriptor_t;
+
+
+/* A descriptor holds the hardware descriptor at the start (the LLP will 
+ * point to this) and additional information to manage the DMA.
+ */
+typedef struct descriptor_tag {
+    hw_block_descriptor_t hw;       /* Hardware descriptor (must be the
+                                       first element */
+    struct {
+        firecracker_dma_endpoint_t src; /* The source endpoint */
+        firecracker_dma_endpoint_t dst; /* The destination endpoint */
+        unsigned int count;             /* Bytes to transfer */
+    } sw;                           /* Software descriptor */
+} descriptor_t;
+
+/* A type that has a size a multiple of 4 bytes. This is used to help us 
+ * align the hardware block descriptors to a 32-bit boundary. The
+ * size of this type is big enough to hold a struct descriptor_list_tag
+ */
+typedef struct aligned_descriptor_tag {
+    u32 descriptor_data[(sizeof(struct descriptor_tag) / 4) + 1];
+} aligned_descriptor_t;
+
+/* Internal state associated with a DMA multi-block list */
+struct firecracker_dma_list_tag {
+    aligned_descriptor_t *descriptor_list;  /* Pointer the HW/SW list */
+    dma_addr_t dma_descriptor_list;     /* DMA address of the list */
+    unsigned int length;                /* Total list items */
+    unsigned int items;                 /* Current used items */
+    descriptor_t *last_desc;            /* Pointer to the last in the 
+                                           list */
+    firecracker_dma_t dma;              /* Link to the engine context */
+    firecracker_dma_xfr_t dma_xfr;      /* Transfer associated with the list */
+    int src_list;                       /* 1 if the source is a multi-block
+                                           list type. 0 is multi-block
+                                           auto-reload or continuous */
+    int dst_list;                       /* 1 if the destination is a 
+                                           multi-block list type.
+                                           0 is multi-block auto-reload or
+                                           continuous */
+    descriptor_t *current_block;        /* When running, holds the currently
+                                           transferring block */
+    struct device *device;              /* For dma_alloc_coherent */
+};
+
+
+/* A name for this module */
+#define TITLE "pc20x DMA Controller Driver"
+
+/* A version for this module */
+#define VERSION "v0.02"
+
+/* The name of the driver used in the system */
+#define CARDNAME "pc20x-dmac"
+
+/* Macros for register read/write. These hide the virtual addressing. 
+ * They must be used in the presence of a local 'dma' context
+ */
+#ifndef ENABLE_DEBUGGING
+
+#define DMA_READ(__offset) ioread32(dma->membase + __offset)   
+
+#define DMA_WRITE(__value, __offset)                                    \
+    iowrite32(__value, dma->membase + __offset)
+
+#define DB(__params)
+
+#else /* ENABLE_DEBUGGING */
+
+#define DMA_READ(__offset) debug_ioread32(dma->membase + __offset)
+
+#define DMA_WRITE(__value, __offset)                                    \
+    debug_iowrite32(__value, dma->membase + __offset)
+
+#define DB(__params) dbug_print __params
+
+/* Debugging level for this module */
+static volatile int debug_lvl = ENABLE_DEBUGGING;
+
+/* Debugging levels: */
+#define LVL_FATAL       2   /* fatal error conditions         */
+#define LVL_ERR         3   /* error conditions         */
+#define LVL_WARNING     4   /* warning conditions           */
+#define LVL_NOTICE      5   /* normal but significant condition */
+#define LVL_INFO        6   /* informational            */
+#define LVL_DEBUG       7   /* debug-level messages         */
+#define LVL_TRACE       8   /* trace messages         */
+#define LVL_TRACE_IO    9   /* Register IO trace messages         */
+
+
+/* Name: dbug_print
+ */
+/**Purpose: Printk a debug message if the current debug level is high enough
+ *
+ * Pre-conditions: The debug level is set
+ *
+ * Post-conditions: Output via printk
+ *
+ * Notes: Only built with debug versions (ENABLE_DEBUGGING)
+ *
+ * @param this_lvl - the debug level of the message
+ * @param fmt - va list printf style
+ */
+static void dbug_print(int lvl, const char *fmt, ...)
+{
+    static char lvl_ch[10] = {
+        '0', '1', 'F', 'E', 'W', 'N', 'I', 'D', 'T', '9'
+    };
+#define MAX_FORMAT_SIZE 1024
+    char buf[MAX_FORMAT_SIZE];
+    va_list args;
+    va_start(args, fmt);
+
+    if (debug_lvl >= lvl) {
+
+        if (printk_ratelimit() || lvl < LVL_TRACE_IO) {
+
+            vsnprintf(buf, MAX_FORMAT_SIZE, fmt, args);
+            printk("dmac <%c>: %s", lvl_ch[lvl], buf);
+        }
+        else {
+            printk("%c", lvl_ch[lvl]);
+        }
+    }
+}
+
+
+/* Name: debug_ioread32
+ */
+/**Purpose: Do ioread32 and printk the results
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: None.
+ *
+ * Notes: Used for debugging
+ * debug_lvl - The debugging level. Must be >3 to enable printk output.
+ *
+ * @param p - The address to read from
+ *
+ * @return the results of ioread32
+ *
+ * @see debug_iowrite32
+ */
+static u32 debug_ioread32(void __iomem *p)
+{
+    u32 v = ioread32(p);
+    DB((LVL_TRACE_IO, "ioread32(%p) = 0x%08x\n", p, v));
+    return v;
+}
+
+/* Name: debug_iowrite32
+ */
+/**Purpose: Do iowrite32 and printk the parameters
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: None.
+ *
+ * Notes: Used for debugging
+ * debug_lvl - The debugging level. Must be >3 to enable printk output.
+ *
+ * @param v - Value to write
+ * @param p - The address to read from
+ *
+ * @see debug_ioread32
+ */
+static void debug_iowrite32(u32 v, void __iomem *p)
+{
+    DB((LVL_TRACE_IO, "iowrite32(%p) = 0x%08x\n", p, v));
+    iowrite32(v, p);
+}
+
+#endif /* ENABLE_DEBUGGING */
+
+
+
+/* Macros for thread synchronisation via the spinlock in the engine 
+ * context. Simple locking scheme is employed where the entire API
+ * is locked down to one thread per DMA engine.
+ * These need to be used in the presence of a local 'dma' context
+ * which has to have had its spinlock initialised.
+ */
+#define GET_LOCK() \
+    spin_lock_irqsave(&dma->spinlock, dma->spinlock_flags);
+
+#define RELEASE_LOCK() \
+    spin_unlock_irqrestore(&dma->spinlock, dma->spinlock_flags);
+
+
+/* Time-out for waiting for the FIFO to empty when 
+ * stopping a DMA (in jiffies).
+ * Note: Make this small as it is used in a busy-waiting loop.
+ */
+#define ABORT_TIMEOUT       (HZ / 100)      /* 100th of a second */
+
+/* TR_BYTES macro calculates the number of bytes per transaction, given
+ * an endpoint.
+ */
+#define TR_BYTES(__E)       (1 << __E->tr_width)
+
+/* BURST_BYTES macro calculates the number of bytes per burst transfer,
+ * given an endpoint.
+ * msize_lookup converts from the msize_t enum to transfer width multiplier
+ */
+static u32 msize_lookup[] = {1, 4, 8, 16, 32};
+#define BURST_BYTES(__E)    (TR_BYTES(__E) * msize_lookup[__E->msize])
+
+/* Transfer types used internally */
+#define TRT_NONE    0
+#define TRT_BURST   1
+#define TRT_SINGLE  2
+#define TRT_LAST    4
+
+
+/* Local function prototypes: */
+static void print_ctl_low(u32 reg);
+static void print_ctl_high(u32 reg);
+static void hw_initialise(firecracker_dma_t dma);
+static void hw_shutdown(firecracker_dma_t dma);
+static firecracker_dma_xfr_t alloc_xfr(firecracker_dma_t dma);
+static void free_xfr(firecracker_dma_xfr_t dma_xfr);
+static firecracker_dma_list_t alloc_list(
+        firecracker_dma_t dma, unsigned int count);
+static u32 lookup_tt_fc(int src_periph, int src_fc,
+        int dst_periph, int dst_fc);
+static u32 build_control_register(
+        firecracker_dma_endpoint_t *src, firecracker_dma_endpoint_t *dst);
+static u32 build_llp_control_register(firecracker_dma_list_t list);
+static void update_xfr_registers(firecracker_dma_xfr_t dma_xfr);
+static int get_xfr_state(firecracker_dma_xfr_t dma_xfr);
+static void write_int_registers(firecracker_dma_t dma,
+        dma_int_type_t int_types, unsigned int type, u32 value);
+static int transfer_type(firecracker_dma_xfr_t dma_xfr,
+        firecracker_dma_endpoint_t *endpoint, unsigned int *bytes_left);
+static int get_transaction_state(
+        firecracker_dma_xfr_t dma_xfr, int src_dst);
+static void transfer_request(
+        firecracker_dma_xfr_t dma_xfr, int src_dst, int type);
+static void set_auto_burst_length(
+        firecracker_dma_endpoint_t *endpoint, unsigned int count);
+static int param_checks(firecracker_dma_endpoint_t *src,
+        firecracker_dma_endpoint_t *dst, unsigned int count);
+static void setup_handshaking(firecracker_dma_xfr_t dma_xfr,
+        firecracker_dma_handshake_t *src_handshake,
+        firecracker_dma_handshake_t *dst_handshake);
+static int handshaking_check(firecracker_dma_t dma, 
+        firecracker_dma_handshake_t *src_handshaking, 
+        firecracker_dma_handshake_t *dst_handshaking);
+#ifdef ENABLE_DEBUGGING
+static u32 debug_ioread32(void __iomem *p);
+static void debug_iowrite32(u32 v, void __iomem *p);
+static void dbug_print(int this_lvl, const char *fmt, ...);
+#endif /* ENABLE_DEBUGGING */
+
+
+/* Name: firecracker_dma_init
+ */
+/**Purpose: Engine initialisation
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: DMA engine context initialised. Ready for API calls.
+ * Hardware initialised, DMA engines enabled.
+ *
+ * @return 0 - success always 
+ */
+static struct firecracker_dma_tag *firecracker_dma_init(
+        struct platform_device *pdev)
+{
+    struct plat_firecracker_dma *pdata = pdev->dev.platform_data;
+    struct firecracker_dma_tag *dma;
+
+    dma = kzalloc(sizeof(struct firecracker_dma_tag), GFP_ATOMIC);
+    if (dma == NULL) {
+        /* No memory, return null */
+        DB((LVL_ERR, "Out of memory to allocate engine\n"));
+        return NULL;
+    }
+
+    /* Set the base address */
+    dma->membase = pdata->membase;
+
+    /* Get a pointer to the underlying device for dma_alloc_coherent calls */
+    dma->device = &pdev->dev;
+
+#ifdef ENABLE_DEBUGGING
+    /* Setup debug level */
+    dma->lvl = ENABLE_DEBUGGING;
+#endif
+
+    /* Allocate a spinlock for each engine */
+    spin_lock_init(&dma->spinlock);
+
+    /* Initialise engine hardware */
+    hw_initialise(dma);
+
+    return dma;
+}
+
+/* Name: firecracker_dma_exit
+ */
+/**Purpose: Engine exit
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: Hardware shut-down, DMA engines disabled. Context freed.
+ */
+static void firecracker_dma_exit(struct firecracker_dma_tag *dma)
+{
+    if (dma != NULL) {
+        /* Stop the hardware */
+        hw_shutdown(dma);
+
+        /* Free engine context */
+        kfree(dma);
+    }
+}
+
+
+/*****************************************************************************
+3.1.5. firecracker_dma_setup_direct_xfr
+---------------------------------------
+
+firecracker_dma_xfr_t firecracker_dma_setup_direct_xfr(
+        firecracker_dma_t dma,
+        firecracker_dma_endpoint_t *src, firecracker_dma_endpoint_t *dst,
+        firecracker_dma_handshake_t *src_handshaking,
+        firecracker_dma_handshake_t *dst_handshaking,
+        unsigned int count, unsigned int flags, void *cookie)
+
+
+3.1.5.1. Description
+
+Set up a DMA transfer between src and dst.
+Note that 'count' is the number of bytes, not the number of words.
+
+The DMA set up by this call will not start transferring data until
+firecracker_dma_start is called.
+
+The data structure pointed to by the src and dst parameters are copied
+by the call so can be destroyed once the call returns.
+
+The DMA channel set up by this call will have:
+    - All interrupts disabled
+    - Channel disabled but not suspended
+    - Source and Destination address set to the parameters (see 3.2.2)
+    - Single block transfer mode
+    - Transfer size set to count
+    - Source and Destination Master interface set to the parameters (see 3.2.2)
+    - Transfer Type and Flow control set according to parameters (see 3.2.2)
+    - No Scatter or Gather.
+    - Source/Dest Burst Length set according to parameters (see 3.2.2)
+    - Source/Dest address increment set according to parameters (see 3.2.2)
+    - Source/Dest Transfer Width set according to parameters (see 3.2.2)
+    - Protocol Control set according to flags
+    - Transfer FIFO mode set according to flags
+    - Data pre-fetching is set according to flags
+    - Automatic source/destination reload set by the parameters (see 3.2.2)
+    - Channel priority set according to flags
+    - Source/Dest handshaking setup according to parameters.
+
+If nether of the src or dst are auto-reload, the transfer setup by this call is
+single-block only and will stop when the data has been transferred.
+Free running transfers (multi-block) will wait between blocks if the block
+interrupt is enabled. See 3.2.2 and 3.1.11.
+
+The 'count' parameter is used in one of three ways.
+(1) If one end of the transfer is the flow controller and has hardware handshaking,
+    the count is ignored as the flow controller will control the amount of data in
+    the block.
+(2) If nether end of the transfer is a flow controller (the DMA engine is flow 
+    controller), the count parameter is used to set the block size in the DMA
+    control register.
+(3) If one end of the transfer is a flow controller, but software handshaking is
+    used, the count parameter is ignored. In this situation, client software may
+    not know the size of the block at the point when the transfer is setup. The
+    firecracker_dma_request_transaction function bytes_left parameter is used to 
+    tell the driver the data left in the block when each transaction is requested.
+    firecracker_dma_request_transaction can then decide the type of transaction
+    to request.
+
+
+3.1.5.2. Parameters
+dma                 - The handle to the dma driver returned from 
+                        firecracker_dma_get_dmac_handle.
+src                 - Transfer source details (see 3.2.2)
+dst                 - Transfer destination details (see 3.2.2)
+src_handshake      - The handshaking parameters for transfer source or NULL
+                     if hardware handshaking of source is not used (see 3.2.4)
+dst_handshake      - The handshaking parameters for transfer destination or NULL
+                     if hardware handshaking of destination is not used.
+count               - The number of bytes to transfer. If either end of the
+                        transfer is a hardware handshaking flow controller,
+                        this is ignored.
+flags | PROTCTL_0   - Sets the PROTCTL bits
+flags | PROTCTL_1
+flags | PROTCTL_2
+flags | PROTCTL_3
+flags | FIFO_MODE   - Sets the FIFO_MODE bit
+flags | FCMODE      - Sets the FCMODE bit
+flags | CH_PRIOR_0  \
+flags | CH_PRIOR_1  - Sets the
+flags | CH_PRIOR_2  -  channel priority
+flags | CH_PRIOR_3  /
+cookie              - Pointer returned by firecracker_dma_int_get_xfr
+
+3.1.5.3. Returns
+Handle to the new transfer created or NULL if something went wrong.
+*****************************************************************************/
+firecracker_dma_xfr_t firecracker_dma_setup_direct_xfr(
+        firecracker_dma_t dma,
+        firecracker_dma_endpoint_t *src, firecracker_dma_endpoint_t *dst,
+        firecracker_dma_handshake_t *src_handshaking,
+        firecracker_dma_handshake_t *dst_handshaking,
+        unsigned int count, unsigned int flags, void *cookie)
+{
+    struct firecracker_dma_xfr_tag *dma_xfr = NULL;
+
+    DB((LVL_INFO, "Enter firecracker_dma_setup_direct_xfr\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Check we have source and destination */
+    if (src == NULL || dst == NULL) {
+        DB((LVL_ERR, "src or dst NULL\n"));
+        goto EXIT;
+    }
+
+    /* Do various parameter checks and exit if they fail */
+    if (param_checks(src, dst, count) == 0) {
+        goto EXIT;
+    }
+
+    /* Check the handshaking parameters */
+    if (handshaking_check(dma, src_handshaking, dst_handshaking) == 0) {
+        goto EXIT;
+    }
+
+    /* Allocate a transfer object including DMA channel */
+    dma_xfr = alloc_xfr(dma);
+    if (dma_xfr == NULL) {
+        /* Out of resources */
+        goto EXIT;
+    }
+
+    /* Set the transfer state */
+    dma_xfr->state = STOPPED;
+
+    /* Setup transfer structure */
+    dma_xfr->src = *src;
+    dma_xfr->dst = *dst;
+    dma_xfr->count = count;
+    dma_xfr->flags = flags;
+    dma_xfr->list = NULL;
+    dma_xfr->cookie = cookie;
+
+    /* Deal with auto burst length */
+    set_auto_burst_length(&dma_xfr->src, count);
+    set_auto_burst_length(&dma_xfr->dst, count);
+
+    /* Setup the handshaking */
+    setup_handshaking(dma_xfr, src_handshaking, dst_handshaking);
+
+    /* Disable all interrupts for the channel */
+    write_int_registers(dma, INT_ALL, 
+            MASK, DMA_IRQ_DISABLE_CHANNEL(dma_xfr->channel));
+
+EXIT:
+    RELEASE_LOCK();
+    return dma_xfr;
+}
+
+
+
+/*****************************************************************************
+3.1.1. firecracker_dma_start
+----------------------------
+
+int firecracker_dma_start(firecracker_dma_xfr_t dma_xfr)
+
+3.1.1.1. Description
+Start a DMA transfer on a channel previously set up with the 
+firecracker_dma_setup_direct_xfr() or firecracker_dma_setup_list_xfr()
+functions.
+Once started, the transfer is locked and will not be modifiable. This
+includes a DMA multi-block list that is associated with a transfer.
+Transfers will continue to completion asynchronously. Once finished,
+they can be restarted.
+
+3.1.1.2. Parameters
+dma_xfr             - The transfer handle.
+
+3.1.1.3. Returns
+EINVAL              - The transfer is already running
+*****************************************************************************/
+int firecracker_dma_start(firecracker_dma_xfr_t dma_xfr)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    firecracker_dma_list_t list = dma_xfr->list;
+    unsigned int ch = dma_xfr->channel;
+    int res = 0;
+
+    DB((LVL_INFO, "Enter firecracker_dma_start\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Check and set the transfer state */
+    if (get_xfr_state(dma_xfr) != STOPPED) {
+        /* Already running error */
+        DB((LVL_ERR, "Transfer running\n"));
+        res = EINVAL;
+        goto EXIT;
+    }
+    dma_xfr->state = RUNNING;
+
+    /* Reset the current block if using multi-block list */
+    if (list != NULL) {
+        list->current_block = (descriptor_t *)list->descriptor_list;
+    }
+
+    /* Write the DMA hardware */
+    update_xfr_registers(dma_xfr);
+
+    /* Start the DMA channel */
+    DMA_WRITE(DMA_ENABLE_CHANNEL(ch), DMA_CHANNEL_ENABLE_REG_OFFSET);
+
+EXIT:
+    RELEASE_LOCK();
+    return res;
+}
+
+
+/*****************************************************************************
+3.1.2. firecracker_dma_abort
+----------------------------
+
+int firecracker_dma_abort(firecracker_dma_xfr_t dma_xfr)
+
+3.1.2.1. Description
+Abort a DMA transfer.
+Once aborted, the transfer can be restarted. Also the transfer 
+can be modified once aborted. If the transfer is restarted, it
+will continue from the start of the single transfer buffer or
+multi-block list.
+
+3.1.2.2. Parameters
+dma_xfr             - The transfer handle.
+
+3.1.2.3. Returns
+EINVAL              - The transfer is not running
+*****************************************************************************/
+int firecracker_dma_abort(firecracker_dma_xfr_t dma_xfr)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    int res = 0;
+    u32 status;
+    unsigned long timeout_jiffies;
+
+    DB((LVL_INFO, "Enter firecracker_dma_abort\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Check and set the transfer state */
+    if (get_xfr_state(dma_xfr) != RUNNING) {
+        /* Already stopped. It is not unusual for this to happen */
+        DB((LVL_NOTICE, "Aborting a stopped transfer\n"));
+        res = EINVAL;
+        goto EXIT;
+    }
+    dma_xfr->state = STOPPING;
+
+    /* Set the suspend bit, wait for the FIFO to clear before
+     * disabling the channel
+     */
+    dma_xfr->config_low |= DMA_CH_SUSP;
+    DMA_WRITE(dma_xfr->config_low,
+            DMA_N_LOW_CONFIGURATION_REG_OFFSET(dma_xfr->channel));
+
+    /* Release the API spinlock while waiting as interrupts may
+     * need to be serviced to empty the FIFO and these will try
+     * to grab the lock.
+     * This is safe as we are not updating state while polling.
+     */
+    RELEASE_LOCK();
+
+    /* Poll the FIFO_EMPTY bit */
+    timeout_jiffies = jiffies + ABORT_TIMEOUT;
+    while (1) {
+
+        /* Check for time out */
+        if (time_after(jiffies, timeout_jiffies)) {
+            DB((LVL_ERR, "Timed out waiting for FIFO to empty\n"));
+            res = EIO;
+            break;
+        }
+
+        /* Check for the empty FIFO empty */
+        status = DMA_READ(
+            DMA_N_LOW_CONFIGURATION_REG_OFFSET(dma_xfr->channel));
+        if (status & DMA_FIFO_EMPTY) {
+            break;
+        }
+    };
+
+    GET_LOCK();
+
+    /* Disable the channel */
+    DMA_WRITE(
+            DMA_DISABLE_CHANNEL(dma_xfr->channel), 
+            DMA_CHANNEL_ENABLE_REG_OFFSET);
+
+    /* Now stopped, set state */
+    dma_xfr->state = STOPPED;
+
+EXIT:
+    RELEASE_LOCK();
+    return res;
+}
+
+
+/*****************************************************************************
+3.1.3. firecracker_dma_release
+------------------------------
+
+firecracker_dma_release(firecracker_dma_xfr_t dma_xfr)
+
+3.1.3.1. Description
+Stop a DMA transfer and release resources.
+Once released, the transfer can not be restarted and has to be setup
+once more. The transfer handle will become invalid on exit of this
+function.
+
+3.1.3.2. Parameters
+dma_xfr             - The transfer handle.
+*****************************************************************************/
+void firecracker_dma_release(firecracker_dma_xfr_t dma_xfr)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    firecracker_dma_list_t list = dma_xfr->list;
+
+    DB((LVL_INFO, "Enter firecracker_dma_release\n"));
+
+    /* Make sure the transfer has is stopped */
+    firecracker_dma_abort(dma_xfr);     /* Ignoring the returned value */
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Reset any interrupts that have been left pending */
+    write_int_registers(dma, INT_ALL, CLEAR, DMA_IRQ_CHANNEL(dma_xfr->channel));
+
+    /* Disconnect from multi-block list */
+    if (list != NULL) {
+        list->dma_xfr = NULL;
+    }
+
+    /* Free the resources */
+    free_xfr(dma_xfr);
+
+    RELEASE_LOCK();
+}
+
+
+/*****************************************************************************
+3.1.4. firecracker_dma_set_debug_level
+--------------------------------------
+
+firecracker_dma_set_debug_level(firecracker_dma_t dma, int lvl)
+
+3.1.4.1. Description
+Sets the debugging level for the DMA driver, 0 - no debug, 3 - all the debug.
+Affects the amount of printk traffic.
+
+3.1.4.2. Parameters
+dma                 - The handle to the dma driver returned from 
+                        firecracker_dma_get_dmac_handle.
+lvl                 - Debug level (0-3).
+*****************************************************************************/
+void firecracker_dma_set_debug_level(firecracker_dma_t dma, int lvl)
+{
+#ifdef ENABLE_DEBUGGING
+    debug_lvl = lvl;
+#endif
+}
+
+
+/*****************************************************************************
+3.1.6. firecracker_dma_list_create
+----------------------------------
+
+firecracker_dma_list_t firecracker_dma_list_create(
+        firecracker_dma_t dma,
+        unsigned int count)
+
+3.1.6.1. Description
+Creates a DMA buffer list that can be assigned to a multi-block transfer.
+The list initially is empty. Entries can be added to the list using 
+firecracker_dma_list_add.
+A list can be assigned to one transfer only using firecracker_dma_setup_list_xfr.
+The list can only be modified before any transfer is started.
+This function allocates memory. Lists must be destroyed by calling 
+firecracker_dma_list_destroy otherwise the driver will leak memory.
+
+Circular multi-block lists have a link from the last element to the first. 
+When applied to the DMA hardware, this means that the multi-block transfer
+restarts once it gets to the end of the list.
+The firecracker_dma_handle_block_int function should be used to set the
+number of blocks of the multi-block transfer.
+
+3.1.6.2. Parameters
+dma                 - The handle to the dma driver returned from 
+                        firecracker_dma_get_dmac_handle.
+count               - The maximum number of elements in the list.
+
+3.1.6.3. Returns
+The address of the list created or NULL if the request could not be satisfied.
+*****************************************************************************/
+firecracker_dma_list_t firecracker_dma_list_create(
+        firecracker_dma_t dma, unsigned int count)
+{
+    firecracker_dma_list_t list;
+
+    DB((LVL_INFO, "Enter firecracker_dma_list_create\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Allocate the list */
+    list = alloc_list(dma, count);
+    if (list == NULL) {
+        /* Not enough resources, exit */
+        goto EXIT;
+    }
+
+    /* Setup the structure */
+    list->dma = dma;
+    list->dma_xfr = NULL;
+    list->items = 0;
+    list->last_desc = NULL;
+    list->length = count;
+    list->src_list = 1;
+    list->dst_list = 1;
+
+EXIT:
+    RELEASE_LOCK();
+    return list;
+}
+
+
+/*****************************************************************************
+3.1.7. firecracker_dma_list_add
+-------------------------------
+
+firecracker_dma_list_add(firecracker_dma_list_t list,
+                         firecracker_dma_endpoint_t *src, firecracker_dma_endpoint_t *dst,
+                         unsigned int count)
+
+3.1.7.1. Description
+Add an entry to the end of a DMA multi-block list. The entry added to the list
+specifies a simple block transfer.
+The data pointed to by the src and dst parameters are copied by the call so
+can be destroyed once the call returns.
+This function will not modify a list that is currently in use with a DMA 
+operation.
+
+The first element of the list must have both src and dst endpoints. If either
+endpoint (not both) is to be continuous, subsequent elements need to set 
+the endpoint to NULL. If either endpoint (not both) is to be auto-reload,
+the first element needs to set the auto_reload flag and subsequent elements
+need to set the endpoint to NULL. See 3.2.2.
+
+Notes:
+1.  Each block of the list can set a transfer width. Transfer width affects the
+    setting of scatter/gather which is set globally, for the transfer. Scatter/
+    gather is setup in the hardware based on the transfer widths of the first
+    element of the block list. It is recommended that subsequent blocks use
+    the same transfer width (if SG is enabled), otherwise there will be
+    undefined effects.
+
+3.1.7.2. Parameters
+list                - The DMA multi-block list to add a new block to
+src                 - The source DMA endpoint parameters 
+                        or NULL if auto-reload or continuous
+dst                 - The destination endpoint parameters
+                        or NULL if auto-reload or continuous
+count               - The number of bytes to transfer. If either end of the
+                        transfer is a hardware flow controller, this is ignored.
+    
+3.1.7.3. Returns
+ENOMEM              - The list is full, no more items can be added
+EBUSY               - If the list is in use with a DMA transfer
+EINVAL              - The combination of source and destination endpoints is
+                        invalid.
+*****************************************************************************/
+int firecracker_dma_list_add(
+        firecracker_dma_list_t list,
+        firecracker_dma_endpoint_t *src, firecracker_dma_endpoint_t *dst,
+        unsigned int count)
+{
+    firecracker_dma_t dma = list->dma;
+    int res = 0;
+    descriptor_t *new_desc;
+    dma_addr_t dma_new_desc;
+    firecracker_dma_xfr_t dma_xfr = list->dma_xfr;
+    descriptor_t *first_desc = (descriptor_t *)list->descriptor_list;
+
+    DB((LVL_INFO, "Enter firecracker_dma_list_add\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Do various parameter checks and exit if they fail */
+    if (param_checks(src, dst, count) == 0) {
+        res = EINVAL;
+        goto EXIT;
+    }
+
+    /* Check we have room */
+    if (list->length == list->items) {
+        DB((LVL_ERR, "List full\n"));
+        res = ENOMEM;
+        goto EXIT;
+    }
+
+    /* Check for transfers running the list */
+    if (dma_xfr != NULL) {
+        if (get_xfr_state(dma_xfr) != STOPPED) {
+            /* Cannot modify a list that is active */
+            DB((LVL_ERR, "Transfer running\n"));
+            res = EBUSY;
+            goto EXIT;
+        }
+    }
+
+    /* If this is the first item, we must have both src and dst parameters */
+    if (list->items == 0) {
+        if (src == NULL || dst == NULL) {
+            DB((LVL_ERR, "First list element must have both source and destination endpoints\n"));
+            res = EINVAL;
+            goto EXIT;
+        }
+    }
+    /* If this is the second element and src or dst are NULL, 
+     * we are not using a list for the endpoint
+     */
+    else if (list->items == 1) {
+        if (src == NULL && dst == NULL) {
+            /* Either src or dst must be set */
+            DB((LVL_ERR, "List element must have either source or destination endpoints\n"));
+            res = EINVAL;
+            goto EXIT;
+        }
+
+        /* If the source is not set, we are not using a list for it */
+        if (src == NULL) {
+            list->src_list = 0;
+        }
+
+        /* If the destination is not set, we are not using a list for it */
+        if (dst == NULL) {
+            list->dst_list = 0;
+        }
+    }
+    else {  /* Not the first or second item */
+
+        /* Check that, once we have chosen a non list type multi-block transfer
+         * (auto-reload or continuous), we must stick to it.
+         */
+        if (list->src_list == 1) {
+            if (src == NULL) {
+                res = EINVAL;
+            }
+        }
+        else {
+            if (src != NULL) {
+                res = EINVAL;
+            }
+        }
+
+        if (list->dst_list == 1) {
+            if (dst == NULL) {
+                res = EINVAL;
+            }
+        }
+        else {
+            if (dst != NULL) {
+                res = EINVAL;
+            }
+        }
+
+        if (res == EINVAL) {
+            DB((LVL_ERR, "List element must be consistent\n"));
+            goto EXIT;
+        }
+    }
+
+    /* Get a pointer to the new descriptor */
+    new_desc = (descriptor_t *)&(list->descriptor_list[list->items]);
+
+    /* Get the physical address (DMA address) of the new descriptor */
+    dma_new_desc = 
+        list->dma_descriptor_list + 
+        (sizeof(aligned_descriptor_t) * list->items);
+
+    /* Allocate the new descriptor */
+    list->items++;
+
+    /* Record the first source/destination for the non-list type
+     * transfers in the software list.
+     */
+    if (src != NULL) {
+        new_desc->sw.src = *src;
+        /* Deal with auto burst length */
+        set_auto_burst_length(&new_desc->sw.src, count);
+    }
+    if (dst != NULL) {
+        new_desc->sw.dst = *dst;
+        /* Deal with auto burst length */
+        set_auto_burst_length(&new_desc->sw.dst, count);
+    }
+    new_desc->sw.count = count;
+
+    /* Set the link of the new last element to point to the first. 
+     * This ensures that the hardware is ready to be restarted at the 
+     * beginning of the list when it completes
+     */
+    new_desc->hw.link = list->dma_descriptor_list;
+
+    /* Link the previous item to this one and enable the block chaining
+     * for it.
+     */
+    if (list->last_desc != NULL) {
+        list->last_desc->hw.link = dma_new_desc;
+        list->last_desc->hw.control |= build_llp_control_register(list);
+    }
+
+    /* Where either the source or destination is not list type, and is null
+     * at this point, use the endpoint descriptor at the head of the list
+     */
+    if (src == NULL) {
+        src = &first_desc->sw.src;
+    }
+    if (dst == NULL) {
+        dst = &first_desc->sw.dst;
+    }
+
+    /* Setup the new hardware block descriptor */
+    new_desc->hw.source_addr = src->dma_addr;
+    new_desc->hw.dest_addr = dst->dma_addr;
+    new_desc->hw.control = build_control_register(src, dst);
+    new_desc->hw.block_ts = count / TR_BYTES(src);
+
+    /* The new last descriptor is now the one we just created */
+    list->last_desc = new_desc;
+
+EXIT:
+    RELEASE_LOCK();
+    return res;
+}
+
+
+/*****************************************************************************
+3.1.8. firecracker_dma_list_clear
+---------------------------------
+
+firecracker_dma_list_clear(firecracker_dma_list_t list)
+
+
+3.1.8.1. Description
+This function resets a list to the state that it was in just after it was 
+created when calling firecracker_dma_list_create. This function does
+not free the memory associated by the list.
+This function will not modify a list that is currently in use with a DMA 
+operation.
+
+
+3.1.8.2. Parameters
+list                - The DMA list returned from firecracker_dma_list_create
+
+
+3.1.8.3. Returns
+EBUSY - If the list is in use with a DMA transfer
+*****************************************************************************/
+int firecracker_dma_list_clear(firecracker_dma_list_t list)
+{
+    firecracker_dma_t dma = list->dma;
+    int res = 0;
+    struct firecracker_dma_xfr_tag *dma_xfr = list->dma_xfr;
+
+    DB((LVL_INFO, "Enter firecracker_dma_list_clear\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Check for transfers running the list */
+    if (dma_xfr != NULL) {
+        if (get_xfr_state(dma_xfr) != STOPPED) {
+            /* Cannot modify a list that is active */
+            DB((LVL_ERR, "Transfer running\n"));
+            res = EBUSY;
+            goto EXIT;
+        }
+    }
+
+    /* Reset the list */
+    list->items = 0;
+    list->last_desc = NULL;
+    list->src_list = 1;
+    list->dst_list = 1;
+
+EXIT:
+    RELEASE_LOCK();
+    return res;
+}
+
+
+/*****************************************************************************
+3.1.9. firecracker_dma_list_destroy
+-----------------------------------
+
+firecracker_dma_list_destroy(firecracker_dma_list_t list)
+
+
+3.1.9.1. Description
+This function frees the resources allocated by a list. Lists need to
+be freed after use to avoid a memory leak.
+This function will not modify a list that is currently in use with a DMA 
+operation.
+
+
+3.1.9.2. Parameters
+list                - The DMA list returned from firecracker_dma_list_create
+
+
+3.1.9.3. Returns
+EBUSY - If the list is in use with a DMA transfer
+*****************************************************************************/
+int firecracker_dma_list_destroy(firecracker_dma_list_t list)
+{
+    firecracker_dma_t dma = list->dma;
+    int res = 0;
+    struct firecracker_dma_xfr_tag *dma_xfr = list->dma_xfr;
+    struct firecracker_dma_list_tag local_list;
+
+    DB((LVL_INFO, "Enter firecracker_dma_list_destroy\n"));
+
+    /* Stop compiler warnings */
+    local_list.device = NULL;
+    local_list.length = 0;
+    local_list.descriptor_list = NULL;
+    local_list.dma_descriptor_list = 0;
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Make sure there are no references to the list from transfers.
+     * A transfers using the list needs to be destroyed before the
+     * list can be destroyed.
+     */
+    if (dma_xfr != NULL) {
+        /* Cannot destroy a list that is referenced */
+        DB((LVL_ERR, "List in use\n"));
+        res = EBUSY;
+        goto EXIT;
+    }
+
+    /* Take a copy of the list before we free it so that we can free 
+     * the DMA coherent area outside of the spinlock. This is done
+     * because dma_free_coherent must not be called with interrupts
+     * disabled.
+     */
+    local_list = *list;
+
+    /* Free the object */
+    kfree(list);
+
+EXIT:
+    RELEASE_LOCK();
+
+    /* Free the descriptor list if were are not here because of an error */
+    if (res == 0) {
+        dma_free_coherent(local_list.device, 
+                sizeof(aligned_descriptor_t) * local_list.length,
+                local_list.descriptor_list, local_list.dma_descriptor_list);
+    }
+
+    return res;
+}
+
+
+/*****************************************************************************
+3.1.10. firecracker_dma_setup_list_xfr
+--------------------------------------
+
+firecracker_dma_xfr_t firecracker_dma_setup_list_xfr(
+        firecracker_dma_list_t list,
+        firecracker_dma_handshake_t *src_handshaking,
+        firecracker_dma_handshake_t *dst_handshaking,
+        unsigned int flags, void *cookie)
+
+
+3.1.10.1. Description
+Set up a multi-block DMA transfer.
+The transfer is controlled by the list provided. 
+The DMA list can be modified once this function has been called but
+when the DMA operations is started (by calling firecracker_dma_start) the
+list will be locked and any attempt to modify it will not be allowed.
+Data transfer is not started until the firecracker_dma_start is called.
+
+The transfer setup by this call is multi-block only and will stop when the 
+end of the multi-block list is reached. In addition, the transfer will wait
+between blocks if the block interrupt is enabled. See 3.2.6.1.
+
+Source/Dest handshaking setup according to parameters.
+
+3.1.10.2. Parameters
+list                - The DMA multi-block list containing the data blocks
+                        to be transferred.
+src_handshake      - The handshaking parameters for transfer source or NULL
+                     if hardware handshaking of source is not used (see 3.2.4)
+dst_handshake      - The handshaking parameters for transfer destination or NULL
+                     if hardware handshaking of destination is not used.
+flags | PROTCTL_0   - Sets the PROTCTL bits
+flags | PROTCTL_1
+flags | PROTCTL_2
+flags | PROTCTL_3
+flags | FIFO_MODE   - Sets the FIFO_MODE bit
+flags | FCMODE      - Sets the FCMODE bit
+flags | CH_PRIOR_0  \
+flags | CH_PRIOR_1  - Sets the
+flags | CH_PRIOR_2  -  channel priority
+flags | CH_PRIOR_3  /
+cookie              - Pointer returned by firecracker_dma_int_get_xfr
+
+3.1.10.3. Returns
+ENOMEM              - No enough resources to complete the call
+EBUSY               - If the list is already in use with a DMA transfer
+EINVAL              - Combination of parameters is illegal.
+*****************************************************************************/
+firecracker_dma_xfr_t firecracker_dma_setup_list_xfr(
+        firecracker_dma_list_t list,
+        firecracker_dma_handshake_t *src_handshaking,
+        firecracker_dma_handshake_t *dst_handshaking,
+        unsigned int flags, void *cookie)
+{
+    firecracker_dma_t dma = list->dma;
+    struct firecracker_dma_xfr_tag *dma_xfr = NULL;
+
+    DB((LVL_INFO, "Enter firecracker_dma_setup_list_xfr\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Check that the list is not in use with another transfer */
+    if (list->dma_xfr != NULL) {
+        DB((LVL_ERR, "List in use\n"));
+        goto EXIT;
+    }
+
+    /* Check the handshaking parameters */
+    if (handshaking_check(dma, src_handshaking, dst_handshaking) == 0) {
+        goto EXIT;
+    }
+
+    /* Allocate a transfer object including DMA channel */
+    dma_xfr = alloc_xfr(dma);
+    if (dma_xfr == NULL) {
+        /* Out of resources */
+        goto EXIT;
+    }
+
+    /* Set the transfer state */
+    dma_xfr->state = STOPPED;
+
+    /* Setup transfer structure */
+    dma_xfr->flags = flags;
+    dma_xfr->list = list;
+    dma_xfr->cookie = cookie;
+
+    /* Pointer from list to the new transfer */
+    list->dma_xfr = dma_xfr;
+
+    /* Setup the handshaking */
+    setup_handshaking(dma_xfr, src_handshaking, dst_handshaking);
+
+    /* Disable all interrupts for the channel */
+    write_int_registers(dma, INT_ALL, 
+            MASK, DMA_IRQ_DISABLE_CHANNEL(dma_xfr->channel));
+
+EXIT:
+    RELEASE_LOCK();
+    return dma_xfr;
+}
+
+
+/*****************************************************************************
+3.1.11. firecracker_dma_enable_int
+----------------------------------------
+
+firecracker_dma_enable_int(firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types)
+
+3.1.11.1. Description
+Enable interrupt generation of a number of types of interrupt on a DMA transfer.
+
+3.1.11.2. Parameters
+dma_xfr             - The transfer handle.
+int_types           - The types of interrupt (see 3.2.6).
+*****************************************************************************/
+void firecracker_dma_enable_int(
+        firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+
+    DB((LVL_INFO, "Enter firecracker_dma_enable_int\n"));
+
+    GET_LOCK();
+    write_int_registers(dma, int_types, 
+            MASK, DMA_IRQ_ENABLE_CHANNEL(dma_xfr->channel));
+    RELEASE_LOCK();
+}
+
+
+/*****************************************************************************
+3.1.12. firecracker_dma_disable_int
+-----------------------------------------
+
+firecracker_dma_disable_int(firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types)
+
+3.1.12.1. Description
+Disable interrupt generation of a number of types of interrupt on a DMA transfer.
+
+3.1.12.2. Parameters
+dma_xfr             - The transfer handle.
+int_types           - The types of interrupt (see 3.2.6).
+*****************************************************************************/
+void firecracker_dma_disable_int(
+        firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+
+    DB((LVL_INFO, "Enter firecracker_dma_disable_int\n"));
+
+    GET_LOCK();
+    write_int_registers(dma, int_types, 
+            MASK, DMA_IRQ_DISABLE_CHANNEL(dma_xfr->channel));
+    RELEASE_LOCK();
+}
+
+
+/*****************************************************************************
+3.1.13. firecracker_dma_clear_int
+-----------------------------------------
+
+firecracker_dma_clear_int(firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types)
+
+3.1.13.1. Description
+Clears a number of interrupt status bits, ready for new interrupt generation.
+
+3.1.13.2. Parameters
+dma_xfr             - The transfer handle.
+int_types           - The types of interrupt (see 3.2.6).
+*****************************************************************************/
+void firecracker_dma_clear_int(
+        firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+
+    DB((LVL_INFO, "Enter firecracker_dma_clear_int\n"));
+
+    GET_LOCK();
+    write_int_registers(dma, int_types, 
+            CLEAR, DMA_IRQ_CHANNEL(dma_xfr->channel));
+    RELEASE_LOCK();
+}
+
+
+/*****************************************************************************
+3.1.28. firecracker_dma_int_get_xfr
+-----------------------------------
+
+firecracker_dma_xfr_t firecracker_dma_int_get_xfr(
+        firecracker_dma_t dma, dma_int_type_t *int_types, void **cookie)
+
+3.1.28.1. Description
+Returns the transfer handle that caused the last interrupt, so long as the interrupt 
+is one of int_types.
+This function also returns the interrupt type that caused the interrupt in the
+location pointed to be int_types.
+
+3.1.28.2. Parameters
+dma                 - The engine handle.
+int_types           - Pointer to types to search for and if one found, returns the 
+                        type of the interrupt.
+cookie              - Pointer to pointer set on exit to the cookie value set in
+                        firecracker_dma_setup_direct_xfr or 
+                        firecracker_dma_setup_list_xfr.
+
+3.1.28.3. Returns
+A transfer handle or NULL if no interrupt occurred.
+*****************************************************************************/
+firecracker_dma_xfr_t firecracker_dma_int_get_xfr(
+        firecracker_dma_t dma, dma_int_type_t *interrupt_type,
+        void **cookie)
+{
+    firecracker_dma_xfr_t dma_xfr = NULL;
+    dma_int_type_t int_type;
+    unsigned int int_channel = 0;
+    u32 hw_int_status = 0;
+ 
+    DB((LVL_INFO, "Enter firecracker_dma_int_get_xfr\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Search for an interrupt type that has been triggered */
+    for (int_type = 1; int_type < INT_ALL; int_type <<= 1) {
+
+        /* If the interrupt type is not one that has been requested, move
+         * on to the next type.
+         */
+        if (((*interrupt_type) & int_type) == 0) {
+            continue;
+        }
+
+        /* Read one of the interrupt status registers */
+        /* Note: the order that the interrupt types appear in the following
+         * switch is important as it defines the order in which interrupts 
+         * are serviced.
+         * The dma_int_type_t needs to be in the same order as this switch.
+         */
+        switch (int_type) {
+            case INT_BLOCK:
+                hw_int_status = 
+                    DMA_READ(DMA_BLOCK_COMPLETE_REG_OFFSET(STATUS));
+                break;
+
+            case INT_DST_TRANSACTION:
+                hw_int_status = 
+                    DMA_READ(DMA_DST_TRX_COMPLETE_REG_OFFSET(STATUS));
+                break;
+
+            case INT_ERROR:
+                hw_int_status = 
+                    DMA_READ(DMA_ERROR_REG_OFFSET(STATUS));
+                break;
+
+            case INT_SRC_TRANSACTION:
+                hw_int_status = 
+                    DMA_READ(DMA_SRC_TRX_COMPLETE_REG_OFFSET(STATUS));
+                break;
+
+            case INT_TRANSFER:
+                hw_int_status = 
+                    DMA_READ(DMA_TRANSFER_COMPLETE_REG_OFFSET(STATUS));
+                break;
+
+            default:
+                /* Execution should not get here */
+                hw_int_status = 0;
+        }
+
+        /* Now find a channel number. Do a round
+         * robin search to avoid starving any channels
+         */
+        int_channel = dma->last_int_channel;
+        do {
+            /* Move on to the next channel */
+            int_channel++;
+            if (int_channel >= DMA_CHANNELS) {
+                int_channel = 0;
+            }
+
+            /* Break if the channel status is set and the channel
+             * is enabled.
+             */
+            if ((hw_int_status & (1 << int_channel)) != 0 &&
+                    dma->channel[int_channel].allocated == 1) {
+
+                /* Channel found, set the transfer handle to be returned */
+                dma_xfr = &dma->channel[int_channel].transfer;
+                if (cookie != NULL) {
+                    *cookie = dma_xfr->cookie;
+                }
+                *interrupt_type = int_type;
+                break;
+            }
+
+            /* Repeat until we have got back to where we left off */
+        } while (int_channel != dma->last_int_channel);
+        
+        if (dma_xfr != NULL) {
+            /* Channel found, stop looking */
+            break;
+        }
+    }
+
+    if (dma_xfr == NULL) {
+        DB((LVL_INFO, "firecracker_dma_int_get_xfr, no xfr found\n"));
+    }
+
+    /* Record the channel so that we do not service it next time
+     * without looking for others first.
+     */
+    dma->last_int_channel = int_channel;
+
+    RELEASE_LOCK();
+    return dma_xfr;
+}
+
+
+/*****************************************************************************
+3.1.32. firecracker_dma_handle_block_int
+----------------------------------------
+
+void firecracker_dma_handle_block_int(
+        firecracker_dma_xfr_t dma_xfr, unsigned int *blocks_left)
+
+3.1.32.1 Description
+This function should be called by client code from the block complete interrupt
+handler. This function handles proper termination of multi-block transfers by 
+resetting the CFG.RELOAD_SRC, CFG.RELOAD_DST, CTL.LLP_SRC_EN and CTL.LLP_DST_EN bits
+on the last but one block of the transfer.
+The blocks_left parameter points to a count of the number of blocks in the transfer.
+blocks_left is updated on exit of the function.
+
+3.1.32.2. Parameters
+dma_xfr             - The transfer handle.
+blocks_left         - Pointer to the count of the blocks remaining in the transfer.
+                        This is updated at the end of the transfer
+
+3.1.32.3. Returns
+EINVAL - The transfer is not running.
+*****************************************************************************/
+int firecracker_dma_handle_block_int(
+        firecracker_dma_xfr_t dma_xfr, unsigned int *blocks_left)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    firecracker_dma_list_t list = dma_xfr->list;
+    int res = 0;
+    u32 curr_offset;
+
+    DB((LVL_INFO, "Enter firecracker_dma_handle_block_int\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Check the transfer state */
+    if (get_xfr_state(dma_xfr) != RUNNING) {
+        /* Not running error */
+        DB((LVL_ERR, "Transfer not running\n"));
+        res = EINVAL;
+        goto EXIT;
+    }
+
+    /* Update the number of blocks left */
+    *blocks_left = *blocks_left - 1;
+
+    /* Update the current_block pointer to the next in the list. This
+     * value is currently in the LLP. The LLP will be dereferenced 
+     * (by hardware) on exit of the block complete interrupt so it
+     * should not change while we execute this code.
+     */
+    if (list != NULL) {
+
+        /* Get the offset from the start of the list to the current block */
+        curr_offset = 
+            DMA_READ(DMA_N_LINKED_LIST_POINTER_REG_OFFSET(dma_xfr->channel)) -
+            list->dma_descriptor_list;
+
+        /* Get the current block as the offset from the first */
+        list->current_block = 
+            (descriptor_t *)(((char *)list->descriptor_list) + curr_offset);
+    }
+
+    /* Reset the auto-reload enable bits on the last but one block */
+    if (*blocks_left == 1) {
+        dma_xfr->config_low &= ~DMA_RELOAD_SRC;
+        dma_xfr->config_low &= ~DMA_RELOAD_DST;
+
+        /* Write the low configuration register */
+        DMA_WRITE(dma_xfr->config_low,
+                DMA_N_LOW_CONFIGURATION_REG_OFFSET(dma_xfr->channel));
+
+        /* For list type transfers, set the last block LLI.CTLx.LLP_SRC_EN 
+         * and LLI.CTLx.LLP_DST_EN to 0
+         */
+        if (list != NULL) {
+
+            /* Disable the src and dst lists in the last (current) block */
+            list->current_block->hw.control &= ~DMA_LLP_SRC_EN;
+            list->current_block->hw.control &= ~DMA_LLP_DST_EN;
+        }
+    }
+
+EXIT:
+    RELEASE_LOCK();
+    return res;
+}
+
+
+
+/*****************************************************************************
+3.1.23. firecracker_dma_get_raw_status
+--------------------------------------
+
+dma_int_type_t firecracker_dma_get_raw_status(
+    firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types)
+
+3.1.23.1. Description
+Get the raw status of a DMA transfer. The value returned is consistent with the 
+dma_int_type_t type, see 3.2.6.
+This function would typically be used to polling client code.
+
+3.1.23.2. Parameters
+dma_xfr             - The transfer handle.
+int_types           - The status types to be retrieved.
+
+3.1.23.3. Returns
+A bitmask where a '1' bit indicates the status type is set.
+*****************************************************************************/
+dma_int_type_t firecracker_dma_get_raw_status(
+    firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    dma_int_type_t ret = 0;
+    u32 hw_int_status;
+    
+    DB((LVL_INFO, "Enter firecracker_dma_get_raw_status\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* A macro that can be instantiated for each int_type */
+#define GET_RAW_STATUS_TYPE(__type, __reg)                                  \
+    if ((int_types & __type) != 0) {                                        \
+        hw_int_status = DMA_READ(__reg(RAW));                               \
+        if ((hw_int_status & DMA_IRQ_CHANNEL(dma_xfr->channel)) != 0) {       \
+            ret |= __type;                                                  \
+        }                                                                   \
+    }
+
+    GET_RAW_STATUS_TYPE(INT_BLOCK, DMA_BLOCK_COMPLETE_REG_OFFSET);
+    GET_RAW_STATUS_TYPE(INT_DST_TRANSACTION, DMA_DST_TRX_COMPLETE_REG_OFFSET);
+    GET_RAW_STATUS_TYPE(INT_ERROR, DMA_ERROR_REG_OFFSET);
+    GET_RAW_STATUS_TYPE(INT_SRC_TRANSACTION, DMA_SRC_TRX_COMPLETE_REG_OFFSET);
+    GET_RAW_STATUS_TYPE(INT_TRANSFER, DMA_TRANSFER_COMPLETE_REG_OFFSET);
+
+    RELEASE_LOCK();
+    return ret;
+}
+
+
+
+/*****************************************************************************
+3.1.30. firecracker_dma_setup_sg
+--------------------------------
+
+int firecracker_dma_setup_sg(
+    firecracker_dma_xfr_t dma_xfr, firecracker_dma_sg_t *sg, int src_dest)
+
+3.1.30.1 Description
+This function is used to setup the scatter or gather parameters of a DMA transfer.
+If SG is not setup, the DMA transfer defaults to switching the SG capability off.
+
+3.1.30.2. Parameters
+dma_xfr             - The transfer handle.
+sg                  - The SG parameters (see 3.2.3)
+src_dest            - 1 for source and 0 for destination SG 
+
+
+3.1.30.3. Returns
+EBUSY - The DMA transfer is in progress and so cannot be modified at this time 
+*****************************************************************************/
+int firecracker_dma_setup_sg(
+    firecracker_dma_xfr_t dma_xfr,
+    firecracker_dma_sg_t *sg, int src_dst)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    int res = 0;
+
+    DB((LVL_INFO, "Enter firecracker_dma_setup_sg\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+
+    /* Check the transfer state */
+    if (get_xfr_state(dma_xfr) != STOPPED) {
+        /* Already running error */
+        DB((LVL_ERR, "Transfer running\n"));
+        res = EINVAL;
+        goto EXIT;
+    }
+
+    /* Copy the parameters */
+    if (src_dst == SRC) {
+        dma_xfr->gather = *sg;
+    }
+    else {
+        dma_xfr->scatter = *sg;
+    }
+
+EXIT:
+    RELEASE_LOCK();
+    return res;
+}
+
+
+/*****************************************************************************
+3.1.31. firecracker_dma_request_transaction
+-------------------------------------------
+
+int firecracker_dma_request_transaction(
+    firecracker_dma_xfr_t dma_xfr, int src_dest, unsigned int *bytes_left)
+
+3.1.31.1 Description
+This function is used to request a new transaction on the source or destination
+of a transfer. The DMA endpoint (source or destination) needs to be configured
+for software handshaking, otherwise this function has no effect.
+For flow controlling endpoints, the type of transaction, burst, single or last is
+calculated from the bytes_left parameter. For non-flow controlling endpoints, the
+type of transfer is calculated by the hardware (the endpoint enters the single
+transaction region automatically).
+
+Notes:
+1. When requesting transactions of a flow controlling endpoint, the bytes_left
+   parameter can be set to a high value (say 1000) if it is not known how big
+   the block is. This will cause burst endpoints.
+2. Once the size of the block is known, the bytes_left should be set 
+   appropriately. The bytes_left will be updated by the function and the new
+   updated value should be used in the next call to this function.
+3. Once the block size is known, client code should continue to call this 
+   function with the value of bytes_left returned from the previous call and
+   not revert to setting a high value (as in 1).
+4. Client code should not call this function with zero bytes left if the last
+   call specified many bytes left (as in 1). The reason is that the function
+   needs to have prior knowledge of the end of the block so that it can set the
+   last transaction flag on the last transaction.
+5. The bytes_left must be divisible by the transfer width of the source and 
+   destination endpoints.
+
+Briefly (flow controlling endpoints):
+Burst transactions are chosen up to the point where the last burst transaction
+would spill over the end of the DMA buffer (size indicated by 'count').
+Then single transactions are chosen for the remaining data.
+Finally, a last transaction is chosen for the final transaction. 
+
+
+3.1.31.2. Parameters
+dma_xfr             - The transfer handle.
+src_dest            - 1 for source and 0 for destination 
+bytes_left          - The number of bytes left to transfer in the block. This is
+                      used only for flow controlling endpoints and is updated
+                      when the function returns. When this reached zero, no more
+                      transactions should be requested for this endpoint.
+
+
+3.1.31.3. Returns
+EBUSY - The DMA transfer is not in progress and so transaction cannot be requested
+        at this time.
+EFAULT - Something went wrong and the driver did not keep track of the state of the
+         hardware.
+EINVAL - The transfer is not running.
+*****************************************************************************/
+int firecracker_dma_request_transaction(
+        firecracker_dma_xfr_t dma_xfr, int src_dst,
+        unsigned int *bytes_left)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    firecracker_dma_list_t list = dma_xfr->list;
+    firecracker_dma_endpoint_t *endpoint;
+    descriptor_t *curr_desc;
+    int res = 0;
+    int xfr_type;
+
+    DB((LVL_INFO, "Enter firecracker_dma_request_transaction\n"));
+
+    /* Simply lock the API against multiple threads */
+    GET_LOCK();
+    
+    /* Check the transfer state */
+    if (get_xfr_state(dma_xfr) != RUNNING) {
+        /* Not running error */
+        DB((LVL_NOTICE, "Transfer not running\n"));
+        res = EINVAL;
+        goto EXIT;
+    }
+
+    /* Check that a transfer is not already in progress */
+    if (get_transaction_state(dma_xfr, src_dst) == 1) {
+        /* Transaction in progress error */
+        DB((LVL_NOTICE, "Transaction currently in progress\n"));
+        res = EBUSY;
+        goto EXIT;
+    }
+
+    /* If this is not a flow controlling endpoint, always do a 
+     * burst transfer. The hardware will enter the single transaction
+     * region automatically and interoperate our request appropriately
+     */
+    if ((src_dst == SRC && dma_xfr->src.flow_controller == 0) ||
+            (src_dst == DST && dma_xfr->dst.flow_controller == 0)) {
+
+        transfer_request(dma_xfr, src_dst, TRT_SINGLE | TRT_BURST);
+    }
+    else {  /* Endpoint is a flow controller */
+
+        /* Handle non-list differently from list transfers */
+        if (list == NULL) {
+
+            /* Get the correct endpoint */
+            if (src_dst == SRC) {
+                endpoint = &dma_xfr->src;
+            }
+            else {
+                endpoint = &dma_xfr->dst;
+            }
+        }
+        else { /* Multi-block list type */
+
+            /* Find the current running block */
+            curr_desc = list->current_block;
+
+            /* Get the correct endpoint */
+            if (src_dst == SRC) {
+                /* If auto-reload type, use the first element */
+                if (list->src_list == 0) {
+                    curr_desc = (descriptor_t *)&list->descriptor_list[0];
+                }
+                endpoint = &curr_desc->sw.src;
+            }
+            else {  /* Dst endpoint */
+                /* If auto-reload type, use the first element */
+                if (list->dst_list == 0) {
+                    curr_desc = (descriptor_t *)&list->descriptor_list[0];
+                }
+                endpoint = &curr_desc->sw.dst;
+            }
+        }   /* multi-block list type transfer */
+
+        /* Work out the transfer type based in the endpoint in use */
+        xfr_type = transfer_type(dma_xfr, endpoint, bytes_left);
+
+        /* do nothing and exit if we have nothing more to transfer */
+        if (xfr_type != TRT_NONE) {
+            /* Request the transfer */
+            transfer_request(dma_xfr, src_dst, xfr_type);
+        }
+    }   /* endpoint is a flow controller */
+
+EXIT:
+    RELEASE_LOCK();
+    return res;
+}
+
+
+/*****************************************************************************
+3.1.24. firecracker_dma_get_dmac_handle
+---------------------------------------
+
+firecracker_dma_t firecracker_dma_get_dmac_handle(int controller)
+
+3.1.24.1. Description
+Get the handle of one of the Firecracker DMA controllers.
+
+3.1.24.2. Parameters
+controller          - The controller number, 0 or 1
+
+3.1.24.3. Returns
+A handle to the DMA driver that is to be used in other driver APIs.
+*****************************************************************************/
+
+static int find_dmac(struct device *device, void *data)
+{
+    struct platform_device *pdev = to_platform_device(device);
+    if (!strcmp(pdev->name, CARDNAME) && (pdev->id == *(int *)data)) {
+        return (int)pdev;
+    }
+    return 0;
+}
+
+firecracker_dma_t firecracker_dma_get_dmac_handle(int controller)
+{
+    struct platform_device *pdev =
+        (struct platform_device *)bus_for_each_dev(
+                &platform_bus_type, NULL, &controller, find_dmac);
+    
+    if (pdev != NULL) {
+        return platform_get_drvdata(pdev);
+    }
+    
+    return NULL;
+}
+
+
+/*****************************************************************************
+3.1.25. firecracker_dma_dump_regs
+---------------------------------
+
+firecracker_dma_dump_regs(firecracker_dma_t dma)
+
+3.1.25.1. Description
+Use printk to output all DMA configuration registers for all channels,
+including the information held in multi-block lists.
+
+3.1.25.2. Parameters
+dma_xfr             - The transfer handle.
+*****************************************************************************/
+void firecracker_dma_dump_regs(firecracker_dma_t dma)
+{
+    int i;
+    u32 reg;
+    u32 llp;
+
+#define PRINT_REG(__name, __offset)                                     \
+    reg = DMA_READ(__offset);                                           \
+    printk("\t"__name":\t0x%08x\n", reg);
+
+#define PRINT_BIT(__name, __mask)                                       \
+    printk("\t\t"__name":\t%u\n", reg & __mask ?1:0);
+
+#define PRINT_FIELD(__name, __mask, __shift)                            \
+        printk("\t\t"__name":\t0x%08x\n", (reg & __mask) >> __shift)
+
+    for (i = 0; i < 4; i++) {
+        printk("CHANNEL %u:\n", i);
+
+        PRINT_REG("SAR", DMA_N_SRC_ADDRESS_REG_OFFSET(i));
+
+        PRINT_REG("DAR", DMA_N_DST_ADDRESS_REG_OFFSET(i));
+
+        PRINT_REG("LLP", DMA_N_LINKED_LIST_POINTER_REG_OFFSET(i));
+        llp = reg;
+        
+        PRINT_REG("CTLlow", DMA_N_CONTROL_REG_OFFSET(i));
+        print_ctl_low(reg);
+        
+        PRINT_REG("CTLhigh", DMA_N_BLOCK_SIZE_REG_OFFSET(i));
+        print_ctl_high(reg);
+        
+        PRINT_REG("CFGlow", DMA_N_LOW_CONFIGURATION_REG_OFFSET(i));
+        PRINT_FIELD("CH_PRIOR", DMA_CH_PRIOR_MASK, DMA_CH_PRIOR_SHIFT);
+        PRINT_BIT("CH_SUSP", DMA_CH_SUSP);
+        PRINT_BIT("FIFO_EMPTY", DMA_FIFO_EMPTY);
+        PRINT_BIT("HS_SEL_DST", DMA_HS_SEL_DST);
+        PRINT_BIT("HS_SEL_SRC", DMA_HS_SEL_SRC);
+        PRINT_BIT("DST_HS_POL", DMA_DST_HS_POL);
+        PRINT_BIT("SRC_HS_POL", DMA_SRC_HS_POL);
+        PRINT_FIELD("MAX_ABRST", DMA_MAX_ABRST_MASK, DMA_MAX_ABRST_SHIFT);
+        PRINT_BIT("RELOAD_SRC", DMA_RELOAD_SRC);
+        PRINT_BIT("RELOAD_DST", DMA_RELOAD_DST);
+        
+        PRINT_REG("CFGhigh", DMA_N_HIGH_CONFIGURATION_REG_OFFSET(i));
+        PRINT_BIT("FCMODE", DMA_FCMODE);
+        PRINT_BIT("FIFO_MODE", DMA_FIFO_MODE);
+        PRINT_FIELD("PROTCTL", DMA_PROTCTL_MASK, DMA_PROTCTL_SHIFT);
+        PRINT_FIELD("SRC_PER", DMA_SRC_PER_MASK, DMA_SRC_PER_SHIFT);
+        PRINT_FIELD("DEST_PER", DMA_DST_PER_MASK, DMA_DST_PER_SHIFT);
+        
+        PRINT_REG("SGR", DMA_N_SRC_GATHER_REG_OFFSET(i));
+        PRINT_FIELD("SGI", DMA_SG_INTERVAL_MASK, DMA_SG_INTERVAL_SHIFT);
+        PRINT_FIELD("SGC", DMA_SG_COUNT_MASK, DMA_SG_COUNT_SHIFT);
+        
+        PRINT_REG("DSR", DMA_N_DST_SCATTER_REG_OFFSET(i));
+        PRINT_FIELD("DSI", DMA_SG_INTERVAL_MASK, DMA_SG_INTERVAL_SHIFT);
+        PRINT_FIELD("DSC", DMA_SG_COUNT_MASK, DMA_SG_COUNT_SHIFT);
+
+#if 0   /* TODO - This code contains a bug, it uses the physical address
+           from the llp where it should use a virtual address. */
+           
+#define PRINT_LLP_REG(__name, __field)                                  \
+    reg = ((hw_block_descriptor_t *)llp)->__field;                      \
+    printk("\tLLP."__name":\t0x%08x\n", reg);
+
+        if (llp != 0) {
+            printk("MULTI BLOCK LIST:\n");
+            do {
+                printk("\tBLOCK @ 0x%08x :\n", llp);
+
+                PRINT_LLP_REG("SAR", source_addr);
+                PRINT_LLP_REG("DAR", dest_addr);
+                PRINT_LLP_REG("LLP", link);
+                PRINT_LLP_REG("CTLlow", control);
+                print_ctl_low(reg);
+                PRINT_LLP_REG("CTLhigh", block_ts);
+                print_ctl_high(reg);
+
+                llp = ((hw_block_descriptor_t *)llp)->link;
+            } while (llp != 0);
+        }
+#endif
+    }
+
+#define PRINT_CH_REG(__name, __offset)                                  \
+    reg = DMA_READ(__offset);                                           \
+    printk("\t"__name":\t ch0(%u) ch1(%u) ch2(%u) ch3(%u)\n", reg&DMA_CHANNEL(0)?1:0, reg&DMA_CHANNEL(1)?1:0, reg&DMA_CHANNEL(2)?1:0, reg&DMA_CHANNEL(3)?1:0);
+
+    printk("INTERRUPTS:\n");
+
+    PRINT_CH_REG("RawTfr", DMA_TRANSFER_COMPLETE_REG_OFFSET(RAW));
+    PRINT_CH_REG("RawBlock", DMA_BLOCK_COMPLETE_REG_OFFSET(RAW));
+    PRINT_CH_REG("RawSrcTran", DMA_SRC_TRX_COMPLETE_REG_OFFSET(RAW));
+    PRINT_CH_REG("RawDstTran", DMA_DST_TRX_COMPLETE_REG_OFFSET(RAW));
+    PRINT_CH_REG("RawErr", DMA_ERROR_REG_OFFSET(RAW));
+
+    PRINT_CH_REG("StatusTfr", DMA_TRANSFER_COMPLETE_REG_OFFSET(STATUS));
+    PRINT_CH_REG("StatusBlock", DMA_BLOCK_COMPLETE_REG_OFFSET(STATUS));
+    PRINT_CH_REG("StatusSrcTran", DMA_SRC_TRX_COMPLETE_REG_OFFSET(STATUS));
+    PRINT_CH_REG("StatusDstTran", DMA_DST_TRX_COMPLETE_REG_OFFSET(STATUS));
+    PRINT_CH_REG("StatusErr", DMA_ERROR_REG_OFFSET(STATUS));
+
+    PRINT_CH_REG("MaskTfr", DMA_TRANSFER_COMPLETE_REG_OFFSET(MASK));
+    PRINT_CH_REG("MaskBlock", DMA_BLOCK_COMPLETE_REG_OFFSET(MASK));
+    PRINT_CH_REG("MaskSrcTran", DMA_SRC_TRX_COMPLETE_REG_OFFSET(MASK));
+    PRINT_CH_REG("MaskDstTran", DMA_DST_TRX_COMPLETE_REG_OFFSET(MASK));
+    PRINT_CH_REG("MaskErr", DMA_ERROR_REG_OFFSET(MASK));
+
+    PRINT_REG("StatusInt", DMA_IRQ_STATUS_REG_OFFSET);
+    PRINT_BIT("TFR", DMA_STATUS_TFR);
+    PRINT_BIT("BLOCK", DMA_STATUS_BLOCK);
+    PRINT_BIT("SRCT", DMA_STATUS_SRCT);
+    PRINT_BIT("DSTT", DMA_STATUS_DSTT);
+    PRINT_BIT("ERR", DMA_STATUS_ERR);
+
+    printk("HANDSHAKING:\n");
+    PRINT_CH_REG("ReqSrcReg", DMA_SRC_TRX_REQUEST_REG_OFFSET(BURST));
+    PRINT_CH_REG("ReqDstReg", DMA_DST_TRX_REQUEST_REG_OFFSET(BURST));
+    PRINT_CH_REG("SglReqSrcReg", DMA_SRC_TRX_REQUEST_REG_OFFSET(SINGLE));
+    PRINT_CH_REG("SglReqDstReg", DMA_DST_TRX_REQUEST_REG_OFFSET(SINGLE));
+    PRINT_CH_REG("LstSrcReg", DMA_SRC_TRX_REQUEST_REG_OFFSET(LAST));
+    PRINT_CH_REG("LstDstReg", DMA_DST_TRX_REQUEST_REG_OFFSET(LAST));
+
+    printk("MISC:\n");
+    PRINT_REG("DmaCfgReg", DMA_CONFIGURATION_REG_OFFSET);
+    PRINT_CH_REG("ChEnReg", DMA_CHANNEL_ENABLE_REG_OFFSET);
+    PRINT_REG("DmaIdReg", DMA_ID_REG_OFFSET);
+    PRINT_REG("DmaTestReg", DMA_TEST_REG_OFFSET);
+}
+
+
+/* Name: print_ctl_low
+ */
+/**Purpose: Printk the bits of the low dword of the control register
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: Output to printk
+ *
+ * @param reg - The value of the low part of the control register 
+ */
+static void print_ctl_low(u32 reg)
+{
+    PRINT_BIT("INT_EN", DMA_INT_EN);
+    PRINT_FIELD("DST_TR_WIDTH", DMA_DST_TR_WIDTH_MASK, DMA_DST_TR_WIDTH_SHIFT);
+    PRINT_FIELD("SRC_TR_WIDTH", DMA_SRC_TR_WIDTH_MASK, DMA_SRC_TR_WIDTH_SHIFT);
+    PRINT_FIELD("DINC", DMA_DINC_MASK, DMA_DINC_SHIFT);
+    PRINT_FIELD("SINC", DMA_SINC_MASK, DMA_SINC_SHIFT);
+    PRINT_FIELD("DST_MSIZE", DMA_DST_MSIZE_MASK, DMA_DST_MSIZE_SHIFT);
+    PRINT_FIELD("SRC_MSIZE", DMA_SRC_MSIZE_MASK, DMA_SRC_MSIZE_SHIFT);
+    PRINT_BIT("SRC_GATHER_EN", DMA_SRC_GATHER_EN);
+    PRINT_BIT("DST_SCATTER_EN", DMA_DST_SCATTER_EN);
+    PRINT_FIELD("TT_FC", DMA_TT_FC_MASK, DMA_TT_FC_SHIFT);
+    PRINT_FIELD("DMS", DMA_DMS_MASK, DMA_DMS_SHIFT);
+    PRINT_FIELD("SMS", DMA_SMS_MASK, DMA_SMS_SHIFT);
+    PRINT_BIT("LLP_DST_EN", DMA_LLP_DST_EN);
+    PRINT_BIT("LLP_SRC_EN", DMA_LLP_SRC_EN);
+}
+
+
+/* Name: print_ctl_high
+ */
+/**Purpose: Printk the bits of the high dword of the control register
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: Output to printk
+ *
+ * @param reg - The value of the low part of the control register 
+ */
+static void print_ctl_high(u32 reg)
+{
+    PRINT_FIELD("BLOCK_TS", DMA_BLOCK_TS_MASK, DMA_BLOCK_TS_SHIFT);
+    PRINT_BIT("DONE", DMA_DONE);
+}
+
+
+
+/* Hardware initialisation */
+/* Name: hw_initialise
+ */
+/**Purpose: Initialise the DMA engine and enable it.
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: DMA engine enabled, all channels disabled.
+ *
+ * @param dma - Engine context
+ */
+static void hw_initialise(firecracker_dma_t dma)
+{
+    int ch;
+
+    /* Disable the hardware before we initialise it */
+    hw_shutdown(dma);
+
+    /* Switch all channels off and enable the DMA engine */
+    for (ch = 0; ch < DMA_CHANNELS; ++ch) {
+        DMA_WRITE(DMA_DISABLE_CHANNEL(ch), DMA_CHANNEL_ENABLE_REG_OFFSET);
+    }
+
+    /* Enable the engine */
+    DMA_WRITE(DMA_ENABLE, DMA_CONFIGURATION_REG_OFFSET);
+}
+
+
+/* Name: hw_shutdown
+ */
+/**Purpose: Disable the DMA hardware
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: The DMA engine is disabled.
+ *
+ * @param dma - Engine context
+ */
+static void hw_shutdown(firecracker_dma_t dma)
+{
+    /* Disable the DMA */
+    DMA_WRITE(~DMA_ENABLE, DMA_CONFIGURATION_REG_OFFSET);
+}
+
+
+/* Name: alloc_xfr
+ */
+/**Purpose: Allocate a transfer.
+ *
+ * Pre-conditions: The engine is initialised.
+ *
+ * Post-conditions: One of the DMA channels is marked as in use. The associated
+ * transfer is initialised.
+ *
+ * Notes: There are 4 transfers available per engine.
+ *
+ * @param dma - Engine context
+ *
+ * @return handle to the new allocated transfer or NULL if none available. 
+ *
+ * @see free_xfr()
+ */
+static firecracker_dma_xfr_t alloc_xfr(firecracker_dma_t dma)
+{
+    firecracker_dma_xfr_t dma_xfr;
+    int ch;
+
+    /* Find a free channel */
+    for (ch = 0; ch < DMA_CHANNELS; ++ch) {
+        if (dma->channel[ch].allocated == 0) {
+            break;
+        }
+    }
+
+    if (ch == DMA_CHANNELS) {
+        /* No channels available */
+        DB((LVL_ERR, "All channels in use\n"));
+        return NULL;
+    }
+
+    /* Pointer to the new transfer */
+    dma_xfr = &dma->channel[ch].transfer;
+
+    /* Reset the structure */
+    memset(dma_xfr, 0, sizeof(struct firecracker_dma_xfr_tag));
+
+    /* Set the link to the engine context */
+    dma_xfr->dma = dma;
+
+    /* Set the channel number and allocated flag */
+    dma->channel[ch].allocated = 1;
+    dma_xfr->channel = ch;
+
+    return dma_xfr;
+}
+
+/* Name: free_xfr
+ */
+/**Purpose: Release a transfer and its DMA channel so that it 
+ * becomes available to be allocated.
+ *
+ * Pre-conditions: The transfer is allocated from alloc_xfr.
+ *
+ * Post-conditions: The transfer is available for allocation. Any 
+ * handshaking interfaces used by the transfer are made available.
+ *
+ * @param dma_xfr - The transfer handle returned from alloc_xfr 
+ *
+ * @see alloc_xfr()
+ */
+static void free_xfr(firecracker_dma_xfr_t dma_xfr)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+
+    /* Reset the allocated flag */
+    dma->channel[dma_xfr->channel].allocated = 0;
+
+    /* Release any handshaking interfaces used in the transfer */
+    if (dma_xfr->src_handshaking == 1) {
+        dma->handshaking_inuse[dma_xfr->src_handshake.interface] = 0;
+    }
+    if (dma_xfr->dst_handshaking == 1) {
+        dma->handshaking_inuse[dma_xfr->dst_handshake.interface] = 0;
+    }
+}
+
+
+/* Name: alloc_list
+ */
+/**Purpose: Allocate the list to multi-block transfers
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: Heap memory allocated. The allocated list is initialised.
+ *
+ * Notes: The length of the list allocated is set at the calling time.
+ * Memory should be allocated by free_list.
+ *
+ * @param count - the maximum number of elements to the list. 
+ *
+ * @return handle of the newly allocated list 
+ *
+ * @see free_list()
+ */
+static firecracker_dma_list_t alloc_list(
+        firecracker_dma_t dma, unsigned int count)
+{
+    firecracker_dma_list_t list;
+
+    /* Allocate the object */
+    list = kzalloc(sizeof(struct firecracker_dma_list_tag), GFP_ATOMIC);
+    if (list == NULL) {
+        /* No memory, return null */
+        DB((LVL_ERR, "Out of memory to allocate list\n"));
+        return NULL;
+    }
+
+    /* Hold the device in the list for freeing */
+    list->device = dma->device;
+
+    /* Allocate the list. This must be on a 32-bit word boundary for the
+     * hardware. We need a coherent buffer so to avoid the 
+     * cache. This means that changes to the descriptors will be
+     * seen immediately by the hardware.
+     */
+    list->descriptor_list = 
+        (aligned_descriptor_t *)dma_alloc_coherent(
+            list->device, sizeof(aligned_descriptor_t) * count,
+            &list->dma_descriptor_list, GFP_ATOMIC);
+    if (list->descriptor_list == NULL) {
+        /* No memory, free the object and return null */
+        DB((LVL_ERR, "Out of memory to allocate list\n"));
+        kfree(list);
+        return NULL;
+    }
+
+    /* Reset the list */
+    memset(list->descriptor_list, 0, sizeof(aligned_descriptor_t) * count);
+
+    return list;
+}
+
+/* Name: lookup_tt_fc
+ */
+/**Purpose: Given the periph_not_mem and flow controller flags for the source
+ * and destination endpoints, work out the TT_FC field value.
+ *
+ * Pre-conditions: Memory endpoints must not be flow controllers.
+ * Both source and destination cannot be flow controllers.
+ *
+ * Post-conditions: None.
+ *
+ * @param src_periph - 1 for source peripheral, 0 for memory 
+ * @param src_fc - 1 for source flow controller 
+ * @param dst_periph - 1 for destination peripheral, 0 for memory 
+ * @param dst_fc - 1 for destination flow controller 
+ *
+ * @return <Comment about return var> 
+ */
+
+
+/* Lookup the value in the TT_FC field from the periph_not_mem and
+ * flow_controller flags.
+ */
+
+/* Transfer Type/Flow Controller encoding table */
+struct tt_fc_lookup_tag {
+    int src_periph;      /* Source is peripheral not memory */
+    int src_fc;          /* Source is a flow controller */
+    int dst_periph;      /* Destination is peripheral not memory */
+    int dst_fc;          /* Destination is a flow controller */
+} tt_fc_lookup[] = {
+    {0, 0, 0, 0},           /* M to M, DMA FC */
+    {0, 0, 1, 0},           /* M to P, DMA FC */
+    {1, 0, 0, 0},           /* P to M, DMA FC */
+    {1, 0, 1, 0},           /* P to P, DMA FC */
+    {1, 1, 0, 0},           /* P to M, SRC FC */
+    {1, 1, 1, 0},           /* P to P, SRC FC */
+    {0, 0, 1, 1},           /* M to P, DST FC */
+    {1, 0, 1, 1}            /* P to P, DST FC */
+};
+#define TT_FC_LEN (sizeof(tt_fc_lookup) / sizeof(struct tt_fc_lookup_tag))
+   
+
+static u32 lookup_tt_fc(
+    int src_periph,      /* Source is peripheral not memory */
+    int src_fc,          /* Source is a flow controller */
+    int dst_periph,      /* Destination is peripheral not memory */
+    int dst_fc)          /* Destination is a flow controller */
+{
+    u32 tt_fc;
+    struct tt_fc_lookup_tag match;
+
+    match.src_periph = src_periph;
+    match.src_fc = src_fc;
+    match.dst_periph = dst_periph;
+    match.dst_fc = dst_fc;
+
+    for (tt_fc = 0; tt_fc < TT_FC_LEN; ++tt_fc)
+    {
+        if (memcmp(&tt_fc_lookup[tt_fc], &match, 
+                    sizeof(struct tt_fc_lookup_tag)) == 0) {
+            return tt_fc;
+        }
+    }
+
+    return 0;
+}
+
+
+/* Name: build_control_register
+ */
+/**Purpose: Given a source and destination endpoint, build the contents of
+ * the control register (CTL[0:32]).
+ *
+ * Pre-conditions: The source and destination endpoints are valid endpoints.
+ *
+ * Post-conditions: None.
+ *
+ * Notes: The DMA_LLP_SRC_EN and DMA_LLP_DST_EN bits are set by the 
+ * build_llp_control_register function so that we do not set these bits
+ * when used for the last element of a multi-block list.
+ *
+ * @param src - Source endpoint parameters
+ * @param dst - Destination endpoint parameters
+ *
+ * @return The 32-bit value to be programmed into the control register.
+ */
+static u32 build_control_register(
+        firecracker_dma_endpoint_t *src, firecracker_dma_endpoint_t *dst)
+{
+    u32 tt_fc;                      /* New TT_FC reg */
+
+    /* Build up the control register */
+    u32 control = 0;
+
+    /* Enable the channel global interrupt */
+    control |= DMA_INT_EN;
+
+    /* Set the Source/Destination Transfer Width */
+    control |= (((u32)src->tr_width << DMA_SRC_TR_WIDTH_SHIFT) 
+            & DMA_SRC_TR_WIDTH_MASK);
+    control |= (((u32)dst->tr_width << DMA_DST_TR_WIDTH_SHIFT) 
+            & DMA_DST_TR_WIDTH_MASK);
+
+    /* Set the Source/Destination address incrementing */
+    control |= (((u32)src->addr_inc << DMA_SINC_SHIFT) & DMA_SINC_MASK);
+    control |= (((u32)dst->addr_inc << DMA_DINC_SHIFT) & DMA_DINC_MASK);
+
+    /* Set the Source/Destination transaction length */
+    control |= ((src->msize << DMA_SRC_MSIZE_SHIFT) 
+            & DMA_SRC_MSIZE_MASK);
+    control |= ((dst->msize << DMA_DST_MSIZE_SHIFT) 
+            & DMA_DST_MSIZE_MASK);
+
+    /* Scatter gather enable */
+    if (src->enable_sg == 1) {
+        control |= DMA_SRC_GATHER_EN;
+    }
+    if (dst->enable_sg == 1) {
+        control |= DMA_DST_SCATTER_EN;
+    }
+
+    /* Set the transfer type and flow control */
+    tt_fc = lookup_tt_fc(
+            src->periph_not_mem,
+            src->flow_controller,
+            dst->periph_not_mem,
+            dst->flow_controller);
+    control |= ((tt_fc << DMA_TT_FC_SHIFT) & DMA_TT_FC_MASK);
+
+    /* Set the Source/Destination master select */
+    control |= (((u32)src->ahb_master_select << DMA_SMS_SHIFT) & DMA_SMS_MASK);
+    control |= (((u32)dst->ahb_master_select << DMA_DMS_SHIFT) & DMA_DMS_MASK);
+
+    return control;
+}
+
+
+
+/* Name: build_llp_control_register
+ */
+/**Purpose: Given a linked list, build the contents of
+ * the control register source/dest block chaining bits.
+ *
+ * Pre-conditions: The list ia a valid list.
+ *
+ * Post-conditions: None.
+ *
+ * @param list - Non-NULL indicates a list type transfer.
+ *
+ * @return The 32-bit value to be programmed into the control register.
+ */
+static u32 build_llp_control_register(firecracker_dma_list_t list)
+{
+    /* Build up the control register */
+    u32 control = 0;
+
+    /* Set the source/destination block chaining enable */
+    if (list != NULL) {
+        if (list->src_list == 1) {
+            control |= DMA_LLP_SRC_EN;
+        }
+        if (list->dst_list == 1) {
+            control |= DMA_LLP_DST_EN;
+        }
+    }
+
+    return control;
+}
+
+
+/* Name: update_xfr_registers
+ */
+/**Purpose: DMA channel given a transfer.
+ *
+ * Pre-conditions: The transfer is not running. The transfer is valid.
+ *
+ * Post-conditions: DMA registers are written.
+ *
+ * Notes: For linked list transfers, the list is allocated and setup in the
+ * transfer.
+ * This function handles setting up all registers for the DMA transfer.
+ *
+ * @param dma_xfr - The transfer handle 
+ */
+static void update_xfr_registers(firecracker_dma_xfr_t dma_xfr)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    firecracker_dma_endpoint_t *src;
+    firecracker_dma_endpoint_t *dst;
+    firecracker_dma_list_t list = dma_xfr->list;
+    unsigned int flags = dma_xfr->flags;
+    unsigned int count = dma_xfr->count;
+    unsigned int ch = dma_xfr->channel;
+    u32 block_ts;                   /* New BLOCK_TS reg */
+    u32 sg;                         /* New scatter/gather reg */
+    descriptor_t *desc;
+
+    /* If we are using a list, the src and dst endpoint information is
+     * held in the list. The first element in the list sets the registers.
+     * If we are not using a list, the src and dst 
+     * endpoint information is held in the transfer itself.
+     */
+    /* Write the linked list pointer. This will be NULL if we have not
+     * setup for linked multi-block.
+     */
+    if (list == NULL) {
+        src = &dma_xfr->src;
+        dst = &dma_xfr->dst;
+
+        DMA_WRITE(0,
+                DMA_N_LINKED_LIST_POINTER_REG_OFFSET(ch));
+    }
+    else {
+        desc = (descriptor_t *)list->descriptor_list;
+
+        src = &desc->sw.src;
+        dst = &desc->sw.dst;
+
+        /* Set the LLP register to the start of the block list */
+        DMA_WRITE(list->dma_descriptor_list, 
+                DMA_N_LINKED_LIST_POINTER_REG_OFFSET(ch));
+    }
+
+    /* Write the Source/Destination address registers */
+    DMA_WRITE(src->dma_addr, DMA_N_SRC_ADDRESS_REG_OFFSET(ch));
+    DMA_WRITE(dst->dma_addr, DMA_N_DST_ADDRESS_REG_OFFSET(ch));
+
+    /* Write the control register */
+    DMA_WRITE(
+            build_control_register(src, dst) | build_llp_control_register(list),
+            DMA_N_CONTROL_REG_OFFSET(ch));
+
+    /* Write the block transfer size (top dword of control register) */
+    block_ts = count / TR_BYTES(src);
+    DMA_WRITE(block_ts, DMA_N_BLOCK_SIZE_REG_OFFSET(ch));
+
+    /* Build the low configuration register */
+    dma_xfr->config_low = 0;
+
+    /* Set the channel priority */
+    dma_xfr->config_low |= ((((u32)flags & CH_PRIOR_MASK) 
+                << DMA_CH_PRIOR_SHIFT) & DMA_CH_PRIOR_MASK);
+
+    /* Set software handshaking for source and destination */
+    if (dma_xfr->src_handshaking == 1) {
+        /* Is hardware handshaking, set polarity */
+        if (dma_xfr->src_handshake.active_low == 1) {
+            dma_xfr->config_low |= DMA_SRC_HS_POL;
+        }
+    }
+    else {
+        /* Set software handshaking */
+        dma_xfr->config_low |= DMA_HS_SEL_SRC;
+    }
+
+    if (dma_xfr->dst_handshaking == 1) {
+        /* Is hardware handshaking, set polarity */
+        if (dma_xfr->dst_handshake.active_low == 1) {
+            dma_xfr->config_low |= DMA_DST_HS_POL;
+        }
+    }
+    else { 
+        /* Set software handshaking */
+        dma_xfr->config_low |= DMA_HS_SEL_DST;
+    }
+
+    /* Set the source and destination auto-reload */
+    if (src->auto_reload == 1) {
+        dma_xfr->config_low |= DMA_RELOAD_SRC;
+    }
+    if (dst->auto_reload == 1) {
+        dma_xfr->config_low |= DMA_RELOAD_DST;
+    }
+
+    /* Write the low configuration register */
+    DMA_WRITE(dma_xfr->config_low, DMA_N_LOW_CONFIGURATION_REG_OFFSET(ch));
+
+    /* Build the high configuration register */
+    dma_xfr->config_high = 0;
+
+    /* Set the flow control mode */
+    if (flags & FC_MODE) {
+        dma_xfr->config_high |= DMA_FCMODE;
+    }
+
+    /* Set the FIFO mode */
+    if (flags & FIFO_MODE) {
+        dma_xfr->config_high |= DMA_FIFO_MODE;
+    }
+
+    /* Set the protection control */
+    dma_xfr->config_high |= ((((u32)flags & PROTCTL_MASK) >> PROTCTL_SHIFT
+                << DMA_PROTCTL_SHIFT) & DMA_PROTCTL_MASK);
+
+    /* Set the src/dst handshaking peripheral */
+    if (dma_xfr->src_handshaking == 1) {
+        dma_xfr->config_high |= 
+            (((u32)dma_xfr->src_handshake.interface << DMA_SRC_PER_SHIFT)
+             & DMA_SRC_PER_MASK);
+    }
+    if (dma_xfr->dst_handshaking == 1) {
+        dma_xfr->config_high |= 
+            (((u32)dma_xfr->dst_handshake.interface << DMA_DST_PER_SHIFT)
+             & DMA_DST_PER_MASK);
+    }
+
+    /* Write the high configuration register */
+    DMA_WRITE(dma_xfr->config_high, DMA_N_HIGH_CONFIGURATION_REG_OFFSET(ch));
+
+    /* Set the Scatter/Gather registers */
+    sg = 0;
+    sg |= ((dma_xfr->gather.count / TR_BYTES(src)
+                << DMA_SG_COUNT_SHIFT) & DMA_SG_COUNT_MASK);
+    sg |= ((dma_xfr->gather.interval / TR_BYTES(src)
+                << DMA_SG_INTERVAL_SHIFT) & DMA_SG_INTERVAL_MASK);
+    DMA_WRITE(sg, DMA_N_SRC_GATHER_REG_OFFSET(ch));
+
+    sg = 0;
+    sg |= ((dma_xfr->scatter.count / TR_BYTES(dst)
+                << DMA_SG_COUNT_SHIFT) & DMA_SG_COUNT_MASK);
+    sg |= ((dma_xfr->scatter.interval / TR_BYTES(dst)
+                << DMA_SG_INTERVAL_SHIFT) & DMA_SG_INTERVAL_MASK);
+    DMA_WRITE(sg, DMA_N_DST_SCATTER_REG_OFFSET(ch));
+}
+
+
+/* Name: get_xfr_state
+ */
+/**Purpose: Get/update the current state of a DMA transfer
+ *
+ * Pre-conditions: The transfer is allocated and initialised.
+ *
+ * Post-conditions: The transfer state is updated if the hardware indicates
+ * that it is not running.
+ *
+ * Notes: Transfers are started in software and can stop in hardware. This
+ * function gets the combined state.
+ *
+ * @param dma_xfr - The transfer handle 
+ *
+ * @return RUNNING, STOPPED or STOPPING. 
+ */
+static int get_xfr_state(firecracker_dma_xfr_t dma_xfr)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    u32 hw_state;
+
+    /* Read the channel enables */
+    hw_state = DMA_READ(DMA_CHANNEL_ENABLE_REG_OFFSET);
+
+    /* If the channel is not enabled, it has stopped */
+    if ((hw_state & DMA_CHANNEL(dma_xfr->channel)) == 0) {
+        dma_xfr->state = STOPPED;
+    }
+
+    return dma_xfr->state;
+}
+
+
+/* Name: write_int_registers
+ */
+/**Purpose: Write many interrupt registers at once.
+ *
+ * Pre-conditions: The engine is initialised.
+ *
+ * Post-conditions: Several interrupt registers are updated
+ *
+ * @param dma - The engine context
+ * @param int_types - A bit-field of the interrupt types to be affected. 
+ *                      interrupt types include block, src/dst transaction,
+ *                      error and transfer complete. See dma_int_type_t.
+ * @param type - The property of the interrupt to update. Interrupt properties
+ *                 include MASK or CLEAR.
+ * @param value - The value to write to the interrupt registers.
+ */
+static void write_int_registers(
+        firecracker_dma_t dma, dma_int_type_t int_types,
+        unsigned int type, u32 value)
+{
+#define WRITE_INT_REG_TYPE(__type, __reg)                                   \
+    if ((int_types & __type) != 0) {                                        \
+        DMA_WRITE(value, __reg(type));                                      \
+    }
+
+    WRITE_INT_REG_TYPE(INT_BLOCK, DMA_BLOCK_COMPLETE_REG_OFFSET);
+    WRITE_INT_REG_TYPE(INT_DST_TRANSACTION, DMA_DST_TRX_COMPLETE_REG_OFFSET);
+    WRITE_INT_REG_TYPE(INT_ERROR, DMA_ERROR_REG_OFFSET);
+    WRITE_INT_REG_TYPE(INT_SRC_TRANSACTION, DMA_SRC_TRX_COMPLETE_REG_OFFSET);
+    WRITE_INT_REG_TYPE(INT_TRANSFER, DMA_TRANSFER_COMPLETE_REG_OFFSET);
+}
+
+
+/* Name: transfer_type
+ */
+/**Purpose: Return the transfer request signals (software handshaking) that
+ * need to be asserted for the next transaction
+ *
+ * Pre-conditions: The transfer is running. The bytes_left is divisible by 
+ * the transfer width. The endpoint uses software handshaking.
+ *
+ * Post-conditions: None.
+ *
+ * @param dma_xfr - The transfer handle 
+ * @param endpoint - The endpoint for which the transfer request is to be made.
+ * @param bytes_left - The number of bytes of the block left to transfer
+ *
+ * @return bit field with TRT_BURST, TRT_LAST, TRT_SINGLE bits set according
+ * to the correct settings for the next transfer request.
+ *
+ * @see transfer_request()
+ */
+static int transfer_type(
+        firecracker_dma_xfr_t dma_xfr,
+        firecracker_dma_endpoint_t *endpoint,
+        unsigned int *bytes_left)
+{
+    /* Burst transactions while there is enough data left for a whole
+     * burst.
+     */
+    if (*bytes_left > BURST_BYTES(endpoint)) {
+        /* Increment the transferred count by a burst */
+        *bytes_left -= BURST_BYTES(endpoint);
+        return TRT_BURST;
+    }
+
+    if (*bytes_left == BURST_BYTES(endpoint)) {
+        /* Increment the transferred count by a burst */
+        *bytes_left -= BURST_BYTES(endpoint);
+        return TRT_BURST | TRT_LAST;
+    }
+
+    /* Single transactions up to the last */
+    if (*bytes_left > TR_BYTES(endpoint)) {
+        /* Increment the transferred counter by a single transaction */
+        *bytes_left -= TR_BYTES(endpoint);
+        /* For a single transfer, set the single and burst bits */
+        return TRT_SINGLE | TRT_BURST;
+    }
+     
+    /* Last transaction at the end. Note, it is impossible to 
+     * transfer less than a transfer width.
+     * This is defensive, parameter checking should ensure we always
+     * have a block size that is a whole number of transfer widths.
+     */
+    if (*bytes_left == TR_BYTES(endpoint)) {
+        /* Increment the transferred counter by a single transaction */
+        *bytes_left -= TR_BYTES(endpoint);
+        /* For a single transfer, set the single and burst bits */
+        return TRT_SINGLE | TRT_BURST | TRT_LAST;
+    }
+
+    return TRT_NONE;
+}
+
+
+/* Name: get_transaction_state
+ */
+/**Purpose: Checks that a transfer request (software handshaking) is not in
+ * progress.
+ *
+ * Pre-conditions: The transfer is running. 
+ * The endpoint uses software handshaking.
+ *
+ * Post-conditions: None.
+ *
+ * @param dma_xfr - The transfer handle 
+ * @param src_dst - The source or destination of the transfer.
+ *
+ * @return 1 if a transfer request is in progress and 0 otherwise.
+ */
+static int get_transaction_state(
+        firecracker_dma_xfr_t dma_xfr, int src_dst)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+    u32 status;
+
+    /* Get the burst or single status bits, burst for flow controllers */
+    if (src_dst == SRC) {
+        if (dma_xfr->src.flow_controller == 0) {
+            status = DMA_READ(DMA_SRC_TRX_REQUEST_REG_OFFSET(SINGLE));
+        }
+        else {
+            status = DMA_READ(DMA_SRC_TRX_REQUEST_REG_OFFSET(BURST));
+        }
+    }
+    else {
+        if (dma_xfr->dst.flow_controller == 0) {
+            status = DMA_READ(DMA_DST_TRX_REQUEST_REG_OFFSET(SINGLE));
+        }
+        else {
+            status = DMA_READ(DMA_DST_TRX_REQUEST_REG_OFFSET(BURST));
+        }
+    }
+
+    /* Return 1 if the burst bit is set for the channel */
+    if ((status & DMA_CHANNEL(dma_xfr->channel)) != 0) {
+        return 1;
+    }
+
+    return 0;
+}
+
+
+/* Name: transfer_request
+ */
+/**Purpose: Set the DMA transfer request registers to trigger a request.
+ *
+ * Pre-conditions: The transfer is running. The endpoint uses software 
+ * handshaking. 
+ *
+ * Post-conditions: DMA transfer request registers updated.
+ *
+ * @param dma_xfr - The transfer handle 
+ * @param src_dst - Selects the source or destination endpoint.
+ * @param type - Bit field is the flags that need to be set (returned from 
+ *               transfer_type.
+ *
+ * @see transfer_type()
+ */
+static void transfer_request(
+        firecracker_dma_xfr_t dma_xfr, int src_dst, int type)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+
+    /* A macro that sets the correct channel/request type bits */
+#define MAKE_REQUEST(__type)                                                \
+        if (src_dst == SRC) {                                              \
+            DMA_WRITE(DMA_REQ_CHANNEL(dma_xfr->channel),                    \
+                    DMA_SRC_TRX_REQUEST_REG_OFFSET(__type));                \
+        }                                                                   \
+        else {                                                              \
+            DMA_WRITE(DMA_REQ_CHANNEL(dma_xfr->channel),                    \
+                    DMA_DST_TRX_REQUEST_REG_OFFSET(__type));                \
+        }
+
+    if ((type & TRT_LAST) != 0) {
+        MAKE_REQUEST(LAST);
+    }
+
+    if ((type & TRT_SINGLE) != 0) {
+        MAKE_REQUEST(SINGLE);
+    }
+
+    if ((type & TRT_BURST) != 0) {
+        MAKE_REQUEST(BURST);
+    }
+}
+
+
+/* Name: set_auto_burst_length
+ */
+/**Purpose: This function deals with the 'auto' setting for the transaction
+ * size. It chooses the best transaction size and updates the endpoint 
+ * parameters.
+ *
+ * Pre-conditions: The count parameter is divisible by the transfer width.
+ * The block size needs to be known and set by calling code.
+ *
+ * Post-conditions: The endpoint is updated with the chosen burst size.
+ *
+ * Notes: The transaction size that results in the fewest transactions 
+ * (burst and single) to complete the block is chosen.
+ *
+ * @param endpoint - The endpoint parameters
+ * @param count - The size of the block in bytes
+ */
+static void set_auto_burst_length(
+        firecracker_dma_endpoint_t *endpoint, unsigned int count)
+{
+    int cost, cheepest_cost = 10000;    /* A big number! */
+    msize_t cheepest = 0;
+
+    /* Check that we has an auto type burst size */
+    if (endpoint->msize != MS_AUTO) {
+        return;
+    }
+
+    /* Try each burst size in turn and make costing. Cheapest wins. */
+    for (endpoint->msize = 0; endpoint->msize < MS_AUTO; ++endpoint->msize) {
+
+        /* If the count is smaller than the transaction size, skip 
+         * the rest as only bigger ones follow
+         */
+        if (BURST_BYTES(endpoint) > count) {
+            break;
+        }
+
+        /* The cost is the number of burst transactions plus the
+         * number of single transactions needed to complete the
+         * block.
+         */
+        cost = count / BURST_BYTES(endpoint);
+        cost += (count % BURST_BYTES(endpoint)) / TR_BYTES(endpoint);
+
+        /* If this is cheaper, remember it */
+        if (cost <= cheepest_cost) {
+            cheepest_cost = cost;
+            cheepest = endpoint->msize;
+        }
+    }
+
+    /* Set the cheapest in the endpoint */
+    endpoint->msize = cheepest;
+}
+
+
+/* Name: param_checks
+ */
+/**Purpose: Do some parameter checks on endpoint parameters.
+ *
+ * Pre-conditions: None.
+ *
+ * Post-conditions: None.
+ *
+ * @param src - The source endpoint parameters
+ * @param dst - The destination endpoint parameters
+ * @param count - The block size
+ *
+ * @return 0 if parameter checking failed and 1 otherwise.
+ */
+static int param_checks(firecracker_dma_endpoint_t *src,
+        firecracker_dma_endpoint_t *dst, unsigned int count)
+{
+    /* Check that the source transfer width is suitable for the number of
+     * bytes to be transferred
+     */
+    if (src != NULL) {
+        if ((count % TR_BYTES(src)) != 0) {
+            DB((LVL_ERR, "Block size not divisible by transfer width\n"));
+            return 0;
+        }
+    }
+
+    /* Check that we are not setting memory as a flow controller */
+    if (src != NULL) {
+        if (src->periph_not_mem == 0 && src->flow_controller == 1) {
+            DB((LVL_ERR, "Memory endpoint cannot be flow controller\n"));
+            return 0;
+        }
+    }
+
+    if (dst != NULL) {
+        if (dst->periph_not_mem == 0 && dst->flow_controller == 1) {
+            DB((LVL_ERR, "Memory endpoint cannot be flow controller\n"));
+            return 0;
+        }
+    }
+
+    /* Check that both the source and destination are not flow controllers */
+    if (src != NULL && dst != NULL) {
+        if (src->flow_controller == 1 && dst->flow_controller == 1) {
+            DB((LVL_ERR, "Only one endpoint can be flow controller\n"));
+            return 0;
+        }
+    }
+
+#ifndef ENABLE_TR_WIDTH
+    /* The DMA controller has fixed source and destination transfer widths.
+     * Reject unsupported modes.
+     */
+    if (src != NULL) {
+        if (src->tr_width != TR_WIDTH32) {
+            DB((LVL_ERR, "DMA Controller only supports 32 bit transfer width\n"));
+            return 0;
+        }
+    }
+    if (dst != NULL) {
+        if (dst->tr_width != TR_WIDTH32) {
+            DB((LVL_ERR, "DMA Controller only supports 32 bit transfer width\n"));
+            return 0;
+        }
+    }
+#endif
+
+    return 1;
+}
+
+
+/* Name: setup_handshaking
+ */
+/**Purpose: Set the handshaking parameter in the transfer endpoint
+ *
+ * Pre-conditions: The transfer in not running.
+ *
+ * Post-conditions: The transfer is updated. Hardware is not updated
+ *
+ * @param dma_xfr - The transfer handle 
+ * @param src_handshake - The source handshaking parameters
+ * @param dst_handshake - The destination handshaking parameters
+ */
+static void setup_handshaking(firecracker_dma_xfr_t dma_xfr,
+        firecracker_dma_handshake_t *src_handshake,
+        firecracker_dma_handshake_t *dst_handshake)
+{
+    firecracker_dma_t dma = dma_xfr->dma;
+
+    /* Copy the parameters */
+    if (src_handshake != NULL) {
+        dma_xfr->src_handshake = *src_handshake;
+        dma_xfr->src_handshaking = 1;
+
+        /* Mark the interface as in use */
+        dma->handshaking_inuse[src_handshake->interface] = 1;
+    }
+
+    if (dst_handshake != NULL) {
+        dma_xfr->dst_handshake = *dst_handshake;
+        dma_xfr->dst_handshaking = 1;
+
+        /* Mark the interface as in use */
+        dma->handshaking_inuse[dst_handshake->interface] = 1;
+    }
+}
+
+
+/* Name: handshaking_check
+ */
+/**Purpose: Check the handshaking parameters. Check if any handshaking
+ * interface is used on more than one endpoint.
+ *
+ * Pre-conditions: Engine is initialised. The handshaking interfaces in use
+ * are maintained in the engine context.
+ *
+ * Post-conditions: None.
+ *
+ * @param dma - The engine context
+ * @param src_handshaking - The handshaking parameters for the source or 
+ *                          NULL if not using hardware handshaking 
+ *                          parameters for the source.
+ * @param dst_handshaking - As src_handshaking for the destination.
+ *
+ * @return 0 if the handshaking is in use and 1 otherwise
+ */
+static int handshaking_check(firecracker_dma_t dma, 
+        firecracker_dma_handshake_t *src_handshaking, 
+        firecracker_dma_handshake_t *dst_handshaking)
+{
+    if (src_handshaking != NULL) {
+        if (dma->handshaking_inuse[src_handshaking->interface] == 1) {
+            DB((LVL_ERR, "Source handshaking interface in use\n"));
+            return 0;
+        }
+    }
+    if (dst_handshaking != NULL) {
+        if (dma->handshaking_inuse[dst_handshaking->interface] == 1) {
+            DB((LVL_ERR, "Destination handshaking interface in use\n"));
+            return 0;
+        }
+    }
+    if (src_handshaking != NULL && dst_handshaking != NULL) {
+        if (src_handshaking->interface == dst_handshaking->interface) {
+            DB((LVL_ERR, "Same Source and Destination handshaking interface\n"));
+            return 0;
+        }
+    }
+    return 1;
+}
+
+
+static int dmac_drv_probe(struct platform_device *pdev)
+{
+    struct firecracker_dma_tag *dma;
+
+    dma = firecracker_dma_init(pdev);
+    if (!dma) {
+        printk("%s: could not allocate device.\n", CARDNAME);
+        return -ENOMEM;
+    }
+
+    platform_set_drvdata(pdev, dma);
+
+    return 0;
+}
+
+
+static int dmac_drv_remove(struct platform_device *pdev)
+{
+    struct firecracker_dma_tag *dma = platform_get_drvdata(pdev);
+
+    platform_set_drvdata(pdev, NULL);
+
+    firecracker_dma_exit(dma);
+
+    return 0;
+}
+
+
+static struct platform_driver dmac_driver = {
+    .probe      = dmac_drv_probe,
+    .remove     = dmac_drv_remove,
+    .driver     = {
+        .name   = CARDNAME,
+    }
+};
+
+
+static int dmac_init_module(void)
+{
+    int ret;
+
+    ret = platform_driver_register(&dmac_driver);
+    if (ret != 0) {
+        DB((LVL_ERR, "Failed to register DMAC driver\n"));
+        return ret;
+    }
+
+    printk(KERN_INFO "%s version %s loaded\n", TITLE, VERSION);
+
+    return ret;
+}
+
+
+static void dmac_cleanup_module(void)
+{
+    platform_driver_unregister(&dmac_driver);
+}
+
+
+/* Module exports: */
+module_init(dmac_init_module);
+module_exit(dmac_cleanup_module);
+EXPORT_SYMBOL(firecracker_dma_setup_direct_xfr);
+EXPORT_SYMBOL(firecracker_dma_start);
+EXPORT_SYMBOL(firecracker_dma_abort);
+EXPORT_SYMBOL(firecracker_dma_release);
+EXPORT_SYMBOL(firecracker_dma_set_debug_level);
+EXPORT_SYMBOL(firecracker_dma_list_create);
+EXPORT_SYMBOL(firecracker_dma_list_add);
+EXPORT_SYMBOL(firecracker_dma_list_clear);
+EXPORT_SYMBOL(firecracker_dma_list_destroy);
+EXPORT_SYMBOL(firecracker_dma_setup_list_xfr);
+EXPORT_SYMBOL(firecracker_dma_enable_int);
+EXPORT_SYMBOL(firecracker_dma_disable_int);
+EXPORT_SYMBOL(firecracker_dma_clear_int);
+EXPORT_SYMBOL(firecracker_dma_int_get_xfr);
+EXPORT_SYMBOL(firecracker_dma_handle_block_int);
+EXPORT_SYMBOL(firecracker_dma_get_raw_status);
+EXPORT_SYMBOL(firecracker_dma_setup_sg);
+EXPORT_SYMBOL(firecracker_dma_request_transaction);
+EXPORT_SYMBOL(firecracker_dma_get_dmac_handle);
+EXPORT_SYMBOL(firecracker_dma_dump_regs);
+
+
+
+
+
diff --git a/arch/arm/mach-firecracker/firecracker_emac.c b/arch/arm/mach-firecracker/firecracker_emac.c
new file mode 100644
index 0000000..c785a20
--- /dev/null
+++ b/arch/arm/mach-firecracker/firecracker_emac.c
@@ -0,0 +1,4123 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * linux/arch/arm/mach-firecracker/firecracker_emac.c
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Description:
+ *
+ * This module provides the network interface to the firecracker EMAC
+ * hardware.
+ *
+ * References:
+ *
+ * Synopsys DesignWare Ethernet Universal Databook Version 3.2
+ * November 2005.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/etherdevice.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/ethtool.h>
+#include <linux/if_vlan.h>
+#include <mach/io.h>
+#include <asm/delay.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+
+/* Required for hw timestamping */
+#include <net/timestamping.h>
+
+/* Required for DP82640 Ethernet Phy as used on the
+ * PC7802 platform
+ */
+#include <mach/dp83640.h>
+
+/* Constants --------------------------------------------------------------- */
+
+/* Default fixed MAC address to use in this driver. The hardware is read
+ * at initialisation and if no valid address is found there, this
+ * one is used.
+ */
+static unsigned char default_mac_address[ETH_ALEN] =
+{
+    0x00, 0x15, 0xe1, 0x00, 0x00, 0x00
+};
+
+/* Used to store the io remapped base address of the EMAC block */
+static void __iomem *mem_region = NULL;
+
+/* Forward structure reference */
+struct emac_dma_desc;
+
+/* emac_desc structure holds management data used by the driver */
+struct emac_desc {
+    /* Pointer to the hardware descriptor associated with this software one */
+    struct emac_dma_desc *hw_desc;
+
+    /* Pointer to the device that uses this descriptor */
+    struct net_device *dev;
+
+    /* Pointer to the ring used by this descriptor */
+    struct emac_ring *ring;
+
+    /* Pointer to the associated socket buffer wired up to this
+     * descriptor or NULL if it is not wired up to a socket buffer.
+     */
+    struct sk_buff *skb;
+
+    /* Pointer to the associated socket buffer fragment wired up to this
+     * descriptor or NULL if it is not wired up to a socket buffer fragment.
+     */
+    struct skb_frag_struct *frag;
+
+    /* The direction of the mapped buffer associated with this descriptor.
+     * Used when unmapping.
+     */
+    enum dma_data_direction dir;
+
+    /* The length of the mapped buffer associated with this descriptor.
+     * Used when unmapping.
+     */
+    unsigned int length;
+};
+
+/* emac_hw_desc mirrors the EMAC DMA descriptor. It must have the same
+ * endian and packing as the hardware.
+ * These are used for both receive and transmit descriptors.
+ * A facility of the DMA hardware that allows a gap between descriptors
+ * in memory is utilised for the additional pointer to management information
+ * This structure must be a multiple of 4 bytes in size.
+ */
+struct emac_dma_desc {
+    u32 status;
+    u32 control;
+    u32 buffer1;
+    u32 buffer2;
+    struct emac_desc *sw_desc;
+};
+
+/* emac_ring structure holds ring management and the address in
+ * DMA able memory of the hardware descriptor ring.
+ */
+struct emac_ring {
+
+    /* Pointer to the start of the descriptor ring in DMA capable memory */
+    struct emac_dma_desc *hw_desc;
+
+    /* Physical address of the above descriptor ring, for the hardware */
+    dma_addr_t dma_ring_start;
+
+    /* Pointer to the software descriptor ring that holds driver management
+     * data. This ring mirrors the hardware one.
+     */
+    struct emac_desc *sw_desc;
+
+    /* The maximum number of elements in the ring */
+    unsigned int length;
+
+    /* The number of elements not in use */
+    unsigned int space;
+
+    /* The next to be processed by the driver */
+    struct emac_desc *next;
+    unsigned int next_idx;
+
+    /* The next to be processed by the hardware */
+    struct emac_desc *next_dma;
+    unsigned int next_dma_idx;
+
+    /* Pointer to the device that uses this ring */
+    struct net_device *dev;
+
+    /* Thread synchronisation for the ring */
+    spinlock_t lock;
+
+    /* The number of work items scheduled for the ring */
+    atomic_t pending;
+
+    /* A flag indicating if the ring is stopping */
+    atomic_t stopping;
+
+    /* A wait queue for waiting for pending ring work to complete */
+    wait_queue_head_t pending_waitq;
+
+    /* Pointer to the struct device for mapping operations */
+    struct device *device;
+};
+
+/* This structure is private to each device */
+struct emac_priv {
+
+    /* Statistics counters */
+    struct net_device_stats stats;
+
+    /* Transmit and Receive descriptor rings */
+    struct emac_ring* tx_ring;
+    struct emac_ring* rx_ring;
+
+    /* Declare a work function for two level transmit interrupt processing.
+     * We get two level receive interrupt processing 'for free' as we use the
+     * interrupt mitigating NAPI interface. This suite our hardware as
+     * interrupts are not queued.
+     */
+    struct workqueue_struct *tx_int_workqueue;
+    struct work_struct tx_int_work;
+
+    /* Declare a work function that is triggered by the PHY driver's callback
+     * to update the link status. This will be responsible for starting and
+     * stopping the hardware.
+     */
+    struct workqueue_struct *link_adjust_workqueue;
+    struct work_struct link_adjust_work;
+
+    /* PHY device and state */
+    struct phy_device *phydev;
+    int speed;
+    int duplex;
+    int link;
+    int oldspeed;
+    int oldduplex;
+    int oldlink;
+
+    /* Used to address a particular
+     * Phy on the mdio bus
+     */
+    int phy_address;
+
+    /* Levels of speed, duplex and link */
+#define PHY_SPEED_10    10
+#define PHY_SPEED_100   100
+#define PHY_DUPLEX_HALF 0
+#define PHY_DUPLEX_FULL 1
+#define PHY_LINK_DOWN   0
+#define PHY_LINK_UP     1
+
+    /* Required field, controls messages */
+    u32 msg_enable;
+
+    /* Pointer to the struct device for mapping operations */
+    struct device *device;
+    struct net_device *self;
+
+    /* Mirrored device registers */
+    u32 op_mode;
+    u32 ie_mask;
+    u32 hash_low;
+    u32 hash_high;
+
+    /* Thread synchronisation for the above register mirrors */
+    spinlock_t mirror_lock;
+
+    /* For VLAN */
+    struct vlan_group *vlgrp;
+
+    struct napi_struct napi;
+
+    /* Used to indicate whether hw timestamping
+       of received packets is required or not */
+    unsigned int hw_timestamp_flag;
+
+    /* Used for sysfs access to the Ethernet Phy registers */
+    unsigned int phy_register;
+};
+
+/* Globals ----------------------------------------------------------------- */
+/*!
+ * \brief Keep a local pointer to the netdev structure.
+ *        Note: used for sysfs functions only.
+ */
+static struct net_device *sysfs_ndev;
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Used to indicate successful function return value */
+#define SUCCESS (0)
+
+/* GET_MAC_FROM_EMAC enables code that reads the interface MAC address
+ * from the EMAC (first filter) at initialisation.
+ */
+#define GET_MAC_FROM_EMAC
+
+/* The interrupt mask for normal transmit interrupts */
+#define EMAC_NORM_TX_INT_MASK                       \
+        (EMAC_TX_INT)
+
+/* The interrupt mask for normal receive interrupts */
+#define EMAC_NORM_RX_INT_MASK                       \
+        (EMAC_RX_INT)
+
+/* The interrupt mask for abnormal interrupts */
+#define EMAC_ABNORM_INT_MASK                        \
+        (EMAC_FATAL_BUS_ERROR_INT |                 \
+        EMAC_TX_UNDERFLOW_INT |                     \
+        EMAC_RX_OVERFLOW_INT |                      \
+        EMAC_TX_JABBER_TIMEOUT_INT |                \
+        EMAC_TX_STOPPED_INT |                       \
+        EMAC_RX_STOPPED_INT |                       \
+        EMAC_RX_UNAVAILABLE_INT)
+
+/* The interrupt mask for summery interrupts */
+#define EMAC_SUMMERY_INT_MASK                       \
+        (EMAC_NORMAL_SUMM_INT |                     \
+        EMAC_ABNORMAL_SUMM_INT)
+
+/* Stop and reset timeouts. */
+#define EMAC_RESET_US                       (50)
+#define EMAC_STOP_US                        (50)
+#define EMAC_STOP_COUNT                     (10)
+
+/* EMAC_RX_CONTROL_FIELD_INIT and EMAC_TX_CONTROL_FIELD_INIT are the setup
+ * value of the receive and transmit descriptor control field respectively
+ */
+#define EMAC_RX_CONTROL_FIELD_INIT          (0)
+#define EMAC_TX_CONTROL_FIELD_INIT                  \
+        (EMAC_TX_DESC_CNTL_ENABLE_INT_COM |         \
+        EMAC_TX_DESC_CNTL_FIRST_SEG |               \
+        EMAC_TX_DESC_CNTL_LAST_SEG)
+
+/* EMAC_RX_REJECTION_MASK is a collection of the receive descriptor status
+ * bits that if set indicate that the received data is invalid and should
+ * be discarded.
+ */
+#define EMAC_RX_REJECTION_MASK                      \
+    (EMAC_DESC_STATUS_ERR_SUM |                     \
+     EMAC_RX_DESC_STATUS_FAIL_SRC_ADDR |            \
+     EMAC_RX_DESC_STATUS_LEN_ERR |                  \
+     EMAC_RX_DESC_STATUS_DRIBBLE_ERR)
+
+/* EMAC_CHECKSUM_LENGTH defines the number of bytes added to the received
+ * frame when hardware checksumming is enabled (IPC).
+ */
+#define EMAC_CHECKSUM_LENGTH                (2)
+
+/* The number of bytes at the end of the frame for the ethernet frame check
+ * sequence (CRC). Defined by ethernet.
+ */
+#define ETHERNET_FCS_LEN                    (4)
+
+/* MII_WAIT_TIMEOUT - defines the number of jiffies to wait for the MII
+ * busy flag to be reset by the hardware.
+ */
+#define MII_WAIT_TIMEOUT 10
+
+/* Various names */
+#define CARDNAME "pc20x-emac"
+#define TITLE "pc20x EMAC"
+#define VERSION "0.06"
+
+/* Timeout for waiting for a ring to stop */
+#define EMAC_RING_STOP_WAIT_TIMEOUT 2000
+
+/* EMAC_DMA_BUS_WIDTH defines the bus width of the EMAC DMA */
+#define EMAC_DMA_BUS_WIDTH_SHIFT    (2)
+#define EMAC_DMA_BUS_WIDTH          (1 << EMAC_DMA_BUS_WIDTH_SHIFT) /* 4 */
+#define EMAC_DMA_BUS_WIDTH_MASK     (EMAC_DMA_BUS_WIDTH - 1)        /* b'0011 */
+
+/* The maximum size of a single DMA transfer, allowing for size alignment */
+#define EMAC_MAX_DMA_LENGTH         (2032)
+
+/* The maximum packet size that can be handled by this driver */
+#define EMAC_MAX_PACKET_LENGTH      (EMAC_MAX_DMA_LENGTH * 2)
+
+/* The length mask to be applied to the receive descriptors */
+#define EMAC_RX_LENGTH_MASK         (0xf)
+#define EMAC_RX_LENGTH_ALLIGN       (16)
+
+/* The length of a DMA descriptor used to calculate the descriptor skip */
+#define EMAC_DMA_DESCRIPTOR_LENGTH  (16)
+
+/* EMAC_TIMEOUT is set in the net device structure setting the timeout
+ * for transmission.
+ */
+#define EMAC_TIMEOUT 1000
+
+/* Default receive and transmit ring lengths */
+#define EMAC_RX_RING_LENGTH 100
+#define EMAC_TX_RING_LENGTH 100
+
+/* The poll quota (must be less than the ring length) */
+#define EMAC_NAPI_POLL_WEIGHT 64
+
+/* CSR_CLOCK_RANGE defines the clock range setting to use */
+#define EMAC_CSR_CLOCK_RANGE EMAC_GMII_CSR_RANGE_100_150
+
+/* Support MII PHY abilities */
+#define EMAC_MII_SUPPORTED \
+    (SUPPORTED_10baseT_Half \
+     | SUPPORTED_10baseT_Full \
+     | SUPPORTED_100baseT_Half \
+     | SUPPORTED_100baseT_Full \
+     | SUPPORTED_Autoneg \
+     | SUPPORTED_MII)
+
+/* Various configurable parameters */
+static int watchdog = EMAC_TIMEOUT;
+module_param(watchdog, int, 0400);
+MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
+
+static int rx_ring_length = EMAC_RX_RING_LENGTH;
+module_param(rx_ring_length, int, 0);
+MODULE_PARM_DESC(rx_ring_length, "Receive Descriptor Ring Length");
+
+static int tx_ring_length = EMAC_TX_RING_LENGTH;
+module_param(tx_ring_length, int, 0);
+MODULE_PARM_DESC(tx_ring_length, "Transmit Descriptor Ring Length");
+
+static int napi_poll_weight = EMAC_NAPI_POLL_WEIGHT;
+module_param(napi_poll_weight, int, 0);
+MODULE_PARM_DESC(napi_poll_weight, "Receive NAPI Poll Weight");
+
+/* Debugging levels: */
+#define LVL_FATAL       2   /* fatal error conditions */
+#define LVL_ERR         3   /* error conditions */
+#define LVL_WARNING     4   /* warning conditions */
+#define LVL_NOTICE      5   /* normal but significant condition */
+#define LVL_INFO        6   /* informational */
+#define LVL_DEBUG       7   /* debug-level messages */
+#define LVL_TRACE       8   /* trace messages */
+#define LVL_TRACE_IO    9   /* Register IO trace messages */
+
+#if CONFIG_FIRECRACKER_EMAC_DEBUG > 0
+
+/* Define ENABLE_DEBUGGING to include code for debugging via printk.
+ * The value of ENABLE_DEBUGGING specifies the default debug level.
+ */
+#define ENABLE_DEBUGGING CONFIG_FIRECRACKER_EMAC_DEBUG
+
+#else
+
+#undef ENABLE_DEBUGGING
+
+#endif
+
+/* Macros for register read/write. These hide the virtual addressing.
+ */
+#ifndef ENABLE_DEBUGGING
+
+#define EMAC_READ(__offset) \
+    ioread32(__io(IO_ADDRESS(PC20X_EMAC_BASE + __offset)))
+
+#define EMAC_WRITE(__value, __offset) \
+    iowrite32(__value, __io(IO_ADDRESS(PC20X_EMAC_BASE + __offset)))
+
+#define DB(__params)
+
+#else /* ENABLE_DEBUGGING */
+
+#define EMAC_READ(__offset) \
+    debug_ioread32(PC20X_EMAC_BASE + __offset)
+
+#define EMAC_WRITE(__value, __offset) \
+    debug_iowrite32(__value, (PC20X_EMAC_BASE + __offset))
+
+#define DB(__params) dbug_print __params
+
+/* Debugging level for this module */
+static volatile int debug_lvl = ENABLE_DEBUGGING;
+
+static void dbug_print(int lvl, const char *fmt, ...)
+{
+    static char lvl_ch[10] = {
+        '0', '1', 'F', 'E', 'W', 'N', 'I', 'D', 'T', '9'
+    };
+#define MAX_FORMAT_SIZE 1024
+    char buf[MAX_FORMAT_SIZE];
+    va_list args;
+    va_start(args, fmt);
+
+    if (debug_lvl >= lvl) {
+
+        if (printk_ratelimit() || lvl < LVL_TRACE_IO) {
+
+            vsnprintf(buf, MAX_FORMAT_SIZE, fmt, args);
+            printk("emac <%c>: %s", lvl_ch[lvl], buf);
+        }
+        else {
+            printk("%c", lvl_ch[lvl]);
+        }
+    }
+}
+
+static void debug_iowrite32(u32 val, unsigned int paddr)
+{
+    DB((LVL_TRACE_IO, "iowrite32(0x%08x)=0x%08x\n", paddr, val));
+    iowrite32(val, __io(IO_ADDRESS(paddr)));
+}
+
+static unsigned int debug_ioread32(unsigned int paddr)
+{
+    unsigned int val = ioread32(__io(IO_ADDRESS(paddr)));
+    DB((LVL_TRACE_IO, "ioread32(0x%08x)=0x%08x\n", paddr, val));
+    return val;
+}
+
+static void print_ring(struct emac_ring *ring, char *prefix, u32 hw_next, u32 sw_next_idx)
+{
+    int i;
+    char str_ow[200];
+    char str_po[200];
+    static volatile u32 hw_next_off;
+    static volatile int hw_next_idx;
+
+    hw_next_off = hw_next - ring->dma_ring_start;
+    hw_next_idx = hw_next_off / sizeof(struct emac_dma_desc);
+
+    for (i = 0; i < ring->length; ++i) {
+        if (i == hw_next_idx) {
+            if (i == sw_next_idx) {
+                str_po[i] = 'X';
+            }
+            else {
+                str_po[i] = '^';
+            }
+        }
+        else if (i == sw_next_idx) {
+            str_po[i] = 'v';
+        }
+        else {
+            str_po[i] = ' ';
+        }
+
+        if (ring->hw_desc[i].buffer1 == 0)
+        {
+            if (ring->hw_desc[i].status & EMAC_DESC_STATUS_OWNER) {
+                str_ow[i] = 'd';
+            }
+            else {
+                str_ow[i] = 'h';
+            }
+        }
+        else {
+            if (ring->hw_desc[i].status & EMAC_DESC_STATUS_OWNER) {
+                str_ow[i] = 'D';
+            }
+            else {
+                str_ow[i] = 'H';
+            }
+        }
+    }
+    str_ow[i] = 0;
+    str_po[i] = 0;
+
+    DB((LVL_DEBUG, "%s OW: %s\n", prefix, str_ow));
+    DB((LVL_DEBUG, "%s PO: %s\n", prefix, str_po));
+}
+
+static void print_rings(struct net_device *dev, int now)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    static int rate_limit = 0;
+    u32 hw_next_tx = /*EMAC_READ(EMAC_DMA_CURR_TX_DESC_REG_OFFSET);*/
+        ioread32(__io(IO_ADDRESS(PC20X_EMAC_BASE + EMAC_DMA_CURR_TX_DESC_REG_OFFSET)));
+    u32 hw_next_rx = /*EMAC_READ(EMAC_DMA_CURR_RX_DESC_REG_OFFSET);*/
+        ioread32(__io(IO_ADDRESS(PC20X_EMAC_BASE + EMAC_DMA_CURR_RX_DESC_REG_OFFSET)));
+
+    if (debug_lvl >= LVL_TRACE) {
+        now = 1;
+    }
+
+    if (((++rate_limit % 8) == 0) || now) {
+        print_ring(priv->tx_ring, "TX", hw_next_tx, priv->tx_ring->next_idx);
+        print_ring(priv->rx_ring, "RX", hw_next_rx, priv->rx_ring->next_dma_idx);
+    }
+}
+
+/* Read all the PHY registers and print them out */
+static int emac_mii_read(struct mii_bus *bus, int mii_id, int regnum);
+static void emac_dump_phy_regs(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+    int i;
+    int reg[] = {
+        0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 17, 18, 19, 20, 30, -1
+    };
+    int val;
+
+    for (i = 0; reg[i] != -1; i++) {
+        val = emac_mii_read(mii_bus, priv->phy_address, reg[i]);
+
+        DB((LVL_DEBUG, "PHY reg[%u] = 0x%04x\n", reg[i], val));
+    }
+}
+
+#endif /* ENABLE_DEBUGGING */
+
+/* Prototypes--------------------------------------------------------------- */
+
+static u32
+emac_ioread32 (unsigned int register_offset);
+
+static void
+emac_iowrite32 (u32 value,
+                unsigned int register_offset);
+
+static struct emac_desc
+*emac_next_desc(struct emac_ring *ring);
+
+static struct emac_desc
+*emac_next_dma_desc(struct emac_ring *ring);
+
+static struct emac_desc
+*emac_previous_desc(struct emac_ring *ring);
+
+static void
+emac_reset_ring_state(struct emac_ring *ring);
+
+static void
+emac_set_ring_ownership(struct emac_ring *ring,
+                        int host_not_dma);
+
+static int
+emac_phy_busy_wait(void);
+
+static int
+emac_mii_read(struct mii_bus *bus,
+              int mii_id,
+              int regnum);
+
+static int
+emac_mii_write(struct mii_bus *bus,
+               int mii_id,
+               int regnum,
+               u16 value);
+
+static void
+emac_interrupt_control(struct net_device *dev,
+                       int rx_not_tx,
+                       int enable);
+
+static void
+emac_dma_control(struct net_device *dev,
+                 int rx_not_tx,
+                 int enable);
+
+static void
+emac_hw_tx_resume(struct net_device *dev);
+
+static void
+emac_hw_rx_resume(struct net_device *dev);
+
+static void
+emac_set_mac_for_addr(struct net_device *dev,
+                      int num, u8 *addr,
+                      int source_flt);
+
+static void
+emac_get_mac(struct net_device *dev,
+             u8 *addr);
+
+static void
+emac_reset_mac(struct net_device *dev,
+               int num);
+
+static void
+emac_calc_hash_for_addr(struct net_device *dev,
+                        u8 *addr);
+
+static void
+emac_set_hash(struct net_device *dev);
+
+static int
+emac_rx_errors(struct net_device *dev,
+               struct emac_dma_desc *desc);
+
+static int
+emac_tx_errors(struct net_device *dev,
+               struct emac_dma_desc *desc);
+
+static void
+emac_unmap_skb_frag(struct net_device *dev,
+                    struct emac_desc *desc);
+
+static void
+emac_free_skb_frag(struct net_device *dev,
+                   struct emac_desc *desc);
+
+static void
+emac_free_ring_skb(struct net_device *dev,
+                   struct emac_ring *ring);
+
+static struct sk_buff
+*emac_allocate_skb(struct net_device *dev);
+
+static void
+emac_wait_stop_ring(struct emac_ring *ring);
+
+static void
+emac_start(struct net_device *dev);
+
+static void
+emac_reset(struct net_device *dev);
+
+static void
+emac_adjust_link_trigger(struct net_device *dev);
+
+static void
+emac_adjust_link(struct work_struct *param);
+
+static int
+emac_init_phy(struct net_device *dev);
+
+static ssize_t
+emac_sysfs_1588_seconds_show(struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf);
+
+static ssize_t
+emac_sysfs_1588_seconds_store(struct device *dev,
+                              struct device_attribute *attr,
+                              const char *buf,
+                              size_t count);
+
+static ssize_t
+emac_sysfs_1588_nano_seconds_show(struct device *dev,
+                                  struct device_attribute *attr,
+                                  char *buf);
+
+static ssize_t
+emac_sysfs_1588_nano_seconds_store(struct device *dev,
+                                   struct device_attribute *attr,
+                                   const char *buf,
+                                   size_t count);
+
+static ssize_t
+emac_sysfs_1588_timer_increment_show(struct device *dev,
+                                     struct device_attribute *attr,
+                                     char *buf);
+
+static ssize_t
+emac_sysfs_1588_timer_increment_store(struct device *dev,
+                                      struct device_attribute *attr,
+                                      const char *buf,
+                                      size_t count);
+
+static ssize_t
+emac_sysfs_phy_register_show(struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf);
+
+static ssize_t
+emac_sysfs_phy_register_store(struct device *dev,
+                              struct device_attribute *attr,
+                              const char *buf,
+                              size_t count);
+
+static ssize_t
+emac_sysfs_phy_register_value_show(struct device *dev,
+                                   struct device_attribute *attr,
+                                   char *buf);
+
+static ssize_t
+emac_sysfs_phy_register_value_store(struct device *dev,
+                                    struct device_attribute *attr,
+                                    const char *buf,
+                                    size_t count);
+
+static int
+emac_sysfs_add(struct platform_device *pdev);
+
+static void
+emac_sysfs_remove(struct platform_device *pdev);
+
+static int
+emac_init_dp83640_phy(struct net_device *dev);
+
+static void
+emac_dp83640_select_page(struct net_device *dev,
+                         unsigned int page);
+
+static int
+emac_dp83640_set_1588_seconds(struct net_device *dev,
+                              u32 timer_seconds);
+
+static int
+emac_dp83640_get_1588_seconds(struct net_device *dev,
+                              u32 *timer_seconds);
+
+static int
+emac_dp83640_set_1588_nano_seconds(struct net_device *dev,
+                                   u32 timer_nano_seconds);
+
+static int
+emac_dp83640_get_1588_nano_seconds(struct net_device *dev,
+                                   u32 *timer_nano_seconds);
+
+static int
+emac_dp83640_set_1588_timer_increment(struct net_device *dev,
+                                      u32 rate);
+
+static int
+emac_dp83640_get_1588_timer_increment(struct net_device *dev,
+                                      u32 *rate);
+
+static void
+emac_free_ring(struct emac_ring *ring);
+
+static struct emac_ring
+*emac_allocate_ring(struct net_device *dev,
+                    unsigned int length);
+
+static int
+emac_wireup_desc_dma(struct net_device *dev,
+                     struct emac_desc *desc,
+                     void *ptr,
+                     unsigned int length,
+                     enum dma_data_direction dir);
+
+static int
+emac_get_next_dma_packet_status(struct emac_ring *ring);
+
+static void
+emac_tx_interrupt_work(struct work_struct *param);
+
+static irqreturn_t
+emac_interrupt(int irq,
+               void *dev_id);
+
+int
+emac_release(struct net_device *dev);
+
+static int
+emac_open(struct net_device *dev);
+
+int
+emac_config(struct net_device *dev,
+            struct ifmap *map);
+
+static int
+emac_pass_up_skb(struct net_device *dev,
+                 struct sk_buff *skb,
+                 u32 status);
+
+static int
+emac_poll(struct napi_struct *napi_s,
+          int budget);
+
+int
+emac_tx(struct sk_buff *skb,
+        struct net_device *dev);
+
+static void
+emac_tx_timeout(struct net_device *dev);
+
+int
+emac_ioctl(struct net_device *dev,
+           struct ifreq *rq,
+           int cmd);
+
+static int
+emac_hwtstamp_ioctl(struct net_device *dev,
+                    struct ifreq *ifr,
+                    int cmd);
+
+struct
+net_device_stats *emac_stats(struct net_device *dev);
+
+static void
+emac_vlan_rx_register(struct net_device *dev,
+                      struct vlan_group *grp);
+
+static void
+emac_vlan_rx_kill_vid(struct net_device *dev,
+                      uint16_t vid);
+
+static void
+emac_set_multi(struct net_device *dev);
+
+void
+emac_init(struct net_device *dev,
+          struct platform_device *pdev);
+
+static int
+emac_mii_probe(struct device *dev);
+
+static int
+emac_mii_remove(struct device *dev);
+
+static int
+emac_drv_probe(struct platform_device *pdev);
+
+static int
+emac_drv_remove(struct platform_device *pdev);
+
+/* Functions --------------------------------------------------------------- */
+
+/*
+ *  Read an emac register
+ */
+static u32
+emac_ioread32 (unsigned int register_offset)
+{
+    void __iomem *p = mem_region + register_offset;
+
+    u32 value = ioread32(p);
+
+    return value;
+}
+
+/*
+ * Write to an emac register
+ */
+static void
+emac_iowrite32 (u32 value,
+                unsigned int register_offset)
+{
+    void __iomem *p = mem_region + register_offset;
+
+    iowrite32(value, p);
+}
+
+/*
+ * Move the next pointer in a ring on to the next sw descriptor
+ */
+static struct emac_desc
+*emac_next_desc(struct emac_ring *ring)
+{
+    ring->next_idx++;
+
+    if (ring->next_idx == ring->length) {
+        ring->next_idx = 0;
+    }
+
+    ring->next = &ring->sw_desc[ring->next_idx];
+
+    DB((LVL_TRACE, "Next idx %u\n", ring->next_idx));
+
+    return ring->next;
+}
+
+/*
+ * Move the next DMA pointer in a ring on to the next sw descriptor
+ */
+static struct emac_desc
+*emac_next_dma_desc(struct emac_ring *ring)
+{
+    ring->next_dma_idx++;
+
+    if (ring->next_dma_idx == ring->length) {
+        ring->next_dma_idx = 0;
+    }
+
+    ring->next_dma = &ring->sw_desc[ring->next_dma_idx];
+
+    DB((LVL_TRACE, "Next DMA idx %u\n", ring->next_dma_idx));
+
+    return ring->next_dma;
+}
+
+/*
+ * Move the next pointer in a ring back to the previous descriptor
+ */
+static struct emac_desc
+*emac_previous_desc(struct emac_ring *ring)
+{
+    if (ring->next_idx == 0) {
+        ring->next_idx = ring->length-1;
+    }
+    else {
+        ring->next_idx--;
+    }
+
+    ring->next = &ring->sw_desc[ring->next_idx];
+
+    return ring->next;
+}
+
+/* Reset the ring pointers state */
+static void
+emac_reset_ring_state(struct emac_ring *ring)
+{
+    ring->space = ring->length;
+    ring->next_idx = 0;
+    ring->next = ring->sw_desc;
+    ring->next_dma_idx = 0;
+    ring->next_dma = ring->sw_desc;
+    atomic_set(&ring->pending, 0);
+}
+
+/* Set the ownership flag on all elements of a ring */
+static void
+emac_set_ring_ownership(struct emac_ring *ring,
+                        int host_not_dma)
+{
+    int i;
+
+    for (i = 0; i < ring->length; ++i) {
+        if (host_not_dma) {
+            ring->hw_desc[i].status &= ~EMAC_DESC_STATUS_OWNER;
+        }
+        else {
+            ring->hw_desc[i].status |= EMAC_DESC_STATUS_OWNER;
+        }
+    }
+}
+
+/* Wait with timeout for the PHY busy signal to be reset */
+static int
+emac_phy_busy_wait(void)
+{
+    int res = 0;
+    unsigned long timeout_jiffies;
+    u32 addr_reg;
+
+    timeout_jiffies = jiffies + MII_WAIT_TIMEOUT;
+    while (1) {
+
+        /* Check for time out */
+        if (time_after(jiffies, timeout_jiffies)) {
+            DB((LVL_ERR, "Timed out waiting for MII\n"));
+            res = -ETIMEDOUT;
+            break;
+        }
+
+        /* Check for the busy bit */
+        addr_reg = emac_ioread32(EMAC_MAC_GMII_ADDR_REG_OFFSET);
+        if ((addr_reg & EMAC_GMII_BUSY) == 0) {
+            break;
+        }
+    }
+
+    return res;
+}
+
+/* Read the bus for PHY at addr mii_id, register regnum, and
+ * return the value.  Clears miimcom first.  All PHY
+ */
+static int
+emac_mii_read(struct mii_bus *bus,
+              int mii_id,
+              int regnum)
+{
+    int res = 0;
+    unsigned int value = 0;
+
+    /* The emac_phy_[read|write] functions ensure that their operation
+     * has completed before they exit so we do not have to wait
+     * for a previous operation to finish here and we can go ahead and
+     * use the MII interface.
+     */
+
+    /* Setup the address register and start the read */
+    emac_iowrite32((u32)
+                   ((mii_id << EMAC_GMII_ADDRESS_SHIFT) |
+                    (regnum << EMAC_GMII_GMII_REG_SHIFT) |
+                    EMAC_CSR_CLOCK_RANGE |
+                    EMAC_GMII_BUSY),
+                   EMAC_MAC_GMII_ADDR_REG_OFFSET);
+
+    /* Wait for the MII to finish */
+    res = emac_phy_busy_wait();
+    if (res != 0) {
+        DB((LVL_ERR, "Timeout waiting for PHY\n"));
+        goto out;
+    }
+
+    /* Read back the register contents */
+    value = emac_ioread32(EMAC_MAC_GMII_DATA_REG_OFFSET);
+
+out:
+    return value;
+}
+
+/* Write value to the PHY at mii_id at register regnum,
+ * on the bus, waiting until the write is done before returning.
+ */
+static int
+emac_mii_write(struct mii_bus *bus,
+               int mii_id,
+               int regnum,
+               u16 value)
+{
+    /* The emac_phy_[read|write] functions ensure that their operation
+     * has completed before they exit so we do not have to wait
+     * for a previous operation to finish here and we can go ahead and
+     * use the MII interface.
+     */
+
+    /* Set the register contents to be written */
+    emac_iowrite32((u32)value, EMAC_MAC_GMII_DATA_REG_OFFSET);
+
+    /* Setup the address register and start the write */
+    emac_iowrite32((u32)
+                   ((mii_id << EMAC_GMII_ADDRESS_SHIFT) |
+                    (regnum << EMAC_GMII_GMII_REG_SHIFT) |
+                    EMAC_CSR_CLOCK_RANGE |
+                    EMAC_GMII_WRITE |
+                    EMAC_GMII_BUSY),
+                   EMAC_MAC_GMII_ADDR_REG_OFFSET);
+
+    /* Wait for the MII to finish */
+    emac_phy_busy_wait();
+
+    return 0;
+}
+
+/* Enable/disable, receive/transmit interrupts */
+static void
+emac_interrupt_control(struct net_device *dev,
+                       int rx_not_tx,
+                       int enable)
+#define RX 1
+#define TX 0
+#define ENABLE 1
+#define DISABLE 0
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    unsigned long flags;
+    u32 mask;
+
+    /* Thread synchronisation required */
+    spin_lock_irqsave(&priv->mirror_lock, flags);
+
+    /* Update the mirror */
+    if (rx_not_tx) {
+        mask = EMAC_NORM_RX_INT_MASK;
+    }
+    else {
+        mask = EMAC_NORM_TX_INT_MASK;
+    }
+
+    if (enable) {
+        priv->ie_mask |= mask;
+    }
+    else {
+        priv->ie_mask &= ~mask;
+    }
+
+    /* Write the IE mirror to the hardware */
+    emac_iowrite32(priv->ie_mask, EMAC_DMA_IE_REG_OFFSET);
+
+    /* Release thread sync */
+    spin_unlock_irqrestore(&priv->mirror_lock, flags);
+}
+
+/* Enable/disable, EMAC DMA */
+static void
+emac_dma_control(struct net_device *dev,
+                 int rx_not_tx,
+                 int enable)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    unsigned long flags;
+    u32 mask;
+
+    /* Thread synchronisation required */
+    spin_lock_irqsave(&priv->mirror_lock, flags);
+
+    /* Update the mirror */
+    if (rx_not_tx) {
+        mask = EMAC_START_RX;
+    }
+    else {
+        mask = EMAC_START_TX;
+    }
+
+    if (enable) {
+        priv->op_mode |= mask;
+    }
+    else {
+        priv->op_mode &= ~mask;
+    }
+
+    /* Write the mirror to the hardware */
+    emac_iowrite32(priv->op_mode, EMAC_DMA_MODE_REG_OFFSET);
+
+    /* Release thread sync */
+    spin_unlock_irqrestore(&priv->mirror_lock, flags);
+}
+
+/* Make sure the EMAC DMA transmission is not suspended */
+static void
+emac_hw_tx_resume(struct net_device *dev)
+{
+    u32 reg;
+
+    reg = emac_ioread32(EMAC_DMA_STATUS_REG_OFFSET);
+    if ((reg & EMAC_DMA_TX_STATE_MASK) == EMAC_DMA_TX_SUSPENDED) {
+        emac_iowrite32(0, EMAC_DMA_TX_DEMAND_REG_OFFSET);
+    }
+}
+
+/* Make sure the EMAC DMA reception is not suspended */
+static void
+emac_hw_rx_resume(struct net_device *dev)
+{
+    u32 reg;
+
+    reg = emac_ioread32(EMAC_DMA_STATUS_REG_OFFSET);
+    if ((reg & EMAC_DMA_RX_STATE_MASK) == EMAC_DMA_RX_SUSPENDED) {
+        emac_iowrite32(0, EMAC_DMA_RX_DEMAND_REG_OFFSET);
+    }
+}
+
+
+/* There are multiple MAC Address register pairs on some controllers
+ * This function sets the numth pair to a given address
+ */
+static void
+emac_set_mac_for_addr(struct net_device *dev,
+                      int num, u8 *addr,
+                      int source_flt)
+{
+    u32 reg = (addr[5] << 8) | addr[4];
+
+    /* Exact match zero is always enabled for destination */
+    if (num > 0) {
+        reg |= EMAC_MAC_ADDR_ENABLE;
+
+        /* Use source filtering */
+        if (source_flt) {
+            reg |= EMAC_MAC_ADDR_SOURCE;
+        }
+    }
+
+    emac_iowrite32(reg, EMAC_MAC_ADDR_N_HIGH_REG_OFFSET(num));
+
+    emac_iowrite32((addr[3]<<24) | (addr[2]<<16) | (addr[1]<<8) | addr[0],
+            EMAC_MAC_ADDR_N_LOW_REG_OFFSET(num));
+}
+
+/* Read the hardware for a MAC address. This would be used when we expect
+ * the hardware to be setup by the bootloader.
+ * This function reads the first MAC filter. We expect the interface address
+ * to be set in the first MAC filter. If the MAC read is invalid, it uses
+ * the default that is hardcoded in the driver.
+ */
+static void
+emac_get_mac(struct net_device *dev,
+             u8 *addr)
+{
+#ifdef GET_MAC_FROM_EMAC
+    u32 reg;
+
+    /* Read the high filter reg. This contains the 5th and 6th bytes */
+    reg = emac_ioread32(EMAC_MAC_ADDR_N_HIGH_REG_OFFSET(0));
+
+    addr[4] = reg & 0xff;
+    reg >>= 8;
+    addr[5] = reg & 0xff;
+
+    /* Read the low filter reg. This contains the first to 4th bytes */
+    reg = emac_ioread32(EMAC_MAC_ADDR_N_LOW_REG_OFFSET(0));
+
+    addr[0] = reg & 0xff;
+    reg >>= 8;
+    addr[1] = reg & 0xff;
+    reg >>= 8;
+    addr[2] = reg & 0xff;
+    reg >>= 8;
+    addr[3] = reg & 0xff;
+
+    if (!is_valid_ether_addr(addr)) {
+        printk(KERN_INFO "%s: Invalid MAC Address found in EMAC filter\n",
+               dev->name);
+        goto set_default_mac;
+    }
+    return;
+
+#endif  /* GET_MAC_FROM_EMAC */
+
+set_default_mac:
+    memcpy(addr, default_mac_address, ETH_ALEN);
+    printk(KERN_INFO "%s: Using MAC Address: %02x:%02x:%02x:%02x:%02x:%02x\n",
+           dev->name, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+}
+
+static void
+emac_reset_mac(struct net_device *dev,
+               int num)
+{
+    if (num > 0) {
+        emac_iowrite32(0, EMAC_MAC_ADDR_N_HIGH_REG_OFFSET(num));
+        emac_iowrite32(0, EMAC_MAC_ADDR_N_LOW_REG_OFFSET(num));
+    }
+}
+
+static void
+emac_calc_hash_for_addr(struct net_device *dev,
+                        u8 *addr)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    int i, lsb, b;
+    u32 crc = 0xFFFFFFFF;
+    u32 poly = 0xEDB88320;
+    int hash_bit;
+    u8 byte;
+
+    /* Munge the address bytes into a crc */
+    for (i = 0; i < ETH_ALEN; i++) {
+
+        /* Get the next byte of the address */
+        byte = addr[i];
+
+        /* Munge the byte into the crc */
+        for (b = 0; b < 8; ++b) {
+
+            lsb = (crc ^ byte) & 1;
+            crc >>= 1;
+            if (lsb != 0) crc ^= poly;
+            byte >>= 1;
+        }
+    }
+
+    /* Upper 6 bits is the bit number */
+    hash_bit = (crc>>26) & 0x3F;
+
+    /* Set the bit in the hash registers to allow the address through the
+     * filtering.
+     */
+    if (hash_bit >= 32) {
+        priv->hash_high |= (1 << (hash_bit - 32));
+    }
+    else {
+        priv->hash_low |= (1 << hash_bit);
+    }
+}
+
+static void
+emac_set_hash(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    emac_iowrite32(priv->hash_high, EMAC_MAC_HASH_HIGH_REG_OFFSET);
+    emac_iowrite32(priv->hash_low, EMAC_MAC_HASH_LOW_REG_OFFSET);
+}
+
+/* Record the receive errors given a descriptor. If there are no
+ * errors, return 0.
+ */
+static int
+emac_rx_errors(struct net_device *dev,
+               struct emac_dma_desc *desc)
+{
+    u32 status = desc->status;
+
+    /* Deal with errors in descriptors, and descriptors
+     * that hold partial frames. We only support a frame that fits
+     * into one descriptor.
+     */
+    if (((status & EMAC_RX_REJECTION_MASK) != 0) ||
+            ((status & EMAC_RX_DESC_STATUS_FIRST_DESC) == 0) ||
+            ((status & EMAC_RX_DESC_STATUS_LAST_DESC) == 0)) {
+        return 1;
+    }
+    return 0;
+}
+
+/* Record the transmit errors given a descriptor. If there are no
+ * errors, return 0.
+ */
+static int
+emac_tx_errors(struct net_device *dev,
+               struct emac_dma_desc *desc)
+{
+    u32 status = desc->status;
+
+    if (status & EMAC_DESC_STATUS_ERR_SUM) {
+        return 1;
+    }
+    return 0;
+}
+
+/* Unmaps the socket buffer or fragment attached to a descriptor */
+static void
+emac_unmap_skb_frag(struct net_device *dev,
+                    struct emac_desc *desc)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    u32 buffer1 = desc->hw_desc->buffer1;
+
+    if (buffer1 != 0) {
+        dma_unmap_single(priv->device, buffer1, desc->length, desc->dir);
+    }
+}
+
+/*
+ * Disconnect, unmap and free a socket buffer connected to a descriptor.
+ */
+static void
+emac_free_skb_frag(struct net_device *dev,
+                   struct emac_desc *desc)
+{
+    struct emac_dma_desc *hw_desc = desc->hw_desc;
+
+    /* Mark the descriptor as owned by the host to prevent the hardware
+     * writing into it when we have unmapped it (for safety).
+     */
+    hw_desc->status &= ~EMAC_DESC_STATUS_OWNER;
+
+    /* Unmap the fragment or socket buffer */
+    emac_unmap_skb_frag(dev, desc);
+
+    /* If a socket buffer is connected, free it. This frees all the
+     * socket buffer fragments also and must arrange for the descriptors
+     * holding the fragments to be unmapped before we get to the head
+     * socket buffer
+     */
+    if (desc->skb != NULL) {
+
+        /* Free the socket buffer. This includes all fragments which should
+         * have been unmapped by previous calls to this function.
+         */
+        dev_kfree_skb(desc->skb);
+    }
+
+    /* Make sure the socket buffer association is reset in the descriptor */
+    desc->skb = NULL;
+    desc->frag = NULL;
+
+    /* If we freed something here, update the space left */
+    if (hw_desc->buffer1 != 0) {
+
+        /* Increment the space left on the ring */
+        desc->ring->space++;
+    }
+
+    /* Mark as unused */
+    hw_desc->buffer1 = 0;
+}
+
+
+static void
+emac_free_ring_skb(struct net_device *dev,
+                   struct emac_ring *ring)
+{
+    int i;
+
+    /* Free any socket buffers we may have. Do this in the
+     * reverse order to that which they were added so that we ensure
+     * a socket buffer's fragments are unmapped before the socket
+     * buffer itself is freed.
+     */
+    for (i = 0; i < ring->length; ++i) {
+
+        /* Move back to the previous descriptor */
+        emac_previous_desc(ring);
+
+        /* Free the buffer associated with the descriptor */
+        emac_free_skb_frag(dev, ring->next);
+    }
+
+    /* Reset the ring pointers */
+    emac_reset_ring_state(ring);
+}
+
+/*
+ * Allocate a socket buffer.
+ */
+static struct sk_buff
+*emac_allocate_skb(struct net_device *dev)
+{
+    struct sk_buff *skb;
+    unsigned int length;
+
+    /* The length of the skb needs to hold all data delivered by the
+     * hardware. This includes:
+     * MTU size, 2 bytes for IP alignment, ethernet header, VLAN header,
+     * checksum added by the hardware and extra bytes for DMA length
+     * alignment.
+     */
+    length = dev->mtu + 2 + ETH_HLEN + VLAN_ETH_HLEN +
+        EMAC_CHECKSUM_LENGTH + EMAC_RX_LENGTH_ALLIGN;
+
+    /* Allocate the socket buffer. Always allocate maximum size */
+    skb = dev_alloc_skb(length);
+    if (skb == NULL) {
+        DB((LVL_WARNING, "emac: dev_alloc_skb failed\n"));
+        goto out;
+    }
+
+    /* Align IP on 16 Bit boundary */
+    skb_reserve(skb, 2);
+
+out:
+    return skb;
+}
+
+/* Wait (block) for the ring handler thread to complete it's last scheduled
+ * run.
+ */
+static void
+emac_wait_stop_ring(struct emac_ring *ring)
+{
+    long ret;
+
+    DB((LVL_TRACE, "emac_wait_stop_ring\n"));
+
+    /* Set the stopping state */
+    atomic_set(&ring->stopping, 1);
+
+    DB((LVL_DEBUG, "wait pending count = %u\n", atomic_read(&ring->pending)));
+
+    /* Wait for the pending count to become zero */
+    ret = wait_event_interruptible_timeout(
+            ring->pending_waitq,
+            (atomic_read(&ring->pending) == 0),
+            EMAC_RING_STOP_WAIT_TIMEOUT);
+
+    if (ret == 0) {
+        DB((LVL_ERR, "Timed out waiting for ring to stop\n"));
+    }
+    else if (ret == -ERESTARTSYS) {
+        DB((LVL_ERR, "Signal received while waiting for ring to stop\n"));
+    }
+
+    /* Re-set the stopping state */
+    atomic_set(&ring->stopping, 0);
+}
+
+/* Initialises the EMAC and EMAC DMA registers and starts transmission and
+ * reception. Does not allocate buffers.
+ */
+static void
+emac_start(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    u32 reg;
+    unsigned int skip;
+
+    DB((LVL_TRACE, "emac_start\n"));
+
+    /* Set Host bus access parameters */
+    skip = (sizeof(struct emac_dma_desc) -
+            EMAC_DMA_DESCRIPTOR_LENGTH) / EMAC_DMA_BUS_WIDTH;
+    emac_iowrite32(
+            EMAC_BURST_LENGTH_8 |
+            ((skip << EMAC_DMA_SKIP_SHIFT) & EMAC_DMA_SKIP_MASK),
+            EMAC_DMA_BUS_MODE_REG_OFFSET);
+
+    /* Set the descriptor ring start addresses */
+    emac_iowrite32(priv->rx_ring->dma_ring_start, EMAC_DMA_RX_LIST_REG_OFFSET);
+    emac_iowrite32(priv->tx_ring->dma_ring_start, EMAC_DMA_TX_LIST_REG_OFFSET);
+
+    /* Set the MAC filter register up */
+    emac_set_mac_for_addr(dev, 0, dev->dev_addr, 0);
+
+    /* Set up the frame filter control */
+    reg = 0;     /* Use defaults */
+    emac_iowrite32(reg, EMAC_MAC_FRAME_FLT_REG_OFFSET);
+
+    /* Set the flow control reg */
+    reg = 0;
+    if (priv->duplex == PHY_DUPLEX_FULL) {
+        reg |= (EMAC_RX_FLOW_ENABLE | EMAC_TX_FLOW_ENABLE);
+    }
+    emac_iowrite32(reg, EMAC_MAC_FLOW_CONTROL_REG_OFFSET);
+
+    /* Set the hardware up for duplex. Same settings for 10 and 100 speed */
+    reg =
+        EMAC_FRAME_BURST_ENABLE |
+        EMAC_PORT_SELECT |
+        EMAC_CHECKSUM_OFFLOAD |
+        EMAC_TX_ENABLE |
+        EMAC_RX_ENABLE;
+
+    if (priv->duplex == PHY_DUPLEX_HALF) {
+        reg |= EMAC_DIABLE_RECEIVE_OWN;
+    }
+    else {
+        reg |= EMAC_DUPLEX_MODE;
+    }
+
+    /* Set the control register.
+     * Starts the MAC reception and transmission
+     */
+    emac_iowrite32(reg, EMAC_MAC_CONFIG_REG_OFFSET);
+
+    /* Set the operation mode */
+    priv->op_mode =
+        EMAC_OPERATE_ON_SECOND_FRAME |
+        (0x3 << EMAC_TX_THRESHOLD_SHIFT);   /* Set high tx threshold. This
+                                               avoids the TX underflow
+                                               errors */
+
+    /* Setup the MMI statistics hardware, no interrupts, wrapping counters */
+    emac_iowrite32(EMAC_MMC_INT_ALL, EMAC_MMC_RX_INT_MASK_OFFSET);
+    emac_iowrite32(EMAC_MMC_INT_ALL, EMAC_MMC_TX_INT_MASK_OFFSET);
+    emac_iowrite32(0, EMAC_MMC_CONTROL_OFFSET);
+
+    /* Initialise hw_timestamp_flag */
+    priv->hw_timestamp_flag = HWTSTAMP_FILTER_NONE;
+
+    /* Initialise the phy_register (sysfs access) value */
+    priv->phy_register = 0;
+
+    /* Enable the interrupts */
+    priv->ie_mask = EMAC_ABNORM_INT_MASK | EMAC_SUMMERY_INT_MASK;
+    emac_interrupt_control(dev, RX, ENABLE);    /* Enable Rx IRQ */
+    emac_interrupt_control(dev, TX, ENABLE);    /* Enable Tx IRQ */
+
+    /* Start the DMA reception and transmission */
+    emac_dma_control(dev, RX, ENABLE);      /* Enable Rx */
+    emac_dma_control(dev, TX, ENABLE);      /* Enable Tx */
+
+    /* Tell the stack to continue sending us packets */
+    netif_wake_queue(dev);
+
+    DB((LVL_TRACE, "emac_start complete\n"));
+}
+
+/* Stop the receive and transmit rings. Stop interrupts. Reset the
+ * EMAC DMA controller. Does not free any ring buffers.
+ */
+static void
+emac_reset(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    u32 reg;
+    unsigned int stops;
+
+    DB((LVL_TRACE, "emac_reset\n"));
+
+    /* This can be called from anywhere, while the rings are in any state.
+     * We need to do thread synchronisation and make sure no transmit
+     * or receive threads are running before we continue.
+     */
+
+    /* Make sure the hard_start_xmit function is not running and will not
+     * be called
+     */
+    netif_tx_disable(dev);
+
+    /* Disable all interrupts */
+    priv->ie_mask = 0;
+    emac_interrupt_control(dev, RX, DISABLE);    /* Disable Rx */
+    emac_interrupt_control(dev, TX, DISABLE);    /* Disable Tx */
+
+    /* Wait for work-queues. This blocks until the handler function has
+     * finished running and no others are pending.
+     * As the interrupts are disabled at this point, the handler will not
+     * be scheduled to run again.
+     * This handles the thread synchronisation with ring handlers.
+     */
+    if (priv->tx_ring != NULL) {
+        emac_wait_stop_ring(priv->tx_ring);
+    }
+    if (priv->rx_ring != NULL) {
+        emac_wait_stop_ring(priv->rx_ring);
+    }
+
+    /* Stop the DMA hardware */
+    emac_dma_control(dev, RX, DISABLE);    /* Disable Rx */
+    emac_dma_control(dev, TX, DISABLE);    /* Disable Tx */
+
+    /* Stop the MAC hardware */
+    emac_iowrite32(0, EMAC_MAC_CONFIG_REG_OFFSET);
+
+    /* Busy wait for the hardware to stop */
+    stops = EMAC_STOP_COUNT;
+    do {
+        /* Wait a while for the reset to happen */
+        udelay(EMAC_STOP_US);
+
+        reg = emac_ioread32(EMAC_DMA_STATUS_REG_OFFSET);
+        if ((reg & (EMAC_DMA_TX_STATE_MASK | EMAC_DMA_RX_STATE_MASK)) == 0) {
+            break;
+        }
+    } while(--stops > 0);
+
+    if (stops == 0) {
+        /* Timeout waiting for stop */
+        printk(KERN_ERR "%s: Can't stop EMAC DMA\n", dev->name);
+    }
+
+    /* Set the reset bit to ensure the EMAC DMA is not running */
+    emac_iowrite32(EMAC_SOFT_RESET, EMAC_DMA_BUS_MODE_REG_OFFSET);
+
+    /* Wait a while for the reset to happen */
+    udelay(EMAC_RESET_US);
+
+    /* Check that the reset has happened */
+    reg = emac_ioread32(EMAC_DMA_BUS_MODE_REG_OFFSET);
+    if ((reg & EMAC_SOFT_RESET) != 0) {
+        /* Reset has not occurred. Error */
+        printk(KERN_ERR "%s: Can't reset EMAC DMA\n", dev->name);
+    }
+
+    /* Make sure no socket buffers are left attached to the
+     * transmit descriptor ring. Free any that are found.
+     * We may just have disabled the interrupt before the transmit
+     * had a chance to complete.
+     */
+    emac_free_ring_skb(dev, priv->tx_ring);
+
+    /* Reset the receive rings state */
+    emac_reset_ring_state(priv->rx_ring);
+
+    /* Discard received packets transferred into the receive
+     * ring after the interrupts were disabled but before the DMA was
+     * disabled.
+     */
+    emac_set_ring_ownership(priv->rx_ring, 0);
+
+#ifdef ENABLE_DEBUGGING
+    print_rings(dev, 1);
+#endif
+
+    DB((LVL_TRACE, "emac_reset complete\n"));
+}
+
+/* Schedule handling of updated link */
+static void
+emac_adjust_link_trigger(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+
+    /* Copy the updated state to out local context. This allows
+     * the PHY driver to update state asynchronously
+     */
+    priv->link = priv->phydev->link;
+    priv->duplex = priv->phydev->duplex;
+    priv->speed = priv->phydev->speed;
+
+//    DB((LVL_DEBUG, "Link adjust event, link %s\n", priv->link ? "up":"down"));
+
+    /* Schedule the handler */
+    queue_work(priv->link_adjust_workqueue, &priv->link_adjust_work);
+}
+
+/* Called every time the controller might need to be made
+ * aware of new link state.  The PHY code conveys this
+ * information through variables in the phydev structure, and this
+ * function converts those variables into the appropriate
+ * register values, and can bring down the device if needed.
+ */
+static void
+emac_adjust_link(struct work_struct *param)
+{
+    struct emac_priv *priv = container_of(param, struct emac_priv, link_adjust_work);
+    struct net_device *dev = priv->self;
+    int new_state = 0;
+
+    if (priv->link) {
+
+        /* Now we make sure that we can be in full duplex mode.
+         * If not, we operate in half-duplex mode. */
+        if (priv->duplex != priv->oldduplex) {
+            new_state = 1;
+            priv->oldduplex = priv->duplex;
+        }
+
+        if (priv->speed != priv->oldspeed) {
+            new_state = 1;
+            priv->oldspeed = priv->speed;
+        }
+
+        if (!priv->oldlink) {
+            new_state = 1;
+            priv->oldlink = 1;
+        }
+
+        /* Something changed. Stop everything, set the new mode and
+         * restart everything again once more.
+         */
+        if (new_state) {
+
+            emac_reset(dev);
+            emac_start(dev);
+        }
+    }
+    else if (priv->oldlink) {
+        new_state = 1;
+        priv->oldlink = 0;
+        priv->oldspeed = 0;
+        priv->oldduplex = -1;
+
+        emac_reset(dev);
+    }
+
+    /* Print new link state */
+    if (new_state && priv->phydev && netif_msg_link(priv)) {
+        phy_print_status(priv->phydev);
+
+#ifdef ENABLE_DEBUGGING
+        emac_dump_phy_regs(dev);
+#endif
+    }
+}
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int
+emac_init_phy(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct phy_device *phydev;
+    char phy_id[BUS_ID_SIZE];
+
+    int ret = 0;
+
+    priv->oldlink = 0;
+    priv->oldspeed = 0;
+    priv->oldduplex = -1;
+
+    /* The hardware is hard wired to the phy */
+#define PHY_BUS_ID "0"
+
+    snprintf(phy_id, BUS_ID_SIZE, PHY_ID_FMT, PHY_BUS_ID, priv->phy_address);
+
+    /* Attach to the PHY */
+    phydev = phy_connect(dev, phy_id, &emac_adjust_link_trigger, 0,
+                         PHY_INTERFACE_MODE_MII);
+    if (IS_ERR(phydev)) {
+        DB((LVL_ERR, "Could not attach to PHY\n"));
+        return PTR_ERR(phydev);
+    }
+
+    printk(KERN_INFO "%s: Connected to Phy (id = 0x%08x)\n", dev->name,
+           phydev->phy_id);
+
+    /* Remove any features not supported by the controller */
+    phydev->supported &= EMAC_MII_SUPPORTED;
+    phydev->advertising = phydev->supported;
+
+    priv->phydev = phydev;
+
+    if (machine_is_pc7802())
+    {
+        /* Set up the DP83640 Phy as used on the PC7802 platform */
+        ret = emac_init_dp83640_phy(dev);
+        if (0 != ret)
+        {
+            printk(KERN_INFO "%s: Problem with initialising the DP83640\n",
+                   dev->name);
+        }
+    }
+
+    return 0;
+}
+
+static int
+emac_init_dp83640_phy(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    int value;
+
+    /* Select register bank 4 */
+    emac_dp83640_select_page(dev, DP83640_PAGE_SEL_4);
+
+    /* Reset the PTP clock and associated logic */
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_CTRL_REG,
+                         (u16)DP83640_PTP_RESET);
+
+    /* The reset bit is not self clearing */
+    udelay (1);
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_CTRL_REG,
+                         (u16)0);
+
+    /* Enable the PTP Clock */
+    value = emac_mii_read(mii_bus,
+                          priv->phy_address,
+                          DP83640_PTP_CTRL_REG);
+    value |= DP83640_PTP_ENABLE;
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_CTRL_REG,
+                         (u16)value);
+
+    return SUCCESS;
+}
+
+static void
+emac_dp83640_select_page(struct net_device *dev,
+                         unsigned int page)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    int value;
+
+    /* Select the phy register page */
+    page &= DP83640_PAGE_SEL_MASK;
+
+    value = emac_mii_read(mii_bus,
+                          priv->phy_address,
+                          DP83640_MII_PAGE_SELECT_REG);
+    value &= DP83640_PAGE_SEL_MASK;
+    value |= page;
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_MII_PAGE_SELECT_REG,
+                         (u16)value);
+}
+
+static int
+emac_dp83640_set_1588_seconds(struct net_device *dev,
+                              u32 timer_seconds)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    int value;
+
+    u16 ns_low, ns_high, sec_low, sec_high;
+
+    /* Select register bank 4 */
+    emac_dp83640_select_page(dev, DP83640_PAGE_SEL_4);
+
+    /* Read back the current timer value */
+    value = emac_mii_read(mii_bus,
+                          priv->phy_address,
+                          DP83640_PTP_CTRL_REG);
+    value |= DP83640_PTP_READ_CLK;
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_CTRL_REG,
+                         (u16)value);
+
+    ns_low = emac_mii_read(mii_bus,
+                           priv->phy_address,
+                           DP83640_PTP_TIME_DATA_REG);
+    ns_high = emac_mii_read(mii_bus,
+                            priv->phy_address,
+                            DP83640_PTP_TIME_DATA_REG);
+    sec_low = emac_mii_read(mii_bus,
+                            priv->phy_address,
+                            DP83640_PTP_TIME_DATA_REG);
+    sec_high = emac_mii_read(mii_bus,
+                             priv->phy_address,
+                             DP83640_PTP_TIME_DATA_REG);
+
+   /* Write back the new seconds value
+    * Note: we preserve the ns value
+    */
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_TIME_DATA_REG,
+                         ns_low);
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_TIME_DATA_REG,
+                         ns_high);
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_TIME_DATA_REG,
+                         (u16)(timer_seconds & 0xFFFF));
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_TIME_DATA_REG,
+                         (u16)((timer_seconds & 0xFFFF0000) >> 16));
+
+    value = emac_mii_read(mii_bus,
+                          priv->phy_address,
+                          DP83640_PTP_CTRL_REG);
+    value |=  DP83640_PTP_LOAD_CLK;
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_CTRL_REG,
+                         (u16)value);
+
+    return SUCCESS;
+}
+
+static int
+emac_dp83640_get_1588_seconds(struct net_device *dev,
+                              u32 *timer_seconds)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    int value;
+
+    u16 ns_low, ns_high, sec_low, sec_high;
+    u32 sec_read;
+
+    /* Select register bank 4 */
+    emac_dp83640_select_page(dev, DP83640_PAGE_SEL_4);
+
+    /* Read back the current timer value */
+    value = emac_mii_read(mii_bus,
+                          priv->phy_address,
+                          DP83640_PTP_CTRL_REG);
+    value |= DP83640_PTP_READ_CLK;
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_CTRL_REG,
+                         (u16)value);
+
+    ns_low = emac_mii_read(mii_bus,
+                           priv->phy_address,
+                           DP83640_PTP_TIME_DATA_REG);
+    ns_high = emac_mii_read(mii_bus,
+                            priv->phy_address,
+                            DP83640_PTP_TIME_DATA_REG);
+    sec_low = emac_mii_read(mii_bus,
+                            priv->phy_address,
+                            DP83640_PTP_TIME_DATA_REG);
+    sec_high = emac_mii_read(mii_bus,
+                             priv->phy_address,
+                             DP83640_PTP_TIME_DATA_REG);
+
+    sec_read = (u32)sec_high;
+    sec_read <<= 16;
+    sec_read |= sec_low;
+    *timer_seconds = sec_read;
+
+    return SUCCESS;
+}
+
+static int
+emac_dp83640_set_1588_nano_seconds(struct net_device *dev,
+                                   u32 timer_nano_seconds)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    int value;
+
+    u16 ns_low, ns_high, sec_low, sec_high;
+
+    /* Select register bank 4 */
+    emac_dp83640_select_page(dev, DP83640_PAGE_SEL_4);
+
+    /* Read back the current timer value */
+    value = emac_mii_read(mii_bus,
+                          priv->phy_address,
+                          DP83640_PTP_CTRL_REG);
+    value |= DP83640_PTP_READ_CLK;
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_CTRL_REG,
+                         (u16)value);
+
+    ns_low = emac_mii_read(mii_bus,
+                           priv->phy_address,
+                           DP83640_PTP_TIME_DATA_REG);
+    ns_high = emac_mii_read(mii_bus,
+                            priv->phy_address,
+                            DP83640_PTP_TIME_DATA_REG);
+    sec_low = emac_mii_read(mii_bus,
+                            priv->phy_address,
+                            DP83640_PTP_TIME_DATA_REG);
+    sec_high = emac_mii_read(mii_bus,
+                             priv->phy_address,
+                             DP83640_PTP_TIME_DATA_REG);
+
+   /* Write back the new nano seconds value
+    * Note: we preserve the seconds value
+    */
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_TIME_DATA_REG,
+                         (u16)(timer_nano_seconds & 0xFFFF));
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_TIME_DATA_REG,
+                         (u16)((timer_nano_seconds & 0xFFFF0000) >> 16));
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_TIME_DATA_REG,
+                         sec_low);
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_TIME_DATA_REG,
+                         sec_high);
+
+    value = emac_mii_read(mii_bus,
+                          priv->phy_address,
+                          DP83640_PTP_CTRL_REG);
+    value |=  DP83640_PTP_LOAD_CLK;
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_CTRL_REG,
+                         (u16)value);
+
+    return SUCCESS;
+}
+
+static int
+emac_dp83640_get_1588_nano_seconds(struct net_device *dev,
+                                   u32 *timer_nano_seconds)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    int value;
+
+    u16 ns_low, ns_high, sec_low, sec_high;
+    u32 ns_read;
+
+    /* Select register bank 4 */
+    emac_dp83640_select_page(dev, DP83640_PAGE_SEL_4);
+
+    /* Read back the current timer value */
+    value = emac_mii_read(mii_bus,
+                          priv->phy_address,
+                          DP83640_PTP_CTRL_REG);
+    value |= DP83640_PTP_READ_CLK;
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_CTRL_REG,
+                         (u16)value);
+
+    ns_low = emac_mii_read(mii_bus,
+                           priv->phy_address,
+                           DP83640_PTP_TIME_DATA_REG);
+    ns_high = emac_mii_read(mii_bus,
+                            priv->phy_address,
+                            DP83640_PTP_TIME_DATA_REG);
+    sec_low = emac_mii_read(mii_bus,
+                            priv->phy_address,
+                            DP83640_PTP_TIME_DATA_REG);
+    sec_high = emac_mii_read(mii_bus,
+                             priv->phy_address,
+                             DP83640_PTP_TIME_DATA_REG);
+
+    ns_read = (u32)ns_high;
+    ns_read <<= 16;
+    ns_read |= ns_low;
+    *timer_nano_seconds = ns_read;
+
+    return SUCCESS;
+}
+
+static int
+emac_dp83640_set_1588_timer_increment(struct net_device *dev,
+                                      u32 rate)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    /* Select register bank 4 */
+    emac_dp83640_select_page(dev, DP83640_PAGE_SEL_4);
+
+    /* Write to the rate high register first */
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_RATE_HIGH_REG,
+                         (u16)((rate & 0xFFFF0000) >> 16));
+
+    /* Finally write to the rate low register */
+    (void)emac_mii_write(mii_bus,
+                         priv->phy_address,
+                         DP83640_PTP_RATE_LOW_REG,
+                         (u16)(rate & 0xFFFF));
+
+    return SUCCESS;
+}
+
+static int
+emac_dp83640_get_1588_timer_increment(struct net_device *dev,
+                                      u32 *rate)
+{
+
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    u16 rate_low, rate_high;
+    u32 rate_read;
+
+    /* Select register bank 4 */
+    emac_dp83640_select_page(dev, DP83640_PAGE_SEL_4);
+
+    /* Read the rate value from the Phy */
+    rate_low = emac_mii_read(mii_bus,
+                             priv->phy_address,
+                             DP83640_PTP_RATE_LOW_REG);
+    rate_high = emac_mii_read(mii_bus,
+                              priv->phy_address,
+                              DP83640_PTP_RATE_HIGH_REG);
+
+    rate_read = (u32)rate_high;
+    rate_read <<= 16;
+    rate_read |= rate_low;
+    *rate = rate_read;
+
+    return SUCCESS;
+}
+
+/*
+ * Free a RX/TX ring
+ */
+static void
+emac_free_ring(struct emac_ring *ring)
+{
+    if (ring != NULL) {
+
+        /* Free hardware descriptors */
+        if (ring->hw_desc != NULL) {
+            dma_free_coherent(ring->device,
+                    sizeof(struct emac_dma_desc) * ring->length,
+                    ring->hw_desc, ring->dma_ring_start);
+        }
+
+        /* Free software descriptors */
+        if (ring->sw_desc != NULL) {
+            kfree(ring->sw_desc);
+        }
+
+        /* Free ring */
+        kfree(ring);
+    }
+}
+
+/*
+ * Allocate a RX/TX ring
+ */
+static struct emac_ring
+*emac_allocate_ring(struct net_device *dev,
+                    unsigned int length)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct emac_ring *ring = NULL;
+    int i;
+
+    /* First allocate the ring structure itself */
+    ring = (struct emac_ring *)kzalloc(sizeof(struct emac_ring), GFP_ATOMIC);
+    if (ring == NULL) {
+        DB((LVL_ERR, "Failed to allocate buffer\n"));
+        goto out_fail;
+    }
+
+    /* Allocate the software descriptors */
+    ring->sw_desc = (struct emac_desc *)kzalloc(
+            sizeof(struct emac_desc) * length, GFP_ATOMIC);
+    if (ring->sw_desc == NULL) {
+        DB((LVL_ERR, "Failed to allocate buffer\n"));
+        goto out_fail;
+    }
+
+    /* Next allocate the hardware descriptors. They must be on
+     * word boundaries. We need a coherent buffer so to avoid the
+     * cache. This means that changes to the descriptors will be
+     * seen immediately by the hardware.
+     */
+    ring->hw_desc = (struct emac_dma_desc *)dma_alloc_coherent(
+            priv->device, sizeof(struct emac_dma_desc) * length,
+            &ring->dma_ring_start, GFP_ATOMIC);
+    if (ring->hw_desc == NULL) {
+        DB((LVL_ERR, "Failed to allocate DMA buffer\n"));
+        goto out_fail;
+    }
+
+    /* Zero the DMA descriptors */
+    memset(ring->hw_desc, 0, sizeof(struct emac_dma_desc) * length);
+
+    /* Setup the ring structure */
+    ring->length = length;
+    emac_reset_ring_state(ring);
+    ring->dev = dev;
+    ring->device = priv->device;
+
+    /* Setup all the descriptors */
+    for (i = 0; i < length; ++i) {
+
+        /* Setup the descriptor */
+        ring->sw_desc[i].dev = dev;
+        ring->sw_desc[i].ring = ring;
+
+        /* Mark it as owned by the HOST so the hardware will not use it */
+        ring->hw_desc[i].status &= ~EMAC_DESC_STATUS_OWNER;
+
+        /* Link the SW-HW descriptors */
+        ring->sw_desc[i].hw_desc = &ring->hw_desc[i];
+        ring->hw_desc[i].sw_desc = &ring->sw_desc[i];
+    }
+
+    /* Setup the thread lock */
+    spin_lock_init(&ring->lock);
+
+    /* Setup the stopping wait queue */
+    init_waitqueue_head(&ring->pending_waitq);
+
+    return ring;
+
+    /* Error handling, release resources and return NULL */
+out_fail:
+    emac_free_ring(ring);
+    return NULL;
+}
+
+/*
+ * Setup the descriptor fields to point to the data buffer.
+ * If this function fails, it descriptor is not changed
+ */
+static int
+emac_wireup_desc_dma(struct net_device *dev,
+                     struct emac_desc *desc,
+                     void *ptr,
+                     unsigned int length,
+                     enum dma_data_direction dir)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct emac_dma_desc *hw_desc = desc->hw_desc;
+    dma_addr_t dma_addr;
+    int ret = 0;
+    u32 buf1_length = 0, buf2_length = 0;
+
+    /* Limit the length to the maximum. When we allocate a socket
+     * buffer of this length, a larger buffer is allocated and we
+     * cannot handle it.
+     */
+    if (length > (EMAC_MAX_DMA_LENGTH * 2)) {
+        length = (EMAC_MAX_DMA_LENGTH * 2);
+    }
+
+    /* Create a DMA mapping for the whole data buffer */
+    dma_addr = dma_map_single(priv->device, ptr, length, dir);
+    if (dma_addr == 0) {
+        ret = -ENOMEM;
+        DB((LVL_ERR, "emac: dma_map_single failed\n"));
+        goto out;
+    }
+
+    /* Record the direction and length for unmapping later */
+    desc->dir = dir;
+    desc->length = length;
+
+    /* Decrement the space left on the ring if we are not
+     * replacing an existing buffer
+     */
+    if (hw_desc->buffer1 == 0) {
+        desc->ring->space--;
+    }
+
+    /* Set the first DMA buffer pointer to the start of the buffer */
+    hw_desc->buffer1 = (u32)dma_addr;
+
+    /* If the length is less that the DMA length, use the first buffer only,
+     * otherwise use both buffers.
+     */
+    if (length <= EMAC_MAX_DMA_LENGTH) {
+
+        buf1_length = length;
+    }
+    else {
+
+        /* Set the maximum size for the first buffer */
+        buf1_length = EMAC_MAX_DMA_LENGTH;
+
+        /* Set the length of the second buffer */
+        buf2_length = length - EMAC_MAX_DMA_LENGTH;
+
+        /* Set the second DMA pointer, part way through the mapped area */
+        hw_desc->buffer2 = (u32)dma_addr + EMAC_MAX_DMA_LENGTH;
+    }
+
+    /* Modify the control field */
+    buf1_length =
+        (buf1_length << EMAC_DESC_CNTL_TBS1_SHIFT) & EMAC_DESC_CNTL_TBS1_MASK;
+    buf2_length =
+        (buf2_length << EMAC_DESC_CNTL_TBS2_SHIFT) & EMAC_DESC_CNTL_TBS2_MASK;
+    hw_desc->control &= ~EMAC_DESC_CNTL_TBS1_MASK;
+    hw_desc->control &= ~EMAC_DESC_CNTL_TBS2_MASK;
+    hw_desc->control = hw_desc->control | buf1_length | buf2_length;
+
+out:
+    return ret;
+}
+
+/*
+ * Get the status of a packet given the first descriptor that is wired up to
+ * it. This function looks at the ownership of the first and last descriptors
+ * and decides if the packet is owned by the host, hardware or shared between
+ * both.
+ */
+#define EMAC_DMA_OWNED 0
+#define EMAC_HOST_OWNED 1
+#define EMAC_JOINTLY_OWNED 2
+static int
+emac_get_next_dma_packet_status(struct emac_ring *ring)
+{
+    struct emac_desc *head_desc = ring->next_dma;
+    struct emac_dma_desc *head_hw_desc = head_desc->hw_desc;
+#ifdef CONFIG_FIRECRACKER_EMAC_FRAG_TX
+    struct emac_dma_desc *last_hw_desc;
+    unsigned int last_idx;
+#endif
+
+    /* The next_dma descriptor must be the head of a packet */
+    if (head_desc->skb == NULL) {
+        DB((LVL_ERR, "emac: Internal Ring ERROR\n"));
+        return 0;
+    }
+
+#ifdef CONFIG_FIRECRACKER_EMAC_FRAG_TX
+
+    /* Get a pointer to the last descriptor in the packet */
+    last_idx = ring->next_dma_idx + skb_shinfo(head_desc->skb)->nr_frags;
+    if (last_idx >= ring->length) {
+        last_idx -= ring->length;
+    }
+    last_hw_desc = &ring->hw_desc[last_idx];
+
+    /* Work out who owns the packet */
+    if ((head_hw_desc->status & EMAC_DESC_STATUS_OWNER) != 0 &&
+            (last_hw_desc->status & EMAC_DESC_STATUS_OWNER) != 0) {
+        return EMAC_DMA_OWNED;
+    }
+
+    if ((head_hw_desc->status & EMAC_DESC_STATUS_OWNER) == 0 &&
+            (last_hw_desc->status & EMAC_DESC_STATUS_OWNER) == 0) {
+        return EMAC_HOST_OWNED;
+    }
+
+    return EMAC_JOINTLY_OWNED;
+
+#else   /* CONFIG_FIRECRACKER_EMAC_FRAG_TX */
+
+    if ((head_hw_desc->status & EMAC_DESC_STATUS_OWNER) != 0) {
+        return EMAC_DMA_OWNED;
+    }
+    return EMAC_HOST_OWNED;
+
+#endif  /* CONFIG_FIRECRACKER_EMAC_FRAG_TX */
+
+}
+
+/*
+ * Normal transmit interrupt handling, free up transmitted packets
+ * This is called from a work queue and is not in interrupt context.
+ */
+static void
+emac_tx_interrupt_work(struct work_struct *param)
+{
+    struct emac_priv *priv = container_of(param, struct emac_priv, tx_int_work);
+    struct net_device *dev = priv->self;
+    struct emac_ring *ring = priv->tx_ring;
+    struct emac_desc *head_desc, *desc;
+
+    /* Thread synchronisation with the transmit function is required here */
+    spin_lock_bh(&ring->lock);
+
+    DB((LVL_TRACE, "emac_tx_interrupt_work\n"));
+
+    /* While there are more transmitted packets to free, free them. We
+     * need to check that the whole packet is sent before starting to
+     * free it. We 'look ahead' down the transmit ring at the descriptor
+     * that is wired to the last fragment of the packet. If that one has been
+     * sent, we know the whole packet has been sent.
+     * This is what emac_get_next_dma_packet_status does for us.
+     */
+    while (ring->next_dma->skb != NULL &&
+            emac_get_next_dma_packet_status(ring) == EMAC_HOST_OWNED) {
+
+        /* Hold the descriptor containing the head of the frame while
+         * we unmap fragments. We will free the head last.
+         */
+        head_desc = ring->next_dma;
+
+        /* Count the transmit errors */
+        emac_tx_errors(dev, head_desc->hw_desc);
+
+        /* Move on to the first fragment (or the next frame if
+         * there are none)
+         */
+        desc = emac_next_dma_desc(ring);
+
+        /* Continue unmapping fragments until we get to the
+         * end of the frame. This is shown by the absence of a fragment which
+         * will be the case weather or not following packets are in the
+         * ring.
+         */
+        while (desc->frag != NULL) {
+
+            /* Count the transmit errors */
+            emac_tx_errors(dev, desc->hw_desc);
+
+            /* Free the buffer associated with the descriptor */
+            emac_free_skb_frag(dev, desc);
+
+            /* Move on to the next fragment */
+            desc = emac_next_dma_desc(ring);
+        }
+
+        /* Unmap and free the head last */
+        emac_free_skb_frag(dev, head_desc);
+    }
+
+    /* We have finished this work item. Maintain the pending count */
+    atomic_dec(&ring->pending);
+    DB((LVL_DEBUG, "Tx finished, pending count = %u\n",
+                atomic_read(&ring->pending)));
+
+    /* Re-enable transmit interrupt, if we are not stopping */
+    if (atomic_read(&ring->stopping) == 0) {
+        emac_interrupt_control(dev, TX, ENABLE);
+
+        /* Start the stack (if stopped) as there in now more space on the
+         * transmit ring
+         */
+        /* Use netif_wake_queue instead of netif_start_queue here as
+         * we want transmission to continue immediately.
+         */
+        netif_wake_queue(dev);
+    }
+
+    /* Release thread sync */
+    spin_unlock_bh(&ring->lock);
+
+    /* Wake up any thread that is waiting for the transmit handler
+     * to complete
+     */
+    wake_up_interruptible(&ring->pending_waitq);
+}
+
+
+/*
+ * The EMAC interrupt handler.
+ */
+static irqreturn_t
+emac_interrupt(int irq,
+               void *dev_id)
+{
+    struct net_device *dev = (struct net_device *)dev_id;
+    struct emac_priv *priv = netdev_priv(dev);
+    u32 statusword;
+
+#ifdef ENABLE_DEBUGGING
+    print_rings(dev, 0);
+#endif
+
+    /* Retrieve the interrupt status */
+    statusword = emac_ioread32(EMAC_DMA_STATUS_REG_OFFSET) & priv->ie_mask;
+    /* Clear all interrupt status bits we will service */
+    emac_iowrite32(statusword, EMAC_DMA_STATUS_REG_OFFSET);
+
+    DB((LVL_DEBUG, "Interrupt, status 0x%08x. netdev state 0x%08x\n", statusword, dev->state));
+
+    /* Handle Fatal bus error */
+    if (statusword & EMAC_FATAL_BUS_ERROR_INT) {
+        DB((LVL_ERR, "Fatal Bus Error Interrupt Seen\n"));
+    }
+
+    /* Handle normal receive interrupts and receive ring full interrupt */
+    if (statusword & EMAC_NORM_RX_INT_MASK) {
+
+        DB((LVL_DEBUG, "Handle normal Rx interrupt\n"));
+
+        /* Disable further receive interrupts */
+        emac_interrupt_control(dev, RX, DISABLE);
+
+        /* Schedule receive polling */
+        atomic_inc(&priv->rx_ring->pending);
+        DB((LVL_DEBUG, "Rx pending count = %u\n",
+                    atomic_read(&priv->rx_ring->pending)));
+        netif_rx_schedule(dev, &priv->napi);
+    }
+
+    /* Handle normal transmit interrupts */
+    if (statusword & EMAC_NORM_TX_INT_MASK) {
+
+        DB((LVL_DEBUG, "Handle normal Tx interrupt\n"));
+
+        /* Disable transmit interrupts */
+        emac_interrupt_control(dev, TX, DISABLE);
+
+        /* Normal transmit handling. Queue work item */
+        atomic_inc(&priv->tx_ring->pending);
+        DB((LVL_DEBUG, "Tx pending count = %u\n",
+                    atomic_read(&priv->tx_ring->pending)));
+        queue_work(priv->tx_int_workqueue, &priv->tx_int_work);
+    }
+
+    /* Rx unavailable */
+    if (statusword & (EMAC_RX_UNAVAILABLE_INT)) {
+        DB((LVL_WARNING, "RX Unavailable seen\n"));
+        priv->stats.rx_over_errors++;
+    }
+
+    /* Handle under/overflows */
+    if (statusword & (EMAC_TX_UNDERFLOW_INT | EMAC_RX_OVERFLOW_INT)) {
+        DB((LVL_WARNING, "Underflow or overflow seen\n"));
+    }
+
+    /* Handle transmit jabber */
+    if (statusword & EMAC_TX_JABBER_TIMEOUT_INT) {
+        DB((LVL_WARNING, "Transmit Jabber seen\n"));
+    }
+
+    /* Handle TX/RX stopped interrupt by restarting */
+    if (statusword & (EMAC_TX_STOPPED_INT | EMAC_RX_STOPPED_INT)) {
+        DB((LVL_WARNING, "Rx or Tx stopped seen, Restarting\n"));
+        emac_dma_control(dev, RX, ENABLE);      /* Enable Rx */
+        emac_dma_control(dev, TX, ENABLE);      /* Enable Tx */
+    }
+
+    return IRQ_HANDLED;
+}
+
+int
+emac_release(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+
+    /* Stop PHY link status monitor */
+    if (priv->phydev != NULL) {
+        phy_stop(priv->phydev);
+        phy_disconnect(priv->phydev);
+    }
+    priv->phydev = NULL;
+
+    /* Force an update to the link status immediately, do not wait for the PHY
+     * driver code to do it's poll. This saves time and is less complex
+     * as we do not have to implement a wait. If the PHY driver happens to
+     * trigger the link down around the same time as we do this, a second
+     * link down event will be swallowed.
+     */
+    netif_carrier_off(dev);
+    priv->link = 0;
+    queue_work(priv->link_adjust_workqueue, &priv->link_adjust_work);
+
+    /* Wait for the link down and reset of hardware */
+    if (priv->link_adjust_workqueue != NULL) {
+        flush_workqueue(priv->link_adjust_workqueue);
+        destroy_workqueue(priv->link_adjust_workqueue);
+    }
+
+    if (priv->tx_int_workqueue != NULL) {
+        flush_workqueue(priv->tx_int_workqueue);
+        destroy_workqueue(priv->tx_int_workqueue);
+    }
+
+    /* Release the interrupt, if we have it */
+    free_irq(dev->irq, dev);
+
+    if (priv->rx_ring != NULL) {
+        /* Free the receive socket buffers */
+        emac_free_ring_skb(dev, priv->rx_ring);
+    }
+
+    if (priv->tx_ring != NULL) {
+        /* Free any transmit socket buffers we may have */
+        emac_free_ring_skb(dev, priv->tx_ring);
+    }
+
+    /* Free the descriptor rings */
+    emac_free_ring(priv->rx_ring);
+    emac_free_ring(priv->tx_ring);
+    priv->rx_ring = NULL;
+    priv->tx_ring = NULL;
+
+    /* Stop transmission */
+    netif_stop_queue(dev);
+
+    napi_disable(&priv->napi);
+
+    return 0;
+}
+
+/*
+ * Open and close
+ */
+
+static int
+emac_open(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct sk_buff *skb;
+    int ret = 0;
+    int i;
+    struct emac_desc *sw_desc = NULL;
+    struct emac_dma_desc *hw_desc = NULL;
+
+    /* Setup a work queue for the transmit interrupt
+     * second level processing
+     */
+    priv->tx_int_workqueue = create_singlethread_workqueue("EMAC TX");
+    if (priv->tx_int_workqueue == NULL) {
+        ret = -ENOMEM;
+        DB((LVL_ERR, "Failed to create TX work queue \n"));
+        goto out;
+    }
+
+    /* Setup a work item for the above work queue */
+    INIT_WORK(&priv->tx_int_work, emac_tx_interrupt_work);
+
+    /* Setup a work queue for the link adjustment handling */
+    priv->link_adjust_workqueue = create_singlethread_workqueue("EMAC LINK");
+    if (priv->link_adjust_workqueue == NULL) {
+        ret = -ENOMEM;
+        DB((LVL_ERR, "Failed to create LINK work queue \n"));
+        goto out;
+    }
+
+    /* Setup a work item for the above work queue */
+    INIT_WORK(&priv->link_adjust_work, emac_adjust_link);
+
+    /* Register for interrupts emac_interrupt */
+    ret = request_irq(
+            dev->irq, &emac_interrupt, IRQF_DISABLED, dev->name, dev);
+    if (ret != 0) {
+        DB((LVL_ERR, "Failed to register IRQ\n"));
+        goto out;
+    }
+
+    /* Allocate receive descriptor ring */
+    priv->rx_ring = emac_allocate_ring(dev, rx_ring_length);
+    if (priv->rx_ring == NULL) {
+        ret = -ENOMEM;
+        DB((LVL_ERR, "Failed to allocate RX ring\n"));
+        goto out;
+    }
+
+    /* Allocate transmit descriptor ring */
+    priv->tx_ring = emac_allocate_ring(dev, tx_ring_length);
+    if (priv->tx_ring == NULL) {
+        ret = -ENOMEM;
+        DB((LVL_ERR, "Failed to allocate TX ring\n"));
+        goto out;
+    }
+
+    /* Allocate receive socket buffers and setup receive descriptors */
+    for (i = 0; i < rx_ring_length; ++i) {
+
+        /* Handy pointer to the descriptor */
+        sw_desc = &priv->rx_ring->sw_desc[i];
+        hw_desc = sw_desc->hw_desc;
+
+        /* Setup the receive control */
+        hw_desc->control = EMAC_RX_CONTROL_FIELD_INIT;
+
+        /* Allocate a socket buffer and connect it to the descriptor */
+        skb = emac_allocate_skb(dev);
+        if (skb == NULL) {
+            ret = -ENOMEM;
+            DB((LVL_ERR, "Failed to allocate RX SKB\n"));
+            goto out;
+        }
+
+        /* Connect the socket buffer to the descriptor */
+        ret = emac_wireup_desc_dma(
+                dev, sw_desc, skb->tail,
+                skb_tailroom(skb) & ~EMAC_RX_LENGTH_MASK, DMA_FROM_DEVICE);
+        if (ret != 0) {
+            DB((LVL_ERR, "Failed to map RX SKB\n"));
+            goto out;
+        }
+
+        /* Associate the descriptor with the socket buffer */
+        sw_desc->skb = skb;
+        sw_desc->frag = NULL;
+
+        /* Mark it as owned by the DMA so the hardware will fill it */
+        hw_desc->status |= EMAC_DESC_STATUS_OWNER;
+    }
+
+    /* Mark the last receive descriptor as the end of the ring */
+    hw_desc->control |= EMAC_DESC_CNTL_END_RING;
+
+    /* Setup transmit descriptors */
+    for (i = 0; i < tx_ring_length; ++i) {
+
+        hw_desc = &priv->tx_ring->hw_desc[i];
+        hw_desc->control = EMAC_TX_CONTROL_FIELD_INIT;
+    }
+
+    /* Mark the last transmit descriptor as the end of the ring */
+    hw_desc->control |= EMAC_DESC_CNTL_END_RING;
+
+    /* Configure the PHY. Start link status monitoring */
+    ret = emac_init_phy(dev);
+    if (ret != 0) {
+        DB((LVL_ERR, "Failed to initialise PHY driver\n"));
+        goto out;
+    }
+
+    napi_enable(&priv->napi);
+
+    /* Tell the PHY driver we are ready for business, when the link up
+     * event occurs, we will start the EMAC DMA hardware (see emac_start)
+     */
+    phy_start(priv->phydev);
+
+    /* Tell the upper levels not to send us packets to be transmitted, until
+     * we have established a link
+     */
+    netif_carrier_off(dev);
+    netif_tx_disable(dev);
+
+    return 0;
+out:
+    if (ret != 0) {
+        emac_release(dev);
+    }
+    return ret;
+}
+
+/*
+ * Configuration changes (passed on by ifconfig)
+ */
+int
+emac_config(struct net_device *dev,
+            struct ifmap *map)
+{
+    if (dev->flags & IFF_UP) /* can't act on a running interface */
+        return -EBUSY;
+
+    /* Don't allow changing the I/O address */
+    if (map->base_addr != dev->base_addr) {
+        printk(KERN_WARNING "%s: Can't change I/O address\n", dev->name);
+        return -EOPNOTSUPP;
+    }
+
+    /* Don't allow changing the IRQ */
+    if (map->irq != dev->irq) {
+        printk(KERN_WARNING "%s: Can't change IRQ\n", dev->name);
+        return -EOPNOTSUPP;
+    }
+
+    /* ignore other fields */
+    return 0;
+}
+/* Pass a new received socket buffer to the networking layer */
+static int
+emac_pass_up_skb(struct net_device *dev,
+                 struct sk_buff *skb,
+                 u32 status)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+    unsigned int data_length;
+    unsigned short vlan_tag = 0;
+
+    /* Get the received length from the descriptor */
+    data_length =
+        (status & EMAC_RX_DESC_STATUS_FLEN_MASK) >>
+        EMAC_RX_DESC_STATUS_FLEN_SHIFT;
+
+    /* Set the length of the data received in the socket buffer.
+     * Trim the received Ethernet FCS and the EMAC checksum from the
+     * received buffer so that the networking stack only sees the
+     * IP payload. This is done so that the networking stack believes
+     * the checksum we will pass in via skb->csum and will not spend time
+     * generating its own checksum.
+     */
+    skb_put(skb, data_length - ETHERNET_FCS_LEN - EMAC_CHECKSUM_LENGTH);
+
+    /* To do hardware checksumming, we need to get the IP payload
+     * checksum into skb->csum.
+     * The EMAC adds the 1's complement checksum after the packet data.
+     * We invert this and pass it in.
+     */
+    skb->csum = (skb->data[data_length-1] << 8) | skb->data[data_length-2];
+    skb->csum = (~skb->csum) & 0xffff;
+    skb->ip_summed = 1;   /* Checked by hardware */
+
+    /* Set up the Ethernet device that received the packet */
+    skb->dev = dev;
+
+    /* If the hardware tells us it is a VLAN frame, get the tag from the
+     * data before we remove the header.
+     * This is often done by the hardware but not in our case, we have
+     * to look inside the header ourselves.
+     * Remove the VLAN header data from the received frame by shifting the
+     * source and destination MAC addresses. This turns the VLAN frame
+     * into a normal Ethernet packet which is what the network stack
+     * expects from us.
+     */
+    if (status & EMAC_RX_DESC_STATUS_VLAN) {
+
+        /* Ignore the return value. If the hardware tells us it is VLAN
+         * and it is not, something much more serious has occurred.
+         */
+        vlan_get_tag(skb, &vlan_tag);
+
+        /* Shift the MAC addresses to make it into an normal packet */
+        memmove(skb->data + VLAN_HLEN, skb->data, ETH_ALEN + ETH_ALEN);
+        skb_pull(skb, VLAN_HLEN);
+    }
+
+    /* Get the protocol type of the packet */
+    skb->protocol = eth_type_trans(skb, dev);
+
+    /* If this is a VLAN packet the hardware will tell us */
+    if ((status & EMAC_RX_DESC_STATUS_VLAN) && priv->vlgrp) {
+
+        /* Pass the packet to the VLAN layer */
+        return vlan_hwaccel_receive_skb(skb, priv->vlgrp, vlan_tag);
+    }
+
+    if (machine_is_pc7802())
+    {
+        if (priv->hw_timestamp_flag == HWTSTAMP_FILTER_ALL)
+        {
+            /* We have been asked to include the hardware timestamp of the
+               received packet in the socket buffer */
+
+            ktime_t hw_timestamp;
+
+            int value;
+
+            u16 ns_low, ns_high, sec_low, sec_high;
+
+            /* Obtain the current timestamp value from the DP83640
+             * Ethernet Phy
+             */
+
+            /* Select register bank 4 */
+            emac_dp83640_select_page(dev, DP83640_PAGE_SEL_4);
+
+            /* Read back the current timer value */
+            value = emac_mii_read(mii_bus,
+                                  priv->phy_address,
+                                  DP83640_PTP_CTRL_REG);
+            value |= DP83640_PTP_READ_CLK;
+            (void)emac_mii_write(mii_bus,
+                                 priv->phy_address,
+                                 DP83640_PTP_CTRL_REG,
+                                 (u16)value);
+
+            ns_low = emac_mii_read(mii_bus,
+                                   priv->phy_address,
+                                   DP83640_PTP_TIME_DATA_REG);
+            ns_high = emac_mii_read(mii_bus,
+                                    priv->phy_address,
+                                    DP83640_PTP_TIME_DATA_REG);
+            sec_low = emac_mii_read(mii_bus,
+                                    priv->phy_address,
+                                    DP83640_PTP_TIME_DATA_REG);
+            sec_high = emac_mii_read(mii_bus,
+                                     priv->phy_address,
+                                     DP83640_PTP_TIME_DATA_REG);
+
+            hw_timestamp.tv.sec = (sec_high << 16) | sec_low;
+            hw_timestamp.tv.nsec = (ns_high << 16) | ns_low;
+
+            /* Set hardware timestamp value in the socket buffer */
+            skb_hwtstamp_set(skb, hw_timestamp);
+        }
+    }
+
+    /* Pass the packet to the network layer */
+    return netif_receive_skb(skb);
+}
+
+/*
+ * The poll implementation.
+ */
+static int
+emac_poll(struct napi_struct *napi_s, int budget)
+{
+    int npackets = 0;
+    struct emac_priv *priv = container_of(napi_s, struct emac_priv, napi);
+    struct net_device *dev = priv->self;
+    struct emac_desc *desc;
+    struct emac_dma_desc *hw_desc;
+    struct emac_ring *ring = priv->rx_ring;
+    struct sk_buff *new_skb, *full_skb;
+    int congestion = NET_RX_SUCCESS;
+
+    DB((LVL_TRACE, "emac_poll\n"));
+
+    /* While there are more transmitted packets to free, free them. */
+    /* While there are more packets and the stack wants more */
+    /* While the network stack is not reporting congestion */
+    while (npackets < budget &&
+           emac_get_next_dma_packet_status(ring) == EMAC_HOST_OWNED &&
+           congestion == NET_RX_SUCCESS) {
+
+        /* Handy pointer to this descriptor, and the socket buffer
+         * that is full of received data
+         */
+        desc = ring->next_dma;
+        hw_desc = desc->hw_desc;
+        full_skb = desc->skb;
+
+        /* Move on to the next packet for future processing */
+        emac_next_dma_desc(ring);
+
+        /* Discard bad frames and count errors */
+        if (emac_rx_errors(dev, hw_desc) != 0) {
+
+            /* Re-use the socket buffer that is already connected to the
+             * descriptor. Set the ownership to DMA owned.
+             */
+            hw_desc->status |= EMAC_DESC_STATUS_OWNER;
+
+            /* Continue processing the next packet */
+            continue;
+        }
+
+        /* Allocate a socket buffer to replace the one we are about to
+         * send to the networking layer.
+         */
+        new_skb = emac_allocate_skb(dev);
+        if (new_skb == NULL) {
+
+            /* Socket buffer allocation failure. Debug message */
+            DB((LVL_NOTICE, "Packet Dropped\n"));
+
+            /* Record the dropped packets */
+            priv->stats.rx_dropped++;
+
+            /* Re-use the socket buffer that is already connected to the
+             * descriptor as we cannot allocate a new one. Mark the
+             * descriptor for filling by the EMAC DMA, thus overwriting
+             * the received data.
+             */
+            hw_desc->status |= EMAC_DESC_STATUS_OWNER;
+
+            /* Continue processing the next packet */
+            continue;
+        }
+
+        /* Unmap the socket buffer that has received data */
+        emac_unmap_skb_frag(dev, desc);
+
+        /* Pass the socket buffer that has received data to
+         * the network layer
+         */
+        congestion = emac_pass_up_skb(dev, full_skb, hw_desc->status);
+
+        /* Handle congestion in the network stack */
+        switch (congestion) {
+            case NET_RX_CN_LOW:
+                DB((LVL_NOTICE, "Receive congestion Low\n"));
+                break;
+            case NET_RX_CN_MOD:
+                DB((LVL_NOTICE, "Receive congestion Medium\n"));
+                break;
+            case NET_RX_CN_HIGH:
+                DB((LVL_NOTICE, "Receive congestion High\n"));
+                break;
+            case NET_RX_DROP:
+                break;
+        }
+
+        /* Count the packets sent to the network layer so that we
+         * do not exceed our quota.
+         */
+        npackets++;
+
+        /* Connect the newly allocated socket buffer to the descriptor */
+        if (emac_wireup_desc_dma(
+                dev, desc, new_skb->tail,
+                skb_tailroom(new_skb) & ~EMAC_RX_LENGTH_MASK,
+                DMA_FROM_DEVICE) != 0) {
+
+            /* This really needs to succeed. If it fails, all we can do
+             * is leave the descriptor owned by the DMA. When the DMA comes
+             * around the ring to this descriptor again, it will stop.
+             * Closing and re-opening the driver will restart reception
+             * in this situation.
+             */
+            DB((LVL_ERR, "Mmap fail! Reception disabled.\n"));
+
+            dev_kfree_skb(new_skb);
+            new_skb = NULL;
+            desc->skb = NULL;
+            hw_desc->buffer1 = 0;
+            ring->space++;
+            continue;
+        }
+
+        /* Associate the descriptor with the new socket buffer */
+        desc->skb = new_skb;
+
+        /* Mark it as owned by the DMA so the hardware will fill it */
+        hw_desc->status |= EMAC_DESC_STATUS_OWNER;
+    }
+
+    /* If we processed all packets, we're done; tell the kernel and
+     * re-enable interrupts
+     */
+    if (emac_get_next_dma_packet_status(ring) != EMAC_HOST_OWNED) {
+
+        /* Stop polling, we have received everything */
+        atomic_dec(&ring->pending);
+        DB((LVL_DEBUG, "Rx poll finished, pending count = %u\n",
+                    atomic_read(&ring->pending)));
+
+        netif_rx_complete(dev, &priv->napi);
+
+        /* Enable the receive interrupts */
+        if (atomic_read(&ring->stopping) == 0) {
+            emac_interrupt_control(dev, RX, ENABLE);
+        }
+
+        /* Wake up any thread that is waiting for the receive handler
+         * to complete
+         */
+        wake_up_interruptible(&ring->pending_waitq);
+
+        return 0;
+    }
+
+    DB((LVL_DEBUG, "Rx poll unfinished, pending count = %u\n",
+                atomic_read(&ring->pending)));
+
+    /* Kick the hardware to continue receiving if it is suspended as there
+     * are now more descriptors available for the DMA to write into.
+     */
+    emac_hw_rx_resume(dev);
+
+    /* We couldn't process everything. */
+    return 1;
+}
+
+/*
+ * Transmit a packet (called by the kernel)
+ */
+int
+emac_tx(struct sk_buff *skb,
+        struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    int ret = NETDEV_TX_OK;
+    struct emac_desc *desc, *first_desc;
+    struct emac_dma_desc *hw_desc;
+    struct emac_ring *ring = priv->tx_ring;
+#ifdef CONFIG_FIRECRACKER_EMAC_FRAG_TX
+    unsigned int f;
+    unsigned int nr_frags;
+    struct skb_frag_struct *frag;
+#endif
+
+    DB((LVL_TRACE, "emac_tx\n"));
+
+    /* Thread synchronisation with the transmit function is required here */
+    spin_lock_bh(&ring->lock);
+
+#ifndef CONFIG_FIRECRACKER_EMAC_FRAG_TX
+
+    /* We do not like fragmented packets */
+    if (skb_shinfo(skb)->nr_frags > 0) {
+        DB((LVL_WARNING, "Fragmented Tx packet, dropping\n"));
+        goto out_fail;
+    }
+
+    /* Check that we have enough space on the ring */
+    if (ring->space == 0) {
+#ifdef ENABLE_DEBUGGING
+        print_rings(dev, 1);
+#endif /* ENABLE_DEBUGGING */
+        /* Stop the stack to give us time to clear the backlog */
+        netif_stop_queue(dev);
+        ret = NETDEV_TX_BUSY;
+        DB((LVL_NOTICE, "TX ring full. Deferring. TX clean pending count = %u\n", atomic_read(&ring->pending)));
+        priv->stats.tx_fifo_errors++;
+        goto out;
+    }
+
+#else /* CONFIG_FIRECRACKER_EMAC_FRAG_TX */
+
+    /* Check that we have enough space on the ring for the fragmented
+     * packet, head plus fragments.
+     */
+    nr_frags = skb_shinfo(skb)->nr_frags;
+    if (ring->space < (nr_frags + 1)) {
+        /* Stop the stack to give us time to clear the backlog */
+        netif_stop_queue(dev);
+        ret = NETDEV_TX_BUSY;
+        DB((LVL_NOTICE, "TX ring full. Deferring.\n"));
+        priv->stats.tx_fifo_errors++;
+        goto out;
+    }
+
+#endif  /* CONFIG_FIRECRACKER_EMAC_FRAG_TX */
+
+    /* We are required to save the time stamp */
+    dev->trans_start = jiffies;
+
+    /* Add the socket buffer to the transmit ring. We assume that the
+     * socket buffer is not larger that a page. This is a valid assumption
+     * as we have a maximum MTU of 4k (a page) and the networking layer
+     * should not be sending us frames larger than this.
+     */
+
+    /* Handy pointer to the first transmit descriptor to be added */
+    first_desc = ring->next;
+    desc = first_desc;
+    hw_desc = desc->hw_desc;
+
+    /* Set the descriptor to point to the socket buffer. Data is passed
+     * to the hardware hence DMA_TO_DEVICE.
+     */
+    ret = emac_wireup_desc_dma(
+            dev, desc, skb->data, skb->len - skb->data_len, DMA_TO_DEVICE);
+    if (ret != 0) {
+        /* If the mmap fails, exit discarding the packet. This is safe as
+         * we have not changed the ring yet.
+         */
+        ret = NETDEV_TX_OK;
+        DB((LVL_ERR, "Failed to map TX SKB. Discarding packet\n"));
+        goto out_fail;
+    }
+
+    /* Associate the first descriptor with the socket buffer head */
+    desc->skb = skb;
+    desc->frag = NULL;
+
+
+#ifdef CONFIG_FIRECRACKER_EMAC_FRAG_TX
+
+    /* Mark the first descriptor as the start of the frame */
+    hw_desc->control |= EMAC_TX_DESC_CNTL_FIRST_SEG;
+    hw_desc->control &= ~EMAC_TX_DESC_CNTL_LAST_SEG;
+
+    if (nr_frags > 0) {
+        DB((LVL_NOTICE, "Fragmented Tx packet\n"));
+    }
+
+    /* Deal with fragments before marking the first as owned by DMA */
+
+    /* For each fragment of the shared info, add it to a descriptor */
+    for (f = 0; f < nr_frags; f++) {
+
+        /* Move on to the next descriptor */
+        desc = emac_next_desc(ring);
+        hw_desc = desc->hw_desc;
+
+        /* Handy pointer to the next fragment */
+        frag = &skb_shinfo(skb)->frags[f];
+
+        /* Set the descriptor to point to the fragment */
+        ret = emac_wireup_desc_dma(dev, desc,
+                page_address(frag->page) + frag->page_offset, frag->size,
+                DMA_TO_DEVICE);
+        if (ret != 0) {
+            /* If the mmap fails, move the next pointer back to the previous
+             * and set as the end of the packet. The partial packet will
+             * be transmitted. This is the cleanest way to deal with this
+             * unusual error path.
+             */
+            desc = emac_previous_desc(ring);
+            hw_desc = desc->hw_desc;
+            ret = NETDEV_TX_OK;
+            break;
+        }
+
+        /* Associate the descriptor with the buffer fragment */
+        desc->skb = NULL;
+        desc->frag = frag;
+
+        /* Mark as nether the first or last descriptor */
+        hw_desc->control &= ~EMAC_TX_DESC_CNTL_FIRST_SEG;
+        hw_desc->control &= ~EMAC_TX_DESC_CNTL_LAST_SEG;
+
+        /* Mark the descriptor as owned by the DMA */
+        hw_desc->status |= EMAC_DESC_STATUS_OWNER;
+    }
+
+    /* Mark the last descriptor as the end of the frame */
+    hw_desc->control |= EMAC_TX_DESC_CNTL_LAST_SEG;
+
+#endif  /* CONFIG_FIRECRACKER_EMAC_FRAG_TX */
+
+    /* Move on to the next descriptor where the
+     * following frame will be added
+     */
+    emac_next_desc(ring);
+
+    /* Now that the tail fragments have been passed to DMA ownership,
+     * mark the first (head) descriptor as owned by the DMA. This
+     * avoids a race condition between the DMA hardware reading fragments
+     * at the same time as we are adding them to the ring. The DMA will
+     * only start reading fragments when the first (head) ownership
+     * is passed to the DMA. At this point, all subsequent fragments
+     * will have been setup.
+     */
+    first_desc->hw_desc->status |= EMAC_DESC_STATUS_OWNER;
+
+    /* Make sure the hardware is sending and not suspended */
+    emac_hw_tx_resume(dev);
+
+    goto out;
+
+
+out_fail:
+    /* Free the socket buffer as we are discarding it */
+    dev_kfree_skb_any(skb);
+
+out:
+    /* Release thread sync */
+    spin_unlock_bh(&ring->lock);
+
+    return ret;
+}
+
+/*
+ * Deal with a transmit timeout.
+ */
+static void
+emac_tx_timeout(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+
+    DB((LVL_WARNING, "Transmit timeout at %ld, latency %ld\n", jiffies,
+                jiffies - dev->trans_start));
+
+    /* Simulate a dropped link and get the PHY link maintaining code to
+     * reset the link and hardware.
+     * I assume the link is up when this is called.
+     */
+    priv->oldlink = 0;
+    priv->link = 1;
+    queue_work(priv->link_adjust_workqueue, &priv->link_adjust_work);
+}
+
+/*
+ * Ioctl commands
+ */
+int
+emac_ioctl(struct net_device *dev,
+           struct ifreq *rq,
+           int cmd)
+{
+    if (machine_is_pc7802())
+    {
+        switch (cmd)
+        {
+            case SIOCSHWTSTAMP:
+	        return emac_hwtstamp_ioctl(dev, rq, cmd);
+
+            default:
+	        return -EOPNOTSUPP;
+        }
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+static int emac_hwtstamp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct hwtstamp_config config;
+
+    if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+    {
+        return -EFAULT;
+    }
+
+    /* reserved for future extensions */
+    if (config.flags)
+    {
+	return -EINVAL;
+    }
+
+    /* We do not support hardware timestamping of outgoing packets,
+       leave the frame work in here for possible future software
+       enhancements */
+    switch (config.tx_type)
+    {
+        case HWTSTAMP_TX_OFF:
+	    break;
+
+        case HWTSTAMP_TX_ON:
+	    break;
+
+        default:
+	    return -ERANGE;
+    }
+
+    switch (config.rx_filter_type)
+    {
+        case HWTSTAMP_FILTER_NONE:
+            /* Hardware timestamping not required */
+            priv->hw_timestamp_flag = HWTSTAMP_FILTER_NONE;
+
+            printk(KERN_INFO "%s: Hardware timestamping of received "
+                             "packets disabled\n", dev->name);
+            break;
+
+        case HWTSTAMP_FILTER_ALL:
+	    /* Hardware timestamping of received packets is required */
+            priv->hw_timestamp_flag = HWTSTAMP_FILTER_ALL;
+
+            printk(KERN_INFO "%s: Hardware timestamping of received "
+                             "packets enabled\n", dev->name);
+	    config.rx_filter_type = HWTSTAMP_FILTER_ALL;
+	    break;
+
+        case HWTSTAMP_FILTER_SOME:
+            printk(KERN_INFO "%s: HWTSTAMP_FILTER_SOME not "
+                             "supported by driver\n", dev->name);
+            break;
+
+        case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+            printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V1_L4_EVENT"
+                             " not supported by driver\n", dev->name);
+            break;
+
+        case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V1_L4_SYNC"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L4_EVENT"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L4_SYNC"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L2_EVENT"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L2_SYNC"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_EVENT"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_SYNC"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_DELAY_REQ"
+                              " not supported by driver\n", dev->name);
+            break;
+
+        default:
+	    return -ERANGE;
+    }
+
+    return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ? -EFAULT : 0;
+}
+
+/*
+ * Return statistics to the caller
+ */
+struct net_device_stats
+*emac_stats(struct net_device *dev)
+{
+    struct net_device_stats *stats =
+        &((struct emac_priv *)netdev_priv(dev))->stats;
+
+    /* Read the hardware statistics into our local statistics */
+    stats->tx_packets = emac_ioread32(EMAC_MMC_TX_FRAME_COUNT_GB);
+    stats->rx_packets = emac_ioread32(EMAC_MMC_RX_FRAME_COUNT_GB);
+    stats->tx_bytes = emac_ioread32(EMAC_MMC_TX_BYTE_COUNT_GB);
+    stats->rx_bytes = emac_ioread32(EMAC_MMC_RX_BYTE_COUNT_GB);
+
+    /* bad packets received (total frames minus good frames) */
+    stats->rx_errors =
+        stats->rx_packets -
+        emac_ioread32(EMAC_MMC_RX_BROADCAST_FRAMES_G) -
+        emac_ioread32(EMAC_MMC_RX_MULTICAST_FRAMES_G) -
+        emac_ioread32(EMAC_MMC_RX_UNICAST_FRAMES_G);
+
+    /* packet transmit problems (total frames minus good frames) */
+    stats->tx_errors =
+        stats->tx_packets - emac_ioread32(EMAC_MMC_TX_FRAME_COUNT_G);
+
+    /* transmit under run */
+    stats->tx_dropped = emac_ioread32(EMAC_MMC_TX_UNDERFLOW);
+
+    /* multicast packets received */
+    stats->multicast = emac_ioread32(EMAC_MMC_RX_MULTICAST_FRAMES_G);
+
+    /* packets sent after collisions in half duplex mode */
+    stats->collisions =
+        emac_ioread32(EMAC_MMC_TX_SINGLE_COLL_G) +
+        emac_ioread32(EMAC_MMC_TX_MULTI_COLL_G);
+
+    /* frames received with length error */
+    stats->rx_length_errors = emac_ioread32(EMAC_MMC_RX_LENGTH_ERROR);
+
+    /* received packet with CRC error */
+    stats->rx_crc_errors = emac_ioread32(EMAC_MMC_RX_CRC_ERROR);
+
+    /* received frame alignment error */
+    stats->rx_frame_errors = emac_ioread32(EMAC_MMC_RX_ALLIGN_ERROR);
+
+    /* received FIFO overrun */
+    stats->rx_fifo_errors =
+        (emac_ioread32(EMAC_DMA_STATS_REG_OFFSET) &&
+        EMAC_FIFO_OVERFLOW_MASK) >> EMAC_FIFO_OVERFLOW_SHIFT;
+
+    /* receiver missed packet */
+    stats->rx_missed_errors =
+        (emac_ioread32(EMAC_DMA_STATS_REG_OFFSET) &&
+        EMAC_MISSED_FRAMES_MASK) >> EMAC_MISSED_FRAMES_SHIFT;
+
+    /* transmit aborted due to excessive collisions */
+    stats->tx_aborted_errors = emac_ioread32(EMAC_MMC_TX_EXCESS_COLL);
+
+    /* transmit aborted due to carrier sense error */
+    stats->tx_carrier_errors = emac_ioread32(EMAC_MMC_TX_CARRIER_ERR);
+
+    /* the self-test indicates my transceiver might be broken */
+    stats->tx_heartbeat_errors = 0;
+
+    /* transmit aborted due late collision */
+    stats->tx_window_errors = emac_ioread32(EMAC_MMC_TX_LATE_COLL);
+
+    stats->rx_compressed = 0;
+    stats->tx_compressed = 0;
+
+    return stats;
+}
+
+/* Enables and disables VLAN insertion/extraction */
+static void
+emac_vlan_rx_register(struct net_device *dev,
+                      struct vlan_group *grp)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+
+    priv->vlgrp = grp;
+}
+
+static void
+emac_vlan_rx_kill_vid(struct net_device *dev,
+                      uint16_t vid)
+{
+    /* Nothing to do. We do not support filtering */
+}
+
+/* Update the hash table based on the current list of multicast
+ * addresses we subscribe to.  Also, change the promiscuity of
+ * the device based on the flags (this function is called
+ * whenever dev->flags is changed */
+static void
+emac_set_multi(struct net_device *dev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+    struct dev_mc_list *mc_ptr;
+    u32 ff_reg = 0;
+
+    if(dev->flags & IFF_PROMISC) {
+        if (netif_msg_drv(priv))
+            printk(KERN_INFO "%s: Entering promiscuous mode.\n",
+                    dev->name);
+
+        /* Set the PR (Promiscuous Mode) frame filter mode */
+        ff_reg |= EMAC_PROMISCUOUS_MODE;
+    }
+
+    /* Deal with multicast */
+    if(dev->flags & IFF_ALLMULTI) {
+
+        /* Set the PM (Pass All Multicast) frame filter mode */
+        ff_reg |= EMAC_PASS_ALL_MULTICAST;
+    }
+    else {
+
+        int idx;
+
+        /* zero out the hash */
+        emac_iowrite32(0, EMAC_MAC_HASH_HIGH_REG_OFFSET);
+        emac_iowrite32(0, EMAC_MAC_HASH_LOW_REG_OFFSET);
+
+        idx = 1;
+
+        /* Clear the hash masks */
+        priv->hash_high = 0;
+        priv->hash_low = 0;
+
+        if (dev->mc_count > (EMAC_MAX_MAC_ADDRS - 1)) {
+            /* Use hash tables for filtering more that 16 addresses */
+            for (mc_ptr = dev->mc_list; mc_ptr; mc_ptr = mc_ptr->next) {
+
+                emac_calc_hash_for_addr(dev, mc_ptr->dmi_addr);
+            }
+
+            /* Set the HMC (Hash MultiCast) bit of the filter control */
+            ff_reg |= EMAC_HASH_MULTICAST;
+        }
+
+        else if (dev->mc_count > 0) {
+            /* Use perfect filtering if between 0 and 15 addresses */
+
+            /* Parse the list, and set the appropriate bits */
+            for (mc_ptr = dev->mc_list; mc_ptr; mc_ptr = mc_ptr->next) {
+
+                emac_set_mac_for_addr(dev, idx, mc_ptr->dmi_addr, 0);
+                idx++;
+            }
+        }
+
+        /* Clear out any remaining exact match addresses */
+        for (; idx < EMAC_MAX_MAC_ADDRS; ++idx) {
+            emac_reset_mac(dev, idx);
+        }
+
+        /* Set the calculated final hash masks */
+        emac_set_hash(dev);
+    }
+
+    /* Set the frame filter control */
+    emac_iowrite32(ff_reg, EMAC_MAC_FRAME_FLT_REG_OFFSET);
+}
+
+
+/*
+ * The init function (sometimes called probe).
+ * It is invoked by register_netdev()
+ */
+void
+emac_init(struct net_device *dev,
+          struct platform_device *pdev)
+{
+    struct emac_priv *priv = netdev_priv(dev);
+
+    /*
+     * Then, assign other fields in dev, using ether_setup() and some
+     * hand assignments
+     */
+    ether_setup(dev); /* assign some of the fields */
+
+    dev->open               = emac_open;
+    dev->stop               = emac_release;
+    dev->set_config         = emac_config;
+    dev->hard_start_xmit    = emac_tx;
+    dev->do_ioctl           = emac_ioctl;
+    dev->get_stats          = emac_stats;
+    dev->tx_timeout         = emac_tx_timeout;
+    dev->watchdog_timeo     = msecs_to_jiffies(watchdog);
+    dev->set_multicast_list = emac_set_multi;
+    dev->vlan_rx_register   = emac_vlan_rx_register;
+    dev->vlan_rx_kill_vid   = emac_vlan_rx_kill_vid;
+
+    /* Setup our features */
+    dev->features           |= NETIF_F_HW_VLAN_RX;
+#ifdef CONFIG_FIRECRACKER_EMAC_FRAG_TX
+    /* We will accept fragmented transmit packets */
+    dev->features           |= NETIF_F_SG;
+#endif
+
+    /* Reset the private data */
+    memset(priv, 0, sizeof(struct emac_priv));
+
+    netif_napi_add(dev, &priv->napi, emac_poll, napi_poll_weight);
+
+    /* Get a pointer to the struct device for mapping operations */
+    priv->device = &pdev->dev;
+    priv->self = dev;
+
+    /* Setup the thread lock for mirrored registers */
+    spin_lock_init(&priv->mirror_lock);
+
+    /* Assign the hardware address of the interface */
+    emac_get_mac(dev, dev->dev_addr);
+
+    /* Set up the Phy Address */
+    if (machine_is_pc7802())
+    {
+        /* On the PC7802 platform the Phy Address is 1 */
+        priv->phy_address = 1;
+    }
+    else
+    {
+        /* On the PC7202/5 the PC20x is running in reverse
+         * MII mode.  The Phy Address of the internal Phy
+         * is 0.
+         */
+        priv->phy_address = 0;
+    }
+}
+
+/* Sysfs functions and data structures */
+static ssize_t
+emac_sysfs_1588_seconds_show(struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf)
+{
+    u32 value;
+
+    (void)emac_dp83640_get_1588_seconds(sysfs_ndev, &value);
+
+    return snprintf(buf, PAGE_SIZE, "%u\n", value);
+}
+
+static ssize_t
+emac_sysfs_1588_seconds_store(struct device *dev,
+                              struct device_attribute *attr,
+                              const char *buf,
+                              size_t count)
+{
+    unsigned long value = 0;
+    char *endp;
+
+    value = simple_strtoul(buf, &endp, 0);
+
+    if (buf != endp)
+    {
+        /* We have some valid data to write */
+        (void)emac_dp83640_set_1588_seconds(sysfs_ndev, (u32)value);
+    }
+
+    return (ssize_t)count;
+}
+
+static DEVICE_ATTR(1588_timer_seconds, (S_IRUGO | S_IWUGO),
+                   emac_sysfs_1588_seconds_show,
+                   emac_sysfs_1588_seconds_store);
+
+static ssize_t
+emac_sysfs_1588_nano_seconds_show(struct device *dev,
+                                  struct device_attribute *attr,
+                                  char *buf)
+{
+    u32 value;
+
+    (void)emac_dp83640_get_1588_nano_seconds(sysfs_ndev, &value);
+
+    return snprintf(buf, PAGE_SIZE, "%u\n", value);
+}
+
+static ssize_t
+emac_sysfs_1588_nano_seconds_store(struct device *dev,
+                                   struct device_attribute *attr,
+                                   const char *buf,
+                                   size_t count)
+{
+    unsigned long value = 0;
+    char *endp;
+
+    value = simple_strtoul(buf, &endp, 0);
+
+    if (buf != endp)
+    {
+        /* We have some valid data to write */
+        (void)emac_dp83640_set_1588_nano_seconds(sysfs_ndev, (u32)value);
+    }
+
+    return (ssize_t)count;
+}
+
+static DEVICE_ATTR(1588_timer_nano_seconds, (S_IRUGO | S_IWUGO),
+                   emac_sysfs_1588_nano_seconds_show,
+                   emac_sysfs_1588_nano_seconds_store);
+
+static ssize_t
+emac_sysfs_1588_timer_increment_show(struct device *dev,
+                                     struct device_attribute *attr,
+                                     char *buf)
+{
+    u32 value;
+
+    (void)emac_dp83640_get_1588_timer_increment(sysfs_ndev, &value);
+
+    return snprintf(buf, PAGE_SIZE, "%u\n", value);
+}
+
+static ssize_t
+emac_sysfs_1588_timer_increment_store(struct device *dev,
+                                      struct device_attribute *attr,
+                                      const char *buf,
+                                      size_t count)
+{
+    unsigned long value = 0;
+    char *endp;
+
+    value = simple_strtoul(buf, &endp, 0);
+
+    if (buf != endp)
+    {
+        /* We have some valid data */
+        (void)emac_dp83640_set_1588_timer_increment(sysfs_ndev, (u32)value);
+    }
+
+    return (ssize_t)count;
+}
+
+static DEVICE_ATTR(1588_timer_increment, (S_IRUGO | S_IWUGO),
+                   emac_sysfs_1588_timer_increment_show,
+                   emac_sysfs_1588_timer_increment_store);
+
+static ssize_t
+emac_sysfs_phy_register_show(struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf)
+{
+    struct emac_priv *priv = netdev_priv(sysfs_ndev);
+
+    return snprintf(buf, PAGE_SIZE, "%u\n", priv->phy_register);
+}
+
+static ssize_t
+emac_sysfs_phy_register_store(struct device *dev,
+                              struct device_attribute *attr,
+                              const char *buf,
+                              size_t count)
+{
+    struct emac_priv *priv = netdev_priv(sysfs_ndev);
+
+    unsigned long value = 0;
+    char *endp;
+
+    value = simple_strtoul(buf, &endp, 0);
+
+    if (buf != endp)
+    {
+        /* We have some valid data to write */
+        priv->phy_register = (u32)value;
+    }
+
+    return (ssize_t)count;
+}
+
+static DEVICE_ATTR(phy_register, (S_IRUGO | S_IWUGO),
+                   emac_sysfs_phy_register_show,
+                   emac_sysfs_phy_register_store);
+
+static ssize_t
+emac_sysfs_phy_register_value_show(struct device *dev,
+                                   struct device_attribute *attr,
+                                   char *buf)
+{
+    struct emac_priv *priv = netdev_priv(sysfs_ndev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    int value;
+
+    value = emac_mii_read(mii_bus,
+                          priv->phy_address,
+                          priv->phy_register);
+
+    return snprintf(buf, PAGE_SIZE, "%u\n", value);
+}
+
+static ssize_t
+emac_sysfs_phy_register_value_store(struct device *dev,
+                                    struct device_attribute *attr,
+                                    const char *buf,
+                                    size_t count)
+{
+    struct emac_priv *priv = netdev_priv(sysfs_ndev);
+    struct mii_bus *mii_bus = (struct mii_bus *)dev_get_drvdata(priv->device);
+
+    unsigned long value = 0;
+    char *endp;
+
+    value = simple_strtoul(buf, &endp, 0);
+
+    if (buf != endp)
+    {
+        emac_mii_write(mii_bus,
+                       priv->phy_address,
+                       priv->phy_register,
+                       (u16)value);
+    }
+
+    return (ssize_t)count;
+}
+
+static DEVICE_ATTR(phy_register_value, (S_IRUGO | S_IWUGO),
+                   emac_sysfs_phy_register_value_show,
+                   emac_sysfs_phy_register_value_store);
+
+/*!
+ * The group of sysfs attributes that should be added
+ * to the sysfs filesystem.
+ */
+static struct attribute *emac_sysfs_attrs[] =
+{
+    &dev_attr_1588_timer_seconds.attr,
+    &dev_attr_1588_timer_nano_seconds.attr,
+    &dev_attr_1588_timer_increment.attr,
+    &dev_attr_phy_register.attr,
+    &dev_attr_phy_register_value.attr,
+    NULL
+};
+
+/*!
+ * Add the sysfs attributes as a group
+ */
+static struct attribute_group emac_attr_group =
+{
+    .attrs = emac_sysfs_attrs
+};
+
+static int
+emac_sysfs_add(struct platform_device *pdev)
+{
+    return sysfs_create_group(&pdev->dev.kobj, &emac_attr_group);
+}
+
+static void
+emac_sysfs_remove(struct platform_device *pdev)
+{
+    sysfs_remove_group(&pdev->dev.kobj, &emac_attr_group);
+}
+
+/*
+ * MII Platform stuff
+ */
+static int
+emac_mii_probe(struct device *dev)
+{
+    struct mii_bus *new_bus;
+    int err = 0;
+    int i;
+    static int mii_irqs[PHY_MAX_ADDR];
+    int mii_bus_id = 0;
+
+    if (NULL == dev)
+        return -EINVAL;
+
+    new_bus = mdiobus_alloc();
+
+    if (NULL == new_bus) {
+        DB((LVL_ERR, "Failed to init mdiobus\n"));
+        return -ENOMEM;
+    }
+
+    new_bus->name = "pc20x MII Bus";
+    new_bus->read = &emac_mii_read;
+    new_bus->write = &emac_mii_write;
+    snprintf(new_bus->id, MII_BUS_ID_SIZE, "%x", mii_bus_id);
+
+    new_bus->priv = NULL;
+
+    /* No irqs */
+    for (i = 0; i < PHY_MAX_ADDR; ++i) {
+        mii_irqs[i] = -1;
+    }
+    new_bus->irq = mii_irqs;
+
+    new_bus->parent = dev;
+    dev_set_drvdata(dev, new_bus);
+
+    err = mdiobus_register(new_bus);
+
+    if (0 != err) {
+        printk (KERN_ERR "%s: Cannot register as MDIO bus\n", new_bus->name);
+        goto reg_map_fail;
+    }
+
+    return 0;
+
+reg_map_fail:
+    mdiobus_free(new_bus);
+
+    return err;
+}
+
+static int
+emac_mii_remove(struct device *dev)
+{
+    struct mii_bus *bus = dev_get_drvdata(dev);
+
+    mdiobus_unregister(bus);
+
+    dev_set_drvdata(dev, NULL);
+
+    kfree(bus);
+
+    return 0;
+}
+
+/*
+ * Finally, the platform/module stuff
+ */
+static int
+emac_drv_probe(struct platform_device *pdev)
+{
+    struct net_device *ndev;
+
+    int ret;
+
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+    struct resource *irq = platform_get_resource( pdev, IORESOURCE_IRQ, 0 );
+
+    if ( !mem || !irq )
+    {
+        /* Oops, we do not have valid resources */
+        printk (KERN_ERR "%s: Could not obtain platform resources.\n",
+                          CARDNAME);
+        return -EINVAL;
+    }
+
+    if (!request_mem_region(mem->start, (mem->end - mem->start) + 1, CARDNAME))
+    {
+        printk (KERN_ERR "%s: Memory mapping error, Address=0x%08x,"
+                         " Size=0x%08x\n", CARDNAME, mem->start,
+                          (mem->end - mem->start) + 1);
+        return -ENOMEM;
+    }
+
+    mem_region = ioremap(mem->start, (mem->end - mem->start) + 1);
+    if (!mem_region)
+    {
+        /* Oops, not a successful ioremap */
+        printk (KERN_ERR "%s: Could not remap io addresses.\n",
+                          CARDNAME);
+
+        ret = -ENOMEM;
+        goto out_alloc_failed;
+    }
+
+    ndev = alloc_etherdev(sizeof(struct emac_priv));
+    if (!ndev)
+    {
+        printk(KERN_ERR "%s: Could not allocate net_device structure.\n",
+                         CARDNAME);
+        ret = -ENOMEM;
+        goto out_alloc_failed;
+    }
+
+    SET_NETDEV_DEV(ndev, &pdev->dev);
+
+    ndev->dma = (unsigned char)-1;
+    ndev->irq = irq->start;
+
+    platform_set_drvdata(pdev, ndev);
+
+    emac_init(ndev, pdev);
+
+    /* Register it */
+    ret = register_netdev(ndev);
+    if (ret != 0)
+    {
+        printk("%s: Error %i registering device \"%s\"\n", CARDNAME,
+                ret, ndev->name);
+        goto out_free_netdev;
+    }
+
+    if (machine_is_pc7802())
+    {
+        /* Initislise our local copy for sysfs use */
+        sysfs_ndev = ndev;
+
+        /* Setup sysfs support */
+        ret = emac_sysfs_add(pdev);
+        if (ret)
+        {
+            /* Oops, something not right here */
+            printk(KERN_ERR "%s: failed to create sysfs device attributes\n",
+                   CARDNAME);
+        }
+    }
+
+    /* We have success */
+    printk(KERN_INFO "%s version %s loaded\n", TITLE, VERSION);
+    return 0;
+
+ out_free_netdev:
+    free_netdev(ndev);
+
+ out_alloc_failed:
+    release_mem_region (mem->start, (mem->end - mem->start) + 1);
+
+    /* We have failed in some way */
+    printk(KERN_ERR "%s: registration failed.\n", CARDNAME);
+    return ret;
+}
+
+
+static int
+emac_drv_remove(struct platform_device *pdev)
+{
+    struct net_device *ndev = platform_get_drvdata(pdev);
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+
+    platform_set_drvdata(pdev, NULL);
+
+    unregister_netdev(ndev);
+
+    /* All resources should have been released when the interface was closed */
+    free_netdev(ndev);
+
+    if (mem_region)
+    {
+        iounmap(mem_region);
+        release_mem_region (mem->start, (mem->end - mem->start) + 1);
+    }
+
+    /* Remove sysfs support */
+    emac_sysfs_remove(pdev);
+
+    return 0;
+}
+
+static struct platform_driver emac_driver =
+{
+    .probe      = emac_drv_probe,
+    .remove     = emac_drv_remove,
+    .driver     =
+    {
+        .name   = CARDNAME,
+    }
+};
+
+static struct device_driver emac_mii_driver =
+{
+    .name = "pc20x-mii",
+    .bus = &platform_bus_type,
+    .probe = emac_mii_probe,
+    .remove = emac_mii_remove,
+};
+
+static int __init
+emac_init_module(void)
+{
+    int ret;
+
+    ret = platform_driver_register(&emac_driver);
+    if (ret != 0)
+    {
+        DB((LVL_ERR, "Failed to register EMAC driver\n"));
+        goto out;
+    }
+
+    ret = driver_register(&emac_mii_driver);
+    if (ret != 0)
+    {
+        DB((LVL_ERR, "Failed to register MII driver\n"));
+        goto out_deregister_platform;
+    }
+
+    return ret;
+
+out_deregister_platform:
+    platform_driver_unregister(&emac_driver);
+
+out:
+    return ret;
+}
+
+static void __exit
+emac_cleanup_module(void)
+{
+    driver_unregister(&emac_mii_driver);
+    platform_driver_unregister(&emac_driver);
+}
+
+module_init(emac_init_module);
+module_exit(emac_cleanup_module);
+
+MODULE_AUTHOR("picoChip");
+MODULE_DESCRIPTION( "picoChip PC20x Ethernet Driver" );
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-firecracker/firecracker_reset.c b/arch/arm/mach-firecracker/firecracker_reset.c
new file mode 100644
index 0000000..e487abf
--- /dev/null
+++ b/arch/arm/mach-firecracker/firecracker_reset.c
@@ -0,0 +1,84 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ *  linux/arch/arm/mach-firecracker/firecracker_reset.c
+ *
+ * Copyright (c) 2007 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#include <linux/semaphore.h>
+#include <linux/module.h>
+#include <mach/reset.h>
+
+static void *external_reset_cookie = NULL;
+static reset_t external_reset_fn = NULL;
+static DECLARE_MUTEX(reg_lock);
+
+
+/* firecracker_reset is called from the kernel when it wishes to reset.
+ * This function will initiate a reset if an external reset handler
+ * has been registered. Typically, the CPE20X FPGA driver registers a reset
+ * handler as it is able to perform hardware resets of the board
+ */
+void firecracker_reset(char mode)
+{
+    if (!down_interruptible(&reg_lock)) {
+        if (external_reset_fn != NULL) {
+            external_reset_fn(mode, external_reset_cookie);
+        }
+        else {
+            printk(KERN_WARNING "No reset handler installed. Entering infinite loop\n");
+        }
+        up(&reg_lock);
+    }
+}
+
+/* register_reset_handler is used by drivers that want to advertise 
+ * their ability to hard reset the kernel.
+ * This is first-come-first-served. The first driver to register
+ * the reset handler is the one that will actually be used when
+ * a reset is requested.
+ * Subsequent registrations are ignored.
+ * The reset param is a finction pointer. See reset_t.
+ * The cookie is passed to the reset function when called.
+ */
+void register_reset_handler(reset_t reset, void *cookie)
+{
+    if (!down_interruptible(&reg_lock)) {
+        if (external_reset_fn == NULL) {
+            external_reset_fn = reset;
+            external_reset_cookie = cookie;
+        }
+        up(&reg_lock);
+    }
+}
+
+/* deregister_reset_handler tells the kernel that the reset handler
+ * has disappeared and it can no longer be used. The same parameters
+ * as the register_reset_handler need to be passed.
+ * If the handler was not the first to register and therefore was ignored,
+ * it will not be de registered either.
+ */
+void deregister_reset_handler(reset_t reset, void *cookie)
+{
+    if (!down_interruptible(&reg_lock)) {
+        if (external_reset_fn == reset && external_reset_cookie == cookie) {
+            external_reset_fn = NULL;
+            external_reset_cookie = NULL;
+        }
+        up(&reg_lock);
+    }
+}
+
+EXPORT_SYMBOL(firecracker_reset);
+EXPORT_SYMBOL(register_reset_handler);
+EXPORT_SYMBOL(deregister_reset_handler);
+
diff --git a/arch/arm/mach-firecracker/include/mach/debug-macro.S b/arch/arm/mach-firecracker/include/mach/debug-macro.S
new file mode 100644
index 0000000..5f74e11
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/debug-macro.S
@@ -0,0 +1,25 @@
+/* linux/include/asm-arm/arch-firecracker/debug-macro.S
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Debugging macro include header
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx,      #0xff000000
+		movne	\rx,      #0xfe000000	@ virtual base
+		orr	\rx, \rx, #0x00e40000       @ UART1
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/mach-firecracker/include/mach/dma.h b/arch/arm/mach-firecracker/include/mach/dma.h
new file mode 100644
index 0000000..531642b
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/dma.h
@@ -0,0 +1,401 @@
+/*
+ *  include/asm-arm/arch-firecracker/dma.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Description: See arch/arm/mach-firecracker/dma.c
+ *
+ * This module provides the interface to the firecracker low level DMA
+ * functionality.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+
+#ifndef __FIRECRACKER_DMA_H__
+#define __FIRECRACKER_DMA_H__
+
+
+/*
+ * This is the platform device platform_data structure
+ */
+struct plat_firecracker_dma {
+	void __iomem	*membase;	/* Virtual base pointer */
+};
+
+
+/*****************************************************************************
+3.2.5. firecracker_dma_t
+------------------------
+
+This is the context of the driver. It holds all internal state of the driver
+and is hidden from client code.
+Outside scope.
+*****************************************************************************/
+typedef struct firecracker_dma_tag *firecracker_dma_t;
+
+
+/*****************************************************************************
+3.2.1. firecracker_dma_xfr_t 
+----------------------------
+
+This is a handle representing a dma transfer. Internally it will hold a channel
+number and the state of the channel.
+*****************************************************************************/
+typedef struct firecracker_dma_xfr_tag *firecracker_dma_xfr_t;
+
+
+/*****************************************************************************
+3.2.8. firecracker_dma_list_t
+-----------------------------
+
+This is the context of a DMA multi-block list. It holds all internal state of the
+list and is hidden from client code.
+Outside scope.
+*****************************************************************************/
+typedef struct firecracker_dma_list_tag *firecracker_dma_list_t;
+
+
+/*****************************************************************************
+3.2.2.2. ahb_master_t
+This applies to the CTLx.SMS and CTLx.DMS bits. This selects the bus to use
+for transfer.
+*****************************************************************************/
+typedef enum {
+    AHB_MASTER1 = 0,
+    AHB_MASTER2 = 1,
+    AHB_MASTER3 = 2,
+    AHB_MASTER4 = 3
+} ahb_master_t;
+
+
+/*****************************************************************************
+3.2.2.3. increment_t
+This applies to the CTLx.SINC and DINC bits.
+Where an endpoint is NO_CHANGE, facilities like the scatter/gather is disabled.
+*****************************************************************************/
+typedef enum {
+    INCREMENT = 0,
+    DECREMENT = 1,
+    NO_CHANGE = 2
+} increment_t;
+
+
+/*****************************************************************************
+3.2.2.4. tr_width_t 
+This applies to the CTLx.SRC_TR_WIDTH and DST_TR_WIDTH bits. This sets the 
+transfer width of an endpoint in bits.
+*****************************************************************************/
+typedef enum {
+    TR_WIDTH8 = 0,
+    TR_WIDTH16 = 1,
+    TR_WIDTH32 = 2,
+    TR_WIDTH64 = 3,
+    TR_WIDTH128 = 4,
+    TR_WIDTH256 = 5
+} tr_width_t;
+
+
+/*****************************************************************************
+3.2.2.5. msize_t
+This applies to the CTLx.SRC_MSIZE and DST_MSIZE bits. This sets the burst
+transaction length where the number of bytes transferred in a burst is
+the transfer width x msize.
+
+3.2.2.6. Automatic setting for burst transaction.
+The Burst Transaction Length is set according to the alignment of the count
+parameter and the chosen transfer width. The burst length is chosen to minimise the
+total number of transactions, that is the number of burst transactions plus the 
+number of single transactions.
+*****************************************************************************/
+typedef enum {
+    MS_1_TRW    = 0,
+    MS_4_TRW    = 1,
+    MS_8_TRW    = 2,
+    MS_16_TRW   = 3,
+    MS_32_TRW   = 4,
+    MS_AUTO     = 5         /* See 3.2.2.6 */
+} msize_t;
+
+
+/*****************************************************************************
+3.2.3. firecracker_dma_sg_t
+---------------------------
+
+This type is used to specify the scatter/gather parameters of a channel. 
+This information is used when a transfer is set up and is used in the SGRx
+and DSRx registers. Note, these SG settings apply to the entire DMA transfer
+i.e. all blocks of a multi block transfer (where enabled).
+
+                        |                   |
+                        |                   |
+                        |-------------------|   ^
+                        |    frame 0        |   |-- count (bytes)   
+                     ^  |-------------------|   v
+         interval  --|  |                   |
+          (bytes)    |  |                   |
+                     |  |                   |
+                     |  |                   |
+                     v  |-------------------|
+                        |    frame 1        |
+                        |-------------------|
+                        |                   |
+                        |                   |
+
+
+Note the alignment of the sg_stride and sg_count settings for a transfer
+affect the automatic Burst Transaction Length settings as the hardware has
+to be set up transfer in bursts. 
+The size of the SG frame and stride between SG frames must be a multiple 
+of the Transfer Width of the endpoint. The sg_count and sg_stride will
+be truncated.
+*****************************************************************************/
+typedef struct {
+    unsigned int count;             /* Length of the SG frame in bytes */
+    unsigned int interval;          /* Number of bytes between frames */
+} firecracker_dma_sg_t;
+
+
+/*****************************************************************************
+3.2.4. firecracker_dma_handshake_t
+----------------------------------
+
+This type is used to specify the handshaking of the source or destination 
+of a DMA transfer. This data is used to setup the CFGx registers.
+If the handshaking is not setup for a transfer (by calling 
+firecracker_dma_setup_handshaking), it will default to software handshaking.
+*****************************************************************************/
+typedef struct {
+    unsigned int interface;         /* The handshaking interface to be used
+                                     * (0-3) */
+    int active_low;                 /* The polarity of the handshaking. 
+                                       TRUE for active low. */
+} firecracker_dma_handshake_t;
+
+
+/*****************************************************************************
+3.2.6. dma_int_type_t
+---------------------
+This is a bit-mask that specifies a number of interrupt types.
+A number of interrupt types are specified by OR'ing several definitions, 
+e.g. "INT_DST_TRANS | INT_ERROR | INT_SRC_TRANS" for transactions and errors.
+
+Note, the order that this enum is defined governs the order in which the 
+interrupts are serviced by the firecracker_dma_int_get_xfr function.
+
+3.2.6.1. INT_BLOCK
+This interrupt is generated on DMA block transfer completion
+to the destination peripheral.
+If this interrupt is enabled and the DMA is a multi-block type (either via
+multi-block list or auto-reloading), then DMA will wait after transferring
+each block for this interrupt to be cleared.
+
+3.2.6.2. INT_DST_TRANSACTION | INT_SRC_TRANSACTION
+These interrupts are generated on completion of the last physical bus transfer
+to/from the destination/source endpoint that concludes a transaction (single 
+or burst). Software or hardware handshaking.
+These interrupts would typically be used in software handshaking to generate
+a request for the next transaction.
+
+3.2.6.3. INT_ERROR
+This flag is set when an ERROR response is received from an AHB slave on the
+HRESP bus during a DMA transfer. In addition the transfer is cancelled and
+the channel disabled.
+
+3.2.6.4. INT_TRANSFER
+This interrupt is generated on DMA transfer completion to the destination 
+peripheral.
+
+3.2.6.5. INT_ALL
+All of the interrupt types.
+*****************************************************************************/
+typedef enum {
+    INT_BLOCK           = 1,
+    INT_DST_TRANSACTION = 2,
+    INT_ERROR           = 4,
+    INT_SRC_TRANSACTION = 8,
+    INT_TRANSFER        = 16,
+    INT_ALL             = 255
+} dma_int_type_t;
+
+
+/*****************************************************************************
+3.2.2. firecracker_dma_endpoint_t
+---------------------------------
+
+This type is used to specify a source or destination of a DMA transfer. At its
+simplest, it holds the physical address of the data buffer. This data is used 
+to configure the source/destination address and control registers 
+(SARx, DARx and CTLx). This information does not control the channel 
+configuration or scatter/gather registers (note 3). This structure is used in 
+configuring single or multi-block list type transfers as the information 
+within is used in each element of the multi-block list.
+
+
+Notes
+1.  Either the source or destination can be the flow controller or nether but 
+    not both. If nether is flow controller, the DMA is defaulted to the 
+    controller. The flow controller will control the block size transferred. If
+    a flow controller is assigned which employs hardware handshaking, 
+    the 'count' size specified by firecracker_dma_setup_direct_xfr or 
+    firecracker_dma_list_add is ignored.
+    A memory endpoint cannot be a flow controller.
+    Memory endpoint does not require handshaking (hardware or software) and will
+    proceed to transfer immediately without waiting for a transaction request.
+
+2.  If auto-reload is set for either a source or dest. direct transfer (or both),
+    the transfer will restart again at the end of the last. The transfer will be
+    one-time only if both source and destination auto_reload is false.
+    If the one of src/desc is not auto-reload, its physical address will not
+    be reloaded and will continue from where it stopped at the end of the last
+    block (continuous).
+    When applied to multi-block lists, either src or dest (but not both) can be
+    auto_reload. Only the first of a multi-block list can be set when its 
+    auto_reload flags is true. Thereafter, the endpoint must not be set in the list
+    (pass NULL to the firecracker_dma_list_add endpoint param).
+    Note, if the first element of the multi-block list is set only (subsequent
+    elements are NULL) and the first element does not set the auto_reload flag,
+    the endpoint will be in continuous mode where the physical address will
+    continue from the end of the last block.
+
+3.  The auto_reload information is set in the configuration register. This is the
+    only information passed to the config. register from this structure. Everything
+    else go's into the control reg.
+
+4.  Scatter/Gather will not be enabled unless a SG parameters are set by calling
+    firecracker_dma_setup_sg.
+
+
+*****************************************************************************/
+typedef struct firecracker_dma_endpoint_tag {
+    dma_addr_t dma_addr;            /* Physical address of the data */
+    ahb_master_t ahb_master_select; /* The interface layer used for comms */
+    int periph_not_mem;             /* TRUE if the endpoint is peripheral 
+                                       not memory */
+    int flow_controller;            /* TRUE if the endpoint is the 
+                                       flow controller */
+    int enable_sg;                  /* TRUE if Scatter/gather enabled */
+    increment_t addr_inc;           /* Increment/decrement or fixed addr */
+    tr_width_t tr_width;            /* The endpoint Transfer Width */
+    msize_t msize;                  /* The Burst Transaction size */
+    int auto_reload;                /* TRUE if auto-reload the physical 
+                                       address at end of block (note 2) */
+} firecracker_dma_endpoint_t;
+
+
+/* flag values used in the parameter to the firecracker_dma_setup_direct_xfr and
+ * firecracker_dma_setup_list_xfr
+ */
+#define CH_PRIOR_MASK               (0x0000000f)
+#define CH_PRIOR_SHIFT              (0)
+#define CH_PRIOR_0                  (0x00000000)
+#define CH_PRIOR_1                  (0x00000001)
+#define CH_PRIOR_2                  (0x00000002)
+#define CH_PRIOR_3                  (0x00000003)
+#define PROTCTL_MASK                (0x000000f0)
+#define PROTCTL_SHIFT               (4)
+#define PROTCTL_0                   (0x00000000)
+#define PROTCTL_1                   (0x00000010)
+#define PROTCTL_2                   (0x00000020)
+#define PROTCTL_3                   (0x00000030)
+#define FIFO_MODE                   (0x00000100)
+#define FC_MODE                     (0x00000200)
+
+/* Source/Destination specifiers */
+#define SRC 1
+#define DST 0
+
+
+/* DMA programming interface functions. Refer to arch/arm/mach-firecracker/dma.c for 
+ * details of these functions 
+ */
+firecracker_dma_xfr_t firecracker_dma_setup_direct_xfr(
+        firecracker_dma_t dma,
+        firecracker_dma_endpoint_t *src, firecracker_dma_endpoint_t *dst,
+        firecracker_dma_handshake_t *src_handshaking,
+        firecracker_dma_handshake_t *dst_handshaking,
+        unsigned int count, unsigned int flags, void *cookie);
+
+int firecracker_dma_start(firecracker_dma_xfr_t dma_xfr);
+
+int firecracker_dma_abort(firecracker_dma_xfr_t dma_xfr);
+
+void firecracker_dma_release(firecracker_dma_xfr_t dma_xfr);
+
+void firecracker_dma_set_debug_level(firecracker_dma_t dma, int lvl);
+
+
+firecracker_dma_list_t firecracker_dma_list_create(
+        firecracker_dma_t dma, unsigned int count);
+
+int firecracker_dma_list_add(
+        firecracker_dma_list_t list,
+        firecracker_dma_endpoint_t *src, firecracker_dma_endpoint_t *dst,
+        unsigned int count);
+
+int firecracker_dma_list_clear(firecracker_dma_list_t list);
+
+int firecracker_dma_list_destroy(firecracker_dma_list_t list);
+
+firecracker_dma_xfr_t firecracker_dma_setup_list_xfr(
+        firecracker_dma_list_t list,
+        firecracker_dma_handshake_t *src_handshaking,
+        firecracker_dma_handshake_t *dst_handshaking,
+        unsigned int flags, void *cookie);
+
+void firecracker_dma_enable_int(
+        firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types);
+
+void firecracker_dma_disable_int(
+        firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types);
+
+void firecracker_dma_clear_int(
+        firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types);
+
+firecracker_dma_xfr_t firecracker_dma_int_get_xfr(
+        firecracker_dma_t dma, dma_int_type_t *interript_type,
+        void **cookie);
+
+int firecracker_dma_handle_block_int(
+        firecracker_dma_xfr_t dma_xfr, unsigned int *blocks_left);
+
+dma_int_type_t firecracker_dma_get_raw_status(
+    firecracker_dma_xfr_t dma_xfr, dma_int_type_t int_types);
+
+int firecracker_dma_setup_sg(
+    firecracker_dma_xfr_t dma_xfr,
+    firecracker_dma_sg_t *sg, int src_dst);
+
+int firecracker_dma_request_transaction(
+        firecracker_dma_xfr_t dma_xfr, int src_dst,
+        unsigned int *bytes_left);
+
+firecracker_dma_t firecracker_dma_get_dmac_handle(int controller);
+
+void firecracker_dma_dump_regs(firecracker_dma_t dma);
+
+
+#endif /* __FIRECRACKER_DMA_H__ */
+
+
+
+
+
+
+
+
diff --git a/arch/arm/mach-firecracker/include/mach/dp83640.h b/arch/arm/mach-firecracker/include/mach/dp83640.h
new file mode 100644
index 0000000..4922e1b
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/dp83640.h
@@ -0,0 +1,95 @@
+/*
+ * arch/arm/mach-firecracker/include/dp83640.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * Description:
+ *
+ * This module provides some definitions for the National Semiconductors
+ * DP83640 Ethernet Phy.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __FIRECRACKER_DP83640_H
+#define __FIRECRACKER_DP83640_H
+
+/* PHY Register offsets
+ * Note: These registers are access over the Phy management bus
+ */
+
+/* PHY Registers  */
+#define DP83640_BASIC_MODE_CTRL_REG             (0x00)
+#define DP83640_BASIC_MODE_STATUS_REG           (0x01)
+#define DP83640_PHY_ID_1_REG                    (0x02)
+#define DP83640_PHY_ID_2_REG                    (0x03)
+#define DP83640_PHY_STATUS_REG                  (0x10)
+#define DP83640_MII_INT_CTRL_REG                (0x11)
+#define DP83640_MII_INT_STATUS_REG              (0x12)
+#define DP83640_MII_PAGE_SELECT_REG             (0x13)
+
+/* PTP 1588 Base Registers - Page 4 */
+#define DP83640_PTP_CTRL_REG                    (0x14)
+#define DP83640_PTP_TIME_DATA_REG               (0x15)
+#define DP83640_PTP_STATUS_REG                  (0x16)
+#define DP83640_PTP_TRIGGER_STATUS_REG          (0x17)
+#define DP83640_PTP_RATE_LOW_REG                (0x18)
+#define DP83640_PTP_RATE_HIGH_REG               (0x19)
+#define DP83640_PTP_PAGE4_READ_CHKSUM_REG       (0x1A)
+#define DP83640_PTP_PAGE4_WRITE_CHKSUM_REG      (0x1B)
+#define DP83640_PTP_TX_TIMESTAMP_REG            (0x1C)
+#define DP83640_PTP_RX_TIMESTAMP_REG            (0x1D)
+#define DP83640_PTP_EVENT_STATUS_REG            (0x1E)
+#define DP83640_PTP_EVENT_DATA_REG              (0x1F)
+
+/* PTP 1588 Configuration Registers - Page 5 */
+#define DP83640_PTP_TRIG_CONFIG_REG             (0x14)
+#define DP83640_PTP_EVENT_CONFIG_REG            (0x15)
+#define DP83640_PTP_TX_CONFIG_0_REG             (0x16)
+#define DP83640_PTP_TX_CONFIG_1_REG             (0x17)
+#define DP83640_PTP_STATUS_FRAMES_CONFIG_0_REG  (0x18)
+#define DP83640_PTP_RX_CONFIG_0_REG             (0x19)
+#define DP83640_PTP_RX_CONFIG_1_REG             (0x1A)
+#define DP83640_PTP_RX_CONFIG_2_REG             (0x1B)
+#define DP83640_PTP_RX_CONFIG_3_REG             (0x1C)
+#define DP83640_PTP_RX_CONFIG_4_REG             (0x1D)
+#define DP83640_PTP_TEMP_RATE_DUR_LOW_REG       (0x1E)
+#define DP83640_PTP_TEMP_RATE_DUR_HIGH_REG      (0x1F)
+
+/* PTP 1588 Configuration Registers - Page 6 */
+#define DP83640_PTP_CLK_OP_CTRL_REG             (0x14)
+#define DP83640_PTP_STATUS_FRAMES_CONFIG_1_REG  (0x15)
+#define DP83640_PTP_STATUS_FRAMES_CONFIG_2_REG  (0x16)
+#define DP83640_PTP_STATUS_FRAMES_CONFIG_3_REG  (0x17)
+#define DP83640_PTP_STATUS_FRAMES_CONFIG_4_REG  (0x18)
+#define DP83640_PTP_SFD_CONFIG_REG              (0x19)
+#define DP83640_PTP_INT_CTRL_REG                (0x1A)
+#define DP83640_PTP_CLK_SOURCE_REG              (0x1B)
+#define DP83640_PTP_ETHERNET_TYPE_REG           (0x1C)
+#define DP83640_PTP_OFFSET_REG                  (0x1D)
+#define DP83640_PTP_GPIO_MONITOR_REG            (0x1E)
+#define DP83640_PTP_RX_HASH_REG_REG             (0x1F)
+
+/* Phy Register bit field definitions */
+
+/* DP83640_MII_PAGE_SELECT_REG */
+#define DP83640_PAGE_SEL_0                      (0)
+#define DP83640_PAGE_SEL_4                      (4)
+#define DP83640_PAGE_SEL_5                      (5)
+#define DP83640_PAGE_SEL_6                      (6)
+#define DP83640_PAGE_SEL_MASK                   (0x07)
+
+/* DP83640_PTP_CTRL_REG */
+#define DP83640_PTP_RESET                       (1 << 0)
+#define DP83640_PTP_DISABLE                     (1 << 1)
+#define DP83640_PTP_ENABLE                      (1 << 2)
+#define DP83640_PTP_STEP_CLK                    (1 << 3)
+#define DP83640_PTP_LOAD_CLK                    (1 << 4)
+#define DP83640_PTP_READ_CLK                    (1 << 5)
+
+#endif /* __FIRECRACKER_DP83640_H */
diff --git a/arch/arm/mach-firecracker/include/mach/entry-macro.S b/arch/arm/mach-firecracker/include/mach/entry-macro.S
new file mode 100644
index 0000000..10c4307
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/entry-macro.S
@@ -0,0 +1,36 @@
+/*
+ * include/asm-arm/arch-firecracker/entry-macro.S
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Low-level IRQ helper macros for Firecracker platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <mach/hardware.h>
+
+                .macro  disable_fiq
+                .endm
+
+                .macro  get_irqnr_preamble, base, tmp
+                .endm
+
+                .macro  arch_ret_to_user, tmp1, tmp2
+                .endm
+
+                .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+                ldr     \base, =IO_ADDRESS(PC20X_VIC_BASE)              @ get virtual base
+                ldr     \irqstat, [\base, #VIC_STATUS_REG_OFFSET]       @ get masked status
+                mov     \irqnr, #0                                      @ Init irq number to zero
+                teq     \irqstat, #0                                    @ Test the irq status read from the VIC               
+                beq     1003f                                           @  and if zero, branch (and set the EQ flag)
+
+                clz     \irqnr, \irqstat                                @ Count leading zeros to get the irq number
+                rsb     \irqnr, \irqnr, #31                             @ irqnr = 31 - irqnr so that bit 0 is irq 0 etc.
+1003:          /* EQ will be set if we reach MAXIRQNUM */
+                .endm
+
diff --git a/arch/arm/mach-firecracker/include/mach/gpio.h b/arch/arm/mach-firecracker/include/mach/gpio.h
new file mode 100644
index 0000000..93ab4b9
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/gpio.h
@@ -0,0 +1,73 @@
+#ifndef __MACH_GPIO_H__
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define __MACH_GPIO_H__
+
+/* GPIO pin numbers are defined in linux/picochip/devices/pc202.h */
+#include <linux/picochip/devices/pc202.h>
+
+int
+gpio_is_valid( int gpio );
+
+int
+gpio_request( unsigned gpio,
+              const char *label );
+
+void
+gpio_free( unsigned gpio );
+
+int
+gpio_direction_input( unsigned gpio );
+
+int
+gpio_direction_output( unsigned gpio,
+                       int value );
+
+int
+gpio_cansleep( unsigned gpio );
+
+int
+gpio_export( unsigned gpio,
+             bool direction_may_change );
+
+int
+gpio_unexport( unsigned gpio );
+
+int
+gpio_get_value_cansleep( unsigned gpio );
+
+int
+gpio_set_value_cansleep( unsigned gpio,
+                         int value );
+
+int
+gpio_set_value( unsigned gpio,
+                int value );
+
+int
+gpio_get_value( unsigned gpio );
+
+int
+gpio_to_irq( unsigned gpio );
+
+int
+irq_to_gpio( unsigned irq );
+
+#endif /* __MACH_GPIO_H__ */
diff --git a/arch/arm/mach-firecracker/include/mach/gpio_assignment.h b/arch/arm/mach-firecracker/include/mach/gpio_assignment.h
new file mode 100644
index 0000000..abf71d2
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/gpio_assignment.h
@@ -0,0 +1,30 @@
+/* linux/include/asm-arm/arch-firecracker/gpio_assignment.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * ARM GPIO  assignments for various boards 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_GPIO_ASSIGNMENTS_H
+#define __ASM_ARCH_GPIO_ASSIGNMENTS_H __FILE__
+
+#include <mach/pc20x/gpio.h>
+
+/* CPE SPI GPIOs */
+#define ARM_GPIO_SPI_MOSI   GPIO(0)
+#define ARM_GPIO_SPI_MISO   GPIO(1)
+#define ARM_GPIO_SPI_CLK    GPIO(2)
+#define ARM_GPIO_SPI_CS0    GPIO(3)
+#define ARM_GPIO_SPI_CS1    GPIO(4)
+
+/* SVB GPIOs */
+#define ARM_GPIO_CPU_LED    GPIO(6)
+
+
+#endif /* __ASM_ARCH_GPIO_ASSIGNMENTS_H */
diff --git a/arch/arm/mach-firecracker/include/mach/hardware.h b/arch/arm/mach-firecracker/include/mach/hardware.h
new file mode 100644
index 0000000..6b75c64
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/hardware.h
@@ -0,0 +1,51 @@
+/*
+ *  linux/include/asm-arm/arch-firecracker/hardware.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ *  This file contains the hardware definitions of the Firecracker boards.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <mach/platform.h>
+
+/* Include all the firecracker IO definitions copied from the bootloader here */
+#include <mach/pc20x/pc20x.h>
+#include <mach/pc20x/gpio.h>
+#include <mach/pc20x/memif.h>
+#include <mach/pc20x/picoarray.h>
+#include <mach/pc20x/rap.h>
+#include <mach/pc20x/rtc.h>
+#include <mach/pc20x/timer.h>
+#include <mach/pc20x/uart.h>
+#include <mach/pc20x/wdt.h>
+#include <mach/pc20x/vic.h>
+#include <mach/pc20x/dma.h>
+#include <mach/pc20x/ethernet.h>
+
+/* macro to get at IO space when running virtually */
+
+/* The Virtual IO mapping for firecracker simply maps 0xffxx,xxxx to 
+ * 0xfexx,xxxx.
+ */
+#define IO_ADDRESS(x) ((x) & 0xfeffffff)
+
+#endif
diff --git a/arch/arm/mach-firecracker/include/mach/io.h b/arch/arm/mach-firecracker/include/mach/io.h
new file mode 100644
index 0000000..be83c6e
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/io.h
@@ -0,0 +1,35 @@
+/*
+ *  linux/include/asm-arm/arch-firecracker/io.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)addr;
+}
+#define __io(a)	__io(a)
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+#endif
diff --git a/arch/arm/mach-firecracker/include/mach/irqs.h b/arch/arm/mach-firecracker/include/mach/irqs.h
new file mode 100644
index 0000000..5722fcf
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/irqs.h
@@ -0,0 +1,62 @@
+/*
+ *  linux/include/asm-arm/arch-firecracker/irqs.h
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <mach/platform.h>
+
+#define IRQ_GPIO_0          0
+#define IRQ_GPIO_1          1
+#define IRQ_GPIO_2          2
+#define IRQ_GPIO_3          3
+#define IRQ_GPIO_4          4
+#define IRQ_GPIO_5          5
+#define IRQ_GPIO_6          6
+#define IRQ_GPIO_7          7
+#define IRQ_RTC             8
+#define IRQ_UART_0          9
+#define IRQ_UART_1          10
+#define IRQ_WDOG            11
+#define IRQ_TIMER_0         12
+#define IRQ_TIMER_1         13
+#define IRQ_TIMER_2         14
+#define IRQ_TIMER_3         15
+#define IRQ_PROCIF          16
+#define IRQ_DMA_1           17
+#define IRQ_DMA_2           18
+#define IRQ_DMA_REQ_0       19
+#define IRQ_DMA_REQ_1       20
+#define IRQ_DMA_REQ_2       21
+#define IRQ_DMA_REQ_3       22
+#define IRQ_PICOARRAY_DMA_0 23
+#define IRQ_PICOARRAY_DMA_1 24
+#define IRQ_PICOARRAY_DMA_2 25
+#define IRQ_PICOARRAY_DMA_3 26
+#define IRQ_PICOARRAY_GPR   27
+#define IRQ_EMAC            28
+#define IRQ_INT_GPIO        29
+#define IRQ_UNUSED_1        30
+#define IRQ_UNUSED_2        31
+
+#define NR_IRQS			    32
+
+
+
+
diff --git a/arch/arm/mach-firecracker/include/mach/memory.h b/arch/arm/mach-firecracker/include/mach/memory.h
new file mode 100644
index 0000000..80920d1
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/memory.h
@@ -0,0 +1,89 @@
+/*
+ *  linux/include/asm-arm/arch-firecracker/memory.h
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x00000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
+#define __bus_to_virt(x)	((x) + PAGE_OFFSET)
+
+#ifdef CONFIG_DISCONTIGMEM
+
+/*
+ * The nodes are the followings:
+ *
+ *   node 0: 0x0000.0000 - 0x03ff.ffff
+ *   node 1: 0x0400.0000 - 0x07ff.ffff
+ *   node 2: 0x0800.0000 - 0x0bff.ffff
+ *   node 3: 0x0c00.0000 - 0x0fff.ffff
+ */
+
+/*
+ * Given a kernel address, find the home node of the underlying memory.
+ */
+#define KVADDR_TO_NID(addr) \
+	(((unsigned long)(addr) - PAGE_OFFSET) >> NODE_MAX_MEM_SHIFT)
+
+/*
+ * Given a page frame number, convert it to a node id.
+ */
+#define PFN_TO_NID(pfn) \
+	(((pfn) - PHYS_PFN_OFFSET) >> (NODE_MAX_MEM_SHIFT - PAGE_SHIFT))
+
+/*
+ * Given a kaddr, ADDR_TO_MAPBASE finds the owning node of the memory
+ * and return the mem_map of that node.
+ */
+#define ADDR_TO_MAPBASE(kaddr)  NODE_MEM_MAP(KVADDR_TO_NID(kaddr))
+
+/*
+ * Given a page frame number, find the owning node of the memory
+ * and return the mem_map of that node.
+ */
+#define PFN_TO_MAPBASE(pfn)     NODE_MEM_MAP(PFN_TO_NID(pfn))
+
+/*
+ *  Given a kaddr, LOCAL_MEM_MAP finds the owning node of the memory
+ *  and returns the index corresponding to the appropriate page in the
+ *  node's mem_map.
+ */
+#define LOCAL_MAP_NR(addr) \
+        (((unsigned long)(addr) & (NODE_MAX_MEM_SIZE - 1)) >> PAGE_SHIFT)
+
+#define NODE_MAX_MEM_SHIFT	26
+#define NODE_MAX_MEM_SIZE	(1 << NODE_MAX_MEM_SHIFT)
+
+#endif /* CONFIG_DISCONTIGMEM */
+
+#endif
+
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/dma.h b/arch/arm/mach-firecracker/include/mach/pc20x/dma.h
new file mode 100644
index 0000000..23f172d
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/dma.h
@@ -0,0 +1,182 @@
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              DMA Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __FIRECRACKER_PC20X_DMA_H
+#define __FIRECRACKER_PC20X_DMA_H
+
+
+/* Channel register offsets from DMA base */
+#define DMA_N_SRC_ADDRESS_REG_OFFSET(__N)           (0x000 + (0x058 * (__N)))
+#define DMA_N_DST_ADDRESS_REG_OFFSET(__N)           (0x008 + (0x058 * (__N)))
+#define DMA_N_LINKED_LIST_POINTER_REG_OFFSET(__N)   (0x010 + (0x058 * (__N)))
+#define DMA_N_CONTROL_REG_OFFSET(__N)               (0x018 + (0x058 * (__N)))
+#define DMA_N_BLOCK_SIZE_REG_OFFSET(__N)            (0x01c + (0x058 * (__N)))
+#define DMA_N_LOW_CONFIGURATION_REG_OFFSET(__N)     (0x040 + (0x058 * (__N)))
+#define DMA_N_HIGH_CONFIGURATION_REG_OFFSET(__N)    (0x044 + (0x058 * (__N)))
+#define DMA_N_SRC_GATHER_REG_OFFSET(__N)            (0x048 + (0x058 * (__N)))
+#define DMA_N_DST_SCATTER_REG_OFFSET(__N)           (0x050 + (0x058 * (__N)))
+
+/* Control register bits */
+#define DMA_INT_EN                                  (1 << 0)
+#define DMA_DST_TR_WIDTH_SHIFT                      (1)
+#define DMA_DST_TR_WIDTH_MASK                       (0x7 << DMA_DST_TR_WIDTH_SHIFT)
+#define DMA_SRC_TR_WIDTH_SHIFT                      (4)
+#define DMA_SRC_TR_WIDTH_MASK                       (0x7 << DMA_SRC_TR_WIDTH_SHIFT)
+#define DMA_DINC_SHIFT                              (7)
+#define DMA_DINC_MASK                               (0x3 << DMA_DINC_SHIFT)
+#define DMA_SINC_SHIFT                              (9)
+#define DMA_SINC_MASK                               (0x3 << DMA_SINC_SHIFT)
+#define DMA_DST_MSIZE_SHIFT                         (11)
+#define DMA_DST_MSIZE_MASK                          (0x7 << DMA_DST_MSIZE_SHIFT)
+#define DMA_SRC_MSIZE_SHIFT                         (14)
+#define DMA_SRC_MSIZE_MASK                          (0x7 << DMA_SRC_MSIZE_SHIFT)
+#define DMA_SRC_GATHER_EN                           (1 << 17)
+#define DMA_DST_SCATTER_EN                          (1 << 18)
+#define DMA_TT_FC_SHIFT                             (20)
+#define DMA_TT_FC_MASK                              (0x7 << DMA_TT_FC_SHIFT)
+#define DMA_DMS_SHIFT                               (23)
+#define DMA_DMS_MASK                                (0x3 << DMA_DMS_SHIFT)
+#define DMA_SMS_SHIFT                               (25)
+#define DMA_SMS_MASK                                (0x3 << DMA_SMS_SHIFT)
+#define DMA_LLP_DST_EN                              (1 << 27)
+#define DMA_LLP_SRC_EN                              (1 << 28)
+
+/* Block size (control upper dword) bits */
+#define DMA_BLOCK_TS_SHIFT                          (0)
+#define DMA_BLOCK_TS_MASK                           (0xfff << DMA_BLOCK_TS_SHIFT)
+#define DMA_DONE                                    (1 << 12)
+
+/* Low Configuration register bits */
+#define DMA_CH_PRIOR_SHIFT                          (5)
+#define DMA_CH_PRIOR_MASK                           (0x7 << DMA_CH_PRIOR_SHIFT)
+#define DMA_CH_SUSP                                 (1 << 8)
+#define DMA_FIFO_EMPTY                              (1 << 9)
+#define DMA_HS_SEL_DST                              (1 << 10)
+#define DMA_HS_SEL_SRC                              (1 << 11)
+#define DMA_DST_HS_POL                              (1 << 18)
+#define DMA_SRC_HS_POL                              (1 << 19)
+#define DMA_MAX_ABRST_SHIFT                         (20)
+#define DMA_MAX_ABRST_MASK                          (0x3ff << DMA_MAX_ABRST_SHIFT)
+#define DMA_RELOAD_SRC                              (1 << 30)
+#define DMA_RELOAD_DST                              (1 << 31)
+
+/* High Configuration register bits */
+#define DMA_FCMODE                                  (1 << 0)
+#define DMA_FIFO_MODE                               (1 << 1)
+#define DMA_PROTCTL_SHIFT                           (2)
+#define DMA_PROTCTL_MASK                            (0x7 << DMA_PROTCTL_SHIFT)
+#define DMA_SRC_PER_SHIFT                           (7)
+#define DMA_SRC_PER_MASK                            (0xf << DMA_SRC_PER_SHIFT)
+#define DMA_DST_PER_SHIFT                           (11)
+#define DMA_DST_PER_MASK                            (0xf << DMA_DST_PER_SHIFT)
+
+/* Scatter and gather registers bits */
+#define DMA_SG_INTERVAL_SHIFT                       (0)
+#define DMA_SG_INTERVAL_MASK                        (0xfffff << DMA_SG_INTERVAL_SHIFT)
+#define DMA_SG_COUNT_SHIFT                          (20)
+#define DMA_SG_COUNT_MASK                           (0xfff << DMA_SG_COUNT_SHIFT)
+
+
+
+/* Interrupt register types - used in the following interrupt register macros
+ * eg Clear the block complete interrupt for channel 3
+ * write(DMA_IRQ_CHANNEL(3), DMA_BLOCK_COMPLETE(CLEAR))
+ */
+#define RAW                                         (0x028 * 0)
+#define STATUS                                      (0x028 * 1)
+#define MASK                                        (0x028 * 2)
+#define CLEAR                                       (0x028 * 3)
+
+/* Interrupt registers */
+#define DMA_TRANSFER_COMPLETE_REG_OFFSET(__T)       (0x2c0 + (__T))
+#define DMA_BLOCK_COMPLETE_REG_OFFSET(__T)          (0x2c8 + (__T))
+#define DMA_SRC_TRX_COMPLETE_REG_OFFSET(__T)        (0x2d0 + (__T))
+#define DMA_DST_TRX_COMPLETE_REG_OFFSET(__T)        (0x2d8 + (__T))
+#define DMA_ERROR_REG_OFFSET(__T)                   (0x2e0 + (__T))
+#define DMA_IRQ_STATUS_REG_OFFSET                   (0x360)
+
+/* Interrupt channel bits */
+#define DMA_IRQ_CHANNEL(__N)                        (1 << (__N))
+
+/* Interrupt mask channel bits */
+#define DMA_IRQ_ENABLE_CHANNEL(__N)                 (0x0101 << (__N))
+#define DMA_IRQ_DISABLE_CHANNEL(__N)                (0x0100 << (__N))
+
+/* Interrupt status bits */
+#define DMA_STATUS_TFR                              (1 << 0)
+#define DMA_STATUS_BLOCK                            (1 << 1)
+#define DMA_STATUS_SRCT                             (1 << 2)
+#define DMA_STATUS_DSTT                             (1 << 3)
+#define DMA_STATUS_ERR                              (1 << 4)
+#define DMA_STATUS_IRQ_TYPES                        (5)
+
+
+/* Software handshaking register types - used with the following handshaking
+ * register macros.
+ * For example, request a single transaction on the destination of channel 2
+ * write(DMA_REQ_CHANNEL(2), DMA_DST_TRANSACTION_REQUEST(SINGLE))
+ */
+#define BURST                                       (0x010 * 0)
+#define SINGLE                                      (0x010 * 1)
+#define LAST                                        (0x010 * 2)
+
+/* Software handshaking registers */
+#define DMA_SRC_TRX_REQUEST_REG_OFFSET(__S)         (0x368 + (__S))
+#define DMA_DST_TRX_REQUEST_REG_OFFSET(__S)         (0x370 + (__S))
+
+/* Transaction request channel bits */
+#define DMA_REQ_CHANNEL(__N)                        (0x0101 << (__N))
+
+
+/* Miscellaneous registers */
+#define DMA_CONFIGURATION_REG_OFFSET                (0x398)
+#define DMA_CHANNEL_ENABLE_REG_OFFSET               (0x3a0)
+#define DMA_ID_REG_OFFSET                           (0x3a8)
+#define DMA_TEST_REG_OFFSET                         (0x3b0)
+
+/* DMA configuration register bits */
+#define DMA_ENABLE                                  (0x01)
+
+/* Channel enable/disable bits */
+#define DMA_ENABLE_CHANNEL(__N)                     (0x0101 << (__N))
+#define DMA_DISABLE_CHANNEL(__N)                    (0x0100 << (__N))
+
+/* Four channels per controller */
+#define DMA_CHANNELS        4
+#define DMA_CHANNEL(__N)                            (0x01 << (__N))
+
+/* Four handshaking interfaces per controller */
+#define DMA_HANDSHAKING_IFS 4
+
+#endif /* __FIRECRACKER_PC20X_DMA_H */
+
+
+
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/ethernet.h b/arch/arm/mach-firecracker/include/mach/pc20x/ethernet.h
new file mode 100644
index 0000000..4bb7921
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/ethernet.h
@@ -0,0 +1,370 @@
+/*
+ *  include/asm/arch/svb20x/ethernet.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Description:
+ *
+ * This module provides the network interface to the firecracker EMAC 
+ * hardware.
+ *
+ * References:
+ *
+ * Synopsys DesignWare Ethernet Universal Databook Version 3.2 
+ *  November 2005.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * v0.01 09nov06    - Initial version
+ */
+
+#ifndef __FIRECRACKER_PC20X_ETHERNET_H
+#define __FIRECRACKER_PC20X_ETHERNET_H
+
+/* Register offsets: */
+#define EMAC_MAC_CONFIG_REG_OFFSET          (0x0000)
+#define EMAC_MAC_FRAME_FLT_REG_OFFSET       (0x0004)
+#define EMAC_MAC_HASH_HIGH_REG_OFFSET       (0x0008)
+#define EMAC_MAC_HASH_LOW_REG_OFFSET        (0x000c)
+#define EMAC_MAC_GMII_ADDR_REG_OFFSET       (0x0010)
+#define EMAC_MAC_GMII_DATA_REG_OFFSET       (0x0014)
+#define EMAC_MAC_FLOW_CONTROL_REG_OFFSET    (0x0018)
+#define EMAC_MAC_VLAN_TAG_REG_OFFSET        (0x001c)
+#define EMAC_MAC_VERSION_REG_OFFSET         (0x0020)
+#define EMAC_MAC_WAKE_FILT_REG_OFFSET       (0x0028)
+#define EMAC_MAC_PMT_REG_OFFSET             (0x002c)
+#define EMAC_MAC_ADDR_N_HIGH_REG_OFFSET(__N)(0x0040 + (0x0008 * __N))
+#define EMAC_MAC_ADDR_N_LOW_REG_OFFSET(__N) (0x0044 + (0x0008 * __N))
+
+/* Note the postfix _G means 'Good' and _GB means 'Good or Bad' */
+#define EMAC_MMC_CONTROL_OFFSET             (0x0100)
+#define EMAC_MMC_RX_INT_OFFSET              (0x0104)
+#define EMAC_MMC_TX_INT_OFFSET              (0x0108)
+#define EMAC_MMC_RX_INT_MASK_OFFSET         (0x010c)
+#define EMAC_MMC_TX_INT_MASK_OFFSET         (0x0110)
+#define EMAC_MMC_TX_BYTE_COUNT_GB           (0x0114)
+#define EMAC_MMC_TX_FRAME_COUNT_GB          (0x0118)
+#define EMAC_MMC_TX_BROAD_FRAMES_G          (0x011c)
+#define EMAC_MMC_TX_MULTI_FRAMES_G          (0x0120)
+#define EMAC_MMC_TX_64_BYTE_GB              (0x0124)
+#define EMAC_MMC_TX_65_127_BYTE_GB          (0x0128)
+#define EMAC_MMC_TX_128_255_BYTE_GB         (0x012c)
+#define EMAC_MMC_TX_256_511_BYTE_GB         (0x0130)
+#define EMAC_MMC_TX_512_1023_BYTE_GB        (0x0134)
+#define EMAC_MMC_TX_1024_MAX_BYTES_GB       (0x0138)
+#define EMAC_MMC_TX_UNICAST_FRAMES_GB       (0x013c)
+#define EMAC_MMC_TX_MULTICAST_FRAMES_GB     (0x0140)
+#define EMAC_MMC_TX_BROADCAST_FRAMES_GB     (0x0144)
+#define EMAC_MMC_TX_UNDERFLOW               (0x0148)
+#define EMAC_MMC_TX_SINGLE_COLL_G           (0x014c)
+#define EMAC_MMC_TX_MULTI_COLL_G            (0x0150)
+#define EMAC_MMC_TX_DEFERRED                (0x0154)
+#define EMAC_MMC_TX_LATE_COLL               (0x0158)
+#define EMAC_MMC_TX_EXCESS_COLL             (0x015c)
+#define EMAC_MMC_TX_CARRIER_ERR             (0x0160)
+#define EMAC_MMC_TX_BYTE_COUNT_G            (0x0164)
+#define EMAC_MMC_TX_FRAME_COUNT_G           (0x0168)
+#define EMAC_MMC_TX_EXCESS_DEF_FRAMES       (0x016c)
+#define EMAC_MMC_TX_PAUSED_FRAMES           (0x0170)
+#define EMAC_MMC_TX_VLAN_FRAMES_G           (0x0174)
+#define EMAC_MMC_RX_FRAME_COUNT_GB          (0x0180)
+#define EMAC_MMC_RX_BYTE_COUNT_GB           (0x0184)
+#define EMAC_MMC_RX_BYTE_COUNT_G            (0x0188)
+#define EMAC_MMC_RX_BROADCAST_FRAMES_G      (0x018c)
+#define EMAC_MMC_RX_MULTICAST_FRAMES_G      (0x0190)
+#define EMAC_MMC_RX_CRC_ERROR               (0x0194)
+#define EMAC_MMC_RX_ALLIGN_ERROR            (0x0198)
+#define EMAC_MMC_RX_RUNT_ERROR              (0x019c)
+#define EMAC_MMC_RX_JABBER_ERROR            (0x01a0)
+#define EMAC_MMC_RX_UNDERSIZE_G             (0x01a4)
+#define EMAC_MMC_RX_OVERSIZE_G              (0x01a8)
+#define EMAC_MMC_RX_64_BYTE_GB              (0x01ac)
+#define EMAC_MMC_RX_65_127_BYTE_GB          (0x01b0)
+#define EMAC_MMC_RX_128_255_BYTE_GB         (0x01b4)
+#define EMAC_MMC_RX_256_511_BYTE_GB         (0x01b8)
+#define EMAC_MMC_RX_512_1023_BYTE_GB        (0x01bc)
+#define EMAC_MMC_RX_1024_MAX_BYTES_GB       (0x01c0)
+#define EMAC_MMC_RX_UNICAST_FRAMES_G        (0x01c4)
+#define EMAC_MMC_RX_LENGTH_ERROR            (0x01c8)
+#define EMAC_MMC_RX_OUT_OF_RANGE            (0x01cc)
+#define EMAC_MMC_RX_PAUSE_FRAMES            (0x01d0)
+#define EMAC_MMC_RX_FIFO_OVERFLOW           (0x01d4)
+#define EMAC_MMC_RX_VLAN_FRAMES_GB          (0x01d8)
+#define EMAC_MMC_RX_WATCHDOG_ERROR          (0x01dc)
+
+#define EMAC_DMA_BUS_MODE_REG_OFFSET        (0x1000)
+#define EMAC_DMA_TX_DEMAND_REG_OFFSET       (0x1004)
+#define EMAC_DMA_RX_DEMAND_REG_OFFSET       (0x1008)
+#define EMAC_DMA_RX_LIST_REG_OFFSET         (0x100c)
+#define EMAC_DMA_TX_LIST_REG_OFFSET         (0x1010)
+#define EMAC_DMA_STATUS_REG_OFFSET          (0x1014)
+#define EMAC_DMA_MODE_REG_OFFSET            (0x1018)
+#define EMAC_DMA_IE_REG_OFFSET              (0x101c)
+#define EMAC_DMA_STATS_REG_OFFSET           (0x1020)
+#define EMAC_DMA_CURR_TX_DESC_REG_OFFSET    (0x1048)
+#define EMAC_DMA_CURR_RX_DESC_REG_OFFSET    (0x104c)
+#define EMAC_DMA_CURR_TX_BUF_REG_OFFSET     (0x1050)
+#define EMAC_DMA_CURR_RX_BUF_REG_OFFSET     (0x1054)
+
+
+/* Register bit definitions: */
+
+/* EMAC_MAC_CONFIG_REG_OFFSET bits: */
+#define EMAC_WATCHDOG_DISABLE               (1 << 23)
+#define EMAC_JABBER_DISABLE                 (1 << 22)
+#define EMAC_FRAME_BURST_ENABLE             (1 << 21)
+#define EMAC_JUMBO_FRAME_ENABLE             (1 << 20)
+#define EMAC_INTER_FRAME_GAP_SHIFT          (17)
+#define EMAC_INTER_FRAME_GAP_MASK           (0x7 << EMAC_INTER_FRAME_GAP_SHIFT)
+#define EMAC_PORT_SELECT                    (1 << 15)
+#define EMAC_SPEED_100                      (1 << 14)
+#define EMAC_DIABLE_RECEIVE_OWN             (1 << 13)
+#define EMAC_LOOP_BACK_MODE                 (1 << 12)
+#define EMAC_DUPLEX_MODE                    (1 << 11)
+#define EMAC_CHECKSUM_OFFLOAD               (1 << 10)
+#define EMAC_DISABLE_RETRY                  (1 << 9)
+#define EMAC_LINK_UP                        (1 << 8)
+#define EMAC_CRC_STRIPPING                  (1 << 7)
+#define EMAC_BACK_OFF_SHIFT                 (5)
+#define EMAC_BACK_OFF_MASK                  (0x3 << EMAC_BACK_OFF_SHIFT)
+#define EMAC_DEFERRAL_CHECK                 (1 << 4)
+#define EMAC_TX_ENABLE                      (1 << 3)
+#define EMAC_RX_ENABLE                      (1 << 2)
+
+/* EMAC_MAC_FRAME_FLT_REG_OFFSET bits: */
+#define EMAC_RECEIVE_ALL                    (1 << 31)
+#define EMAC_SOURCE_FILTER_ENABLE           (1 << 9)
+#define EMAC_SOURCE_INVERSE_FILTER          (1 << 8)
+#define EMAC_PASS_CONTROL_FRAMES_SHIFT      (6)
+#define EMAC_PASS_CONTROL_FRAMES_MASK       (0x3 << EMAC_PASS_CONTROL_FRAMES_SHIFT)
+#define EMAC_DISABLE_BROADCAST              (1 << 5)
+#define EMAC_PASS_ALL_MULTICAST             (1 << 4)
+#define EMAC_INVERSE_FILTER                 (1 << 3)
+#define EMAC_HASH_MULTICAST                 (1 << 2)
+#define EMAC_HASH_UNICAST                   (1 << 1)
+#define EMAC_PROMISCUOUS_MODE               (1 << 0)
+
+
+/* EMAC_MAC_GMII_ADDR_REG_OFFSET bits: */
+#define EMAC_GMII_ADDRESS_SHIFT             (11)
+#define EMAC_GMII_ADDRESS_MASK              (0x1f << EMAC_GMII_ADDRESS_SHIFT)
+#define EMAC_GMII_GMII_REG_SHIFT            (6)
+#define EMAC_GMII_GMII_REG_MASK             (0x1f << EMAC_GMII_GMII_REG_SHIFT)
+#define EMAC_GMII_CSR_CLOCK_SHIFT           (2)
+#define EMAC_GMII_CSR_CLOCK_MASK            (0x7 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_60_100          (0x0 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_100_150         (0x1 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_20_35           (0x2 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_35_60           (0x3 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_150_250         (0x4 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_CSR_RANGE_250_300         (0x5 << EMAC_GMII_CSR_CLOCK_SHIFT)
+#define EMAC_GMII_WRITE                     (1 << 1)
+#define EMAC_GMII_BUSY                      (1 << 0)
+
+
+/* EMAC_MAC_FLOW_CONTROL_REG_OFFSET bits: */
+#define EMAC_PAUSE_TIME_SHIFT               (16)
+#define EMAC_PAUSE_TIME_MASK                (0xffff << EMAC_PAUSE_TIME_SHIFT)
+#define EMAC_PAUSE_LOW_THRESHOLD_SHIFT      (4)
+#define EMAC_PAUSE_LOW_THRESHOLD_MASK       (0x3 << EMAC_PAUSE_LOW_THRESHOLD_SHIFT)
+#define EMAC_UNI_PAUSE_DETECT               (1 << 3)
+#define EMAC_RX_FLOW_ENABLE                 (1 << 2)
+#define EMAC_TX_FLOW_ENABLE                 (1 << 1)
+#define EMAC_FLOW_BUSY                      (1 << 0)
+
+
+/* EMAC_MAC_ADDR_N_HIGH_REG_OFFSET bits: */
+#define EMAC_MAC_ADDR_ENABLE                (1 << 31)
+#define EMAC_MAC_ADDR_SOURCE                (1 << 30)
+#define EMAC_MAC_ADDR_MASK_CNTL_SHIFT       (24)
+#define EMAC_MAC_ADDR_MASK_CNTL_MASK        (0x3f << EMAC_MAC_ADDR_MASK_CNTL_SHIFT)
+
+
+/* EMAC_MMC_CONTROL_OFFSET bits: */
+#define EMAC_MMC_CNTL_RESET_ON_READ         (1 << 2)
+#define EMAC_MMC_CNTL_STOP_ROLLOVER         (1 << 1)
+#define EMAC_MMC_CNTL_RESET_COUNTERS        (1 << 0)
+
+/* EMAC_MMC_RX_INT_MASK_OFFSET and EMAC_MMC_TX_INT_MASK_OFFSET bits: */
+#define EMAC_MMC_INT_ALL                    (0xffffffff)
+
+/* EMAC_DMA_BUS_MODE_REG_OFFSET bits: */
+#define EMAC_FIXED_BURST                    (1 << 16)
+#define EMAC_PRIORITY_RATIO_SHIFT           (14)
+#define EMAC_PRIORITY_RATIO_MASK            (0x3 << EMAC_PRIORITY_RATIO_SHIFT)
+#define EMAC_BURST_LENGTH_SHIFT             (8)
+#define EMAC_BURST_LENGTH_MASK              (0x3f << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_1                 (0x1 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_2                 (0x2 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_4                 (0x4 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_8                 (0x8 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_16                (0x10 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_BURST_LENGTH_32                (0x20 << EMAC_BURST_LENGTH_SHIFT)
+#define EMAC_DMA_SKIP_SHIFT                 (2)
+#define EMAC_DMA_SKIP_MASK                  (0x0000007c)
+#define EMAC_DMA_ARBITRATION                (1 << 1)
+#define EMAC_SOFT_RESET                     (1 << 0)
+
+/* EMAC_DMA_STATUS_REG_OFFSET bits: */
+#define EMAC_GMAC_PMT_INT                   (1 << 28)
+#define EMAC_GMAC_MMC_INT                   (1 << 27)
+#define EMAC_GMAC_LINE_IF_INT               (1 << 26)
+#define EMAC_BUS_ERROR_SHIFT                (23)
+#define EMAC_BUS_ERROR_MASK                 (0x7 << EMAC_BUS_ERROR_SHIFT)
+#define EMAC_DMA_TX_STATE_SHIFT             (20)
+#define EMAC_DMA_TX_STATE_MASK              (0x7 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_STOPPED                 (0x0 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_FETCHING                (0x1 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_WAITING                 (0x2 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_READING                 (0x3 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_SUSPENDED               (0x6 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_TX_RUNNING                 (0x7 << EMAC_DMA_TX_STATE_SHIFT)
+#define EMAC_DMA_RX_STATE_SHIFT             (17)
+#define EMAC_DMA_RX_STATE_MASK              (0x7 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_STOPPED                 (0x0 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_FETCHING                (0x1 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_WAITING                 (0x3 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_SUSPENDED               (0x4 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_CLOSING                 (0x5 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_DMA_RX_TRANSFERRING            (0x7 << EMAC_DMA_RX_STATE_SHIFT)
+#define EMAC_NORMAL_SUMM_INT                (1 << 16)
+#define EMAC_ABNORMAL_SUMM_INT              (1 << 15)
+#define EMAC_EARLY_RX_INT                   (1 << 14)
+#define EMAC_FATAL_BUS_ERROR_INT            (1 << 13)
+#define EMAC_EARLY_TX_INT                   (1 << 10)
+#define EMAC_RX_TIMEOUT_INT                 (1 << 9)
+#define EMAC_RX_STOPPED_INT                 (1 << 8)
+#define EMAC_RX_UNAVAILABLE_INT             (1 << 7)
+#define EMAC_RX_INT                         (1 << 6)
+#define EMAC_TX_UNDERFLOW_INT               (1 << 5)
+#define EMAC_RX_OVERFLOW_INT                (1 << 4)
+#define EMAC_TX_JABBER_TIMEOUT_INT          (1 << 3)
+#define EMAC_TX_UNAVAILABLE_INT             (1 << 2)
+#define EMAC_TX_STOPPED_INT                 (1 << 1)
+#define EMAC_TX_INT                         (1 << 0)
+
+
+/* EMAC_DMA_MODE_REG_OFFSET bits: */
+#define EMAC_STORE_FORWARD                  (1 << 21)
+#define EMAC_FLUSH_TX_FIFO                  (1 << 20)
+#define EMAC_TX_THRESHOLD_SHIFT             (14)
+#define EMAC_TX_THRESHOLD_MASK              (0x7 << EMAC_TX_THRESHOLD_SHIFT)
+#define EMAC_START_TX                       (1 << 13)
+#define EMAC_FC_DEACTIVE_SHIFT              (11)
+#define EMAC_FC_DEACTIVE_MASK               (0x3 << EMAC_FC_DEACTIVE_SHIFT)
+#define EMAC_FC_ACTIVE_SHIFT                (9)
+#define EMAC_FC_ACTIVE_MASK                 (0x3 << EMAC_FC_ACTIVE_SHIFT)
+#define EMAC_ENABLE_FLOW_CONTROL            (1 << 8)
+#define EMAC_FORWARD_ERROR_FRAMES           (1 << 7)
+#define EMAC_FORWARD_UNDERSIZE_FRAMES       (1 << 6)
+#define EMAC_RX_THRESHOLD_CONTROL_SHIFT     (1 << 3)
+#define EMAC_RX_THRESHOLD_CONTROL_MASK      (0x3 << EMAC_RX_THRESHOLD_CONTROL_SHIFT)
+#define EMAC_OPERATE_ON_SECOND_FRAME        (1 << 2)
+#define EMAC_START_RX                       (1 << 1)
+
+
+/* EMAC_DMA_IE_REG_OFFSET bits: */
+#define EMAC_NORMAL_SUMM_IE                 (1 << 16)
+#define EMAC_ABNORMAL_SUMM_IE               (1 << 15)
+#define EMAC_EARLY_RX_IE                    (1 << 14)
+#define EMAC_FATAL_BUS_ERROR_IE             (1 << 13)
+#define EMAC_EARLY_TX_IE                    (1 << 10)
+#define EMAC_RX_TIMEOUT_IE                  (1 << 9)
+#define EMAC_RX_STOPPED_IE                  (1 << 8)
+#define EMAC_RX_UNAVAILABLE_IE              (1 << 7)
+#define EMAC_RX_IE                          (1 << 6)
+#define EMAC_TX_UNDERFLOW_IE                (1 << 5)
+#define EMAC_RX_OVERFLOW_IE                 (1 << 4)
+#define EMAC_TX_JABBER_IE                   (1 << 3)
+#define EMAC_TX_UNAVAILABLE_IE              (1 << 2)
+#define EMAC_TX_STOPPED_IE                  (1 << 1)
+#define EMAC_TX_IE                          (1 << 0)
+
+
+/* EMAC_DMA_STATS_REG_OFFSET bits: */
+#define EMAC_OVERFLOW_FIFO_OVERFLOW         (1 << 28)
+#define EMAC_FIFO_OVERFLOW_SHIFT            (17)
+#define EMAC_FIFO_OVERFLOW_MASK             (0x7ff << EMAC_FIFO_OVERFLOW_SHIFT)
+#define EMAC_OVERFLOW_MISSED_FRAMES         (1 << 16)
+#define EMAC_MISSED_FRAMES_SHIFT            (0)
+#define EMAC_MISSED_FRAMES_MASK             (0xffff << EMAC_MISSED_FRAMES_SHIFT)
+
+
+
+/* Descriptor fields: */
+
+/* Transmit/Receive Status: */
+#define EMAC_DESC_STATUS_OWNER              (0x80000000)
+#define EMAC_DESC_STATUS_ERR_SUM            (0x00008000)
+
+/* Transmit Status word: */
+#define EMAC_TX_DESC_STATUS_JABBER_TO       (0x00004000)
+#define EMAC_TX_DESC_STATUS_FLUSHED         (0x00002000)
+#define EMAC_TX_DESC_STATUS_LOSS_CARRIER    (0x00000800)
+#define EMAC_TX_DESC_STATUS_NC              (0x00000400)
+#define EMAC_TX_DESC_STATUS_LC              (0x00000200)
+#define EMAC_TX_DESC_STATUS_EC              (0x00000100)
+#define EMAC_TX_DESC_STATUS_VLAN            (0x00000080)
+#define EMAC_TX_DESC_STATUS_CC_SHIFT        (3)
+#define EMAC_TX_DESC_STATUS_CC_MASK         (0x00000078)
+#define EMAC_TX_DESC_STATUS_ED              (0x00000004)
+#define EMAC_TX_DESC_STATUS_UF              (0x00000002)
+#define EMAC_TX_DESC_STATUS_DB              (0x00000001)
+
+/* Receive Status word: */
+#define EMAC_RX_DESC_STATUS_FAIL_DST_ADDR   (0x40000000)
+#define EMAC_RX_DESC_STATUS_FLEN_SHIFT      (16)
+#define EMAC_RX_DESC_STATUS_FLEN_MASK       (0x3fff0000)
+#define EMAC_RX_DESC_STATUS_DESC_ERR        (0x00004000)
+#define EMAC_RX_DESC_STATUS_FAIL_SRC_ADDR   (0x00002000)
+#define EMAC_RX_DESC_STATUS_LEN_ERR         (0x00001000)
+#define EMAC_RX_DESC_STATUS_OV_ERR          (0x00000800)
+#define EMAC_RX_DESC_STATUS_VLAN            (0x00000400)
+#define EMAC_RX_DESC_STATUS_FIRST_DESC      (0x00000200)
+#define EMAC_RX_DESC_STATUS_LAST_DESC       (0x00000100)
+#define EMAC_RX_DESC_STATUS_IPC_ERR         (0x00000080)
+#define EMAC_RX_DESC_STATUS_LATE_COL        (0x00000040)
+#define EMAC_RX_DESC_STATUS_FRAME_TYPE      (0x00000020)
+#define EMAC_RX_DESC_STATUS_WDT_TIMEOUT     (0x00000010)
+#define EMAC_RX_DESC_STATUS_RX_ERR          (0x00000008)
+#define EMAC_RX_DESC_STATUS_DRIBBLE_ERR     (0x00000004)
+#define EMAC_RX_DESC_STATUS_CRC_ERR         (0x00000002)
+#define EMAC_RX_DESC_STATUS_DST_MATCH_MAC0  (0x00000001)
+
+/* Transmit/Receive Control word: */
+#define EMAC_RX_DESC_CNTL_DISABLE_INT_COM   (0x80000000)    /* Rx only */
+#define EMAC_TX_DESC_CNTL_ENABLE_INT_COM    (0x80000000)    /* Tx only */
+#define EMAC_TX_DESC_CNTL_LAST_SEG          (0x40000000)    /* Tx only */
+#define EMAC_TX_DESC_CNTL_FIRST_SEG         (0x20000000)    /* Tx only */
+#define EMAC_TX_DESC_CNTL_DISABLE_CRC       (0x04000000)    /* Tx only */
+#define EMAC_DESC_CNTL_END_RING             (0x02000000)
+#define EMAC_DESC_CNTL_CHAINED              (0x01000000)
+#define EMAC_TX_DESC_CNTL_DISABLE_PAD       (0x00800000)    /* Tx only */
+#define EMAC_DESC_CNTL_TBS2_SHIFT           (11)
+#define EMAC_DESC_CNTL_TBS2_MASK            (0x003ff800)
+#define EMAC_DESC_CNTL_TBS1_SHIFT           (0)
+#define EMAC_DESC_CNTL_TBS1_MASK            (0x000007ff)
+
+/* EMAC_MAX_MAC_ADDRS defines the number of perfect match addresses
+ * available.
+ */
+#define EMAC_MAX_MAC_ADDRS                      (16)
+
+
+#endif /* __FIRECRACKER_PC20X_ETHERNET_INCLUDED */
+
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/gpio.h b/arch/arm/mach-firecracker/include/mach/pc20x/gpio.h
new file mode 100644
index 0000000..5d84ab7
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/gpio.h
@@ -0,0 +1,54 @@
+/* Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC202_GPIO_H
+#define PC202_GPIO_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define GPIO_SW_PORT_A_DR_REG_OFFSET        0x00    /*; Port A Data Register */
+#define GPIO_SW_PORT_A_DDR_REG_OFFSET	    0x04    /*; Port A Data Direction Register */
+#define GPIO_SW_PORT_A_CTL_REG_OFFSET       0x08    /*; Port A Data Source */
+
+/* global GPIO registers */
+#define GPIO_INT_EN_REG_OFFSET              0x30    /*; Interrupt enable */
+#define GPIO_INT_MASK_REG_OFFSET            0x34    /*; Interrupt mask */
+#define GPIO_INT_TYPE_LEVEL_REG_OFFSET 	    0x38    /*; Interrupt level */
+#define GPIO_INT_POLARITY_REG_OFFSET 	    0x3c    /*; Interrupt polarity */
+
+#define GPIO_INT_STATUS_REG_OFFSET	    0x40    /*; Interrupt status */
+#define GPIO_RAW_INT_STATUS_REG_OFFSET	    0x44    /*; Raw interrupt status */
+
+/* no debounce */
+#define GPIO_PORT_A_EOI_REG_OFFSET          0x4c    /*; Clear interrupt */
+#define GPIO_EXT_PORT_A_REG_OFFSET          0x50    /*; Value of External pins Port A */
+
+#define GPIO_LS_SYNC_REG_OFFSET		    0x60    /*; Synchronization level */
+#define GPIO_ID_CODE_REG_OFFSET		    0x64    /*; GPIO ID code */
+#define GPIO_RESERVED_REG_OFFSET            0x68    /*; reserved */
+#define GPIO_COMP_VERSION_REG_OFFSET	    0x6c    /*; GPIO Component Version */
+
+/* Bit definitions */
+#define GPIO(__N)                           (0x01 << (__N))
+
+#endif /* PC202_GPIO_H */
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/memif.h b/arch/arm/mach-firecracker/include/mach/pc20x/memif.h
new file mode 100644
index 0000000..a03bfe9
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/memif.h
@@ -0,0 +1,111 @@
+
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Memory Interface Register Definitions
+ *
+ *****************************************************************************/ 
+#ifndef __FIRECRACKER_PC20X_MEMIF_H
+#define __FIRECRACKER_PC20X_MEMIF_H
+
+#define MEMIF_PASD_BUFFER0_SETUP_REG_OFFSET                (0x0000 * 2)
+#define MEMIF_PASD_BUFFER0_ADDRESS_SETUP_REG_OFFSET        (0x0001 * 2)
+#define MEMIF_PASD_BUFFER0_FIFO_SETUP_REG_OFFSET           (0x0002 * 2)
+#define MEMIF_PASD_BUFFER1_SETUP_REG_OFFSET                (0x0004 * 2)
+#define MEMIF_PASD_BUFFER1_ADDRESS_SETUP_REG_OFFSET        (0x0005 * 2)
+#define MEMIF_PASD_BUFFER1_FIFO_SETUP_REG_OFFSET           (0x0006 * 2)
+#define MEMIF_PASD_BUFFER2_SETUP_REG_OFFSET                (0x0008 * 2)
+#define MEMIF_PASD_BUFFER2_ADDRESS_SETUP_REG_OFFSET        (0x0009 * 2)
+#define MEMIF_PASD_BUFFER2_FIFO_SETUP_REG_OFFSET           (0x000A * 2)
+#define MEMIF_PASD_BUFFER3_SETUP_REG_OFFSET                (0x000C * 2)
+#define MEMIF_PASD_BUFFER3_ADDRESS_SETUP_REG_OFFSET        (0x000D * 2)
+#define MEMIF_PASD_BUFFER3_FIFO_SETUP_REG_OFFSET           (0x000E * 2)
+#define MEMIF_PAS_BUFFER0_SETUP_REG_OFFSET                 (0x0010 * 2)
+#define MEMIF_PAS_BUFFER0_ADDRESS_SETUP_REG_OFFSET         (0x0011 * 2)
+#define MEMIF_PAS_BUFFER0_FIFO_SETUP_REG_OFFSET            (0x0012 * 2)
+#define MEMIF_PAS_BUFFER1_SETUP_REG_OFFSET                 (0x0014 * 2)
+#define MEMIF_PAS_BUFFER1_ADDRESS_SETUP_REG_OFFSET         (0x0015 * 2)
+#define MEMIF_PAS_BUFFER1_FIFO_SETUP_REG_OFFSET            (0x0016 * 2)
+#define MEMIF_SDRAM_ARB_GROUP0_SLOTA_CONFIG_REG_OFFSET     (0x0020 * 2)
+#define MEMIF_SDRAM_ARB_GROUP0_SLOTB_CONFIG_REG_OFFSET     (0x0021 * 2)
+#define MEMIF_SDRAM_ARB_GROUP1_SLOTA_CONFIG_REG_OFFSET     (0x0022 * 2)
+#define MEMIF_SDRAM_ARB_GROUP1_SLOTB_CONFIG_REG_OFFSET     (0x0023 * 2)
+#define MEMIF_SDRAM_ARB_GROUP2_SLOTA_CONFIG_REG_OFFSET     (0x0024 * 2)
+#define MEMIF_SDRAM_ARB_GROUP2_SLOTB_CONFIG_REG_OFFSET     (0x0025 * 2)
+#define MEMIF_SDRAM_ARB_GROUP3_SLOTA_CONFIG_REG_OFFSET     (0x0026 * 2)
+#define MEMIF_SDRAM_ARB_GROUP3_SLOTB_CONFIG_REG_OFFSET     (0x0027 * 2)
+#define MEMIF_SDRAM_ARB_GROUP4_SLOTA_CONFIG_REG_OFFSET     (0x0028 * 2)
+#define MEMIF_SDRAM_ARB_GROUP4_SLOTB_CONFIG_REG_OFFSET     (0x0029 * 2)
+#define MEMIF_SDRAM_ARB_GROUP5_SLOTA_CONFIG_REG_OFFSET     (0x002A * 2)
+#define MEMIF_SDRAM_ARB_GROUP5_SLOTB_CONFIG_REG_OFFSET     (0x002B * 2)
+#define MEMIF_SDRAM_ARB_GROUP6_SLOTA_CONFIG_REG_OFFSET     (0x002C * 2)
+#define MEMIF_SDRAM_ARB_GROUP6_SLOTB_CONFIG_REG_OFFSET     (0x002D * 2)
+#define MEMIF_SDRAM_ARB_GROUP7_SLOTA_CONFIG_REG_OFFSET     (0x002E * 2)
+#define MEMIF_SDRAM_ARB_GROUP7_SLOTB_CONFIG_REG_OFFSET     (0x002F * 2)
+#define MEMIF_SDRAM_ARB_VALID_GROUPS_CONFIG_REG_OFFSET     (0x0030 * 2)
+#define MEMIF_SRAM_ARB_SLOTA_CONFIG_REG_OFFSET             (0x0040 * 2)
+#define MEMIF_SRAM_ARB_SLOTB_CONFIG_REG_OFFSET             (0x0041 * 2)
+#define MEMIF_SRAM_ARB_SLOTC_CONFIG_REG_OFFSET             (0x0042 * 2)
+#define MEMIF_SRAM_ARB_VALID_SLOTS_CONFIG_REG_OFFSET       (0x0043 * 2)
+#define MEMIF_ARB_UPDATE_REG_OFFSET                        (0x004F * 2)
+#define MEMIF_SDRAM_SETUP_REG_OFFSET                       (0x0050 * 2)
+#define MEMIF_SDRAM_REFRESH_RATE_REG_OFFSET                (0x0051 * 2)
+#define MEMIF_SDRAM_MRS_REG_OFFSET                         (0x0052 * 2)
+#define MEMIF_SDRAM_ERS_REG_OFFSET                         (0x0053 * 2)
+#define MEMIF_SDRAM_SETUP_COMPLETE_REG                     (0x0054 * 2)
+#define MEMIF_SRAM_SETUP_COMPLETE_REG                      (0x0055 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT0_MASTERS03_REG_OFFSET  (0x0060 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT0_MASTERS46_REG_OFFSET  (0x0061 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT1_MASTERS03_REG_OFFSET  (0x0062 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT1_MASTERS46_REG_OFFSET  (0x0063 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT2_MASTERS03_REG_OFFSET  (0x0064 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT2_MASTERS46_REG_OFFSET  (0x0065 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT3_MASTERS03_REG_OFFSET  (0x0066 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT3_MASTERS46_REG_OFFSET  (0x0067 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT4_MASTERS03_REG_OFFSET  (0x0068 * 2)
+#define MEMIF_AHB_ARB_PRIORITY_PORT4_MASTERS46_REG_OFFSET  (0x0069 * 2)
+#define MEMIF_AHB_ARBITRATION_SCHEME_REG_OFFSET            (0x006A * 2)
+#define MEMIF_TEST_MODE_ENABLE_REG_OFFSET                  (0x0070 * 2)
+#define MEMIF_TEST_MODE_WRITE_DATA_REG_OFFSET              (0x0071 * 2)
+#define MEMIF_TEST_MODE_ADDRESS_REG_OFFSET                 (0x0072 * 2)
+#define MEMIF_TEST_MODE_ADDRESS2_REG_OFFSET                (0x0073 * 2)
+#define MEMIF_TEST_MODE_CONTROL_REG_OFFSET                 (0x0074 * 2)
+#define MEMIF_TEST_MODE_READ_DATA_REG_OFFSET               (0x0075 * 2)
+#define MEMIF_PA_BUFFER_STATUS_REG_OFFSET                  (0x0080 * 2)
+
+#define SDRAM_REFRESH_COUNT                                 0x0600
+#define SDRAM_WRGAP7                                       (0x7 << 7)
+#define SDRAM_RWGAP4                                       (0x4 << 3)
+#define SDRAM_WIDTH32                                       0x0000
+#define SDRAM_WIDTH16                                      (0x1 << 2)
+#define SDRAM_SIZE14_R10C                                   0x0000
+#define SDRAM_SIZE13_R10C                                   0x0001
+#define SDRAM_SIZE13_R9C                                    0x0010
+#define SDRAM_CAPTURE_DELAY	                                0x2000
+
+#endif /* __FIRECRACKER_PC20X_MEMIF_H */
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/pc20x.h b/arch/arm/mach-firecracker/include/mach/pc20x/pc20x.h
new file mode 100644
index 0000000..a47b313
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/pc20x.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem Peripherals Base Addresses
+ *
+ *****************************************************************************/
+#ifndef __FIRECRACKER_PC20X_H
+#define __FIRECRACKER_PC20X_H
+
+#define PC20X_PERIPH_BASE       0xffe00000
+#define PC20X_PERIPH_LENGTH     0x00200000
+
+#define PC20X_MEM_IF_BASE       0xffe00000
+#define PC20X_EBI_BASE          0xffe20000
+#define PC20X_UART1_BASE        0xffe40000
+#define PC20X_UART2_BASE        0xffe50000
+#define PC20X_TIMERS_BASE       0xffe60000
+#define PC20X_WDOG_BASE         0xffe70000
+#define PC20X_GPIO_BASE         0xffe80000
+#define PC20X_RTC_CLK_BASE      0xffe90000
+#define PC20X_REMAP_BASE        0xffea0000
+#define PC20X_AHB_2_PICO_BASE   0xffec0000
+#define PC20X_DMAC1_BASE        0xfff00000
+#define PC20X_DMAC2_BASE        0xfff10000
+#define PC20X_EMAC_BASE         0xfff60000
+#define PC20X_PROCIF_BASEP      0xfffc0000
+#define PC20X_GPIO_BASE         0xffe80000
+#define PC02X_CHIP_CONTROL      0xffff03fc
+#define PC20X_VIC_BASE          0xfffffc00
+
+#endif /* __FIRECRACKER_PC20X_H */
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/picoarray.h b/arch/arm/mach-firecracker/include/mach/pc20x/picoarray.h
new file mode 100644
index 0000000..ae3ac88
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/picoarray.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              picoArray Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __FIRECRACKER_PC20X_PICOARRAY_H
+#define __FIRECRACKER_PC20X_PICOARRAY_H
+
+/* Register address offsets from picoArray Base */
+
+/* DMA 0 to 3 available */
+#define PICO_DMA_N_CONFIG_REG_OFFSET(__N)		        (0x00 + 0x0c * (__N))
+#define PICO_DMA_N_STATUS_REG_OFFSET(__N)               (0x04 + 0x0c * (__N))
+#define PICO_DMA_N_DATAREGOFFSET(__N)                   (0x08 + 0x0c * (__N))
+
+/* GPR 0 to 24 available */
+#define PICO_GPR_N_CONFIG_REG_OFFSET(__N)               (0x30 + 0x0c * (__N))
+#define PICO_GPR_N_STATUS_REG_OFFSET(__N)               (0x34 + 0x0c * (__N))
+#define PICO_GPR_N_DATA_REG_OFFSET(__N)                 (0x38 + 0x0c * (__N))
+
+/* ID registers */
+#define PICO_GPR25_CONFIGID_REG_OFFSET                  (0x15c)
+#define PICO_GPR25_STATUSID_REG_OFFSET                  (0x160)
+#define PICO_GPR25_DATAID_REG_OFFSET                    (0x164)
+
+/* Interrupt status */
+/************* TODO - The data sheet is incomplete. Unknown address **********/
+#define PICO_INTERRUPT_STATUS_REG_OFFSET                (0x00)  /* TODO Not correct! */   
+
+/* PicoDmaNConfigRegOffset bit definitions. The watermark value can be 0 to 64 */
+#define PICO_DMA_INTERRUPT_ENABLE                       (0x00000001)
+#define PICO_DMA_ENABLE                                 (0x00000002)
+#define PICO_DMA_FIFO_WATERMARK_MASK                    (0x000001fc)
+#define PICO_DMA_FIFO_WATERMARK_N(__N)                  (__N << 2)
+
+/* PicoGprNConfigRegOffset bit definitions. */
+#define PICO_GPR_INTERRUPT_ENABLE                       (0x00000001)
+
+/* PicoDmaNStatusRegOffset bit definitions */
+#define PICO_DMA_SIGNAL_ENABLE                          (0x00000001)
+#define PICO_DMA_SIGNAL_DIRECTION                       (0x00000002)
+#define PICO_DMA_SIGNAL_BLOCKING                        (0x00000004)
+#define PICO_DMA_STATE                                  (0x00000008)
+#define PICO_DMA_FIFO_LEVEL                             (0x000007f0)
+#define PICO_DMA_FIFO_SINGLE                            (0x00000800)
+
+/* PicoGprNStatusRegOffset bit definitions */
+#define PICO_GPR_SIGNAL_ENABLE                          (0x00000001)
+#define PICO_GPR_SIGNAL_DIRECTION                       (0x00000002)
+#define PICO_GPR_SIGNAL_BLOCKING                        (0x00000004)
+#define PICO_GPR_STATE                                  (0x00000008)
+
+/* PicoInterruptStatusRegOffset bit definitions */
+#define PICO_DMA_N_INTERRUPT_STATUS(__N)                (0x00000001 << __N)
+#define PICO_GPR_N_INTERRUPT_STATUS(__N)                (0x00000010 << __N)
+
+
+#endif /* __FIRECRACKER_PC20X_PICOARRAY_H */
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/rap.h b/arch/arm/mach-firecracker/include/mach/pc20x/rap.h
new file mode 100644
index 0000000..332bfbc
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/rap.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Remap Block Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __FIRECRACKER_PC20X_RAP_H
+#define __FIRECRACKER_PC20X_RAP_H
+
+
+#define RAP_PAUSE_MODE_REG_OFFSET        0x00
+#define RAP_ID_CODE_REG_OFFSET           0x04
+#define RAP_REMAP_MODE_REG_OFFSET        0x08
+#define RAP_RESET_STATUS_REG_OFFSET      0x0c
+#define RAP_RESET_STATUS_CLR_OFFSET      0x10
+#define RAP_COMP_VERSION_OFFSET          0x14
+
+#define RAP_ID_CODE_VALUE                0x00000000
+
+#define RAP_RESET_STATUS_SOFT_IDX        0
+#define RAP_RESET_STATUS_WDOG_IDX        1
+#define RAP_RESET_STATUS_GLBL_IDX        2
+
+#define RAP_RESET_STATUS_SOFT_MASK      (1 << RAP_RESET_STATUS_SOFT_IDX)
+#define RAP_RESET_STATUS_WDOG_MASK      (1 << RAP_RESET_STATUS_WDOG_IDX)
+#define RAP_RESET_STATUS_GLBL_MASK      (1 << RAP_RESET_STATUS_GLBL_IDX)
+
+#define RAP_PAUSE_MODE_REG_RESET         0x00000000
+#define RAP_ID_CODE_REG_RESET            RAP_ID_CODE_VALUE
+#define RAP_REMAP_MODE_REG_RESET         0x00000000
+#define RAP_RESET_STATUS_REG_RESET       0x00000000
+#define RAP_RESET_STATUS_CLR_RESET       0x00000000
+#define RAP_COMP_VERSION_RESET           0x3230322b
+
+#define REMAP_NORMAL_MODE                0x00000001
+
+#endif /* __FIRECRACKER_PC20X_RAP_H */
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/rtc.h b/arch/arm/mach-firecracker/include/mach/pc20x/rtc.h
new file mode 100644
index 0000000..29d8d3b
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/rtc.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Real Time Clock Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __FIRECRACKER_PC20X_RTC_H
+#define __FIRECRACKER_PC20X_RTC_H
+
+/* Register address offsets from RTC Base */
+#define RTC_CURRECT_COUNTER_VALUE_REG_OFFSET     (0x00)
+#define RTC_COUNTER_MATCH_REG_OFFSET             (0x04)
+#define RTC_COUNTER_LOAD_REG_OFFSET              (0x08)
+#define RTC_COUNTER_CONTROL_REG_OFFSET           (0x0c)
+#define RTC_INTERRUPT_STATUS_REG_OFFSET          (0x10)
+#define RTC_RAW_INTERRUPT_STATUS_REG_OFFSET      (0x14)
+#define RTC_INTERRUPT_EOI_REG_OFFSET             (0x18)
+#define RTC_COMPONENT_VERSION_REG_OFFSET         (0x1c)
+
+/* RtcCounterControlRegOffset bit definitions */
+#define INTERRUPT_ENABLE                         (0x01)
+#define INTERRUPT_MASK                           (0x02)
+
+/* Interrupt bits */
+#define RTC_INTERRUPT                            (0x01)
+
+
+#endif /* __FIRECRACKER_PC20X_RTC_H */
+
+
+
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/timer.h b/arch/arm/mach-firecracker/include/mach/pc20x/timer.h
new file mode 100644
index 0000000..7a03395
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/timer.h
@@ -0,0 +1,64 @@
+
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Timer Register Definitions
+ *
+ *****************************************************************************/ 
+#ifndef __FIRECRACKER_PC20X_TIMER_H
+#define __FIRECRACKER_PC20X_TIMER_H
+
+/* The number of timers in the hardware, numbered 0 to N-1 */
+#define TIMER_NUMBER_OF_TIMERS                       4
+
+/* Register definitions for the timers */
+#define TIMER_N_LOAD_COUNT_REG_OFFSET(__N)          (0x0000 + (0x14 * (__N)))
+#define TIMER_N_CURRENT_VALUE_REG_OFFSET(__N)       (0x0004 + (0x14 * (__N)))
+#define TIMER_N_CONTROL_REG_OFFSET(__N)             (0x0008 + (0x14 * (__N)))
+#define TIMER_N_EOI_REG_OFFSET(__N)                 (0x000c + (0x14 * (__N)))
+#define TIMER_N_INTERRUPT_STATUS_REG_OFFSET(__N)    (0x0010 + (0x14 * (__N)))
+
+/* Timer N control register bit definitions */
+#define TIMER_ENABLE                                (0x00000001)
+#define TIMER_MODE                                  (0x00000002)
+#define TIMER_INTERRUPT_MASK                        (0x00000004)
+
+
+/* Register definitions for global timer registers */
+#define TIMERS_INTERRUPT_STATUS_REG_OFFSET          (0x00a0)
+#define TIMERS_EOI_REG_OFFSET                       (0x00a4)
+#define TIMERS_RAW_INTERRUPT_STATUS_REG_OFFSET      (0x00a8)
+
+/* Global Timer Registers bit definitions */
+#define TIMER(__N)                                  (0x00000001 << (__N))
+
+
+#endif /* __FIRECRACKER_PC20X_TIMER_H */
+
+
+
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/uart.h b/arch/arm/mach-firecracker/include/mach/pc20x/uart.h
new file mode 100644
index 0000000..e3dc3bf
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/uart.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              UART Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __FIRECRACKER_PC20X_UART_H
+#define __FIRECRACKER_PC20X_UART_H
+
+/* Register address offsets from UART Base */
+#define UART_RX_BUFFER_REG_OFFSET                   0x00
+#define UART_TX_HOLDING_REG_OFFSET                  0x00
+#define UART_DIVISOR_LOW_REG_OFFSET                 0x00
+#define UART_DIVISOR_HIGH_REG_OFFSET                0x04
+#define UART_INT_ENABLE_REG_OFFSET                  0x04
+#define UART_INT_IDENTITY_REG_OFFSET                0x08
+#define UART_FIFO_CTRL_REG_OFFSET                   0x08
+#define UART_LINE_CTRL_REG_OFFSET                   0x0c
+#define UART_MODEM_CTRL_REG_OFFSET                  0x10
+#define UART_LINE_STATUS_REG_OFFSET                 0x14
+#define UART_MODEM_STATUS_REG_OFFSET                0x18
+#define UART_SCRATCH_REG_OFFSET                     0x1c
+
+#define UART_SHADOW_RX_BUFFER_REG_OFFSET            0x30 /* not available in this implementation */
+#define UART_SHADOW_TX_HOLDING_REG_OFFSET           0x30 /* not available in this implementation */
+
+#define UART_FIFO_ACCESS_REG_OFFSET                 0x70 /* not available in this implementation */
+#define UART_TX_FIFO_READ_REG_OFFSET                0x74 /* not available in this implementation */
+#define UART_RX_FIFO_WRITE_REG_OFFSET               0x78 /* not available in this implementation */
+#define UART_UART_STATUS_REG_OFFSET                 0x7c
+#define UART_TX_FIFO_LEVEL_REG_OFFSET               0x80 /* not available in this implementation */
+#define UART_RX_FIFO_LEVEL_REG_OFFSET               0x84 /* not available in this implementation */
+#define UART_SOFT_RESET_REG_OFFSET                  0x88 /* not available in this implementation */
+
+
+#define UART_SHADOW_RTS_REG_OFFSET                  0x8c
+#define UART_SHADOW_BRK_CTRL_REG_OFFSET             0x90
+#define UART_SHADOW_DMA_MODE_REG_OFFSET             0x94
+#define UART_SHADOW_FIFO_ENABLE_REG_OFFSET          0x98
+#define UART_SHADOW_RCVR_TRIGGER_REG_OFFSET         0x9c
+#define UART_SHADOW_TX_EMPTY_TRIGGER_REG_OFFSET     0xa0
+#define UART_HALT_TX_REG_OFFSET                     0xa4
+#define UART_DMA_SOFT_ACK_REG_OFFSET                0xa8
+#define UART_COMP_PARAM_REG_OFFSET                  0xf4
+#define UART_UART_VERSION_REG_OFFSET                0xf8
+#define UART_COMP_TYPE_REG_OFFSET                   0xfc
+
+/* DLL & DLH */
+#define UART_DIVISOR_MASK                           0xFF
+
+/* IER */ 
+#define UART_INT_ENABLE_PTIME_IDX                   0x7
+                                                        /* Programmable THRE Interrupt Mode Enable that can be */
+                                                        /*  written to only when THRE_MODE_USER == Enabled, */
+                                                        /*  always readable. This is used to enable/disable the */
+                                                        /*  generation of THRE Interrupt. */
+#define UART_INT_ENABLE_EDSSI_IDX                   0x3 /*  R/W Enable Modem Status Interrupt. */
+#define UART_INT_ENABLE_ELSI_IDX                    0x2 /*  R/W Enable Receiver Line Status Interrupt. */
+#define UART_INT_ENABLE_ETBEI_IDX                   0x1 /*  R/W Enable Transmit Holding Register Empty Interrupt. */
+#define UART_INT_ENABLE_ERBFI_IDX                   0x0 /*  R/W Enable Received Data Available Interrupt. */
+
+#define UART_INT_ENABLE_PTIME_MASK                  (1 << UART_INT_ENABLE_PTIME_IDX)
+#define UART_INT_ENABLE_EDSSI_MASK                  (1 << UART_INT_ENABLE_EDSSI_IDX)
+#define UART_INT_ENABLE_ELSI_MASK                   (1 << UART_INT_ENABLE_ELSI_IDX)
+#define UART_INT_ENABLE_ETBEI_MASK                  (1 << UART_INT_ENABLE_ETBEI_IDX)
+#define UART_INT_ENABLE_ERBFI_MASK                  (1 << UART_INT_ENABLE_ERBFI_IDX)
+
+/* IIR */
+#define UART_INT_IDENTITY_MASK                      0x0F
+#define UART_INT_IDENTITY_MODEM_STATUS              0x00
+#define UART_INT_IDENTITY_NONE                      0x01
+#define UART_INT_IDENTITY_THR_EMPTY                 0x02
+#define UART_INT_IDENTITY_RX_DATA                   0x04
+#define UART_INT_IDENTITY_RX_LINE_STATUS            0x06
+#define UART_INT_IDENTITY_BUSY_DETECT               0x07
+#define UART_INT_IDENTITY_CHARACTER_TIMEOUT         0x0C
+
+/* FCR */
+#define UART_FIFO_CTRL_RCVR_MASK                    0xC0
+#define UART_FIFO_CTRL_RCVR_1_CHAR                  0x00
+#define UART_FIFO_CTRL_RCVR_QUARTER_FULL            0x40
+#define UART_FIFO_CTRL_RCVR_HALF_FULL               0x80
+#define UART_FIFO_CTRL_RCVR_2_LESS_THAN_FULL        0xC0
+
+#define UART_FIFO_CTRL_TX_EMPTY_MASK                0x30
+#define UART_FIFO_CTRL_TX_EMPTY_EMPTY               0x00
+#define UART_FIFO_CTRL_TX_EMPTY_2_CHARS             0x10
+#define UART_FIFO_CTRL_TX_EMPTY_QUARTER_FULL        0x20
+#define UART_FIFO_CTRL_TX_EMPTY_HALF_FULL           0x30
+
+#define UART_FIFO_CTRL_ENABLE                       0x01    /* fifo enable bit */
+
+
+/* LCR indices */
+#define UART_LINE_CTRL_DLAB_IDX                     7       /* Divisor latch access bit */
+#define UART_LINE_CTRL_BRK_IDX                      6 
+#define UART_LINE_CTRL_EPS_IDX                      4 
+#define UART_LINE_CTRL_PEN_IDX                      3 
+#define UART_LINE_CTRL_STOP_IDX                     2 
+#define UART_LINE_CTRL_DLS_IDX                      0 
+
+/* LCR bit masks */
+#define UART_LINE_CTRL_DLAB_MASK                    (1 << UART_LINE_CTRL_DLAB_IDX)
+#define UART_LINE_CTRL_BRK_MASK                     (1 << UART_LINE_CTRL_BRK_IDX)      
+#define UART_LINE_CTRL_EPS_MASK                     (1 << UART_LINE_CTRL_EPS_IDX)      
+#define UART_LINE_CTRL_PEN_MASK                     (1 << UART_LINE_CTRL_PEN_IDX)      
+#define UART_LINE_CTRL_STOP_MASK                    (1 << UART_LINE_CTRL_STOP_IDX)
+#define UART_LINE_CTRL_DLS_MASK                     3 
+#define UART_LINE_CTRL_DLS_8_BITS                   3   /* 8 bit data length */
+#define UART_LINE_CTRL_DLS_7_BITS                   2   /* 7 bit data length */
+#define UART_LINE_CTRL_DLS_6_BITS                   1   /* 6 bit data length */
+#define UART_LINE_CTRL_DLS_5_BITS                   0   /* 5 bit data length */
+
+#define UART_LINE_CTRL_1_STOP_BIT                   ~(UART_LINE_CTRL_STOP_MASK)
+#define UART_LINE_CTRL_PARITY_DISABLE               ~(UART_LINE_CTRL_PEN_MASK)
+
+
+/* MCR indices */
+#define UART_MODEM_CTRL_LOOP_BACK_IDX               4
+#define UART_MODEM_CTRL_OUT_2_IDX                   3
+#define UART_MODEM_CTRL_OUT_1_IDX                   2
+#define UART_MODEM_CTRL_CTS_IDX                     1
+#define UART_MODEM_CTRL_DTR_IDX                     0
+
+/* MCR bit masks */
+#define UART_MODEM_CTRL_LOOP_BACK_MASK              (1 << UART_MODEM_CTRL_LOOP_BACK_IDX)
+#define UART_MODEM_CTRL_OUT_2_MASK                  (1 << UART_MODEM_CTRL_OUT_2_IDX)    
+#define UART_MODEM_CTRL_OUT_1_MASK                  (1 << UART_MODEM_CTRL_OUT_1_IDX)    
+#define UART_MODEM_CTRL_CTS_MASK                    (1 << UART_MODEM_CTRL_CTS_IDX)     
+#define UART_MODEM_CTRL_DTR_MASK                    (1 << UART_MODEM_CTRL_DTR_IDX)     
+
+#define UART_MODEM_STATUS_CTS_IDX                   4   /* CTS input */
+#define UART_MODEM_STATUS_DCTS_IDX                  0   /* change in CTS input since last read */
+
+#define UART_LINE_STATUS_THRE_IDX                   5
+#define UART_LINE_STATUS_DATA_READY_IDX             0
+#define UART_LINE_STATUS_THRE_MASK                  (1 << UART_LINE_STATUS_THRE_IDX)
+#define UART_LINE_STATUS_DATA_READY_MASK            (1 << UART_LINE_STATUS_DATA_READY_IDX)
+
+#define UART_UART_STATUS_RFF_IDX                    4   /* RX FIFO full */
+#define UART_UART_STATUS_RFNE_IDX                   3   /* RX FIFO not empty */
+#define UART_UART_STATUS_TFE_IDX                    2 
+#define UART_UART_STATUS_TFNF_IDX                   1 
+#define UART_UART_STATUS_BUSY_IDX                   0 
+
+#define UART_UART_STATUS_RFF_MASK                   (1 << UART_UART_STATUS_RFF_IDX)
+#define UART_UART_STATUS_RFNE_MASK                  (1 << UART_UART_STATUS_RFNE_IDX)
+#define UART_UART_STATUS_TFE_MASK                   (1 << UART_UART_STATUS_TFE_IDX)
+#define UART_UART_STATUS_TFNF_MASK                  (1 << UART_UART_STATUS_TFNF_IDX)
+#define UART_UART_STATUS_BUSY_MASK                  (1 << UART_UART_STATUS_BUSY_IDX)
+
+#endif /* __FIRECRACKER_PC20X_UART_H */
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/vic.h b/arch/arm/mach-firecracker/include/mach/pc20x/vic.h
new file mode 100644
index 0000000..c163a75
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/vic.h
@@ -0,0 +1,58 @@
+
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              VIC Register Definitions
+ *
+ *****************************************************************************/ 
+#ifndef __FIRECRACKER_PC20X_VIC_H
+#define __FIRECRACKER_PC20X_VIC_H
+
+/* VIC registers */
+#define VIC_ENABLE_REG_OFFSET                           (0x00)
+#define VIC_MASK_REG_OFFSET                             (0x08)
+#define VIC_FORCE_REG_OFFSET                            (0x10)
+#define VIC_RAW_STATUS_REG_OFFSET                       (0x18)
+#define VIC_STATUS_REG_OFFSET                           (0x20)
+#define VIC_MASK_STATUS_REG_OFFSET                      (0x28)
+#define VIC_FINAL_STATUS_REG_OFFSET                     (0x30)
+#define VIC_VECTOR_REG_OFFSET                           (0x38)
+#define VIC_VECTOR_PRIORITY_N_REG_OFFSET(__N)           (0x40 + 0x08 * (__N))
+#define VIC_PRIORITY_LEVEL_REG_OFFSET                   (0xd8)
+#define VIC_IRQ_N_PRIORITY_LEVEL_REG_OFFSET(__N)        (0xe8 + 0x04 * (__N))
+
+/* Bit definitions */
+
+#define IRQ_BIT(__N)                                    (0x00000001 << (__N))
+
+/* The active IRQs bitmask */
+#define VIC_USED_IRQ_MASK                               (0x3fffffff)
+
+#endif /* __FIRECRACKER_PC20X_VIC_H */
+
+
diff --git a/arch/arm/mach-firecracker/include/mach/pc20x/wdt.h b/arch/arm/mach-firecracker/include/mach/pc20x/wdt.h
new file mode 100644
index 0000000..4c98737
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/pc20x/wdt.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*****************************************************************************
+ *
+ * Description: picoChip PC20x ARM Subsystem
+ *
+ *              Watchdog Timer Register Definitions
+ *
+ *****************************************************************************/
+#ifndef __FIRECRACKER_PC20X_WDT_H
+#define __FIRECRACKER_PC20X_WDT_H
+
+/* Register address offsets from WDT Base */
+#define WDT_CONTROL_REG_OFFSET                      (0x00)
+#define WDT_TIMEOUT_RANGE_REG_OFFSET                (0x04)
+#define WDT_CURRECT_COUNTER_VALUE_REG_OFFSET        (0x08)
+#define WDT_COUNTER_RESTART_REG_OFFSET              (0x0c)
+#define WDT_INTERRUPT_STATUS_REG_OFFSET             (0x10)
+#define WDT_INTERRUPT_EOI_REG_OFFSET                (0x14)
+
+
+/* WdtControlRegOffset register bit definitions */
+#define ENABLE_WDT                                  (0x01)
+#define RESPONSE_MODE                               (0x02)
+#define RESET_PULSE_LENGTH_2_PCLK                   (0x00 << 2)
+#define RESET_PULSE_LENGTH_4_PCLK                   (0x01 << 2)
+#define RESET_PULSE_LENGTH_8_PCLK                   (0x02 << 2)
+#define RESET_PULSE_LENGTH_16_PCLK                  (0x03 << 2)
+#define RESET_PULSE_LENGTH_32_PCLK                  (0x04 << 2)
+#define RESET_PULSE_LENGTH_64_PCLK                  (0x05 << 2)
+#define RESET_PULSE_LENGTH_128_PCLK                 (0x06 << 2)
+#define RESET_PULSE_LENGTH_256_PCLK                 (0x07 << 2)
+
+/* WdtTimeoutRangeRegOffset register bit definitions */
+#define TIMEOUT_PERIOD_64K                          (0x00 << 0)
+#define TIMEOUT_PERIOD_128K                         (0x01 << 0)
+#define TIMEOUT_PERIOD_256K                         (0x02 << 0)
+#define TIMEOUT_PERIOD_512K                         (0x03 << 0)
+#define TIMEOUT_PERIOD_1M                           (0x04 << 0)
+#define TIMEOUT_PERIOD_2M                           (0x05 << 0)
+#define TIMEOUT_PERIOD_4M                           (0x06 << 0)
+#define TIMEOUT_PERIOD_8M                           (0x07 << 0)
+#define TIMEOUT_PERIOD_16M                          (0x08 << 0)
+#define TIMEOUT_PERIOD_32M                          (0x09 << 0)
+#define TIMEOUT_PERIOD_64M                          (0x0a << 0)
+#define TIMEOUT_PERIOD_128M                         (0x0b << 0)
+#define TIMEOUT_PERIOD_256M                         (0x0c << 0)
+#define TIMEOUT_PERIOD_512M                         (0x0d << 0)
+#define TIMEOUT_PERIOD_1G                           (0x0e << 0)
+#define TIMEOUT_PERIOD_2G                           (0x0f << 0)
+#define FIRST_TIMEOUT_PERIOD_64K                    (0x00 << 4)
+#define FIRST_TIMEOUT_PERIOD_128K                   (0x01 << 4)
+#define FIRST_TIMEOUT_PERIOD_256K                   (0x02 << 4)
+#define FIRST_TIMEOUT_PERIOD_512K                   (0x03 << 4)
+#define FIRST_TIMEOUT_PERIOD_1M                     (0x04 << 4)
+#define FIRST_TIMEOUT_PERIOD_2M                     (0x05 << 4)
+#define FIRST_TIMEOUT_PERIOD_4M                     (0x06 << 4)
+#define FIRST_TIMEOUT_PERIOD_8M                     (0x07 << 4)
+#define FIRST_TIMEOUT_PERIOD_16M                    (0x08 << 4)
+#define FIRST_TIMEOUT_PERIOD_32M                    (0x09 << 4)
+#define FIRST_TIMEOUT_PERIOD_64M                    (0x0a << 4)
+#define FIRST_TIMEOUT_PERIOD_128M                   (0x0b << 4)
+#define FIRST_TIMEOUT_PERIOD_256M                   (0x0c << 4)
+#define FIRST_TIMEOUT_PERIOD_512M                   (0x0d << 4)
+#define FIRST_TIMEOUT_PERIOD_1G                     (0x0e << 4)
+#define FIRST_TIMEOUT_PERIOD_2G                     (0x0f << 4)
+
+/* WdtCounterRestartRegOffset register timer restart code.
+ * To restart the WDT, set this value.
+ */
+#define KICK_WDT                                    (0x76)
+
+/* WdtInterruptStatusRegOffset register bits */
+#define WDT_INTERRUPT                               (0x01)
+
+
+
+#endif /* __FIRECRACKER_PC20X_WDT_H */
+
+
+
diff --git a/arch/arm/mach-firecracker/include/mach/platform.h b/arch/arm/mach-firecracker/include/mach/platform.h
new file mode 100644
index 0000000..852e213
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/platform.h
@@ -0,0 +1,54 @@
+/*
+ * linux/include/asm-arm/arch-firecracker/platform.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ARCH_FIRECRACKER_PLATFORM_H
+#define __ARCH_FIRECRACKER_PLATFORM_H
+
+#include <asm/sizes.h>
+
+/* Flash size and position */
+#define FIRECRACKER_FLASH_BASE          0x20000000
+#define FIRECRACKER_FLASH_SIZE          SZ_128M
+#define FIRECRACKER_FLASH_WIDTH         4
+
+/* SDRAM size and position - the ram in the firecracker is split into 4 banks.
+ * 64M spread over 4 banks, starting at zero with 64M between each bank.
+ * NOTE: The actual ram available is 128M on the SVB but half of it is reserved
+ * for the picoArray.
+ * NOTE: The size here is the default, set if the pc20x_mem= parameter is not
+ * used.
+ */
+#define FIRECRACKER_RAM_START           0x00000000
+#define FIRECRACKER_RAM_SIZE            SZ_64M      /* Default */
+#define FIRECRACKER_RAM_BANKS           4
+#define FIRECRACKER_RAM_BANK_STRIDE     SZ_64M
+
+/* The clock frequency for the UARTs */
+#define FIRECRACKER_BASE_BAUD           3686400     /* 3.6864MHz */
+
+/* The clock frequency for the timers on the various boards */
+#define SVB_TIMER_FREQ                  140000000   /* 140MHz */
+#define PC72052_I10_REVB_TIMER_FREQ     140000000   /* 140MHz */
+#define PC72052_I10_REVA_TIMER_FREQ     80000000    /* 80MHz */
+
+#endif /* __ARCH_FIRECRACKER_PLATFORM_H */
+
diff --git a/arch/arm/mach-firecracker/include/mach/reset.h b/arch/arm/mach-firecracker/include/mach/reset.h
new file mode 100644
index 0000000..984323b
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/reset.h
@@ -0,0 +1,31 @@
+/* linux/include/asm-arm/arch-firecracker/reset.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Firecracker - Reset handler
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_RESET_H
+#define __ASM_ARCH_RESET_H __FILE__
+
+/* Function pointer to a function able to reset the board. This function
+ * is passed to the kernel by a driver.
+ */
+typedef void (*reset_t)(char mode, void *cookie);
+
+/* Trigger a reset (called by kernel) */
+void firecracker_reset(char mode);
+
+/* Reset registration (called by drivers) */
+void register_reset_handler(reset_t reset, void *cookie);
+void deregister_reset_handler(reset_t reset, void *cookie);
+
+
+#endif /* __ASM_ARCH_RESET_H */
+
diff --git a/arch/arm/mach-firecracker/include/mach/spi-gpio.h b/arch/arm/mach-firecracker/include/mach/spi-gpio.h
new file mode 100644
index 0000000..93daef9
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/spi-gpio.h
@@ -0,0 +1,35 @@
+/* linux/include/asm-arm/arch-firecracker/spi-gpio.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Taken from linux/include/asm-arm/arch-firecracker/spi.h
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * Firecracker - SPI Controller platform_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_SPIGPIO_H
+#define __ASM_ARCH_SPIGPIO_H __FILE__
+
+#include <linux/spi/spi.h>
+
+struct firecracker_spigpio_info;
+struct spi_board_info;
+
+struct firecracker_spigpio_info {
+    unsigned char pin_clk;
+    unsigned char pin_mosi;
+    unsigned char pin_miso;
+    unsigned char pin_cs;
+
+    unsigned long board_size;
+    struct spi_board_info *board_info;
+};
+
+
+#endif /* __ASM_ARCH_SPIGPIO_H */
diff --git a/arch/arm/mach-firecracker/include/mach/system.h b/arch/arm/mach-firecracker/include/mach/system.h
new file mode 100644
index 0000000..3b9b8a6
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/system.h
@@ -0,0 +1,41 @@
+/*
+ *  linux/include/asm-arm/arch-firecracker/system.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <mach/reset.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+    firecracker_reset(mode);
+}
+
+#endif
diff --git a/arch/arm/mach-firecracker/include/mach/timex.h b/arch/arm/mach-firecracker/include/mach/timex.h
new file mode 100644
index 0000000..c4af10a
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/timex.h
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-arm/arch-firecracker/timex.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ *  Firecracker architecture timex specifications
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* This is the rate at which the timer that controls the linux tick runs.
+ * It is used to calculate the actual tick frequency that is achieved as
+ * it is not always possible to divide this frequency down to the configured
+ * HZ value.
+ * See jiffies.h.
+ */
+
+#ifndef __TIMEX_H__
+#define __TIMEX_H__
+
+#include <mach/platform.h>
+
+/* The frequency at which the timer gets clocked is dependent on the
+ * machine type we are running on.
+ * Unfortunately the machine we are running on is not known until run time
+ * when the bootloader tells us. Therefore we do not have a known clock
+ * tick rate. 
+ * *** Fake the tick rate! ***
+ * By setting the CLOCK_TICK_RATE to HZ, the kernel is built assuming that
+ * the clock is incremented once every 'tick'. We will have to configure the
+ * hardware (at run time) to make this true.
+ */
+#define CLOCK_TICK_RATE		(HZ)
+
+#endif /* __TIMEX_H__ */
+
diff --git a/arch/arm/mach-firecracker/include/mach/uncompress.h b/arch/arm/mach-firecracker/include/mach/uncompress.h
new file mode 100644
index 0000000..1090b6d
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/uncompress.h
@@ -0,0 +1,47 @@
+/*
+ *  linux/include/asm-arm/arch-firecracker/uncompress.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <mach/hardware.h>
+#include <linux/serial_reg.h>
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	int shift = 2;
+	volatile u8 * uart = (volatile u8 *)(PC20X_UART1_BASE);
+
+	while (!(uart[UART_LSR << shift] & UART_LSR_THRE))
+		barrier();
+	uart[UART_TX << shift] = c;
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff --git a/arch/arm/mach-firecracker/include/mach/vmalloc.h b/arch/arm/mach-firecracker/include/mach/vmalloc.h
new file mode 100644
index 0000000..a10e76f
--- /dev/null
+++ b/arch/arm/mach-firecracker/include/mach/vmalloc.h
@@ -0,0 +1,23 @@
+/*
+ *  linux/include/asm-arm/arch-firecracker/vmalloc.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		(PAGE_OFFSET + 0x18000000)
+
diff --git a/arch/arm/mach-integrator/include/mach/debug-macro.S b/arch/arm/mach-integrator/include/mach/debug-macro.S
index d347d65..ffb7d89 100644
--- a/arch/arm/mach-integrator/include/mach/debug-macro.S
+++ b/arch/arm/mach-integrator/include/mach/debug-macro.S
@@ -14,6 +14,7 @@
 		.macro	addruart,rx
 		mrc	p15, 0, \rx, c1, c0
 		tst	\rx, #1			@ MMU enabled?
+		itee	eq
 		moveq	\rx, #0x16000000	@ physical base address
 		movne	\rx, #0xf0000000	@ virtual base
 		addne	\rx, \rx, #0x16000000 >> 4
diff --git a/arch/arm/mach-integrator/include/mach/entry-macro.S b/arch/arm/mach-integrator/include/mach/entry-macro.S
index 7649c57..ce478b5 100644
--- a/arch/arm/mach-integrator/include/mach/entry-macro.S
+++ b/arch/arm/mach-integrator/include/mach/entry-macro.S
@@ -26,6 +26,7 @@
 		ldr	\irqstat, [\base, #IRQ_STATUS]		@ get masked status
 		ldr	\base, =IO_ADDRESS(INTEGRATOR_HDR_BASE)
 		teq	\irqstat, #0
+		itt	eq
 		ldreq	\irqstat, [\base, #(INTEGRATOR_HDR_IC_OFFSET+IRQ_STATUS)]
 		moveq	\irqnr, #IRQ_CIC_START
 
diff --git a/arch/arm/mach-integrator/include/mach/hardware.h b/arch/arm/mach-integrator/include/mach/hardware.h
index 1251319..d795642 100644
--- a/arch/arm/mach-integrator/include/mach/hardware.h
+++ b/arch/arm/mach-integrator/include/mach/hardware.h
@@ -36,8 +36,12 @@
 #define PCIO_BASE		PCI_IO_VADDR
 #define PCIMEM_BASE		PCI_MEMORY_VADDR
 
+#ifdef CONFIG_MMU
 /* macro to get at IO space when running virtually */
 #define IO_ADDRESS(x) (((x) >> 4) + IO_BASE) 
+#else
+#define IO_ADDRESS(x) (x)
+#endif
 
 #define pcibios_assign_all_busses()	1
 
diff --git a/arch/arm/mach-integrator/integrator_cp.c b/arch/arm/mach-integrator/integrator_cp.c
index 88026cc..ecc0a20 100644
--- a/arch/arm/mach-integrator/integrator_cp.c
+++ b/arch/arm/mach-integrator/integrator_cp.c
@@ -48,14 +48,14 @@
 
 #define INTCP_PA_CLCD_BASE		0xc0000000
 
-#define INTCP_VA_CIC_BASE		0xf1000040
-#define INTCP_VA_PIC_BASE		0xf1400000
-#define INTCP_VA_SIC_BASE		0xfca00000
+#define INTCP_VA_CIC_BASE		IO_ADDRESS(INTEGRATOR_HDR_BASE) + 0x40
+#define INTCP_VA_PIC_BASE		IO_ADDRESS(INTEGRATOR_IC_BASE)
+#define INTCP_VA_SIC_BASE		IO_ADDRESS(0xca000000)
 
 #define INTCP_PA_ETH_BASE		0xc8000000
 #define INTCP_ETH_SIZE			0x10
 
-#define INTCP_VA_CTRL_BASE		0xfcb00000
+#define INTCP_VA_CTRL_BASE		IO_ADDRESS(0xcb000000)
 #define INTCP_FLASHPROG			0x04
 #define CINTEGRATOR_FLASHPROG_FLVPPEN	(1 << 0)
 #define CINTEGRATOR_FLASHPROG_FLWREN	(1 << 1)
@@ -120,12 +120,12 @@ static struct map_desc intcp_io_desc[] __initdata = {
 		.length		= SZ_4K,
 		.type		= MT_DEVICE
 	}, {
-		.virtual	= 0xfca00000,
+		.virtual	= IO_ADDRESS(0xca000000),
 		.pfn		= __phys_to_pfn(0xca000000),
 		.length		= SZ_4K,
 		.type		= MT_DEVICE
 	}, {
-		.virtual	= 0xfcb00000,
+		.virtual	= IO_ADDRESS(0xcb000000),
 		.pfn		= __phys_to_pfn(0xcb000000),
 		.length		= SZ_4K,
 		.type		= MT_DEVICE
@@ -392,8 +392,8 @@ static struct platform_device *intcp_devs[] __initdata = {
  */
 static unsigned int mmc_status(struct device *dev)
 {
-	unsigned int status = readl(0xfca00004);
-	writel(8, 0xfcb00008);
+	unsigned int status = readl(IO_ADDRESS(0xca000000) + 4);
+	writel(8, IO_ADDRESS(0xcb000000) + 8);
 
 	return status & 8;
 }
diff --git a/arch/arm/mach-pc302/Kconfig b/arch/arm/mach-pc302/Kconfig
new file mode 100644
index 0000000..99b77d3
--- /dev/null
+++ b/arch/arm/mach-pc302/Kconfig
@@ -0,0 +1,11 @@
+# $picoChipHeaderSubst$
+
+menu "PC302 platform type"
+	depends on ARCH_PC302
+
+config MACH_PC7302
+	bool "Support PC7302 Board"
+	help
+          Include support for the picoChip PC7302 platform.
+          
+endmenu
diff --git a/arch/arm/mach-pc302/Makefile b/arch/arm/mach-pc302/Makefile
new file mode 100644
index 0000000..41a9e61
--- /dev/null
+++ b/arch/arm/mach-pc302/Makefile
@@ -0,0 +1,8 @@
+# BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+#
+# Makefile for the linux kernel.
+#
+
+obj-y					:= pc302_core.o \
+					   pc302_reset.o \
+					   pc302_cpe.o
diff --git a/arch/arm/mach-pc302/Makefile.boot b/arch/arm/mach-pc302/Makefile.boot
new file mode 100644
index 0000000..c7e75ac
--- /dev/null
+++ b/arch/arm/mach-pc302/Makefile.boot
@@ -0,0 +1,4 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
+
diff --git a/arch/arm/mach-pc302/core.h b/arch/arm/mach-pc302/core.h
new file mode 100644
index 0000000..b561ce8
--- /dev/null
+++ b/arch/arm/mach-pc302/core.h
@@ -0,0 +1,27 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05 
+ *****************************************************************************/
+
+/*
+ *  linux/arch/arm/mach-pc302/core.h
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#ifndef __ASM_ARCH_PC302_H__
+#define __ASM_ARCH_PC302_H__
+
+#include <linux/amba/bus.h>
+
+extern void __init pc302_core_init(void);
+extern void __init pc302_init_irq(void);
+extern void __init pc302_map_io(void);
+extern struct sys_timer pc302_timer;
+
+#endif /* __ASM_ARCH_PC302_H__ */
diff --git a/arch/arm/mach-pc302/include/mach/debug-macro.S b/arch/arm/mach-pc302/include/mach/debug-macro.S
new file mode 100644
index 0000000..c4f8736
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/debug-macro.S
@@ -0,0 +1,25 @@
+/* debug-macro.S
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Debugging macro include header
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx,      #0xfe000000	@ virtual base
+		movne	\rx,      #0x80000000
+		orr	\rx, \rx, #0x00230000       @ UART1
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/mach-pc302/include/mach/dma.h b/arch/arm/mach-pc302/include/mach/dma.h
new file mode 100644
index 0000000..40b2ffa
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/dma.h
@@ -0,0 +1,234 @@
+/*******************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ ******************************************************************************/
+/*!
+ * \file pc302_dma.h
+ * \brief PC302 DMA Register Definitions and register manipulation macros
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All inquiries to support@picochip.com
+ */
+
+#ifndef __PC302_DMA_H__
+#define __PC302_DMA_H__
+
+/* Channel register offsets from DMA base */
+#define PC302_DMA_N_SRC_ADDR_REG_OFFSET(__N)     (0x000 + (0x058 * (__N)))
+#define PC302_DMA_N_DST_ADDR_REG_OFFSET(__N)     (0x008 + (0x058 * (__N)))
+#define PC302_DMA_N_LLP_REG_OFFSET(__N)          (0x010 + (0x058 * (__N)))
+#define PC302_DMA_N_CTRL_REG_OFFSET(__N)         (0x018 + (0x058 * (__N)))
+#define PC302_DMA_N_BLOCK_SIZE_REG_OFFSET(__N)   (0x01c + (0x058 * (__N)))
+#define PC302_DMA_N_SRC_STATUS_REG_OFFSET(__N)   (0x020 + (0x058 * (__N)))
+#define PC302_DMA_N_DST_STATUS_REG_OFFSET(__N)   (0x028 + (0x058 * (__N)))
+#define PC302_DMA_N_SRC_STATUS_ADDR_REG_OFF(__N) (0x030 + (0x058 * (__N)))
+#define PC302_DMA_N_DST_STATUS_ADDR_REG_OFF(__N) (0x038 + (0x058 * (__N)))
+#define PC302_DMA_N_LOW_CONFIG_REG_OFFSET(__N)   (0x040 + (0x058 * (__N)))
+#define PC302_DMA_N_HIGH_CONFIG_REG_OFFSET(__N)  (0x044 + (0x058 * (__N)))
+#define PC302_DMA_N_SRC_GATHER_REG_OFFSET(__N)   (0x048 + (0x058 * (__N)))
+#define PC302_DMA_N_DST_SCATTER_REG_OFFSET(__N)  (0x050 + (0x058 * (__N)))
+
+/* Control register (CTL.x) 32 LSBs */
+#define PC302_DMA_INT_EN                (1 << 0)
+#define PC302_DMA_DST_TR_WIDTH_SHIFT    (1)
+#define PC302_DMA_DST_TR_WIDTH_MASK     (0x7 << PC302_DMA_DST_TR_WIDTH_SHIFT)
+#define PC302_DMA_SRC_TR_WIDTH_SHIFT    (4)
+#define PC302_DMA_SRC_TR_WIDTH_MASK     (0x7 << PC302_DMA_SRC_TR_WIDTH_SHIFT)
+#define PC302_DMA_DINC_SHIFT            (7)
+#define PC302_DMA_DINC_MASK             (0x3 << PC302_DMA_DINC_SHIFT)
+#define PC302_DMA_SINC_SHIFT            (9)
+#define PC302_DMA_SINC_MASK             (0x3 << PC302_DMA_SINC_SHIFT)
+#define PC302_DMA_DST_MSIZE_SHIFT       (11)
+#define PC302_DMA_DST_MSIZE_MASK        (0x7 << PC302_DMA_DST_MSIZE_SHIFT)
+#define PC302_DMA_SRC_MSIZE_SHIFT       (14)
+#define PC302_DMA_SRC_MSIZE_MASK        (0x7 << PC302_DMA_SRC_MSIZE_SHIFT)
+#define PC302_DMA_SRC_GATHER_EN         (1 << 17)
+#define PC302_DMA_DST_SCATTER_EN        (1 << 18)
+/* Bit 19 is undefined */
+#define PC302_DMA_TT_FC_SHIFT           (20)
+#define PC302_DMA_TT_FC_MASK            (0x7 << PC302_DMA_TT_FC_SHIFT)
+#define PC302_DMA_DMS_SHIFT             (23)
+#define PC302_DMA_DMS_MASK              (0x3 << PC302_DMA_DMS_SHIFT)
+#define PC302_DMA_SMS_SHIFT             (25)
+#define PC302_DMA_SMS_MASK              (0x3 << PC302_DMA_SMS_SHIFT)
+#define PC302_DMA_LLP_DST_EN            (1 << 27)
+#define PC302_DMA_LLP_SRC_EN            (1 << 28)
+/* Bit 31 is undefined */
+
+/* Block size register (CTL.x) 32 MSBs */
+#define PC302_DMA_BLOCK_TS_SHIFT        (0)
+/* Max channel block size = 4095. Number of bits = log2(blk_size+1)= 12 */
+#define PC302_DMA_BLOCK_TS_MASK         (0xFFF << PC302_DMA_BLOCK_TS_SHIFT)
+#define PC302_DMA_DONE                  (1 << 12)
+
+/* Configuration register (CFG.x) LSBs */
+/* bits 4:0 are reserved */
+#define PC302_DMA_CH_PRIOR_SHIFT        (5)
+#define PC302_DMA_CH_PRIOR_MASK         (0xF << PC302_DMA_CH_PRIOR_SHIFT)
+#define PC302_DMA_CH_SUSP               (1 << 8)
+#define PC302_DMA_FIFO_EMPTY            (1 << 9)
+#define PC302_DMA_HS_SEL_DST            (1 << 10)
+#define PC302_DMA_HS_SEL_SRC            (1 << 11)
+#define PC302_DMA_CHAN_LOCK_LEVEL_SHIFT (1 << 12)
+#define PC302_DMA_CHAN_LOCK_LEVEL_MASK  (0x3 << PC302_DMA_CHAN_LOCK_LEVEL_MASK)
+#define PC302_DMA_BUS_LOCK_LEVEL_SHIFT  (1 << 14)
+#define PC302_DMA_BUS_LOCK_LEVEL_MASK   (0x3 << PC302_DMA_BUS_LOCK_LEVEL_SHIFT)
+#define PC302_DMA_DST_HS_POL            (1 << 18)
+#define PC302_DMA_SRC_HS_POL            (1 << 19)
+#define PC302_DMA_MAX_ABRST_SHIFT       (20)
+#define PC302_DMA_MAX_ABRST_MASK        (0x3FF << PC302_DMA_MAX_ABRST_SHIFT)
+#define PC302_DMA_RELOAD_SRC            (1 << 30)
+#define PC302_DMA_RELOAD_DST            (1 << 31)
+
+/* Configuration register (CFG.x) MSBs */
+#define PC302_DMA_FC_MODE               (1 << 0)
+#define PC302_DMA_FIFO_MODE             (1 << 1)
+#define PC302_DMA_PROTCTL_SHIFT         (2)
+#define PC302_DMA_PROTCTL_MASK          (0x7 << PC302_DMA_PROTCTL_SHIFT)
+#define PC302_DMA_DST_UPD_EN            (1 << 5)
+#define PC302_DMA_SRC_UPD_EN            (1 << 6)
+#define PC302_DMA_SRC_PER_SHIFT         (7)
+#define PC302_DMA_SRC_PER_MASK          (0xF << PC302_DMA_SRC_PER_SHIFT)
+#define PC302_DMA_DST_PER_SHIFT         (11)
+#define PC302_DMA_DST_PER_MASK          (0xF << PC302_DMA_DST_PER_SHIFT)
+/* bits 15:31 unused */
+
+/* Scatter and gather (SGR.x) registers LSBs */
+#define PC302_DMA_SG_INTERVAL_SHIFT     (0) /* 20 bit register */
+#define PC302_DMA_SG_INTERVAL_MASK      (0xFFFFF << PC302_DMA_SG_INTERVAL_SHIFT)
+#define PC302_DMA_SG_COUNT_SHIFT        (20)/* 12 bit register */
+#define PC302_DMA_SG_COUNT_MASK         (0xFFF << PC302_DMA_SG_COUNT_SHIFT)
+
+/* Interrupt registers.
+ * There are 5 types of interrupt which have their own register families:
+ *      Transfer complete,
+ *      Block complete,
+ *      Source transfer complete,
+ *      Destination transfer complete, and
+ *      Error 
+ *
+ * An update is made by writing/reading a bit in the appropriate register:
+ *      Raw Interrupt Status registers for reading the status of each bit
+ *      Processed Interrupt Status registers
+ *      Interrupt Mask registers
+ *      Interrupt Clear registers
+ *
+ * The following tables gives the address of each register:
+ *  -----------------------------------------------------------------------
+ * | Operation          |                Interrupt Type                    |
+ * |                    | Transfer |  Block  | SRC T/F | DST T/F |  Error  |
+ * |                    |----------|---------|---------|---------|---------|
+ * |Raw Status (R)      |  0x2c0   |  0x2c8  |  0x2d0  |  0x2d8  |  0x2e0  |
+ * |Processed Status (R)|  0x2e8   |  0x2f0  |  0x2f8  |  0x300  |  0x308  |
+ * |Mask (R/W)          |  0x310   |  0x318  |  0x320  |  0x328  |  0x330  |
+ * |Clear (W)           |  0x338   |  0x340  |  0x348  |  0x350  |  0x358  |
+ *  -----------------------------------------------------------------------
+ *
+ * The following 5 macros can be used to access all 20 registers. O is one
+ * of the operation macros defined below.
+ */ 
+#define PC302_DMA_TXFER_COMPLETE_REG_OFFSET(__O)     (0x2c0 + (__O))
+#define PC302_DMA_BLOCK_COMPLETE_REG_OFFSET(__O)     (0x2c8 + (__O))
+#define PC302_DMA_SRC_TRX_COMPLETE_REG_OFFSET(__O)   (0x2d0 + (__O))
+#define PC302_DMA_DST_TRX_COMPLETE_REG_OFFSET(__O)   (0x2d8 + (__O))
+#define PC302_DMA_ERROR_REG_OFFSET(__O)              (0x2e0 + (__O))
+
+/* Interrupt operation macros */
+#define PC302_DMA_INTERRUPT_RAW                      (0x028 * 0)
+#define PC302_DMA_INTERRUPT_STATUS                   (0x028 * 1)
+#define PC302_DMA_INTERRUPT_MASK                     (0x028 * 2)
+#define PC302_DMA_INTERRUPT_CLEAR                    (0x028 * 3)
+
+/* Interrupt mask channel macros
+ * Bits 0:PC302_DMA_CHANNELS-1  = enable / disable
+ * Bits PC302_DMA_CHANNELS:7    = reserved
+ * Bits 8:7+PC302_DMA_CHANNELS  = Corresponding write enable bit
+ * Bits 8+PC302_DMA_CHANNELS:63 = unused
+ */
+#define PC302_DMA_IRQ_ENABLE_CHANNEL(__N)            (0x0101 << (__N))
+#define PC302_DMA_IRQ_DISABLE_CHANNEL(__N)           (0x0100 << (__N))
+
+/* Interrupt clear macro */
+#define PC302_DMA_IRQ_CHANNEL(__N)                   (0x1 << (__N))
+
+/* Interrupt status register */
+#define PC302_DMA_IRQ_STATUS_REG_OFFSET              (0x360)
+
+/* Interrupt status bits */
+#define PC302_DMA_STATUS_TFR                         (1 << 0)
+#define PC302_DMA_STATUS_BLOCK                       (1 << 1)
+#define PC302_DMA_STATUS_SRCT                        (1 << 2)
+#define PC302_DMA_STATUS_DSTT                        (1 << 3)
+#define PC302_DMA_STATUS_ERR                         (1 << 4)
+#define PC302_DMA_STATUS_IRQ_TYPES                   (5)
+/* Bits 5 to 63 are unused */
+
+/*
+ * Software handshaking registers.
+ * Three types of S/W handshaking is permitted, controlled by either the
+ * source or destination; burst (software), single, or last. This results in
+ * 6 registers:
+ *     Source Software Transaction Request           (0x368)
+ *     Destination Software Transaction Request      (0x370)
+ *     Single Source Transaction Request             (0x378)
+ *     Single Destination Transacion Request         (0x380) 
+ *     Last Source Transaction Request               (0x388)
+ *     Last Destination Transaction Request          (0x390)
+ *
+ * The following macros allows the transfer controller to be addressed.
+ * S is the software control type specified by the macros listed below.
+ */
+#define PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(__S)    (0x368 + (__S))
+#define PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(__S)    (0x370 + (__S))
+
+/* Software flow control macros */
+#define PC302_DMA_BURST_TRANSFER                     (0x010 * 0)
+#define PC302_DMA_SINGLE_TRANSFER                    (0x010 * 1)
+#define PC302_DMA_LAST_TRANSFER                      (0x010 * 2)
+
+/*
+ * Software flow Transaction request channel bits 
+ * Bits 0:PC302_DMA_CHANNELS-1  = enable
+ * Bits PC302_DMA_CHANNELS:7    = reserved
+ * Bits 8:7+PC302_DMA_CHANNELS  = Corresponding write enable bit
+ * Bits 8+PC302_DMA_CHANNELS:63 = unused
+ */
+#define PC302_DMA_REQ_CHANNEL(__N)                   (0x0101 << (__N))
+
+/* Miscellaneous registers */
+#define PC302_DMA_CONFIGURATION_REG_OFFSET           (0x398)
+#define PC302_DMA_CHANNEL_ENABLE_REG_OFFSET          (0x3a0)
+#define PC302_DMA_ID_REG_OFFSET                      (0x3a8)
+#define PC302_DMA_TEST_REG_OFFSET                    (0x3b0)
+
+/* DMA configuration (DmaCfgReg) register bits */
+#define PC302_DMA_ENABLE                             (0x01)
+/* bits 1:63 are unused */
+
+/* Channel (ChEnReg) enable/disable bits
+ * Bits 0:PC302_DMA_CHANNELS-1  = enable/disable
+ * Bits PC302_DMA_CHANNELS:7    = reserved
+ * Bits 8:7+PC302_DMA_CHANNELS  = Corresponding write enable bit
+ * Bits 8+PC302_DMA_CHANNELS:63 = unused
+ */
+#define PC302_DMA_ENABLE_CHANNEL(__N)                (0x0101 << (__N))
+#define PC302_DMA_DISABLE_CHANNEL(__N)               (0x0100 << (__N))
+#define PC302_DMA_CHANNEL(__N)                       (0x01 << (__N))
+
+/* Channels per controller */
+#define PC302_DMA_CHANNELS                           (8)
+
+/* Hardware handshaking interfaces per controller */
+#define PC302_DMA_HANDSHAKING_IFS                    (8)
+
+/* Four DMA masters per controller */
+#define PC302_DMA_MASTERS                            (4)
+
+/* Two DMAs in the system */
+#define PC302_NUM_OF_DMAS                            (2)
+
+#endif /* __PC302_DMA_H__ */
diff --git a/arch/arm/mach-pc302/include/mach/dmac_cpe302_main.h b/arch/arm/mach-pc302/include/mach/dmac_cpe302_main.h
new file mode 100644
index 0000000..115f267
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/dmac_cpe302_main.h
@@ -0,0 +1,913 @@
+/*******************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ ******************************************************************************/
+/*!
+ * \file dmac_cpe302_main.h
+ * \brief This module provides the interface to the low level DMA functionality.
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All inquiries to support@picochip.com
+ *
+ * Introduction
+ * ------------
+ *
+ * This is an informal description of the software interface for the PC302 DMA
+ * driver. This API allows kernel modules to access the DMA capabilities of the
+ * PC302. No user space interface to the DMA driver is provided. The API is
+ * loosely based on the PC102 8560 DMA driver interfaces with the addition of
+ * the standard Linux ARM framework support.
+ *
+ * Glossary
+ * --------
+ *
+ * Transfer -       A DMA transfer is the entire operation of moving data from
+ *                  one place to another, from start to finish. It is made up
+ *                  of 1 or more blocks, i.e. single vs multi-block.
+ *
+ * Block -          The transfer of a number of data items. The size of the
+ *                  block can be controlled either by the sending or receiving
+ *                  end or by the DMA controller itself. Blocks can be scatter/
+ *                  gather. A DMA transfer can be multi-block if either a multi-
+ *                  block transfer list is used or if auto-reloading at one end
+ *                  of the transfer is employed.
+ *
+ * Transaction -    For efficiency a number of data items can be moved at one
+ *                  time. This is also called Burst Transaction. A Block (or
+ *                  scatter / gather region) can be a whole number of
+ *                  transactions in size in which case it fits neatly into a
+ *                  number of burst transactions. Otherwise smaller transactions
+ *                  are needed at the end of the block. These single
+ *                  transactions transfer a single data item at one time.
+ *
+ * Transfer Width - The number of bytes in a data item.
+ *
+ * Handshaking -    In order to progress the movement of data, handshaking
+ *                  signals to the DMA hardware tell it when to start a new
+ *                  transaction. The handshaking signal can be generated in
+ *                  hardware (by a peripheral hardware signal), or by software
+ *                  (by setting a bit in a register).
+ *
+ * Notes:
+ *   The references to scatter / gather in these source files are inherited from
+ *   the Synopsys documentation. They are used in linked list multi-block
+ *   transfers and are equivalent to the term 'Striding' used in other DMA
+ *   controllers.
+ *
+ * References
+ * ----------
+ *
+ * The information in this document needs to be read along side the
+ * DesignWare DW_ahb_dmac Databook Version 2.11a April 11, 2008 Synopsys
+ *
+ * High Level interfaces
+ * ---------------------
+ *
+ * The driver software is layered as follows:
+ *
+ *                     -----------------------------------
+ *                     | One or more client applications |
+ *                     -----------------------------------
+ *                     |         PC302 DMA API           |
+ *                     -----------------------------------
+ *                     |         PC302 Hardware          |
+ *                     -----------------------------------
+ *
+ *****************************************************************************/
+
+#ifndef __DMAC_CPE302_MAIN_H__
+#define __DMAC_CPE302_MAIN_H__
+
+/*******************************************************************************
+ * Macros
+ ******************************************************************************/
+
+/*!
+ *  \brief Main flags used to configure optional transfer parameters
+ *
+ *  Flag values for setting the channel priority. Used in functions
+ *  pc302_dma_setup_direct_xfr() and pc302_dma_setup_list_xfr().
+ *  PC302_DMA_CH_PRIOR_7 is the highest priority and
+ *  PC302_DMA_CH_PRIOR the lowest.
+ */
+#define PC302_DMA_CH_PRIOR_0      (0x00000000)
+#define PC302_DMA_CH_PRIOR_1      (0x00000001)
+#define PC302_DMA_CH_PRIOR_2      (0x00000002)
+#define PC302_DMA_CH_PRIOR_3      (0x00000003)
+#define PC302_DMA_CH_PRIOR_4      (0x00000004)
+#define PC302_DMA_CH_PRIOR_5      (0x00000005)
+#define PC302_DMA_CH_PRIOR_6      (0x00000006)
+#define PC302_DMA_CH_PRIOR_7      (0x00000007)
+/*!
+ *  Flag values used to set the channel protection.
+ */
+#define PC302_DMA_PROTCTL_0       (0x00000000)
+#define PC302_DMA_PROTCTL_1       (0x00000010)
+#define PC302_DMA_PROTCTL_2       (0x00000020)
+#define PC302_DMA_PROTCTL_3       (0x00000030)
+/*!
+ *  Optional flag used to configure the internal DMA FIFO mode. When set a
+ *  transfer will only be requested or started when at least half the FIFO is
+ *  empty or full depending on the direction of transfer, or this is the end
+ *  of a burst transaction.
+ *  When unset (the default) a transfer is requested or started if there is
+ *  sufficient space or data available for a single transfer.
+ */
+#define PC302_DMA_FIFO_WAIT      (0x00000100)
+/*!
+ *  Optional flag for configuring the DMA Flow Control Mode. When unset (the
+ *  default), source transactions are processed as soon as they occur.
+ *  When set source transactions are not processed until after a destination
+ *  request has been received. The idea of this mode is that only data that can
+ *  transferred to the destination channel is read from the source.
+ */
+#define PC302_DMA_DST_WAIT       (0x00000200)
+
+/*******************************************************************************
+ * External Data structures & types
+ ******************************************************************************/
+
+/*!
+ * \brief This enum defines the flags that can be used to set the debugging
+ * level for a DMA
+ */
+typedef enum
+{
+    /** Report warning conditions only such as a unexpected return parameter */
+    PC302_DMA_LVL_WARNING,
+
+    /** Report normal but significant conditions */
+    PC302_DMA_LVL_NOTICE,
+
+    /** Provide informational messages such as external API calls */
+    PC302_DMA_LVL_INFO,
+
+    /** Provide debug level messages such as key register values */
+    PC302_DMA_LVL_DEBUG,
+
+    /** Provide trace messages such as internal function calls */
+    PC302_DMA_LVL_TRACE,
+
+    /** Provide register IO trace messages */
+    PC302_DMA_LVL_TRACE_IO
+} pc302_dma_lvl_t;
+
+/*!
+ * \brief This structure defines the context of the driver.
+ * It holds the internal state of the driver and is purposely hidden from
+ * client code.
+ */
+typedef struct pc302_dma_tag *pc302_dma_t;
+
+/*!
+ * \brief This structure defines the handle for representing a dma transfer.
+ * Internally it will hold a channel number and the state of the channel.
+ * It is hidden from the client code.
+*/
+typedef struct pc302_dma_xfr_tag *pc302_dma_xfr_t;
+
+/*!
+ * \brief This structure contains the context of a DMA multi-block list.
+ * It holds all internal state of the list and is hidden from client code.
+ */
+typedef struct pc302_dma_list_tag *pc302_dma_list_t;
+
+/*!
+ * \brief This enum defines the type of source or destination endpoint
+ */
+typedef enum
+{
+    /** Endpoint type is a source */
+    PC302_DMA_SRC,
+
+    /** Endpoint type is a destination */
+    PC302_DMA_DST
+} pc302_dma_endpoint_type_t;
+
+/*!
+ * /brief This enum selects the bus master to use for the transfer.
+ * It is used to define the CTLx.SMS and CTLx.DMS bits.
+ */
+typedef enum
+{
+    PC302_DMA_MASTER1     = 0x0,
+    PC302_DMA_MASTER2     = 0x1,
+    PC302_DMA_MASTER3     = 0x2,
+    PC302_DMA_MASTER4     = 0x3,
+} pc302_master_t;
+
+/*!
+ * \brief This enum determines how the address (source or destination) will be
+ * incremented after each read or write. It is used to define the CTLx.SINC and
+ * DINC bits.
+ */
+typedef enum
+{
+    /** Increment the address pointer between reads / writes */
+    PC302_DMA_ADDR_INCREMENT = 0x0,
+
+    /** Decrement the address pointer between reads / writes */
+    PC302_DMA_ADDR_DECREMENT = 0x1,
+
+    /** Do not increment or decrement the pointer between reads / writes.
+        (Scatter / gather is disabled with this option) */
+    PC302_DMA_ADDR_NO_CHANGE = 0x2
+} pc302_increment_t;
+
+/*!
+ * \brief This enum sets the bus width (in bits) to use for the transfer.
+ * It is used to define the CTLx.SRC_TR_WIDTH and DST_TR_WIDTH bits.
+ */
+typedef enum
+{
+    /** Use a bus width of 8 bits */
+    PC302_DMA_TR_WIDTH8 = 0x0,
+
+    /** Use a bus width of 16 bits */
+    PC302_DMA_TR_WIDTH16 = 0x1,
+
+    /** Use a bus width of 32 bits */
+    PC302_DMA_TR_WIDTH32 = 0x2,
+
+    /** Use a bus width of 64 bits */
+    PC302_DMA_TR_WIDTH64 = 0x3
+} pc302_tr_width_t;
+
+/*!
+ * \brief This enum sets the burst transaction length (in bytes) to use.
+ * The maximum size of the burst is limited by the FIFO size in hardware.
+ * It is used to define the CTLx.SRC_MSIZE and DST_MSIZE bits.
+ */
+typedef enum
+{
+    /** Use a burst transaction size of 1 byte */
+    PC302_DMA_MS_1_TRW = 0x0,
+
+    /** Use a burst transaction size of 4 bytes */
+    PC302_DMA_MS_4_TRW = 0x1,
+
+    /** Use a burst transaction size of 8 bytes */
+    PC302_DMA_MS_8_TRW = 0x2,
+
+    /** Use a burst transaction size of 16 bytes */
+    PC302_DMA_MS_16_TRW = 0x3,
+
+    /** Use a burst transaction size of 32 bytes. This is the maximum size
+        permitted */
+    PC302_DMA_MS_32_TRW = 0x4,
+
+    /** Automatic setting of the burst transaction. With this option the burst
+        transaction Length will be set according to the number of bytes (the
+        count) to be transferred and the chosen transfer width. The burst length
+        is chosen to minimise the total number of transactions, that is the
+        number of burst transactions plus the number of single transactions
+        required to complete the transfer. */
+    PC302_DMA_MS_AUTO
+} pc302_msize_t;
+
+/*!
+ * \brief This structure is used to specify the scatter/gather parameters of a
+ * channel. This information is required when a transfer is set up and is used
+ * in the * SGRx and DSRx registers. Note, these SG settings apply to the entire
+ * DMA transfer i.e. all blocks of a multi block transfer (where enabled).
+ */
+typedef struct
+{
+    /** Length of the scatter / gather frame in bytes */
+    unsigned int count;
+
+    /** The number of bytes between frames */
+    unsigned int interval;
+} pc302_dma_sg_t;
+
+/*!
+ * /brief This structure is used to specify the hardware handshaking for the
+ * source or destination of a DMA transfer. The data is used to setup the
+ * CFGx registers. If the handshaking is not setup for a transfer (by not
+ * calling pc302_dma_setup_handshaking()), the DMA will default to software
+ * handshaking.
+ */
+typedef struct
+{
+    /** The handshaking interface to be used * (0-(DMA_HANDSHAKING_IFS-1)) */
+    unsigned int hwInterface;
+
+    /** The polarity of the handshaking, 1 for active low. */
+    int active_low;
+} pc302_dma_handshake_t;
+
+/*!
+ * /brief This enum contains bit flags used to define the interrupt types to be
+ * enabled, disabled or queried. Each field is a bit-mask that can be logically
+ * ORed together to specify more than one interrupt type.
+ */
+typedef enum
+{
+    /** Generate an interrupt on DMA block transfer completion to the
+        destination endpoint. If this interrupt is enabled and the DMA is a
+        multi-block type (either via multi-block list or auto-reloading), then
+        the DMA will wait after transferring each block for this interrupt to be
+        cleared. */
+    PC302_DMA_INT_BLOCK           = 1,
+
+    /** Generate an interrupt on completion of the last transfer to the
+        destination endpoint that concludes a transaction (single or burst).
+        It is triggered by software or hardware handshaking, and is typically
+        used in software handshaking to generate a request for the next
+        transaction. */
+    PC302_DMA_INT_DST_TRANSACTION = 2,
+
+    /** Interrupt set when an ERROR response is received by the DMA.
+        The transfer is canceled and the channel disabled. */
+    PC302_DMA_INT_ERROR           = 4,
+
+    /** Generate an interrupt on DMA block transfer completion from the
+        source endpoint. If this interrupt is enabled and the DMA is a
+        multi-block type (either via multi-block list or auto-reloading), then
+        the DMA will wait after transferring each block for this interrupt to be
+        cleared. */
+    PC302_DMA_INT_SRC_TRANSACTION = 8,
+
+    /** Interrupt generated on DMA transfer completion to the destination
+        endpoint */
+    PC302_DMA_INT_TRANSFER        = 16,
+
+    /** Enable all  interrupt types. */
+    PC302_DMA_INT_ALL             = 31,
+} dma_int_type_t;
+
+/*!
+ * \brief This type is used to specify the source or destination of a DMA
+ * transfer
+ *
+ * At its simplest, it holds the physical address of the data buffer. This data
+ * is used to configure the source/destination address and control registers
+ * (SARx, DARx and CTLx). This does not control the channel configuration or
+ * scatter/gather registers (see note 3). The structure is used in configuring
+ * single or multi-block list type transfers as the information within is used
+ * in each element of the multi-block list.
+ *
+ * Notes
+ * 1. Either the source or destination can be the flow controller, or neither
+ *  but not both. If neither is the flow controller, the DMA is defaulted to be
+ *  the controller. The flow controller will determine the block size
+ *  transferred. If a flow controller is assigned which employs hardware
+ *  handshaking the 'count' size specified by pc302_dma_setup_direct_xfr() or
+ *  pc302_dma_list_add() is ignored. A memory endpoint cannot be a flow
+ *  controller. The memory endpoint does not require handshaking (hardware or
+ *  software) and will proceed to transfer immediately without waiting for a
+ *  transaction request.
+ *
+ * 2. Auto reload mode and direct transfers. If auto-reload is set for either
+ *  the source or destination end points (or both), the transfer will restart
+ *  again at the end of the last transaction. The transfer will be one-time only
+ *  if both source and destination auto_reload is false. If one of the end
+ *  points is not set to auto-reload (but the other is), its physical address
+ *  will not be reloaded. Instead the address used will continue from where it
+ *  stopped at the end of the last transaction. This is known as continuous
+ *  mode.
+ *
+ * 3. Auto reload and list transfers. When applied to multi-block lists, either
+ *  the source or destination (but not both) end points can be set to
+ *  auto_reload. Only the first block of a multi-block list can be set when its
+ *  auto_reload flags is true. Thereafter the end point must not be set in the
+ *  subsequent blocks of the list (pass NULL as the pc302_dma_list_add endpoint
+ *  param). If the first element of the multi-block list is the only one with
+ *  the end points set but the auto_reload flag is not set, the DMA will be in
+ *  continuous mode where the physical address will continue from the end of the
+ *  last block.
+ *
+ * 4. The auto_reload information is set in the configuration register. This is
+ *  the only information passed to that register from this structure. All other
+ *  data goes into the writing the control register.
+ *
+ * 5. Scatter/Gather will not be enabled unless the SG parameters are set by
+ *  calling pc302_dma_setup_sg().
+ */
+typedef struct
+{
+    /** Physical address of the data */
+    dma_addr_t dma_addr;
+
+    /** The interface layer used for communications */
+    pc302_master_t master;
+
+    /** True if the endpoint is peripheral not memory */
+    int periph_not_mem;
+
+    /** True if the endpoint is the flow controller */
+    int flow_controller;
+
+    /** True if Scatter/gather enabled */
+    int enable_sg;
+
+    /** Increment/decrement or fixed addr */
+    pc302_increment_t addr_inc;
+
+    /** The endpoint Transfer Width */
+    pc302_tr_width_t tr_width;
+
+    /** The Burst Transaction size */
+    pc302_msize_t msize;
+
+    /** True if auto-reload the physical address at end of block */
+    int auto_reload;
+} pc302_dma_endpoint_t;
+
+/*!
+ * /brief Definition of the callback function to be used by client applications
+ * to receive transfer data
+ */
+typedef void (dma_fn_t)(void *client_data,pc302_dma_xfr_t xfr, \
+    dma_int_type_t int_type);
+
+/*******************************************************************************
+ * Public function declarations
+ *****************************************************************************/
+
+/*!
+ * \brief Set up a DMA transfer between source and destination.
+ *
+ * The DMA set up by this call will not start transferring data until
+ * pc302_dma_start() is called.
+ *
+ * The data structure pointed to by the src and dst parameters are copied
+ * by the call so can be destroyed once the call returns.
+ *
+ * The DMA channel set up by this call will have:
+ *  - All interrupts disabled
+ *  - Channel disabled but not suspended
+ *  - Source and Destination address set to the parameters
+ *  - Single block transfer mode
+ *  - Transfer size set to count
+ *  - Source and Destination Master interface set to the parameters
+ *  - Transfer Type and Flow control set according to parameters
+ *  - No Scatter or Gather.
+ *  - Source/Dest Burst Length set according to parameters
+ *  - Source/Dest address increment set according to parameters
+ *  - Source/Dest Transfer Width set according to parameters
+ *  - Protocol Control set according to flags
+ *  - Transfer FIFO mode set according to flags
+ *  - Data pre-fetching is set according to flags
+ *  - Automatic source/destination reload set by the parameters
+ *  - Channel priority set according to flags
+ *  - Source/Dest handshaking setup according to parameters.
+ *
+ * If neither the src or dst are auto-reload, the transfer setup by this call is
+ * once only and will stop when the data has been transferred. Multi-block
+ * transfers will wait between blocks if the block interrupt is enabled.
+ *
+ * The 'count' parameter is used in one of three ways:
+ * 1. If neither end of the transfer is a flow controller (the DMA engine is
+ *    flow controller), the count parameter is used to set the block size in the
+ *    DMA control register.
+ * 2. If one end of the transfer is the flow controller and has hardware
+ *    handshaking, the count is ignored as the flow controller will control the
+ *    amount of data in the block.
+ * 3. If one end of the transfer is a flow controller but software handshaking
+ *    is used, the count parameter is ignored. In this situation client software
+ *    may not know the size of the block at the point when the transfer is
+ *    setup. The bytes_left parameter of pc302_dma_request_transaction function
+ *    is used to tell the driver the data left in the block when each
+ *    transaction is requested. pc302_dma_request_transaction() can then decide
+ *    the type of transaction to request.
+ *
+ * \param dma The dma handle
+ * \param src Transfer source details
+ * \param dst Transfer destination details
+ * \param src_handshake The handshaking parameters for transfer source or NULL
+ *                      if hardware handshaking is not used
+ * \param dst_handshake The handshaking parameters for transfer destination or
+ *                      NULL if hardware handshaking is not used.
+ * \param count The number of bytes to transfer. If either end of the transfer
+ *              is a hardware handshaking flow controller, this is ignored.
+ * \param Flags. A logical OR of one or more of the following flags:
+ *               PC302_DMA_PROTCTL_0   - Sets the PROTCTL bits (only 1 of these
+ *               PC302_DMA_PROTCTL_1     may be selected)
+ *               PC302_DMA_PROTCTL_2
+ *               PC302_DMA_PROTCTL_3
+ *               PC302_DMA_FIFO_MODE   - Sets the FIFO mode
+ *               PC302_DMA_FC_MODE     - Sets the Flow Control mode
+ *               PC302_DMA_CH_PRIOR_0  \
+ *               PC302_DMA_CH_PRIOR_1
+ *               PC302_DMA_CH_PRIOR_1  - Sets the channel priority
+ *               PC302_DMA_CH_PRIOR_2    from PC302_DMA_CH_PRIOR_0
+ *               PC302_DMA_CH_PRIOR_3    (lowest) to
+ *               PC302_DMA_CH_PRIOR_4    PC302_DMA_CH_PRIOR_7
+ *               PC302_DMA_CH_PRIOR_5    (highest)
+ *               PC302_DMA_CH_PRIOR_6
+ *               PC302_DMA_CH_PRIOR_7  /
+ * \param Cookie Pointer to be returned as client data in the callback function
+ *
+ * \return Handle to the new transfer created or NULL if something went wrong.
+ */
+pc302_dma_xfr_t
+pc302_dma_setup_direct_xfr(pc302_dma_t dma,
+			   pc302_dma_endpoint_t *src,
+			   pc302_dma_endpoint_t *dst,
+                           pc302_dma_handshake_t *src_handshaking,
+                           pc302_dma_handshake_t *dst_handshaking,
+                           unsigned int count,
+                           unsigned int flags,
+                           dma_fn_t *handler,
+                           void *cookie);
+
+/*!
+ * \brief Reuse a DMA prevoisly configured transfer handle
+ *
+ * This function can be used to reuse a transfer handle previously setup for
+ * a direct transfer. The function will accept new endpoint structures and
+ * a new transfer size, but does not update any other parameters. It is
+ * therefore useful for repeated DMA transters using the same DMA channel and
+ * hardware configuration. The function circumvents the need to free the transfer
+ * handle using pc302_dma_release and then re-creating it with
+ * pc302_dma_setup_direct_xfr between each transfer.
+ *
+ * Notes
+ * 1. This function does not perform any parameter checking, so must be used
+ *  with extreme caution.
+ * 2. The handle must first be created with pc302_dma_setup_direct_xfr
+ * 3. The handle must be desroyed after use with pc302_dma_release
+ *
+ * \param dma The transfer handle
+ * \param src Transfer source details
+ * \param dst Transfer destination details
+ * \param count The number of bytes to transfer. If either end of the transfer
+ *              is a hardware handshaking flow controller, this is ignored.
+ *
+ * \return 0 on success, or EINVAL if an error was detected
+ */
+int
+pc302_dma_reuse_direct_xfr(pc302_dma_xfr_t dma_xfr,
+                           pc302_dma_endpoint_t *src,
+                           pc302_dma_endpoint_t *dst,
+                           unsigned count);
+
+/*!
+ * \brief Start a DMA transfer on a channel previously set up with the
+ * pc302_dma_setup_direct_xfr() or pc302_dma_setup_list_xfr() functions.
+ *
+ * Once started, the transfer is locked and will not be modifiable. This
+ * includes a DMA multi-block list that is associated with a transfer. Transfers
+ * will continue to completion asynchronously. Once finished, they can be
+ * restarted.
+ *
+ * \param dma_xfr The transfer handle.
+ *
+ * \return OK on success, EINVAL if the transfer is already running
+ */
+int
+pc302_dma_start(pc302_dma_xfr_t dma_xfr);
+
+/*!
+ * \brief Abort a DMA transfer.
+ *
+ * Once aborted, the transfer can be restarted. Also the transfer can be
+ * modified once aborted. If the transfer is restarted, it will continue from
+ * the start of the single transfer buffer or multi-block list.
+ *
+ * \param dma_xfr The transfer handle.
+ *
+ * \return OK on success, or EINVAL if the transfer is not running
+ */
+int
+pc302_dma_abort(pc302_dma_xfr_t dma_xfr);
+
+/*!
+ * \brief Stop a DMA transfer and release resources.
+ *
+ * Once released, the transfer can not be restarted and has to be setup once
+ * more. The transfer handle will become invalid on exit of this function.
+ *
+ * \param dma_xfr The transfer handle.
+ */
+void
+pc302_dma_release(pc302_dma_xfr_t dma_xfr);
+
+/*!
+ * \brief Set a debug level for the DMA handle
+ *
+ * Default debug levels for all DMA handles may be specified at compile time
+ * using the macro CONFIG_PC302_DMA_DEBUG. This function will change the debug
+ * level for the DMA specified.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param lvl The debug level to apply. Can be any of pc302_dma_lvl_t
+ */
+void
+pc302_dma_set_debug_level(pc302_dma_t dma,
+                          pc302_dma_lvl_t lvl);
+
+/*!
+ * \brief Allocate the list for multi-block transfers.
+ *
+ * The heap memory is utilised and the list is initialised. The length of the
+ * list allocated is set at the calling time.
+ *
+ * \param Count The maximum number of elements to the list.
+ *
+ * \return Handle of the newly allocated list
+ */
+pc302_dma_list_t
+pc302_dma_list_create(pc302_dma_t dma,
+                      unsigned int count);
+
+/*!
+ * \brief Add an entry to the end of a DMA multi-block list.
+ *
+ * The entry added to the list specifies a simple block transfer. The data
+ * pointed to by the src and dst parameters are copied by the call so can be
+ * destroyed once the call returns. This function will not modify a list that is
+ * currently in use with a DMA operation.
+ *
+ * The first element of the list must have both src and dst endpoints. If either
+ * endpoint (not both) is to be continuous, subsequent elements need to set the
+ * endpoint to NULL. If either endpoint (not both) is to be auto-reload, the
+ * first element needs to set the auto_reload flag and subsequent elements need
+ * to set the endpoint to NULL.
+ *
+ * Note: Each block of the list can set a transfer width. Transfer width affects
+ * the setting of scatter/gather which is set globally for the transfer.
+ * Scatter / gather is setup in the hardware based on the transfer widths of the
+ * first element of the block list. It is recommended that subsequent blocks use
+ * the same transfer width (if SG is enabled), otherwise there will be undefined
+ * effects.
+ *
+ * \param list The DMA multi-block list to add a new block to
+ * \param src The source DMA endpoint parameters, or NULL if auto-reload or
+ *            continuous modes selected
+ * \param dst The destination endpoint parameters,or NULL if auto-reload or
+ *            continuous modes selected
+ * \param count The number of bytes to transfer. If either end of the transfer
+ *              is a hardware flow controller this parameter is ignored.
+ *
+ * \return ENOMEM The list is full, no more items can be added
+ *         EBUSY  If the list is in use with a DMA transfer
+ *         ENOMEM The list is full, no more items can be added
+ *         EBUSY  If the list is in use with a DMA transfer
+ *         EINVAL The combination of source and destination endpoints is invalid
+ */
+int
+pc302_dma_list_add(pc302_dma_list_t list,
+                   pc302_dma_endpoint_t *src,
+                   pc302_dma_endpoint_t *dst,
+                   pc302_dma_handshake_t *src_handshaking,
+                   pc302_dma_handshake_t *dst_handshaking,
+                   unsigned int count);
+
+/*!
+ * \brief Reset a list to the state that it was in just after it was created
+ * with pc302_dma_list_create().
+ *
+ * This function does not free the memory associated by the list, and it will
+ * not modify a list that is currently in use with a DMA operation.
+ *
+ * \param list The DMA list returned from pc302_dma_list_create
+ *
+ * \return 0 on success, or EBUSY If the list is in use with a DMA transfer
+ */
+int
+pc302_dma_list_clear(pc302_dma_list_t list);
+
+/*!
+ * \brief Frees the resources allocated by a list.
+ *
+ * Lists need to be freed after use to avoid a memory leak. This function will
+ * not modify a list that is currently in use with a DMA operation.
+ *
+ * \param list The DMA list returned from pc302_dma_list_create()
+ *
+ * \return 0 on success, OR EBUSY If the list is in use with a DMA transfer
+ */
+int
+pc302_dma_list_destroy(pc302_dma_list_t list);
+
+/*!
+ * \brief Set up a multi-block DMA transfer.
+ *
+ * The transfer is controlled by the list provided. The DMA list can be modified
+ * once this function has been called but when the DMA operations is started
+ * (by calling pc302_dma_start) the list will be locked and any attempt to
+ * modify it will not be allowed. Data transfer is not started until the
+ * pc302_dma_start() is called. The transfer setup by this call is multi-block
+ * only and will stop when the end of the multi-block list is reached. In
+ * addition the transfer will wait between blocks if the block interrupt is
+ * enabled. Source and destination handshaking is setup according to the
+ * parameters.
+ *
+ * \param list The DMA multi-block list containing the data blocks
+ *             to be transferred.
+ * \param src_handshake The handshaking parameters for transfer source or NULL
+ *                      if hardware handshaking is not used
+ * \param dst_handshake The handshaking parameters for transfer destination or
+ *                      NULL if hardware handshaking is not used.
+ * \param flags A logical OR of one or more flags:
+ *            PC302_DMA_PROTCTL_0   - Sets the PROTCTL bits (only one of these)
+ *            PC302_DMA_PROTCTL_1
+ *            PC302_DMA_PROTCTL_2
+ *            PC302_DMA_PROTCTL_3
+ *            PC302_DMA_FIFO_MODE   - Sets the FIFO mode
+ *            PC302_DMA_FC_MODE     - Sets the Flow Control mode
+ *            PC302_DMA_CH_PRIOR_0  \
+ *            PC302_DMA_CH_PRIOR_1
+ *            PC302_DMA_CH_PRIOR_1  - Sets the channel priority
+ *            PC302_DMA_CH_PRIOR_2    from PC302_DMA_CH_PRIOR_0
+ *            PC302_DMA_CH_PRIOR_3    (lowest) to
+ *            PC302_DMA_CH_PRIOR_4    PC302_DMA_CH_PRIOR_7
+ *            PC302_DMA_CH_PRIOR_5    (highest)
+ *            PC302_DMA_CH_PRIOR_6
+ *            PC302_DMA_CH_PRIOR_7  /
+ * \param cookie Pointer to be returned as client data in callback function
+ *
+ * \return 0 on success, or
+ *         ENOMEM No enough resources to complete the call
+ *         EBUSY  If the list is already in use with a DMA transfer
+ *         EINVAL Combination of parameters is illegal.
+ */
+pc302_dma_xfr_t
+pc302_dma_setup_list_xfr(pc302_dma_list_t list,
+                         pc302_dma_handshake_t *src_handshaking,
+                         pc302_dma_handshake_t *dst_handshaking,
+                         unsigned int flags,
+                         dma_fn_t *handler,
+                         void *cookie);
+
+/*!
+ * \brief Get the handle of specified of the PC302 DMA.
+ *
+ * This handle is to be used as a parameter to all other driver API functions.
+ *
+ *\param dmaNumber The DMA number, (0 or 1)
+ *
+ * return DMA handle, or NULL on error
+ */
+pc302_dma_t
+pc302_dma_get_dma_handle(int controller);
+
+/*!
+ * \brief Enable interrupt generation of a number of types of interrupt on a DMA
+ * transfer.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param int_types The types of interrupt, any logical OR combination of
+ *                 bit field in enum dma_int_type_t
+ */
+void
+pc302_dma_enable_int(pc302_dma_xfr_t dma_xfr,
+                     unsigned int_types);
+
+/*!
+ * \brief Disable interrupt generation of a number of types of interrupt on a
+ * DMA transfer.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param int_types The types of interrupt, any logical OR combination of
+ *                  bit field in enum dma_int_type_t
+ */
+void
+pc302_dma_disable_int(pc302_dma_xfr_t dma_xfr,
+                      dma_int_type_t int_types);
+
+/*!
+ * \brief Clears a number of interrupt status bits, ready for new interrupt
+ * generation.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param int_types The types of interrupt, any logical OR combination of
+ *                  bit field in enum dma_int_type_t
+ */
+void
+pc302_dma_clear_int(pc302_dma_xfr_t dma_xfr,
+                    dma_int_type_t int_types);
+
+/*!
+ * \brief Get the raw status of a DMA transfer
+ *
+ * This function can be used to see if one or more of the specified interrupts
+ * have become set. The value returned is a logical OR of the dma_int_type_t
+ * type, and can by used by the client application as a polling function.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param int_types The types of interrupt, any logical OR combination of
+ *                  bit field in enum dma_int_type_t
+ *
+ * \return A bit mask where a '1' bit indicates the status type is set.
+ *         Any combination int_types is permitted
+ */
+unsigned int
+pc302_dma_get_raw_status(pc302_dma_xfr_t dma_xfr,
+                         dma_int_type_t int_types);
+
+/*!
+ * \brief This function is used to setup the scatter or gather parameters of a
+ * DMA transfer.
+ *
+ * If SG is not setup, the DMA transfer defaults to switching the SG capability
+ * off. The following diagram and note describes how the parameters in
+ * pc302_dma_sg_t configure the scatter / gather.
+ *
+ *                      |                   |
+ *                      |                   |
+ *                      |-------------------|   ^
+ *                      |    frame 0        |   |-- count (bytes)
+ *                   ^  |-------------------|   v
+ *       interval  --|  |                   |
+ *        (bytes)    |  |                   |
+ *                   |  |                   |
+ *                   |  |                   |
+ *                   v  |-------------------|
+ *                      |    frame 1        |
+ *                      |-------------------|
+ *                      |                   |
+ *                      |                   |
+ *
+ * Note the alignment of the interval (sg_stride) and count (sg_count) settings
+ * for a transfer affect the automatic Burst Transaction Length settings as the
+ * hardware has to be set up for transfer in bursts. Both count (the number of
+ * bytes to scatter or gather) and stride (the interval between frames) must be
+ * a multiple of the Transfer Width of the endpoint. To achieve this the
+ * sg_count and sg_stride will values will be truncated as necessary.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param sg The scatter / gather  parameters
+ * \param src_dst 1 for source, and 0 for destination scatter / gather.
+ *
+ * \return 0 on success, or EBUSY if the DMA transfer is in progress and so
+ *         cannot be modified at this time
+ *
+ */
+int
+pc302_dma_setup_sg(pc302_dma_xfr_t dma_xfr,
+                   pc302_dma_sg_t *sg,
+                   pc302_dma_endpoint_type_t src_dst);
+
+/*!
+ * \brief Request a new transaction on the source or destination of a transfer.
+ *
+ * The DMA endpoint (source or destination) needs to be configured for software
+ * handshaking, otherwise this function has no effect. For flow controlling
+ * endpoints the type of transaction, burst, single or last is calculated from
+ * the bytes_left parameter. For non-flow controlling endpoints the type of
+ * transfer is calculated by the hardware (the endpoint enters the single
+ * transaction region automatically).
+ *
+ * Notes:
+ * 1. When requesting transactions of a flow controlling endpoint the bytes_left
+ * parameter can be set to a high value (say 1000) if it is not known how big
+ * the block is. This will cause burst endpoints.
+ *
+ * 2. Once the size of the block is known the bytes_left should be set
+ * appropriately. The bytes_left will be updated by the function and the new
+ * updated value should be used in the next call to this function.
+ *
+ * 3. Once the block size is known client code should continue to call this
+ * function with the value of bytes_left returned from the previous call. The
+ * call must not revert to setting a high value (as in 1).
+ *
+ * 4. Client code should not call this function with zero bytes left if the last
+ * call specified many bytes left (as in 1). The reason is that the function
+ * needs to have prior knowledge of the end of the block so that it can set the
+ * last transaction flag on the last transaction.
+ *
+ * 5. The bytes_left must be divisible by the transfer width of the source and
+ * destination endpoints.
+ *
+ * 6. Burst transactions are chosen up to the point where the last burst
+ * transaction would spill over the end of the DMA buffer (size indicated by
+ * 'count'). Then single transactions are chosen for the remaining data.
+ * Finally, a last transaction is chosen for the final transaction.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param src_dst 1 for source and 0 for destination
+ * \param bytes_left The number of bytes left to transfer in the block. This is
+ *                   used only for flow controlling endpoints and is updated
+ *                   when the function returns. When this reached zero, no more
+ *                   transactions should be requested for this endpoint.
+ * \return 0 on success, or
+ *         EBUSY The DMA transfer is not in progress and so transaction cannot
+ *               be requested at this time.
+ *         EFAULT Something went wrong and the driver did not keep track of the
+ *                state of the hardware.
+ *         EINVAL The transfer is not running.
+ */
+int
+pc302_dma_request_transaction(pc302_dma_xfr_t dma_xfr,
+                              pc302_dma_endpoint_type_t src_dst,
+                              unsigned int *bytes_left);
+
+/*!
+ * \brief Output all DMA configuration registers for all channels, including the
+ * information held in multi-block lists.
+ *
+ * \param dma The DMA handle.
+ */
+void
+pc302_dma_dump_regs(
+    pc302_dma_t dma);
+
+#endif /* __DMAC_CPE302_MAIN_H__ */
+
diff --git a/arch/arm/mach-pc302/include/mach/entry-macro.S b/arch/arm/mach-pc302/include/mach/entry-macro.S
new file mode 100644
index 0000000..011e2e4
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/entry-macro.S
@@ -0,0 +1,57 @@
+/*
+ * entry-macro.S
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * Low-level IRQ helper macros for PC302 platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <mach/hardware.h>
+#include <mach/pc302/pc302.h>
+
+    .macro  disable_fiq
+    .endm
+
+    .macro  get_irqnr_preamble, base, tmp
+    .endm
+
+    .macro  arch_ret_to_user, tmp1, tmp2
+    .endm
+            /*                   r0       r6     r5   lr */
+    .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+    /* Set the base address of the VIC. */
+    ldr     \base,      =IO_ADDRESS(PC302_VIC1_BASE)
+
+    /* Read the status register. */
+    ldr     \irqstat,  [\base, #VIC_IRQ_STATUS_REG_OFFSET]
+    mov     \irqnr,     #0
+
+    /* Check for no interrupt. */
+    teq     \irqstat,   #0
+    beq     1003f               /*< There is no interrupt. */
+
+    /* Find the number of leading 0's and subtract from 31 to get the
+     * interrupt number. */
+    clz     \irqnr,     \irqstat
+    rsb     \irqnr,     \irqnr,     #31
+    b       1005f
+
+    /* Check the next VIC. This is exactly the same as above but with VIC0
+     * rather than VIC1. */
+1003:
+    ldr     \base,      =IO_ADDRESS(PC302_VIC0_BASE)
+    ldr     \irqstat,    [\base,     #VIC_IRQ_STATUS_REG_OFFSET]
+    mov     \irqnr,     #0
+    teq     \irqstat,   #0
+    beq     1005f   /* There is no interrupt. */
+    clz     \irqnr,     \irqstat
+    rsb     \irqnr,     \irqnr,     #31
+    add     \irqnr,     \irqnr,     #32
+1005:
+    .endm
+
diff --git a/arch/arm/mach-pc302/include/mach/gpio.h b/arch/arm/mach-pc302/include/mach/gpio.h
new file mode 100644
index 0000000..a58055e
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/gpio.h
@@ -0,0 +1,73 @@
+#ifndef __MACH_GPIO_H__
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define __MACH_GPIO_H__
+
+/* GPIO pin numbers are defined in linux/picochip/devices/pc302.h */
+#include <linux/picochip/devices/pc302.h>
+
+int
+gpio_is_valid( int gpio );
+
+int
+gpio_request( unsigned gpio,
+              const char *label );
+
+void
+gpio_free( unsigned gpio );
+
+int
+gpio_direction_input( unsigned gpio );
+
+int
+gpio_direction_output( unsigned gpio,
+                       int value );
+
+int
+gpio_cansleep( unsigned gpio );
+
+int
+gpio_export( unsigned gpio,
+             bool direction_may_change );
+
+int
+gpio_unexport( unsigned gpio );
+
+int
+gpio_get_value_cansleep( unsigned gpio );
+
+int
+gpio_set_value_cansleep( unsigned gpio,
+                         int value );
+
+int
+gpio_set_value( unsigned gpio,
+                int value );
+
+int
+gpio_get_value( unsigned gpio );
+
+int
+gpio_to_irq( unsigned gpio );
+
+int
+irq_to_gpio( unsigned irq );
+
+#endif /* __MACH_GPIO_H__ */
diff --git a/arch/arm/mach-pc302/include/mach/hardware.h b/arch/arm/mach-pc302/include/mach/hardware.h
new file mode 100644
index 0000000..7184117
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/hardware.h
@@ -0,0 +1,53 @@
+/*
+ *  hardware.h
+ *
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ *  This file contains the hardware definitions of the PC302 boards.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <mach/platform.h>
+
+#include <mach/pc302/axi2cfg.h>
+#include <mach/pc302/axi2pico.h>
+#include <mach/pc302/ebi.h>
+#include <mach/pc302/fuse.h>
+#include <mach/pc302/gpio.h>
+#include <mach/pc302/mem_arm.h>
+#include <mach/pc302/mem.h>
+#include <mach/pc302/mem_shd.h>
+#include <mach/pc302/pa.h>
+#include <mach/pc302/pc302.h>
+#include <mach/pc302/rtc.h>
+#include <mach/pc302/spa.h>
+#include <mach/pc302/ssi.h>
+#include <mach/pc302/timer.h>
+#include <mach/pc302/tzic.h>
+#include <mach/pc302/tzpc.h>
+#include <mach/pc302/uart.h>
+#include <mach/pc302/vic.h>
+#include <mach/pc302/wdog.h>
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x) (((x) & 0x00ffffff) | 0xfe000000)
+
+#endif
diff --git a/arch/arm/mach-pc302/include/mach/io.h b/arch/arm/mach-pc302/include/mach/io.h
new file mode 100644
index 0000000..444ad81
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/io.h
@@ -0,0 +1,33 @@
+/*
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)addr;
+}
+#define __io(a)	__io(a)
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+#endif
diff --git a/arch/arm/mach-pc302/include/mach/irqs.h b/arch/arm/mach-pc302/include/mach/irqs.h
new file mode 100644
index 0000000..cb5d80c
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/irqs.h
@@ -0,0 +1,79 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __IRQS_H__
+#define __IRQS_H__
+
+/*****************************************************************************/
+/* IRQ Index & Bit Field Manipulation                                        */
+/*****************************************************************************/
+
+/* VIC0 IRQ Indexes */
+#define IRQ_EMAC            31 + 32
+#define IRQ_NPMUIRQ         30 + 32
+#define IRQ_NDMAEXTERRIRQ   29 + 32
+#define IRQ_NDMASIRQ        28 + 32
+#define IRQ_NDMAIRQ         27 + 32
+#define IRQ_DMAC2           26 + 32
+#define IRQ_DMAC1           25 + 32
+#define IRQ_IPSEC           24 + 32
+#define IRQ_SRTP            23 + 32
+#define IRQ_AES             22 + 32
+#define IRQ_AXI2PICO8       21 + 32
+#define IRQ_AXI2PICO7       20 + 32
+#define IRQ_AXI2PICO6       19 + 32
+#define IRQ_AXI2PICO5       18 + 32
+#define IRQ_AXI2PICO4       17 + 32
+#define IRQ_AXI2PICO3       16 + 32
+#define IRQ_AXI2PICO2       15 + 32
+#define IRQ_AXI2PICO1       14 + 32
+#define IRQ_AXI2PICO0       13 + 32
+#define IRQ_AXI2CFG         12 + 32
+#define IRQ_WDG             11 + 32
+#define IRQ_SSI             10 + 32
+#define IRQ_AXI_RD_ERR      9  + 32
+#define IRQ_AXI_WR_ERR      8  + 32
+#define IRQ_TIMER3          7  + 32
+#define IRQ_TIMER2          6  + 32
+#define IRQ_TIMER1          5  + 32
+#define IRQ_TIMER0          4  + 32
+#define IRQ_COMMTX          3  + 32
+#define IRQ_COMMRX          2  + 32
+#define IRQ_SWI             1  + 32
+
+#define VIC0_IRQ_USED_MASK  0xFFFFFFFE00000000LLU
+
+/* VIC1 IRQ Indexes */
+#define IRQ_UART1           10
+#define IRQ_UART2           9
+#define IRQ_RTC             8
+#define IRQ_GPIO7           7
+#define IRQ_GPIO6           6
+#define IRQ_GPIO5           5
+#define IRQ_GPIO4           4
+#define IRQ_GPIO3           3
+#define IRQ_GPIO2           2
+#define IRQ_GPIO1           1
+#define IRQ_GPIO0           0
+
+#define VIC1_IRQ_USED_MASK  0x7FF
+
+#define NR_IRQS             64
+
+#endif /* __IRQS_H__ */
diff --git a/arch/arm/mach-pc302/include/mach/memory.h b/arch/arm/mach-pc302/include/mach/memory.h
new file mode 100644
index 0000000..2a6d56e
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/memory.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x00000000)
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+#endif
+
diff --git a/arch/arm/mach-pc302/include/mach/pc302/axi2cfg.h b/arch/arm/mach-pc302/include/mach/pc302/axi2cfg.h
new file mode 100644
index 0000000..7154aa5
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/axi2cfg.h
@@ -0,0 +1,260 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_AXI2CFG_H
+#define PC302_AXI2CFG_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define AXI2CFG_SYS_CONFIG_REG_OFFSET       0x0000
+#define AXI2CFG_JTAG_ISC_REG_OFFSET         0x0004
+#define AXI2CFG_IRQ_REG_OFFSET              0x0008
+#define AXI2CFG_PURGE_CFG_PORT_REG_OFFSET   0x000C
+#define AXI2CFG_DMA_CFG_REG_OFFSET          0x0010
+#define AXI2CFG_DEVICE_ID_REG_OFFSET        0x0014
+#define AXI2CFG_REVISION_ID_REG_OFFSET      0x0018
+#define AXI2CFG_AXI_ERR_ENABLE_REG_OFFSET   0x001C
+#define AXI2CFG_AXI_ERR_CLEAR_REG_OFFSET    0x0020
+#define AXI2CFG_AXI_ERR_MASK_REG_OFFSET     0x0024
+#define AXI2CFG_AXI_ERR_TEST_REG_OFFSET     0x0028
+#define AXI2CFG_AXI_ERR_RAW_REG_OFFSET      0x002C
+#define AXI2CFG_AXI_ERR_STATE_REG_OFFSET    0x0030
+#define AXI2CFG_CONFIG_WRITE_REG_OFFSET     0x0100
+#define AXI2CFG_CONFIG_READ_REG_OFFSET      0x0200
+#define AXI2CFG_DMAC1_CONFIG_REG_OFFSET     0x0300
+
+
+/*****************************************************************************/
+/* Register Bit Fields		                                             */
+/*****************************************************************************/
+
+#define AXI2CFG_SYS_CONFIG_PA_RST_IDX               30
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ       8
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_HI       23
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO       16
+#define AXI2CFG_SYS_CONFIG_RW_EBI_CLK_DISABLE_IDX   15
+#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX         14
+#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX           13
+#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX         12
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ           4
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_HI           11
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO           8
+#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX       7
+#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX         6
+#define AXI2CFG_SYS_CONFIG_RW_REMAP_IDX             5
+#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX            4
+#define AXI2CFG_SYS_CONFIG_CP15DISABLE_IDX          3
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX            2
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ             2
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_HI             1
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_LO             0
+
+#define AXI2CFG_SYS_CONFIG_PA_RST_MASK              1<<AXI2CFG_SYS_CONFIG_PA_RST_IDX
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_MASK         ((1<<AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ)-1)<<AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO
+#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_MASK        1<<AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX
+#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_MASK          1<<AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX
+#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_MASK        1<<AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_MASK         ((1<<AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ)-1)<<AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO
+#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK      1<<AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX
+#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_MASK        1<<AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX
+#define AXI2CFG_SYS_CONFIG_RW_REMAP_MASK            1<<AXI2CFG_SYS_CONFIG_RW_REMAP_IDX
+#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_MASK           1<<AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX
+#define AXI2CFG_SYS_CONFIG_CP15DISABLE_MASK         1<<AXI2CFG_SYS_CONFIG_CP15DISABLE_IDX
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_MASK           1<<AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_MASK           ((1<<AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ)-1)<<AXI2CFG_SYS_CONFIG_BOOT_MODE_LO
+
+#define AXI2CFG_DMAC1_CONFIG_DMA_WRITE_IDX          17
+#define AXI2CFG_DMAC1_CONFIG_FILL_LEVEL_SZ          7
+#define AXI2CFG_DMAC1_CONFIG_FILL_LEVEL_HI          16
+#define AXI2CFG_DMAC1_CONFIG_FILL_LEVEL_LO          10
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_SZ           7
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_HI           9
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_LO           3
+#define AXI2CFG_DMAC1_CONFIG_SNGL_IDX               2
+#define AXI2CFG_DMAC1_CONFIG_STATE_IDX              1
+#define AXI2CFG_DMAC1_CONFIG_ENABLE_IDX             0
+
+#define AXI2CFG_DMAC1_CONFIG_DMA_WRITE_MASK         1<<AXI2CFG_DMAC1_CONFIG_DMA_WRITE_IDX)
+#define AXI2CFG_DMAC1_CONFIG_FILL_LEVEL_MASK        ((1<<AXI2CFG_DMAC1_CONFIG_FILL_LEVEL_SZ)-1)<<AXI2CFG_DMAC1_CONFIG_FILL_LEVEL_LO
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_MASK         ((1<<AXI2CFG_DMAC1_CONFIG_WATERMARK_SZ)-1)<<AXI2CFG_DMAC1_CONFIG_WATERMARK_LO
+#define AXI2CFG_DMAC1_CONFIG_SNGL_MASK              1<<AXI2CFG_DMAC1_CONFIG_SNGL_IDX
+#define AXI2CFG_DMAC1_CONFIG_STATE_MASK             1<<AXI2CFG_DMAC1_CONFIG_STATE_IDX
+#define AXI2CFG_DMAC1_CONFIG_ENABLE_MASK            1<<AXI2CFG_DMAC1_CONFIG_ENABLE_IDX
+
+#define AXI2CFG_JTAG_ISC_REGISTER_IDX               0
+#define AXI2CFG_JTAG_ISC_IN_CTRL_IDX                1
+#define AXI2CFG_JTAG_ISC_DISABLED_IDX               2
+/* [31:2] - Reserved */
+
+#define AXI2CFG_PURGE_CFG_RD_PORT_IDX               0
+#define AXI2CFG_PURGE_CFG_WR_PORT_IDX               1
+#define AXI2CFG_PURGE_CFG_WR_PRGSS_PORT_IDX         2
+/* [31:3]   Reserved */
+
+#define AXI2CFG_DEVICE_ID_FAT_302_REG_VALUE         0x03020003
+#define AXI2CFG_DEVICE_ID_NML_302_REG_VALUE         0x03020004
+
+/*****************************************************************************/
+/* AXI2CFG IRQ Register Bit Allocation                                       */
+/*****************************************************************************/
+#define AXI2CFG_CFG_IRQ_EN_IDX                      0
+#define AXI2CFG_CFG_IRQ_CLEAR_IDX                   1
+#define AXI2CFG_CFG_IRQ_MASK_IDX                    2
+#define AXI2CFG_CFG_IRQ_TEST_IDX                    3
+#define AXI2CFG_CFG_IRQ_PRE_IDX                     4
+#define AXI2CFG_CFG_IRQ_POST_IDX                    5
+#define AXI2CFG_PICO_IRQ_EN_IDX                     8
+#define AXI2CFG_PICO_IRQ_CLEAR_IDX                  9
+#define AXI2CFG_PICO_IRQ_MASK_IDX                   10
+#define AXI2CFG_PICO_IRQ_TEST_IDX                   11
+#define AXI2CFG_PICO_IRQ_PRE_IDX                    12
+#define AXI2CFG_PICO_IRQ_POST_IDX                   13
+
+#define AXI2CFG_CFG_IRQ_EN_MASK                     1 << AXI2CFG_CFG_IRQ_EN_IDX
+#define AXI2CFG_CFG_IRQ_CLEAR_MASK                  1 << AXI2CFG_CFG_IRQ_CLEAR_IDX
+#define AXI2CFG_CFG_IRQ_MASK_MASK                   1 << AXI2CFG_CFG_IRQ_MASK_IDX
+#define AXI2CFG_CFG_IRQ_TEST_MASK                   1 << AXI2CFG_CFG_IRQ_TEST_IDX
+#define AXI2CFG_CFG_IRQ_PRE_MASK                    1 << AXI2CFG_CFG_IRQ_PRE_IDX
+#define AXI2CFG_CFG_IRQ_POST_MASK                   1 << AXI2CFG_CFG_IRQ_POST_IDX
+#define AXI2CFG_PICO_IRQ_EN_MASK                    1 << AXI2CFG_PICO_IRQ_EN_IDX
+#define AXI2CFG_PICO_IRQ_CLEAR_MASK                 1 << AXI2CFG_PICO_IRQ_CLEAR_IDX
+#define AXI2CFG_PICO_IRQ_MASK_MASK                  1 << AXI2CFG_PICO_IRQ_MASK_IDX
+#define AXI2CFG_PICO_IRQ_TEST_MASK                  1 << AXI2CFG_PICO_IRQ_TEST_IDX
+#define AXI2CFG_PICO_IRQ_PRE_MASK                   1 << AXI2CFG_PICO_IRQ_PRE_IDX
+#define AXI2CFG_PICO_IRQ_POST_MASK                  1 << AXI2CFG_PICO_IRQ_POST_IDX
+
+/*****************************************************************************/
+/* AXI Error Register Bit Allocation                                         */
+/*****************************************************************************/
+#define AXI2CFG_AXI_RD_ERR_DMA1_MST1_IDX           0
+#define AXI2CFG_AXI_RD_ERR_DMA1_MST2_IDX           1
+#define AXI2CFG_AXI_RD_ERR_DMA1_MST3_IDX           2
+#define AXI2CFG_AXI_RD_ERR_DMA1_MST4_IDX           3
+#define AXI2CFG_AXI_RD_ERR_DMA2_MST1_IDX           4
+#define AXI2CFG_AXI_RD_ERR_DMA2_MST2_IDX           5
+#define AXI2CFG_AXI_RD_ERR_DMA2_MST3_IDX           6
+#define AXI2CFG_AXI_RD_ERR_DMA2_MST4_IDX           7
+#define AXI2CFG_AXI_RD_ERR_EMAC_IDX                8
+#define AXI2CFG_AXI_RD_ERR_SPACC3_IDX              9
+#define AXI2CFG_AXI_RD_ERR_SPACC2_IDX              10
+#define AXI2CFG_AXI_RD_ERR_SPACC1_IDX              11
+#define AXI2CFG_AXI_WR_ERR_DMA1_MST1_IDX           12
+#define AXI2CFG_AXI_WR_ERR_DMA1_MST2_IDX           13
+#define AXI2CFG_AXI_WR_ERR_DMA1_MST3_IDX           14
+#define AXI2CFG_AXI_WR_ERR_DMA1_MST4_IDX           15
+#define AXI2CFG_AXI_WR_ERR_DMA2_MST1_IDX           16
+#define AXI2CFG_AXI_WR_ERR_DMA2_MST2_IDX           17
+#define AXI2CFG_AXI_WR_ERR_DMA2_MST3_IDX           18
+#define AXI2CFG_AXI_WR_ERR_DMA2_MST4_IDX           19
+#define AXI2CFG_AXI_WR_ERR_EMAC_IDX                20
+#define AXI2CFG_AXI_WR_ERR_SPACC3_IDX              21
+#define AXI2CFG_AXI_WR_ERR_SPACC2_IDX              22
+#define AXI2CFG_AXI_WR_ERR_SPACC1_IDX              23
+
+#define AXI2CFG_AXI_RD_ERR_DMA1_MST1_MASK          1<<AXI2CFG_AXI_RD_ERR_DMA1_MST1_IDX
+#define AXI2CFG_AXI_RD_ERR_DMA1_MST2_MASK          1<<AXI2CFG_AXI_RD_ERR_DMA1_MST2_IDX
+#define AXI2CFG_AXI_RD_ERR_DMA1_MST3_MASK          1<<AXI2CFG_AXI_RD_ERR_DMA1_MST3_IDX
+#define AXI2CFG_AXI_RD_ERR_DMA1_MST4_MASK          1<<AXI2CFG_AXI_RD_ERR_DMA1_MST4_IDX
+#define AXI2CFG_AXI_RD_ERR_DMA2_MST1_MASK          1<<AXI2CFG_AXI_RD_ERR_DMA2_MST1_IDX
+#define AXI2CFG_AXI_RD_ERR_DMA2_MST2_MASK          1<<AXI2CFG_AXI_RD_ERR_DMA2_MST2_IDX
+#define AXI2CFG_AXI_RD_ERR_DMA2_MST3_MASK          1<<AXI2CFG_AXI_RD_ERR_DMA2_MST3_IDX
+#define AXI2CFG_AXI_RD_ERR_DMA2_MST4_MASK          1<<AXI2CFG_AXI_RD_ERR_DMA2_MST4_IDX
+#define AXI2CFG_AXI_RD_ERR_EMAC_MASK               1<<AXI2CFG_AXI_RD_ERR_EMAC_IDX
+#define AXI2CFG_AXI_RD_ERR_SPACC3_MASK             1<<AXI2CFG_AXI_RD_ERR_SPACC3_IDX
+#define AXI2CFG_AXI_RD_ERR_SPACC2_MASK             1<<AXI2CFG_AXI_RD_ERR_SPACC2_IDX
+#define AXI2CFG_AXI_RD_ERR_SPACC1_MASK             1<<AXI2CFG_AXI_RD_ERR_SPACC1_IDX
+#define AXI2CFG_AXI_WR_ERR_DMA1_MST1_MASK          1<<AXI2CFG_AXI_WR_ERR_DMA1_MST1_IDX
+#define AXI2CFG_AXI_WR_ERR_DMA1_MST2_MASK          1<<AXI2CFG_AXI_WR_ERR_DMA1_MST2_IDX
+#define AXI2CFG_AXI_WR_ERR_DMA1_MST3_MASK          1<<AXI2CFG_AXI_WR_ERR_DMA1_MST3_IDX
+#define AXI2CFG_AXI_WR_ERR_DMA1_MST4_MASK          1<<AXI2CFG_AXI_WR_ERR_DMA1_MST4_IDX
+#define AXI2CFG_AXI_WR_ERR_DMA2_MST1_MASK          1<<AXI2CFG_AXI_WR_ERR_DMA2_MST1_IDX
+#define AXI2CFG_AXI_WR_ERR_DMA2_MST2_MASK          1<<AXI2CFG_AXI_WR_ERR_DMA2_MST2_IDX
+#define AXI2CFG_AXI_WR_ERR_DMA2_MST3_MASK          1<<AXI2CFG_AXI_WR_ERR_DMA2_MST3_IDX
+#define AXI2CFG_AXI_WR_ERR_DMA2_MST4_MASK          1<<AXI2CFG_AXI_WR_ERR_DMA2_MST4_IDX
+#define AXI2CFG_AXI_WR_ERR_EMAC_MASK               1<<AXI2CFG_AXI_WR_ERR_EMAC_IDX
+#define AXI2CFG_AXI_WR_ERR_SPACC3_MASK             1<<AXI2CFG_AXI_WR_ERR_SPACC3_IDX
+#define AXI2CFG_AXI_WR_ERR_SPACC2_MASK             1<<AXI2CFG_AXI_WR_ERR_SPACC2_IDX
+#define AXI2CFG_AXI_WR_ERR_SPACC1_MASK             1<<AXI2CFG_AXI_WR_ERR_SPACC1_IDX
+
+#define AXI2CFG_AXI_RD_ERR_MASK                    (0x00000FFF)
+#define AXI2CFG_AXI_WR_ERR_MASK                    (0x00FFF000)
+#define AXI2CFG_AXI_ERR_MASK_NONE                  (0)
+#define AXI2CFG_AXI_ERR_ENABLE_ALL                 (0x00FFFFFF)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define AXI2CFG_PA_SOFT_RESET_IDX          30
+#define AXI2CFG_SHD_GPIO_7_IDX             23
+#define AXI2CFG_SHD_GPIO_6_IDX             22
+#define AXI2CFG_SHD_GPIO_5_IDX             21
+#define AXI2CFG_SHD_GPIO_4_IDX             20
+#define AXI2CFG_SHD_GPIO_3_IDX             19
+#define AXI2CFG_SHD_GPIO_2_IDX             18
+#define AXI2CFG_SHD_GPIO_1_IDX             17
+#define AXI2CFG_SHD_GPIO_0_IDX             16
+#define AXI2CFG_EBI_CLK_DISABLE_IDX        15
+#define AXI2CFG_EXCEPTION_VECT_EN_IDX      14
+#define AXI2CFG_RMII_EN_IDX                13
+#define AXI2CFG_REV_MII_EN_IDX             12
+#define AXI2CFG_DECODE_MUX_3_IDX           11
+#define AXI2CFG_DECODE_MUX_2_IDX           10
+#define AXI2CFG_DECODE_MUX_1_IDX            9
+#define AXI2CFG_DECODE_MUX_0_IDX            8
+#define AXI2CFG_FREQ_SYNTH_MUX_IDX          7
+#define AXI2CFG_MASK_AXI_ERROR_IDX          6
+#define AXI2CFG_REMAP_IDX                   5
+#define AXI2CFG_WDG_PAUSE_IDX               4
+#define AXI2CFG_CP15DISABLE_IDX             3
+#define AXI2CFG_DMA_CHAN_7_MUX_IDX          2
+#define AXI2CFG_BOOT_MODE_IDX               0
+
+#define AXI2CFG_PA_SOFT_RESET               1 << AXI2CFG_PA_SOFT_RESET_IDX
+#define AXI2CFG_SHD_GPIO_7                  1 << AXI2CFG_SHD_GPIO_7_IDX
+#define AXI2CFG_SHD_GPIO_6                  1 << AXI2CFG_SHD_GPIO_6_IDX
+#define AXI2CFG_SHD_GPIO_5                  1 << AXI2CFG_SHD_GPIO_5_IDX
+#define AXI2CFG_SHD_GPIO_4                  1 << AXI2CFG_SHD_GPIO_4_IDX
+#define AXI2CFG_SHD_GPIO_3                  1 << AXI2CFG_SHD_GPIO_3_IDX
+#define AXI2CFG_SHD_GPIO_2                  1 << AXI2CFG_SHD_GPIO_2_IDX
+#define AXI2CFG_SHD_GPIO_1                  1 << AXI2CFG_SHD_GPIO_1_IDX
+#define AXI2CFG_SHD_GPIO_0                  1 << AXI2CFG_SHD_GPIO_0_IDX
+#define AXI2CFG_EBI_CLK_DISABLE             1 << AXI2CFG_EBI_CLK_DISABLE_IDX
+#define AXI2CFG_EXCEPTION_VECT_EN           1 << AXI2CFG_EXCEPTION_VECT_EN_IDX
+#define AXI2CFG_RMII_EN                     1 << AXI2CFG_RMII_EN_IDX
+#define AXI2CFG_REV_MII_EN                  1 << AXI2CFG_REV_MII_EN_IDX
+#define AXI2CFG_DECODE_MUX_3                1 << AXI2CFG_DECODE_MUX_3_IDX
+#define AXI2CFG_DECODE_MUX_2                1 << AXI2CFG_DECODE_MUX_2_IDX
+#define AXI2CFG_DECODE_MUX_1                1 << AXI2CFG_DECODE_MUX_1_IDX
+#define AXI2CFG_DECODE_MUX_0                1 << AXI2CFG_DECODE_MUX_0_IDX
+#define AXI2CFG_FREQ_SYNTH_MUX              1 << AXI2CFG_FREQ_SYNTH_MUX_IDX
+#define AXI2CFG_MASK_AXI_ERROR              1 << AXI2CFG_MASK_AXI_ERROR_IDX
+#define AXI2CFG_REMAP                       1 << AXI2CFG_REMAP_IDX
+#define AXI2CFG_WDG_PAUSE                   1 << AXI2CFG_WDG_PAUSE_IDX
+#define AXI2CFG_CP15DISABLE                 1 << AXI2CFG_CP15DISABLE_IDX
+#define AXI2CFG_DMA_CHAN_7_MUX              1 << AXI2CFG_DMA_CHAN_7_MUX_IDX
+#define AXI2CFG_BOOT_MODE                   1 << AXI2CFG_BOOT_MODE_IDX
+
+#endif /* PC302_AXI2CFG_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/axi2pico.h b/arch/arm/mach-pc302/include/mach/pc302/axi2pico.h
new file mode 100644
index 0000000..e6a59c2
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/axi2pico.h
@@ -0,0 +1,134 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_AXI2PICO_H
+#define PC302_AXI2PICO_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define AXI2PICO_VP_0_CONFIG_REG_OFFSET     0x0000
+#define AXI2PICO_VP_0_STATUS_REG_OFFSET     0x0004
+#define AXI2PICO_VP_0_DATA_REG_OFFSET       0x0008
+#define AXI2PICO_VP_1_CONFIG_REG_OFFSET     0x0010
+#define AXI2PICO_VP_1_STATUS_REG_OFFSET     0x0014
+#define AXI2PICO_VP_1_DATA_REG_OFFSET       0x0018
+#define AXI2PICO_VP_2_CONFIG_REG_OFFSET     0x0020
+#define AXI2PICO_VP_2_STATUS_REG_OFFSET     0x0024
+#define AXI2PICO_VP_2_DATA_REG_OFFSET       0x0028
+#define AXI2PICO_VP_3_CONFIG_REG_OFFSET     0x0030
+#define AXI2PICO_VP_3_STATUS_REG_OFFSET     0x0034
+#define AXI2PICO_VP_3_DATA_REG_OFFSET       0x0038
+#define AXI2PICO_VP_4_CONFIG_REG_OFFSET     0x0040
+#define AXI2PICO_VP_4_STATUS_REG_OFFSET     0x0044
+#define AXI2PICO_VP_4_DATA_REG_OFFSET       0x0048
+#define AXI2PICO_VP_5_CONFIG_REG_OFFSET     0x0000
+#define AXI2PICO_VP_5_STATUS_REG_OFFSET     0x0054
+#define AXI2PICO_VP_5_DATA_REG_OFFSET       0x0058
+#define AXI2PICO_VP_6_CONFIG_REG_OFFSET     0x0060
+#define AXI2PICO_VP_6_STATUS_REG_OFFSET     0x0064
+#define AXI2PICO_VP_6_DATA_REG_OFFSET       0x0068
+#define AXI2PICO_VP_7_CONFIG_REG_OFFSET     0x0070
+#define AXI2PICO_VP_7_STATUS_REG_OFFSET     0x0074
+#define AXI2PICO_VP_7_DATA_REG_OFFSET       0x0078
+#define AXI2PICO_VP_8_CONFIG_REG_OFFSET     0x0080
+#define AXI2PICO_VP_8_STATUS_REG_OFFSET     0x0084
+#define AXI2PICO_VP_8_DATA_REG_OFFSET       0x0088
+#define AXI2PICO_VP_9_CONFIG_REG_OFFSET     0x0090
+#define AXI2PICO_VP_9_STATUS_REG_OFFSET     0x0094
+#define AXI2PICO_VP_9_DATA_REG_OFFSET       0x0098
+#define AXI2PICO_VP_10_CONFIG_REG_OFFSET    0x00a0
+#define AXI2PICO_VP_10_STATUS_REG_OFFSET    0x00a4
+#define AXI2PICO_VP_10_DATA_REG_OFFSET      0x00a8
+#define AXI2PICO_VP_11_CONFIG_REG_OFFSET    0x00b0
+#define AXI2PICO_VP_11_STATUS_REG_OFFSET    0x00b4
+#define AXI2PICO_VP_11_DATA_REG_OFFSET      0x00b8
+#define AXI2PICO_VP_12_CONFIG_REG_OFFSET    0x00c0
+#define AXI2PICO_VP_12_STATUS_REG_OFFSET    0x00c4
+#define AXI2PICO_VP_12_DATA_REG_OFFSET      0x00c8
+#define AXI2PICO_VP_13_CONFIG_REG_OFFSET    0x00d0
+#define AXI2PICO_VP_13_STATUS_REG_OFFSET    0x00d4
+#define AXI2PICO_VP_13_DATA_REG_OFFSET      0x00d8
+#define AXI2PICO_VP_14_CONFIG_REG_OFFSET    0x00e0
+#define AXI2PICO_VP_14_STATUS_REG_OFFSET    0x00e4
+#define AXI2PICO_VP_14_DATA_REG_OFFSET      0x00e8
+#define AXI2PICO_VP_15_CONFIG_REG_OFFSET    0x00f0
+#define AXI2PICO_VP_15_STATUS_REG_OFFSET    0x00f4
+#define AXI2PICO_VP_15_DATA_REG_OFFSET      0x00f8
+
+#define AXI2PICO_VP_16_CONFIG_REG_OFFSET    0x0100
+#define AXI2PICO_VP_16_STATUS_REG_OFFSET    0x0104
+#define AXI2PICO_VP_16_DATA_REG_OFFSET      0x0108
+#define AXI2PICO_VP_17_CONFIG_REG_OFFSET    0x0110
+#define AXI2PICO_VP_17_STATUS_REG_OFFSET    0x0114
+#define AXI2PICO_VP_17_DATA_REG_OFFSET      0x0118
+#define AXI2PICO_VP_18_CONFIG_REG_OFFSET    0x0120
+#define AXI2PICO_VP_18_STATUS_REG_OFFSET    0x0124
+#define AXI2PICO_VP_18_DATA_REG_OFFSET      0x0128
+#define AXI2PICO_VP_19_CONFIG_REG_OFFSET    0x0130
+#define AXI2PICO_VP_19_STATUS_REG_OFFSET    0x0134
+#define AXI2PICO_VP_19_DATA_REG_OFFSET      0x0138
+#define AXI2PICO_VP_20_CONFIG_REG_OFFSET    0x0140
+#define AXI2PICO_VP_20_STATUS_REG_OFFSET    0x0144
+#define AXI2PICO_VP_20_DATA_REG_OFFSET      0x0148
+#define AXI2PICO_VP_21_CONFIG_REG_OFFSET    0x0100
+#define AXI2PICO_VP_21_STATUS_REG_OFFSET    0x0154
+#define AXI2PICO_VP_21_DATA_REG_OFFSET      0x0158
+#define AXI2PICO_VP_22_CONFIG_REG_OFFSET    0x0160
+#define AXI2PICO_VP_22_STATUS_REG_OFFSET    0x0164
+#define AXI2PICO_VP_22_DATA_REG_OFFSET      0x0168
+#define AXI2PICO_VP_23_CONFIG_REG_OFFSET    0x0170
+#define AXI2PICO_VP_23_STATUS_REG_OFFSET    0x0174
+#define AXI2PICO_VP_23_DATA_REG_OFFSET      0x0178
+#define AXI2PICO_VP_24_CONFIG_REG_OFFSET    0x0180
+#define AXI2PICO_VP_24_STATUS_REG_OFFSET    0x0184
+#define AXI2PICO_VP_24_DATA_REG_OFFSET      0x0188
+#define AXI2PICO_VP_25_CONFIG_REG_OFFSET    0x0190
+#define AXI2PICO_VP_25_STATUS_REG_OFFSET    0x0194
+#define AXI2PICO_VP_25_DATA_REG_OFFSET      0x0198
+#define AXI2PICO_VP_26_CONFIG_REG_OFFSET    0x01a0
+#define AXI2PICO_VP_26_STATUS_REG_OFFSET    0x01a4
+#define AXI2PICO_VP_26_DATA_REG_OFFSET      0x01a8
+#define AXI2PICO_VP_27_CONFIG_REG_OFFSET    0x01b0
+#define AXI2PICO_VP_27_STATUS_REG_OFFSET    0x01b4
+#define AXI2PICO_VP_27_DATA_REG_OFFSET      0x01b8
+#define AXI2PICO_VP_28_CONFIG_REG_OFFSET    0x01c0
+#define AXI2PICO_VP_28_STATUS_REG_OFFSET    0x01c4
+#define AXI2PICO_VP_28_DATA_REG_OFFSET      0x01c8
+#define AXI2PICO_VP_29_CONFIG_REG_OFFSET    0x01d0
+#define AXI2PICO_VP_29_STATUS_REG_OFFSET    0x01d4
+#define AXI2PICO_VP_29_DATA_REG_OFFSET      0x01d8
+
+#define AXI2PICO_INT_STATUS_REG_OFFSET      0x01e0
+
+#define AXI2PICO_VP_30_CONFIG_REG_OFFSET    0x01f0
+#define AXI2PICO_VP_30_STATUS_REG_OFFSET    0x01f4
+#define AXI2PICO_VP_30_DATA_REG_OFFSET      0x01f8
+#define AXI2PICO_VP_31_CONFIG_REG_OFFSET    0x0200
+#define AXI2PICO_VP_31_STATUS_REG_OFFSET    0x0204
+#define AXI2PICO_VP_31_DATA_REG_OFFSET      0x0208
+
+#define AXI2PICO_VP_32_CONFIG_REG_OFFSET    0x0210
+#define AXI2PICO_VP_32_STATUS_REG_OFFSET    0x0214
+#define AXI2PICO_VP_32_DATA_REG_OFFSET      0x0218
+
+#endif /* PC302_AXI2PICO_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/ebi.h b/arch/arm/mach-pc302/include/mach/pc302/ebi.h
new file mode 100644
index 0000000..5c2ac93
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/ebi.h
@@ -0,0 +1,184 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_EBI_H
+#define PC302_EBI_H
+
+/* Constants ---------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define SDRAM_CON_REG_OFFSET                    0x00
+#define SDRAM_TIM0_REG_OFFSET                   0x04
+#define SDRAM_TIM1_REG_OFFSET                   0x08
+#define SDRAM_CTL_REG_OFFSET                    0x0C
+#define SDRAM_REFRESH_REG_OFFSET                0x10
+#define SCHIP_SEL_REGION0_LOW_REG_OFFSET        0x14
+#define SCHIP_SEL_REGION1_LOW_REG_OFFSET        0x18
+#define SCHIP_SEL_REGION2_LOW_REG_OFFSET        0x1C
+#define SCHIP_SEL_REGION3_LOW_REG_OFFSET        0x20
+#define SCHIP_SEL_REGION4_LOW_REG_OFFSET        0x24
+#define SCHIP_SEL_REGION5_LOW_REG_OFFSET        0x28
+#define SCHIP_SEL_REGION6_LOW_REG_OFFSET        0x2C
+#define SCHIP_SEL_REGION7_LOW_REG_OFFSET        0x30
+#define SCHIP_SEL_REGION0_HGH_REG_OFFSET        0x34
+#define SCHIP_SEL_REGION1_HGH_REG_OFFSET        0x38
+#define SCHIP_SEL_REGION2_HGH_REG_OFFSET        0x3C
+#define SCHIP_SEL_REGION3_HGH_REG_OFFSET        0x40
+#define SCHIP_SEL_REGION4_HGH_REG_OFFSET        0x44
+#define SCHIP_SEL_REGION5_HGH_REG_OFFSET        0x48
+#define SCHIP_SEL_REGION6_HGH_REG_OFFSET        0x4C
+#define SCHIP_SEL_REGION7_HGH_REG_OFFSET        0x50
+#define SMASK0_REG_OFFSET                       0x54
+#define SMASK1_REG_OFFSET                       0x58
+#define SMASK2_REG_OFFSET                       0x5C
+#define SMASK3_REG_OFFSET                       0x60
+#define SMASK4_REG_OFFSET                       0x64
+#define SMASK5_REG_OFFSET                       0x68
+#define SMASK6_REG_OFFSET                       0x6C
+#define SMASK7_REG_OFFSET                       0x70
+#define CHIP_SEL_ALIAS0_LOW_REG_OFFSET          0x74
+#define CHIP_SEL_ALIAS1_LOW_REG_OFFSET          0x78
+#define CHIP_SEL_ALIAS0_HGH_REG_OFFSET          0x7C
+#define CHIP_SEL_ALIAS1_HGH_REG_OFFSET          0x80
+#define CHIP_SEL_REMAP0_LOW_REG_OFFSET          0x84
+#define CHIP_SEL_REMAP1_LOW_REG_OFFSET          0x88
+#define CHIP_SEL_REMAP0_HGH_REG_OFFSET          0x8C
+#define CHIP_SEL_REMAP1_HGH_REG_OFFSET          0x90
+#define STATIC_MEM_TIMSET0_REG_OFFSET           0x94
+#define STATIC_MEM_TIMSET1_REG_OFFSET           0x98
+#define STATIC_MEM_TIMSET2_REG_OFFSET           0x9C
+#define FLASH_TRPDR_REG_OFFSET                  0xA0
+#define STATICM_EMCONTROL_REG_OFFSET            0xA4
+#define SYNC_FLASH_OPCODE_REG_OFFSET            0xA8
+#define EXTEND_MODE_REG_OFFSET                  0xAC
+#define SYNC_FLASH_CONFIG_REG_OFFSET            0xB0
+#define SYNC_FLASH_CONTROL_REG_OFFSET           0xB4
+#define SYNC_FLASH_TIM_REG_OFFSET               0xB8
+
+#define SETLOWFREQDEV                           1<<27
+#define RESETLOWFREQDEV                         0<<27
+#define SETREADYMODE                            1<<26
+#define RESETREADYMODE                          0<<26
+#define SETPAGEMODE                             1<<26
+#define RESETPAGEMODE                           0<<26
+#define PAGESIZE4                               0<<24
+#define PAGESIZE8                               1<<24
+#define PAGESIZE16                              2<<24
+#define PAGESIZE32                              3<<24
+#define T_PRC_0                                 4
+#define T_BTA_0                                 7
+#define T_WP_0                                  20<<10
+#define T_WR_0                                  3
+#define T_AS_0                                  1
+#define T_RC_0                                  32
+#define T_PRC_1                                 1
+#define T_BTA_1                                 1
+#define T_WP_1                                  2
+#define T_WR_1                                  1
+#define T_AS_1                                  1
+#define T_RC_1                                  4
+#define T_PRC_2                                 1
+#define T_BTA_2                                 1
+#define T_WP_2                                  2
+#define T_WR_2                                  1
+#define T_AS_2                                  1
+#define T_RC_2                                  4
+
+#define EBI_DECODE_0                            0
+#define EBI_DECODE_1                            1
+#define EBI_DECODE_2                            2
+#define EBI_DECODE_3                            3
+
+#define EBI_SMSKR_REG_SELECT_SHIFT              8
+#define EBI_SMSKR_REG_SELECT_MASK               3
+#define EBI_REG_SELECT_TIMING_SET_0             0
+#define EBI_REG_SELECT_TIMING_SET_1             1
+#define EBI_REG_SELECT_TIMING_SET_2             2
+
+#define EBI_SMSKR_MEM_TYPE_SHIFT                5
+#define EBI_SMSKR_MEM_TYPE_MASK                 3
+#define EBI_MEM_TYPE_SDRAM                      0
+#define EBI_MEM_TYPE_SRAM                       1
+#define EBI_MEM_TYPE_FLASH                      2
+
+#define EBI_SMSKR_MEM_SIZE_SHIFT                0
+#define EBI_SMSKR_MEM_SIZE_MASK                 0x1F
+#define EBI_MEM_SIZE_NO_MEMORY                  0x00
+#define EBI_MEM_SIZE_64KB                       0x01
+#define EBI_MEM_SIZE_128KB                      0x02
+#define EBI_MEM_SIZE_256KB                      0x03
+#define EBI_MEM_SIZE_512KB                      0x04
+#define EBI_MEM_SIZE_1MB                        0x05
+#define EBI_MEM_SIZE_2MB                        0x06
+#define EBI_MEM_SIZE_4MB                        0x07
+#define EBI_MEM_SIZE_8MB                        0x08
+#define EBI_MEM_SIZE_16MB                       0x09
+#define EBI_MEM_SIZE_32MB                       0x0A
+#define EBI_MEM_SIZE_64MB                       0x0B
+#define EBI_MEM_SIZE_128MB                      0x0C
+#define EBI_MEM_SIZE_256MB                      0x0D
+#define EBI_MEM_SIZE_512MB                      0x0E
+#define EBI_MEM_SIZE_1GB                        0x0F
+#define EBI_MEM_SIZE_2GB                        0x10
+#define EBI_MEM_SIZE_4GB                        0x11
+
+#define EBI_TIMING_SET_0                        0
+#define EBI_TIMING_SET_1                        1
+#define EBI_TIMING_SET_2                        2
+
+#define EBI_SMTMGR_REG_READ_PIPE_SHIFT          28
+#define EBI_SMTMGR_REG_READ_PIPE_MASK           3
+
+#define EBI_SMTMGR_REG_CLK_SYNC_SHIFT           27
+#define EBI_SMTMGR_REG_CLK_SYNC_MASK            1
+
+#define EBI_SMTMGR_REG_READY_MODE_SHIFT         26
+#define EBI_SMTMGR_REG_READY_MODE_MASK          1
+
+#define EBI_SMTMGR_REG_PAGE_SIZE_SHIFT          24
+#define EBI_SMTMGR_REG_PAGE_SIZE_MASK           3
+#define EBI_PAGE_SIZE_4                         0
+#define EBI_PAGE_SIZE_8                         1
+#define EBI_PAGE_SIZE_16                        2
+#define EBI_PAGE_SIZE_32                        3
+
+#define EBI_SMTMGR_REG_PAGE_MODE_SHIFT          23
+#define EBI_SMTMGR_REG_PAGE_MODE_MASK           1
+
+#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_SHIFT    19
+#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_MASK     0xF
+
+#define EBI_SMTMGR_REG_BUS_TURN_AROUND_SHIFT    16
+#define EBI_SMTMGR_REG_BUS_TURN_AROUND_MASK     0x7
+
+#define EBI_SMTMGR_REG_WRITE_PULSE_SHIFT        10
+#define EBI_SMTMGR_REG_WRITE_PULSE_MASK         0x3F
+
+#define EBI_SMTMGR_REG_ADDR_HOLD_SHIFT          8
+#define EBI_SMTMGR_REG_ADDR_HOLD_MASK           3
+
+#define EBI_SMTMGR_REG_ADDR_SETUP_SHIFT         6
+#define EBI_SMTMGR_REG_ADDR_SETUP_MASK          3
+
+#define EBI_SMTMGR_REG_TIMING_READ_CYCLE_MASK   0x1F
+
+#endif /* PC302_EBI_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/fuse.h b/arch/arm/mach-pc302/include/mach/pc302/fuse.h
new file mode 100644
index 0000000..de79cee
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/fuse.h
@@ -0,0 +1,76 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_FUSE_H
+#define PC302_FUSE_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define FUSE_MAP_0_REG_OFFSET           0x00
+#define FUSE_MAP_1_REG_OFFSET           0x04
+#define FUSE_MAP_2_REG_OFFSET           0x08
+#define FUSE_MAP_3_REG_OFFSET           0x0C
+#define FUSE_MAP_4_REG_OFFSET           0x10
+#define FUSE_MAP_5_REG_OFFSET           0x14
+#define FUSE_MAP_6_REG_OFFSET           0x18
+#define FUSE_MAP_7_REG_OFFSET           0x1C
+#define FUSE_MAP_8_REG_OFFSET           0x20
+#define FUSE_MAP_9_REG_OFFSET           0x24
+#define FUSE_MAP_10_REG_OFFSET          0x28
+#define FUSE_MAP_11_REG_OFFSET          0x2C
+#define FUSE_MAP_12_REG_OFFSET          0x30
+#define FUSE_MAP_13_REG_OFFSET          0x34
+#define FUSE_MAP_14_REG_OFFSET          0x38
+#define FUSE_MAP_15_REG_OFFSET          0x3C
+#define FUSE_MAP_16_REG_OFFSET          0x40
+#define FUSE_MAP_17_REG_OFFSET          0x44
+#define FUSE_MAP_18_REG_OFFSET          0x48
+#define FUSE_MAP_19_REG_OFFSET          0x4C
+#define FUSE_MAP_20_REG_OFFSET          0x50
+#define FUSE_MAP_21_REG_OFFSET          0x54
+#define FUSE_MAP_22_REG_OFFSET          0x58
+#define FUSE_MAP_23_REG_OFFSET          0x5C
+#define FUSE_MAP_24_REG_OFFSET          0x60
+#define FUSE_MAP_25_REG_OFFSET          0x64
+#define FUSE_MAP_26_REG_OFFSET          0x68
+#define FUSE_MAP_27_REG_OFFSET          0x6C
+#define FUSE_MAP_28_REG_OFFSET          0x70
+#define FUSE_MAP_29_REG_OFFSET          0x74
+#define FUSE_MAP_30_REG_OFFSET          0x78
+#define FUSE_MAP_31_REG_OFFSET          0x7C
+          
+#define PC302_FUSE_CTRL_REG ( 0x200 )
+#define PC302_FUSE_WR_BIT_ADDRESS_REG   ( 0x204 )
+#define PC302_FUSE_WR_PERFORM_REG   ( 0x208 )
+#define PC302_FUSE_WRITE_PAD_EN_REG ( 0x20C )
+#define PC302_FUSE_WRITE_PAD_REG    ( 0x210 )
+
+#define PC302_FUSE_CTRL_WRITE_BUSY  ( 1 << 0 )
+#define PC302_FUSE_CTRL_VDDQ_OE     ( 1 << 1 )
+#define PC302_FUSE_CTRL_VDDQ        ( 1 << 2 )
+
+#define PC302_FUSE_WR_PERFORM_VALUE     ( 0x66757365 ) /* "fuse" */
+#define PC302_FUSE_WRITE_PAD_EN_VALUE   ( 0x656E626C ) /* "enbl" */
+#define PC302_FUSE_WRITE_PAD_VALUE      ( 0x56444451 ) /* "VDDQ" */
+
+#endif /* PC302_FUSE_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/gpio.h b/arch/arm/mach-pc302/include/mach/pc302/gpio.h
new file mode 100644
index 0000000..c259d58
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/gpio.h
@@ -0,0 +1,113 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_GPIO_H
+#define PC302_GPIO_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define GPIO_SW_PORT_A_DR_REG_OFFSET        0x00    /*; Port A Data Register */
+#define GPIO_SW_PORT_A_DDR_REG_OFFSET	    0x04    /*; Port A Data Direction Register */
+#define GPIO_SW_PORT_A_CTL_REG_OFFSET       0x08    /*; Port A Data Source */
+#define GPIO_SW_PORT_B_DR_REG_OFFSET        0x0C    /*; Port B Data Register */
+#define GPIO_SW_PORT_B_DDR_REG_OFFSET	    0x10    /*; Port B Data Direction Register */
+#define GPIO_SW_PORT_B_CTL_REG_OFFSET       0x14    /*; Port B Data Source */
+#define GPIO_SW_PORT_C_DR_REG_OFFSET        0x18    /*; Port C Data Register */
+#define GPIO_SW_PORT_C_DDR_REG_OFFSET	    0x1C    /*; Port C Data Direction Register */
+#define GPIO_SW_PORT_C_CTL_REG_OFFSET       0x20    /*; Port C Data Source */
+
+/* no port {D} */
+
+/* global GPIO registers */
+#define GPIO_INT_EN_REG_OFFSET              0x30    /*; Interrupt enable */
+#define GPIO_INT_MASK_REG_OFFSET            0x34    /*; Interrupt mask */
+#define GPIO_INT_TYPE_LEVEL_REG_OFFSET 	    0x38    /*; Interrupt level */
+#define GPIO_INT_POLARITY_REG_OFFSET 	    0x3c    /*; Interrupt polarity */
+
+#define GPIO_INT_STATUS_REG_OFFSET	    0x40    /*; Interrupt status */
+#define GPIO_RAW_INT_STATUS_REG_OFFSET	    0x44    /*; Raw interrupt status */
+
+/* no debounce */
+#define GPIO_PORT_A_EOI_REG_OFFSET          0x4c    /*; Clear interrupt */
+#define GPIO_EXT_PORT_A_REG_OFFSET          0x50    /*; Value of External pins Port A */
+#define GPIO_EXT_PORT_B_REG_OFFSET          0x54    /*; Value of External pins Port B */
+#define GPIO_EXT_PORT_C_REG_OFFSET          0x58    /*; Value of External pins Port C */
+
+/* no port {D} */
+
+#define GPIO_LS_SYNC_REG_OFFSET		    0x60    /*; Synchronization level */
+#define GPIO_ID_CODE_REG_OFFSET		    0x64    /*; GPIO ID code */
+#define GPIO_RESERVED_REG_OFFSET            0x68    /*; reserved */
+#define GPIO_COMP_VERSION_REG_OFFSET	    0x6c    /*; GPIO Component Version */
+
+/*****************************************************************************/
+/* Register Reset Values                                                     */
+/*****************************************************************************/
+
+/*Address offset from GPIO_BASE */
+#define GPIO_SW_PORT_A_DR_REG_RESET         0x00000000  /*; Port A Data Register */
+#define GPIO_SW_PORT_A_DDR_REG_RESET        0x00000000  /*; Port A Data Direction Register */
+#define GPIO_SW_PORT_A_CTL_REG_RESET        0x00000000  /*; Port A A Data Source */
+#define GPIO_SW_PORT_B_DR_REG_RESET         0x00000000  /*; Port B Data Register */
+#define GPIO_SW_PORT_B_DDR_REG_RESET        0x00000000  /*; Port B Data Direction Register */
+#define GPIO_SW_PORT_B_CTL_REG_RESET        0x00000000  /*; Port B Data Source */
+#define GPIO_SW_PORT_C_DR_REG_RESET         0x00000000  /*; Port C Data Register */
+#define GPIO_SW_PORT_C_DDR_REG_RESET        0x00000000  /*; Port C Data Direction Register */
+#define GPIO_SW_PORT_C_CTL_REG_RESET        0x00000000  /*; Port C Data Source */
+
+/* no port {D} */
+
+/* global GPIO registers */
+#define GPIO_INT_EN_REG_RESET               0x00000000	/*; Interrupt enable */
+#define GPIO_INT_MASK_REG_RESET	 	    0x00000000	/*; Interrupt mask */
+#define GPIO_INT_TYPE_LEVEL_REG_RESET 	    0x00000000	/*; Interrupt level */
+#define GPIO_INT_POLARITY_REG_RESET 	    0x00000000	/*; Interrupt polarity */
+
+#define GPIO_INT_STATUS_REG_RESET           0x00000000  /*; Interrupt status */
+#define GPIO_RAW_INT_STATUS_REG_RESET       0x00000000  /*; Raw interrupt status */
+
+/* no debounce */
+
+#define GPIO_PORT_A_EOI_REG_RESET           0x00000000	/*; Clear interrupt */
+#define GPIO_EXT_PORT_A_REG_RESET           0x00000000	/*; Value of External pins Port A */
+#define GPIO_EXT_PORT_B_REG_RESET           0x00000000	/*; Value of External pins Port B */
+#define GPIO_EXT_PORT_C_REG_RESET           0x00000000	/*; Value of External pins Port C */
+
+/* no port {D} */
+
+#define GPIO_LS_SYNC_REG_RESET		    0x00000000  /*; Synchronization level */
+#define GPIO_ID_CODE_REG_RESET		    0x00000000  /*; GPIO ID code */
+#define GPIO_COMP_VERSION_REG_RESET         0x3230362A  /* ; 2.06b => '2.06*' */
+
+/* Bit definitions */
+
+#define GPIO_BIT_7 0x80
+#define GPIO_BIT_6 0x40
+#define GPIO_BIT_5 0x20
+#define GPIO_BIT_4 0x10
+#define GPIO_BIT_3 0x08
+#define GPIO_BIT_2 0x04
+#define GPIO_BIT_1 0x02
+#define GPIO_BIT_0 0x01
+
+#endif /* PC302_GPIO_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/mem.h b/arch/arm/mach-pc302/include/mach/pc302/mem.h
new file mode 100644
index 0000000..6392479
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/mem.h
@@ -0,0 +1,145 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_MEMIF_H
+#define PC302_MEMIF_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define MEMIF_SDRAM_SETUP_REG_OFFSET            0x00A0
+#define MEMIF_SDRAM_REFRESH_REG_OFFSET          0x00A2
+#define MEMIF_SDRAM_MRS_REG_OFFSET              0x00A4
+#define MEMIF_SDRAM_EMRS_REG_OFFSET             0x00A6
+#define MEMIF_SDRAM_CFG_DONE_REG_OFFSET         0x00A8
+#define MEMIF_SRAM_CFG_DONE_REG_OFFSET          0x00AA
+#define MEMIF_SDRAM_ARB_G0_S01_REG_OFFSET       0x0040
+#define MEMIF_SDRAM_ARB_G0_S23_REG_OFFSET       0x0042
+#define MEMIF_SDRAM_ARB_G1_S01_REG_OFFSET       0x0044
+#define MEMIF_SDRAM_ARB_G1_S23_REG_OFFSET       0x0046
+#define MEMIF_SDRAM_ARB_G2_S01_REG_OFFSET       0x0048
+#define MEMIF_SDRAM_ARB_G2_S23_REG_OFFSET       0x004A
+#define MEMIF_SDRAM_ARB_G3_S01_REG_OFFSET       0x004C
+#define MEMIF_SDRAM_ARB_G3_S23_REG_OFFSET       0x004E
+#define MEMIF_SDRAM_ARB_G4_S01_REG_OFFSET       0x0050
+#define MEMIF_SDRAM_ARB_G4_S23_REG_OFFSET       0x0052
+#define MEMIF_SDRAM_ARB_G5_S01_REG_OFFSET       0x0054
+#define MEMIF_SDRAM_ARB_G5_S23_REG_OFFSET       0x0056
+#define MEMIF_SDRAM_ARB_G6_S01_REG_OFFSET       0x0058
+#define MEMIF_SDRAM_ARB_G6_S23_REG_OFFSET       0x005A
+#define MEMIF_SDRAM_ARB_G7_S01_REG_OFFSET       0x005C
+#define MEMIF_SDRAM_ARB_G7_S23_REG_OFFSET       0x005E
+#define MEMIF_SDRAM_ARB_VALID_REG_OFFSET        0x0060
+#define MEMIF_SRAM_ARB_S01_REG_OFFSET           0x0080
+#define MEMIF_SRAM_ARB_S23_REG_OFFSET           0x0082
+#define MEMIF_SRAM_ARB_S45_REG_OFFSET           0x0084
+#define MEMIF_SRAM_ARB_VALID_REG_OFFSET         0x0086
+#define MEMIF_DLL0_MASTER_REG_OFFSET            0x0120
+#define MEMIF_DLL0_SLAVE_REG_OFFSET             0x0122
+#define MEMIF_DLL0_TEST_REG_OFFSET              0x0124
+#define MEMIF_DLL1_MASTER_REG_OFFSET            0x0126
+#define MEMIF_DLL1_SLAVE_REG_OFFSET             0x0128
+#define MEMIF_DLL1_TEST_REG_OFFSET              0x012A
+#define MEMIF_DLL2_MASTER_REG_OFFSET            0x012C
+#define MEMIF_DLL2_SLAVE_REG_OFFSET             0x012E
+#define MEMIF_DLL2_TEST_REG_OFFSET              0x0130
+#define MEMIF_DLL3_MASTER_REG_OFFSET            0x0132
+#define MEMIF_DLL3_SLAVE_REG_OFFSET             0x0134
+#define MEMIF_DLL3_TEST_REG_OFFSET              0x0136
+#define MEMIF_DLL_UPDATE_REG_OFFSET             0x0138
+
+/* configuration register values */
+#define MEMIF_SDRAM_SETUP_REG_SIZE_SHIFT        0
+#define MEMIF_SDRAM_SETUP_REG_16B_SHIFT         2
+#define MEMIF_SDRAM_SETUP_REG_RW_SHIFT          3
+#define MEMIF_SDRAM_SETUP_REG_WR_SHIFT          7
+#define MEMIF_SDRAM_SETUP_REG_ODT_SHIFT         11
+#define MEMIF_SDRAM_SETUP_REG_CD_SHIFT          13
+#define MEMIF_SDRAM_SETUP_REG_SIZE_0            (0 << MEMIF_SDRAM_SETUP_REG_SIZE_SHIFT)
+#define MEMIF_SDRAM_SETUP_REG_SIZE_1            (1 << MEMIF_SDRAM_SETUP_REG_SIZE_SHIFT)
+#define MEMIF_SDRAM_SETUP_REG_SIZE_2            (2 << MEMIF_SDRAM_SETUP_REG_SIZE_SHIFT)
+#define MEMIF_SDRAM_SETUP_REG_32BIT_MODE        (0 << MEMIF_SDRAM_SETUP_REG_16B_SHIFT)       
+#define MEMIF_SDRAM_SETUP_REG_16BIT_MODE        (1 << MEMIF_SDRAM_SETUP_REG_16B_SHIFT)
+#define MEMIF_SDRAM_SETUP_REG_RW_GAP_4          (4 << MEMIF_SDRAM_SETUP_REG_RW_SHIFT)
+#define MEMIF_SDRAM_SETUP_REG_WR_GAP_7          (7 << MEMIF_SDRAM_SETUP_REG_WR_SHIFT)
+#define MEMIF_SDRAM_SETUP_ODT_OFF               (0 << MEMIF_SDRAM_SETUP_REG_ODT_SHIFT)
+#define MEMIF_SDRAM_SETUP_ODT_75_OHM            (1 << MEMIF_SDRAM_SETUP_REG_ODT_SHIFT)
+#define MEMIF_SDRAM_SETUP_ODT_150_OHM           (2 << MEMIF_SDRAM_SETUP_REG_ODT_SHIFT)
+#define MEMIF_SDRAM_SETUP_ODT_50_OHM            (3 << MEMIF_SDRAM_SETUP_REG_ODT_SHIFT)
+#define MEMIF_SDRAM_SETUP_CAPT_SIM              (1 << MEMIF_SDRAM_SETUP_REG_CD_SHIFT)
+#define MEMIF_SDRAM_SETUP_CAPT_HW               (2 << MEMIF_SDRAM_SETUP_REG_CD_SHIFT)
+#define MEMIF_SDRAM_REFRESH                     0x05DC
+#define MEMIF_SDRAM_MRS                         0x0442
+#define MEMIF_SDRAM_EMRS_ODT_OFF                0x0000
+#define MEMIF_SDRAM_EMRS_ODT_75_OHM             0x0004
+#define MEMIF_SDRAM_EMRS_ODT_150_OHM            0x0040
+#define MEMIF_SDRAM_EMRS_ODT_50_OHM             0x0044
+#define MEMIF_CFG_DONE                          0x0001
+#define MEMIF_SDRAM_ARB_PA_AHB_LWR_SHIFT        0
+#define MEMIF_SDRAM_ARB_OP_DET_LWR_SHIFT        1
+#define MEMIF_SDRAM_ARB_WR_RD_LWR_SHIFT         2
+#define MEMIF_SDRAM_ARB_CSP_LWR_SHIFT           3
+#define MEMIF_SDRAM_ARB_PA_AHB_UPR_SHIFT        8
+#define MEMIF_SDRAM_ARB_OP_DET_UPR_SHIFT        9
+#define MEMIF_SDRAM_ARB_WR_RD_UPR_SHIFT         10
+#define MEMIF_SDRAM_ARB_CSP_UPR_SHIFT           11
+#define MEMIF_SDRAM_ARB_LWR_PA                  (1 << MEMIF_SDRAM_ARB_PA_AHB_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_LWR_AHB                 (0 << MEMIF_SDRAM_ARB_PA_AHB_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_LWR_OP                  (1 << MEMIF_SDRAM_ARB_OP_DET_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_LWR_DET                 (0 << MEMIF_SDRAM_ARB_OP_DET_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_LWR_WR                  (1 << MEMIF_SDRAM_ARB_WR_RD_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_LWR_RD                  (0 << MEMIF_SDRAM_ARB_WR_RD_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_LWR_CSP_0               (0 << MEMIF_SDRAM_ARB_CSP_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_LWR_CSP_1               (1 << MEMIF_SDRAM_ARB_CSP_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_LWR_CSP_2               (2 << MEMIF_SDRAM_ARB_CSP_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_LWR_CSP_3               (3 << MEMIF_SDRAM_ARB_CSP_LWR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_PA                  (1 << MEMIF_SDRAM_ARB_PA_AHB_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_AHB                 (0 << MEMIF_SDRAM_ARB_PA_AHB_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_OP                  (1 << MEMIF_SDRAM_ARB_OP_DET_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_DET                 (0 << MEMIF_SDRAM_ARB_OP_DET_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_WR                  (1 << MEMIF_SDRAM_ARB_WR_RD_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_RD                  (0 << MEMIF_SDRAM_ARB_WR_RD_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_CSP_0               (0 << MEMIF_SDRAM_ARB_CSP_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_CSP_1               (1 << MEMIF_SDRAM_ARB_CSP_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_CSP_2               (2 << MEMIF_SDRAM_ARB_CSP_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_UPR_CSP_3               (3 << MEMIF_SDRAM_ARB_CSP_UPR_SHIFT)
+#define MEMIF_SDRAM_ARB_1_VALID_GRP             0x0001
+#define MEMIF_SDRAM_ARB_2_VALID_GRP             0x0003
+#define MEMIF_SDRAM_ARB_3_VALID_GRP             0x0007
+#define MEMIF_SDRAM_ARB_4_VALID_GRP             0x000F
+#define MEMIF_SDRAM_ARB_5_VALID_GRP             0x001F
+#define MEMIF_SDRAM_ARB_6_VALID_GRP             0x003F
+#define MEMIF_SDRAM_ARB_7_VALID_GRP             0x007F
+#define MEMIF_SDRAM_ARB_8_VALID_GRP             0x00FF
+#define MEMIF_DLL0_SLAVE_DELAY                  0x4803
+#define MEMIF_DLL1_SLAVE_DELAY                  0x4A03
+#define MEMIF_DLL2_SLAVE_DELAY                  0x4A03
+#define MEMIF_DLL3_SLAVE_DELAY                  0x4A03
+#define MEMIF_DLL_UPDATE                        0x0001
+
+#ifdef HARDWARE_BUILD
+#define MEMIF_SDRAM_SETUP_CAPT_DELAY  MEMIF_SDRAM_SETUP_CAPT_HW
+#else
+#define MEMIF_SDRAM_SETUP_CAPT_DELAY  MEMIF_SDRAM_SETUP_CAPT_SIM
+#endif
+
+#endif /* PC302__MEMIF_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/mem_arm.h b/arch/arm/mach-pc302/include/mach/pc302/mem_arm.h
new file mode 100644
index 0000000..f8ba784
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/mem_arm.h
@@ -0,0 +1,207 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_MEM_ARM_H
+#define PC302_MEM_ARM_H
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+        
+#define MEMIF_ARM_INDIRECT_RW_CMD_OFFSET    (0x00 * 4)
+#define MEMIF_ARM_RSVD_0_OFFSET             (0x01 * 4)
+#define MEMIF_ARM_HPR_OFFSET                (0x02 * 4)
+#define MEMIF_ARM_LPR_OFFSET                (0x03 * 4)
+#define MEMIF_ARM_WR_OFFSET                 (0x04 * 4)
+#define MEMIF_ARM_DRAM_PARAM_0_OFFSET       (0x05 * 4)
+#define MEMIF_ARM_DRAM_PARAM_1_OFFSET       (0x06 * 4)
+#define MEMIF_ARM_DRAM_PARAM_2_OFFSET       (0x07 * 4)
+#define MEMIF_ARM_DRAM_PARAM_3_OFFSET       (0x08 * 4)
+#define MEMIF_ARM_DRAM_PARAM_4_OFFSET       (0x09 * 4)
+#define MEMIF_ARM_DRAM_INIT_PARAM_OFFSET    (0x0A * 4)
+#define MEMIF_ARM_DRAM_EMR2_EMR3_OFFSET     (0x0B * 4)
+#define MEMIF_ARM_DRAM_EMR_MR_OFFSET        (0x0C * 4)
+#define MEMIF_ARM_DRAM_BL_OFFSET            (0x0D * 4)
+#define MEMIF_ARM_DRAM_FORCE_LPR_OFFSET     (0x0E * 4)
+#define MEMIF_ARM_ADDR_MAP_0_OFFSET         (0x0F * 4)
+#define MEMIF_ARM_ADDR_MAP_1_OFFSET         (0x10 * 4)
+#define MEMIF_ARM_ADDR_MAP_2_OFFSET         (0x11 * 4)
+#define MEMIF_ARM_DRAM_ODT_OFFSET           (0x12 * 4)
+#define MEMIF_ARM_PHY_DEBUG_0_OFFSET        (0x13 * 4)
+#define MEMIF_ARM_PHY_CMD_RDC_OFFSET        (0x14 * 4)
+#define MEMIF_ARM_CTRL_MODE_OFFSET          (0x15 * 4)
+#define MEMIF_ARM_DLL_CALIB_OFFSET          (0x16 * 4)
+#define MEMIF_ARM_ODT_CTRL_OFFSET           (0x17 * 4)
+#define MEMIF_ARM_DDRC_CTRL_0_OFFSET        (0x18 * 4)
+#define MEMIF_ARM_DDRC_CTRL_1_OFFSET        (0x19 * 4)
+#define MEMIF_ARM_PHY_SLV_DLL_OFFSET        (0x1A * 4)
+#define MEMIF_ARM_PHY_DEBUG_1_OFFSET        (0x1B * 4)
+#define MEMIF_ARM_PHY_DEBUG_2_OFFSET        (0x1C * 4)
+#define MEMIF_ARM_PHY_DEBUG_3_OFFSET        (0x1D * 4)
+#define MEMIF_ARM_PHY_DEBUG_4_OFFSET        (0x1E * 4)
+#define MEMIF_ARM_AXI_GP0_OFFSET            (0x20 * 4)
+#define MEMIF_ARM_AXI_GP1_OFFSET            (0x21 * 4)
+#define MEMIF_ARM_AXI_GP2_OFFSET            (0x22 * 4)
+#define MEMIF_ARM_AXI_GP3_OFFSET            (0x23 * 4)
+#define MEMIF_ARM_AXI_GP4_OFFSET            (0x24 * 4)
+#define MEMIF_ARM_AXI_GPSTATUS0_OFFSET      (0x2A * 4)
+#define MEMIF_ARM_AXI_GPSTATUS1_OFFSET      (0x2B * 4)
+#define MEMIF_ARM_AXI_GPSTATUS2_OFFSET      (0x2C * 4)
+#define MEMIF_ARM_AXI_GPSTATUS3_OFFSET      (0x2D * 4)
+#define MEMIF_ARM_AXI_GPSTATUS4_OFFSET      (0x2E * 4)
+
+/* 31 - 57 UNUSED */
+
+#define MEMIF_ARM_AXI_HP_MSTR_0_OFFSET      (0x3A * 4)      
+#define MEMIF_ARM_AXI_HP_MSTR_1_OFFSET      (0x3B * 4)      
+#define MEMIF_ARM_AXI_HP_MSTR_2_OFFSET      (0x3C * 4)      
+#define MEMIF_ARM_AXI_HP_MSTR_3_OFFSET      (0x3D * 4)      
+#define MEMIF_ARM_AXI_START_ADDR_OFFSET     (0x3E * 4)
+#define MEMIF_ARM_AXI_END_ADDR_OFFSET       (0x3F * 4)
+                
+/*****************************************************************************/
+/* Register Values                                                           */
+/*****************************************************************************/
+
+/* MEMIF_ARM_DRAM_EMR_MR */        
+
+#define MEMIF_ARM_DRAM_EMR_MR_VAL                 0x00000A63        
+
+/* MEMIF_ARM_ADDR_MAP0-2 */        
+
+#define MEMIF_ARM_ADDR_MAP_0_BANK_BIT0_IDX        0
+#define MEMIF_ARM_ADDR_MAP_0_BANK_BIT1_IDX        4
+#define MEMIF_ARM_ADDR_MAP_0_BANK_BIT2_IDX        8
+
+#define MEMIF_ARM_ADDR_MAP_1_COL_BIT2_IDX         0
+#define MEMIF_ARM_ADDR_MAP_1_COL_BIT3_IDX         4
+#define MEMIF_ARM_ADDR_MAP_1_COL_BIT4_6_IDX       8
+#define MEMIF_ARM_ADDR_MAP_1_COL_BIT7_IDX         12
+#define MEMIF_ARM_ADDR_MAP_1_COL_BIT8_IDX         16
+#define MEMIF_ARM_ADDR_MAP_1_COL_BIT9_IDX         20
+#define MEMIF_ARM_ADDR_MAP_1_COL_BIT10_IDX        24
+#define MEMIF_ARM_ADDR_MAP_1_COL_BIT11_IDX        28
+
+#define MEMIF_ARM_ADDR_MAP_2_ROW_BIT0_IDX         0
+#define MEMIF_ARM_ADDR_MAP_2_ROW_BIT1_IDX         4
+#define MEMIF_ARM_ADDR_MAP_2_ROW_BIT2_11_IDX      8   
+#define MEMIF_ARM_ADDR_MAP_2_ROW_BIT12_IDX        12
+#define MEMIF_ARM_ADDR_MAP_2_ROW_BIT13_IDX        16
+#define MEMIF_ARM_ADDR_MAP_2_ROW_BIT14_IDX        20
+#define MEMIF_ARM_ADDR_MAP_2_ROW_BIT15_IDX        24
+
+#define MEMIF_ARM_ADDR_MAP_0_VAL_512Mbx16         0x00000F77  /* bank */
+#define MEMIF_ARM_ADDR_MAP_1_VAL_512Mbx16         0xFFF00000  /* col */
+#define MEMIF_ARM_ADDR_MAP_2_VAL_512Mbx16         0x0FF22222  /* row */
+
+/* MEMIF_ARM_PHY_CMD_RDC */        
+
+#define MEMIF_ARM_PHY_CMD_RDC_USE_FIXED_RE_IDX    16
+#define MEMIF_ARM_PHY_CMD_RDC_WE_TO_RE_DEL_IDX    8
+#define MEMIF_ARM_PHY_CMD_RDC_WR_CMD_TO_DATA_IDX  4
+#define MEMIF_ARM_PHY_CMD_RDC_RD_CMD_TO_DATA_IDX  0
+
+#define MEMIF_ARM_PHY_CMD_RDC_USE_FIXED_RE_MSK    0x1
+#define MEMIF_ARM_PHY_CMD_RDC_WE_TO_RE_DEL_MSK    0x3
+#define MEMIF_ARM_PHY_CMD_RDC_WR_CMD_TO_DATA_MSK  0xF
+#define MEMIF_ARM_PHY_CMD_RDC_RD_CMD_TO_DATA_MSK  0xF
+    
+/* MEMIF_ARM_PHY_SLV_DLL */
+
+/* note Hoyle_DDRC spec v0.12 is wrong, this is the correct bit mapping */
+#define MEMIF_ARM_PHY_SLV_DLL_RD_RATIO0_IDX       16
+#define MEMIF_ARM_PHY_SLV_DLL_RD_RATIO1_IDX       24
+#define MEMIF_ARM_PHY_SLV_DLL_WR_RATIO_IDX        0
+
+#define MEMIF_ARM_PHY_SLV_DLL_RD_RATIO0_MSK       0xff
+#define MEMIF_ARM_PHY_SLV_DLL_RD_RATIO1_MSK       0xff
+#define MEMIF_ARM_PHY_SLV_DLL_WR_RATIO_MSK        0xff
+
+/* MEMIF_ARM_PHY_DEBUG_1 */
+    
+#define MEMIF_ARM_PHY_DEBUG_1_RC_DLL_SVAL0_IDX    0
+#define MEMIF_ARM_PHY_DEBUG_1_RC_DLL_SVAL1_IDX    9
+#define MEMIF_ARM_PHY_DEBUG_1_WR_DLL_SVAL_IDX     18
+
+#define MEMIF_ARM_PHY_DEBUG_1_RC_DLL_SVAL0_MSK    0x1ff
+#define MEMIF_ARM_PHY_DEBUG_1_RC_DLL_SVAL1_MSK    0x1ff
+#define MEMIF_ARM_PHY_DEBUG_1_WR_DLL_SVAL_MSK     0x1ff
+
+/* MEMIF_ARM_PHY_DEBUG_2 */
+    
+#define MEMIF_ARM_PHY_DEBUG_2_MSTR_DLL_LOCK0_IDX  0
+#define MEMIF_ARM_PHY_DEBUG_2_MSTR_DLL_SVAL0_IDX  2
+
+#define MEMIF_ARM_PHY_DEBUG_2_MSTR_DLL_LOCK0_MSK  0x1
+#define MEMIF_ARM_PHY_DEBUG_2_MSTR_DLL_SVAL0_MSK  0x1ff
+
+/* MEMIF_ARM_PHY_DEBUG_3 */
+    
+#define MEMIF_ARM_PHY_DEBUG_3_IN_LOCK_IDX         0
+#define MEMIF_ARM_PHY_DEBUG_3_IN_DELAY_IDX        2
+#define MEMIF_ARM_PHY_DEBUG_3_OUT_DELAY_IDX       11
+
+#define MEMIF_ARM_PHY_DEBUG_3_IN_LOCK_MSK         0x3
+#define MEMIF_ARM_PHY_DEBUG_3_IN_DELAY_MSK        0x1ff
+#define MEMIF_ARM_PHY_DEBUG_3_OUT_DELAY_MSK       0x1ff
+
+/* MEMIF_ARM_AXI_GP0 */
+
+#define MEMIF_ARM_AXI_GP0_LOOPBACK_MODE_IDX       0
+#define MEMIF_ARM_AXI_GP0_LOOPBACK_ERR_CLR_IDX    1
+
+/* MEMIF_ARM_AXI_GP1 */
+
+#define MEMIF_ARM_AXI_GP1_WL_DLL_FORCE_IDX        0
+#define MEMIF_ARM_AXI_GP1_RC_DLL_FORCE0_IDX       1
+#define MEMIF_ARM_AXI_GP1_RC_DLL_FORCE1_IDX       2
+#define MEMIF_ARM_AXI_GP1_WL_DLL_VALUE_IDX        3
+#define MEMIF_ARM_AXI_GP1_RC_DLL_VALUE0_IDX       12
+#define MEMIF_ARM_AXI_GP1_RC_DLL_VALUE1_IDX       21
+
+/* MEMIF_ARM_AXI_GPSTATUS0 */
+
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_DONE_IDX  0
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_FAIL_IDX  1
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_ERR0_IDX  2
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_ERR1_IDX  3
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_ERR2_IDX  4
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_ERR3_IDX  5
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_ERR4_IDX  6
+
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_DONE_MSK 0x1
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_FAIL_MSK 0x1
+#define MEMIF_ARM_AXI_GPSTATUS0_LOOPBACK_ERR_MSK  0x1f
+
+
+/*****************************************************************************/
+/* Base Addresses                                                            */
+/*****************************************************************************/
+        
+/* col  [9:0]  = axaddr[10:1] */
+/* bank [1:0]  = axaddr[12:11] */
+/* row  [12:0] = axaddr[25:13] */      
+#define BANK0_BASE_512Mbx16                 0x00000000 
+#define BANK1_BASE_512Mbx16                 0x00000800
+#define BANK2_BASE_512Mbx16                 0x00001000
+#define BANK3_BASE_512Mbx16                 0x00001800
+
+#endif /* PC302_MEM_ARM_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/mem_shd.h b/arch/arm/mach-pc302/include/mach/pc302/mem_shd.h
new file mode 100644
index 0000000..aa42728
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/mem_shd.h
@@ -0,0 +1,553 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __MEM_SHD_H__
+#define __MEM_SHD_H__
+
+#define MEMIF_SHD_REGS_PA_BUF0_SETUP_OFFSET		0x0000
+#define   MEMIF_SHD_REGS_PA_BUF0_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF0_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF0_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF0_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF0_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF0_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF0_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF0_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF0_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF0_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF0_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF0_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF0_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF0_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF0_ADDR_OFFSET		0x0001
+#define   MEMIF_SHD_REGS_PA_BUF0_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF0_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF1_SETUP_OFFSET		0x0002
+#define   MEMIF_SHD_REGS_PA_BUF1_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF1_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF1_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF1_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF1_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF1_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF1_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF1_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF1_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF1_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF1_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF1_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF1_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF1_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF1_ADDR_OFFSET		0x0003
+#define   MEMIF_SHD_REGS_PA_BUF1_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF1_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF2_SETUP_OFFSET		0x0004
+#define   MEMIF_SHD_REGS_PA_BUF2_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF2_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF2_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF2_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF2_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF2_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF2_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF2_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF2_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF2_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF2_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF2_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF2_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF2_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF2_ADDR_OFFSET		0x0005
+#define   MEMIF_SHD_REGS_PA_BUF2_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF2_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF3_SETUP_OFFSET		0x0006
+#define   MEMIF_SHD_REGS_PA_BUF3_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF3_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF3_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF3_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF3_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF3_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF3_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF3_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF3_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF3_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF3_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF3_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF3_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF3_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF3_ADDR_OFFSET		0x0007
+#define   MEMIF_SHD_REGS_PA_BUF3_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF3_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF4_SETUP_OFFSET		0x0008
+#define   MEMIF_SHD_REGS_PA_BUF4_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF4_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF4_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF4_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF4_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF4_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF4_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF4_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF4_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF4_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF4_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF4_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF4_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF4_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF4_ADDR_OFFSET		0x0009
+#define   MEMIF_SHD_REGS_PA_BUF4_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF4_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF5_SETUP_OFFSET		0x000A
+#define   MEMIF_SHD_REGS_PA_BUF5_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF5_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF5_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF5_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF5_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF5_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF5_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF5_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF5_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF5_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF5_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF5_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF5_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF5_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF5_ADDR_OFFSET		0x000B
+#define   MEMIF_SHD_REGS_PA_BUF5_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF5_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF6_SETUP_OFFSET		0x000C
+#define   MEMIF_SHD_REGS_PA_BUF6_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF6_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF6_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF6_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF6_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF6_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF6_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF6_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF6_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF6_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF6_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF6_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF6_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF6_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF6_ADDR_OFFSET		0x000D
+#define   MEMIF_SHD_REGS_PA_BUF6_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF6_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF7_SETUP_OFFSET		0x000E
+#define   MEMIF_SHD_REGS_PA_BUF7_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF7_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF7_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF7_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF7_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF7_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF7_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF7_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF7_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF7_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF7_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF7_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF7_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF7_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF7_ADDR_OFFSET		0x000F
+#define   MEMIF_SHD_REGS_PA_BUF7_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF7_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF8_SETUP_OFFSET		0x0010
+#define   MEMIF_SHD_REGS_PA_BUF8_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF8_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF8_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF8_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF8_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF8_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF8_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF8_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF8_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF8_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF8_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF8_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF8_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF8_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF8_ADDR_OFFSET		0x0011
+#define   MEMIF_SHD_REGS_PA_BUF8_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF8_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF9_SETUP_OFFSET		0x0012
+#define   MEMIF_SHD_REGS_PA_BUF9_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF9_SIZE_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PA_BUF9_WDWW_IDX		4
+#define      MEMIF_SHD_REGS_PA_BUF9_WDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF9_RDWW_IDX		6
+#define      MEMIF_SHD_REGS_PA_BUF9_RDWW_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF9_WIAP_IDX		8
+#define      MEMIF_SHD_REGS_PA_BUF9_WIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF9_RIAP_IDX		10
+#define      MEMIF_SHD_REGS_PA_BUF9_RIAP_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PA_BUF9_BANK_IDX		12
+#define      MEMIF_SHD_REGS_PA_BUF9_BANK_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PA_BUF9_ONE_ADDR_IDX		15
+#define      MEMIF_SHD_REGS_PA_BUF9_ONE_ADDR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PA_BUF9_ADDR_OFFSET		0x0013
+#define   MEMIF_SHD_REGS_PA_BUF9_SADDR_IDX		0
+#define      MEMIF_SHD_REGS_PA_BUF9_SADDR_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G0_S0_S1_OFFSET		0x0020
+#define   MEMIF_SHD_REGS_SDRAM_G0_S0_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G0_S0_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G0_S1_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G0_S1_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G0_S2_S3_OFFSET		0x0021
+#define   MEMIF_SHD_REGS_SDRAM_G0_S2_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G0_S2_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G0_S3_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G0_S3_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G1_S0_S1_OFFSET		0x0022
+#define   MEMIF_SHD_REGS_SDRAM_G1_S0_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G1_S0_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G1_S1_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G1_S1_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G1_S2_S3_OFFSET		0x0023
+#define   MEMIF_SHD_REGS_SDRAM_G1_S2_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G1_S2_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G1_S3_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G1_S3_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G2_S0_S1_OFFSET		0x0024
+#define   MEMIF_SHD_REGS_SDRAM_G2_S0_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G2_S0_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G2_S1_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G2_S1_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G2_S2_S3_OFFSET		0x0025
+#define   MEMIF_SHD_REGS_SDRAM_G2_S2_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G2_S2_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G2_S3_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G2_S3_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G3_S0_S1_OFFSET		0x0026
+#define   MEMIF_SHD_REGS_SDRAM_G3_S0_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G3_S0_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G3_S1_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G3_S1_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G3_S2_S3_OFFSET		0x0027
+#define   MEMIF_SHD_REGS_SDRAM_G3_S2_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G3_S2_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G3_S3_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G3_S3_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G4_S0_S1_OFFSET		0x0028
+#define   MEMIF_SHD_REGS_SDRAM_G4_S0_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G4_S0_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G4_S1_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G4_S1_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G4_S2_S3_OFFSET		0x0029
+#define   MEMIF_SHD_REGS_SDRAM_G4_S2_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G4_S2_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G4_S3_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G4_S3_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G5_S0_S1_OFFSET		0x002A
+#define   MEMIF_SHD_REGS_SDRAM_G5_S0_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G5_S0_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G5_S1_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G5_S1_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G5_S2_S3_OFFSET		0x002B
+#define   MEMIF_SHD_REGS_SDRAM_G5_S2_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G5_S2_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G5_S3_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G5_S3_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G6_S0_S1_OFFSET		0x002C
+#define   MEMIF_SHD_REGS_SDRAM_G6_S0_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G6_S0_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G6_S1_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G6_S1_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G6_S2_S3_OFFSET		0x002D
+#define   MEMIF_SHD_REGS_SDRAM_G6_S2_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G6_S2_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G6_S3_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G6_S3_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G7_S0_S1_OFFSET		0x002E
+#define   MEMIF_SHD_REGS_SDRAM_G7_S0_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G7_S0_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G7_S1_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G7_S1_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ARB_G7_S2_S3_OFFSET		0x002F
+#define   MEMIF_SHD_REGS_SDRAM_G7_S2_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_G7_S2_CFG_MSK		((1<<6)-1)
+#define   MEMIF_SHD_REGS_SDRAM_G7_S3_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SDRAM_G7_S3_CFG_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_VALID_GROUPS_OFFSET		0x0030
+#define   MEMIF_SHD_REGS_SDRAM_VALID_GROUPS_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_VALID_GROUPS_MSK		((1<<8)-1)
+
+#define MEMIF_SHD_REGS_SRAM_ARB_S0_S1_OFFSET		0x0040
+#define   MEMIF_SHD_REGS_SRAM_S0_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SRAM_S0_CFG_MSK		((1<<7)-1)
+#define   MEMIF_SHD_REGS_SRAM_S1_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SRAM_S1_CFG_MSK		((1<<7)-1)
+
+#define MEMIF_SHD_REGS_SRAM_ARB_S2_S3_OFFSET		0x0041
+#define   MEMIF_SHD_REGS_SRAM_S2_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SRAM_S2_CFG_MSK		((1<<7)-1)
+#define   MEMIF_SHD_REGS_SRAM_S3_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SRAM_S3_CFG_MSK		((1<<7)-1)
+
+#define MEMIF_SHD_REGS_SRAM_ARB_S4_S5_OFFSET		0x0042
+#define   MEMIF_SHD_REGS_SRAM_S4_CFG_IDX		0
+#define      MEMIF_SHD_REGS_SRAM_S4_CFG_MSK		((1<<7)-1)
+#define   MEMIF_SHD_REGS_SRAM_S5_CFG_IDX		8
+#define      MEMIF_SHD_REGS_SRAM_S5_CFG_MSK		((1<<7)-1)
+
+#define MEMIF_SHD_REGS_SRAM_VALID_SLOTS_OFFSET		0x0043
+#define   MEMIF_SHD_REGS_SRAM_VALID_SLOTS_IDX		0
+#define      MEMIF_SHD_REGS_SRAM_VALID_SLOTS_MSK		((1<<6)-1)
+
+#define MEMIF_SHD_REGS_ARB_UPDATE_OFFSET		0x004F
+#define   MEMIF_SHD_REGS_SDRAM_ARB_UPDATE_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_ARB_UPDATE_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_SRAM_ARB_UPDATE_IDX		1
+#define      MEMIF_SHD_REGS_SRAM_ARB_UPDATE_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_SETUP_OFFSET		0x0050
+#define   MEMIF_SHD_REGS_SDRAM_SIZE_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_SIZE_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_SDRAM_BANKS_IDX		2
+#define      MEMIF_SHD_REGS_SDRAM_BANKS_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_SDRAM_RW_GAP_IDX		3
+#define      MEMIF_SHD_REGS_SDRAM_RW_GAP_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_SDRAM_WR_GAP_IDX		7
+#define      MEMIF_SHD_REGS_SDRAM_WR_GAP_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_SDRAM_CAS_LATENCY_IDX		11
+#define      MEMIF_SHD_REGS_SDRAM_CAS_LATENCY_MSK		((1<<3)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_REFRESH_OFFSET		0x0051
+#define   MEMIF_SHD_REGS_SDRAM_REFRESH_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_REFRESH_MSK		((1<<16)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_MRS_OFFSET		0x0052
+#define   MEMIF_SHD_REGS_SDRAM_MRS_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_MRS_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_EMRS_OFFSET		0x0053
+#define   MEMIF_SHD_REGS_SDRAM_EMRS_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_EMRS_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_EMRS2_OFFSET		0x0054
+#define   MEMIF_SHD_REGS_SDRAM_EMRS2_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_EMRS2_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_EMRS3_OFFSET		0x0055
+#define   MEMIF_SHD_REGS_SDRAM_EMRS3_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_EMRS3_MSK		((1<<14)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_ODT_SETUP_OFFSET		0x0056
+#define   MEMIF_SHD_REGS_SDRAM_ODT_ENABLE_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_ODT_ENABLE_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_SDRAM_ODT_ON_DELAY_IDX		1
+#define      MEMIF_SHD_REGS_SDRAM_ODT_ON_DELAY_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_SDRAM_ODT_ON_DURATION_IDX		4
+#define      MEMIF_SHD_REGS_SDRAM_ODT_ON_DURATION_MSK		((1<<3)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_CFG_DONE_OFFSET		0x0057
+#define   MEMIF_SHD_REGS_SDRAM_CFG_DONE_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_CFG_DONE_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_AXI_CONFIG_OFFSET		0x0058
+#define   MEMIF_SHD_REGS_SDRAM_AXI_RBC_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_AXI_RBC_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_SDRAM_AXI_SIZE_IDX		1
+#define      MEMIF_SHD_REGS_SDRAM_AXI_SIZE_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_SDRAM_AXI_BANKS_IDX		3
+#define      MEMIF_SHD_REGS_SDRAM_AXI_BANKS_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_DEBUG_OFFSET		0x0059
+#define   MEMIF_SHD_REGS_SDRAM_DLL_CALIB_DISABLE_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_DLL_CALIB_DISABLE_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_STATUS_OFFSET		0x005A
+#define   MEMIF_SHD_REGS_SDRAM_FSM_STATUS_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_FSM_STATUS_MSK		((1<<9)-1)
+
+#define MEMIF_SHD_REGS_SDRAM_TIMING_OFFSET		0x005B
+#define   MEMIF_SHD_REGS_SDRAM_T_RFC_MIN_IDX		0
+#define      MEMIF_SHD_REGS_SDRAM_T_RFC_MIN_MSK		((1<<7)-1)
+
+#define MEMIF_SHD_REGS_PHY_TEST_OFFSET		0x0060
+#define   MEMIF_SHD_REGS_PHY_LOOPBACK_IDX		0
+#define      MEMIF_SHD_REGS_PHY_LOOPBACK_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_TEST_ENABLE_IDX		1
+#define      MEMIF_SHD_REGS_PHY_TEST_ENABLE_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PHY_CONFIG_OFFSET		0x0061
+#define   MEMIF_SHD_REGS_PHY_FIRST_RD_IDX		0
+#define      MEMIF_SHD_REGS_PHY_FIRST_RD_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PHY_FIRST_WR_IDX		4
+#define      MEMIF_SHD_REGS_PHY_FIRST_WR_MSK		((1<<4)-1)
+#define   MEMIF_SHD_REGS_PHY_BL_IDX		8
+#define      MEMIF_SHD_REGS_PHY_BL_MSK		((1<<3)-1)
+#define   MEMIF_SHD_REGS_PHY_RDC_WE_TO_RE_DELAY_IDX		11
+#define      MEMIF_SHD_REGS_PHY_RDC_WE_TO_RE_DELAY_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PHY_USE_FIXED_RE_IDX		13
+#define      MEMIF_SHD_REGS_PHY_USE_FIXED_RE_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_DIS_CALIB_RST_IDX		14
+#define      MEMIF_SHD_REGS_PHY_DIS_CALIB_RST_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_RDC_FIFO_RST_ERR_CNT_CLR_IDX		15
+#define      MEMIF_SHD_REGS_PHY_RDC_FIFO_RST_ERR_CNT_CLR_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PHY_LOCAL_ODT_CONFIG_OFFSET		0x0062
+#define   MEMIF_SHD_REGS_PHY_RD_LOCAL_ODT_IDX		0
+#define      MEMIF_SHD_REGS_PHY_RD_LOCAL_ODT_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PHY_WR_LOCAL_ODT_IDX		2
+#define      MEMIF_SHD_REGS_PHY_WR_LOCAL_ODT_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PHY_IDLE_LOCAL_ODT_IDX		4
+#define      MEMIF_SHD_REGS_PHY_IDLE_LOCAL_ODT_MSK		((1<<2)-1)
+
+#define MEMIF_SHD_REGS_PHY_RDC_FIFO_RST_ERR_CNT_OFFSET		0x0063
+#define   MEMIF_SHD_REGS_PHY_RDC_FIFO_RST_ERR_CNT_IDX		0
+#define      MEMIF_SHD_REGS_PHY_RDC_FIFO_RST_ERR_CNT_MSK		((1<<4)-1)
+
+#define MEMIF_SHD_REGS_PHY_WR_SLAVE_OFFSET		0x0064
+#define   MEMIF_SHD_REGS_PHY_WR_SLAVE_RATIO0_IDX		0
+#define      MEMIF_SHD_REGS_PHY_WR_SLAVE_RATIO0_MSK		((1<<8)-1)
+#define   MEMIF_SHD_REGS_PHY_WR_SLAVE_RATIO1_IDX		8
+#define      MEMIF_SHD_REGS_PHY_WR_SLAVE_RATIO1_MSK		((1<<8)-1)
+
+#define MEMIF_SHD_REGS_PHY_RD_SLAVE_OFFSET		0x0065
+#define   MEMIF_SHD_REGS_PHY_RD_SLAVE_RATIO0_IDX		0
+#define      MEMIF_SHD_REGS_PHY_RD_SLAVE_RATIO0_MSK		((1<<8)-1)
+#define   MEMIF_SHD_REGS_PHY_RD_SLAVE_RATIO1_IDX		8
+#define      MEMIF_SHD_REGS_PHY_RD_SLAVE_RATIO1_MSK		((1<<8)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_WR_DLL0_OFFSET		0x0066
+#define   MEMIF_SHD_REGS_PHY_DEBUG_WL_DLL_VALUE0_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_WL_DLL_VALUE0_MSK		((1<<9)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_WL_DLL_FORCE0_IDX		9
+#define      MEMIF_SHD_REGS_PHY_DEBUG_WL_DLL_FORCE0_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL0_OFFSET		0x0068
+#define   MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL_VALUE0_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL_VALUE0_MSK		((1<<9)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL_FORCE0_IDX		9
+#define      MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL_FORCE0_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL1_OFFSET		0x0069
+#define   MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL_VALUE1_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL_VALUE1_MSK		((1<<9)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL_FORCE1_IDX		9
+#define      MEMIF_SHD_REGS_PHY_DEBUG_RC_DLL_FORCE1_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PHY_IO_CELL_CONFIG_OFFSET		0x006A
+#define   MEMIF_SHD_REGS_PHY_IO_CELL_CONFIG_IDX		0
+#define      MEMIF_SHD_REGS_PHY_IO_CELL_CONFIG_MSK		((1<<16)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_OFFSET		0x0070
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_DQ_OE0_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_DQ_OE0_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_DQS_OE0_IDX		1
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_DQS_OE0_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_FIFO_WE0_IDX		2
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_FIFO_WE0_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_FIFO_RE0_IDX		3
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_FIFO_RE0_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_DQ_OE1_IDX		4
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_DQ_OE1_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_DQS_OE1_IDX		5
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_DQS_OE1_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_FIFO_WE1_IDX		6
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_FIFO_WE1_MSK		((1<<1)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_FIFO_RE1_IDX		7
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_BC_FIFO_RE1_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_STATUS_RC_DLL_0_OFFSET		0x0071
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_RC_DLL_SLAVE_VALUE0_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_RC_DLL_SLAVE_VALUE0_MSK		((1<<9)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_STATUS_RC_DLL_1_OFFSET		0x0072
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_RC_DLL_SLAVE_VALUE1_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_RC_DLL_SLAVE_VALUE1_MSK		((1<<9)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_STATUS_WR_DLL_OFFSET		0x0073
+#define   MEMIF_SHD_REGS_PHY_DEBUG_WR_SLAVE_DLL_VALUE_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_WR_SLAVE_DLL_VALUE_MSK		((1<<9)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_STATUS_MASTER_DLL_0_OFFSET		0x0074
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_MASTER_DLL_0_SLAVE_VALUE_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_MASTER_DLL_0_SLAVE_VALUE_MSK		((1<<9)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_MASTER_DLL_0_LOCK_IDX		9
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_MASTER_DLL_0_LOCK_MSK		((1<<1)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_STATUS_OF_IN_DELAY_0_OFFSET		0x0075
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_OF_IN_LOCK_STATE_0_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_OF_IN_LOCK_STATE_0_MSK		((1<<2)-1)
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_OF_IN_DELAY_VALUE_0_IDX		2
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_OF_IN_DELAY_VALUE_0_MSK		((1<<9)-1)
+
+#define MEMIF_SHD_REGS_PHY_DEBUG_STATUS_OF_OUT_DELAY_0_OFFSET		0x0076
+#define   MEMIF_SHD_REGS_PHY_DEBUG_STATUS_OF_OUT_DELAY_VALUE_0_IDX		0
+#define      MEMIF_SHD_REGS_PHY_DEBUG_STATUS_OF_OUT_DELAY_VALUE_0_MSK		((1<<9)-1)
+
+#define MEMIF_SHD_REGS_PA_FIFO_STATUS_LWR_OFFSET		0x0080
+#define   MEMIF_SHD_REGS_PA_FIFO_STATUS_LWR_IDX		0
+#define      MEMIF_SHD_REGS_PA_FIFO_STATUS_LWR_MSK		((1<<10)-1)
+
+#define MEMIF_SHD_REGS_PA_FIFO_STATUS_UPR_OFFSET		0x0081
+#define   MEMIF_SHD_REGS_PA_FIFO_STATUS_UPR_IDX		0
+#define      MEMIF_SHD_REGS_PA_FIFO_STATUS_UPR_MSK		((1<<10)-1)
+
+#define MEMIF_SHD_REGS_PA_ADDR_ERROR_LWR_OFFSET		0x0082
+#define   MEMIF_SHD_REGS_PA_ADDR_ERROR_LWR_IDX		0
+#define      MEMIF_SHD_REGS_PA_ADDR_ERROR_LWR_MSK		((1<<10)-1)
+
+#define MEMIF_SHD_REGS_PA_ADDR_ERROR_UPR_OFFSET		0x0083
+#define   MEMIF_SHD_REGS_PA_ADDR_ERROR_UPR_IDX		0
+#define      MEMIF_SHD_REGS_PA_ADDR_ERROR_UPR_MSK		((1<<10)-1)
+
+#define MEMIF_SHD_REGS_PA_ADDR_ERROR_MASK_LWR_OFFSET		0x0084
+#define   MEMIF_SHD_REGS_PA_ADDR_ERROR_MASK_LWR_IDX		0
+#define      MEMIF_SHD_REGS_PA_ADDR_ERROR_MASK_LWR_MSK		((1<<10)-1)
+
+#define MEMIF_SHD_REGS_PA_ADDR_ERROR_MASK_UPR_OFFSET		0x0085
+#define   MEMIF_SHD_REGS_PA_ADDR_ERROR_MASK_UPR_IDX		0
+#define      MEMIF_SHD_REGS_PA_ADDR_ERROR_MASK_UPR_MSK		((1<<10)-1)
+
+#endif /* __MEM_SHD_H__ */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/pa.h b/arch/arm/mach-pc302/include/mach/pc302/pa.h
new file mode 100644
index 0000000..987841a
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/pa.h
@@ -0,0 +1,78 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_PA_H
+#define PC302_PA_H
+
+#define PA_TIMECOUNT 32
+
+#define PA_AEID_CTRL_0    0x0008
+#define PA_AEID_TURBO     0x0028
+#define PA_AEID_UL_TB_FMT 0x0038
+#define PA_AEID_UL_DSPRD  0x0049
+#define PA_AEID_UL_SYM    0x0058
+#define PA_AEID_CTRL_06   0x0068
+#define PA_AEID_MEMIF     0x0088
+#define PA_AEID_AXI2PICO  0x00A8
+
+#define PA_WHATAMI_REG_ADDR 0xa064
+
+#define  PA_WHATAMI_STAN2           0x00
+#define  PA_WHATAMI_RESVD1          0x01
+#define  PA_WHATAMI_MEM             0x02
+#define  PA_WHATAMI_SWITCH          0x03
+#define  PA_WHATAMI_CTRL            0x04
+#define  PA_WHATAMI_MEMIF           0x05
+#define  PA_WHATAMI_RESVD6          0x06
+#define  PA_WHATAMI_PAI             0x07
+#define  PA_WHATAMI_RESVD8          0x08
+#define  PA_WHATAMI_RESVD9          0x09
+#define  PA_WHATAMI_RESVD10         0x0A
+#define  PA_WHATAMI_MAXIM           0x0B
+#define  PA_WHATAMI_AXI2PICO        0x0C
+#define  PA_WHATAMI_DL_SYM          0x0D
+#define  PA_WHATAMI_DL_HS_TB        0x1D
+#define  PA_WHATAMI_DL_HS_RM        0x2D
+#define  PA_WHATAMI_DL_HS_SCCH      0x3D
+#define  PA_WHATAMI_DL_HS_CHIP      0x4D
+#define  PA_WHATAMI_DL_CHIP         0x5D
+#define  PA_WHATAMI_DL_SAMP         0x6D
+#define  PA_WHATAMI_DL_RX_SCH       0x7D
+#define  PA_WHATAMI_UL_SAMP         0x0E
+#define  PA_WHATAMI_UL_DSPRD        0x1E
+#define  PA_WHATAMI_UL_RACH         0x2E
+#define  PA_WHATAMI_UL_EDPDCH       0x3E
+#define  PA_WHATAMI_UL_SYM          0x4E
+#define  PA_WHATAMI_UL_SRCH         0x5E
+#define  PA_WHATAMI_UL_TB_FMT       0x6E
+#define  PA_WHATAMI_UL_VITERBI      0x7E
+#define  PA_WHATAMI_UL_TURBO        0x8E
+
+#define PA_CONFIG_WRITE            0x00010000
+#define PA_CONFIG_READ             0x00020000
+#define PA_CONFIG_ADDR             0x00040000
+#define PA_CONFIG_AEID             0x00080000
+#define PA_CONFIG_VALID            0x00010000
+#define PA_CONFIG_FAIL             0x00020000
+
+#define PA_STATUS_VALID		   0
+#define PA_STATUS_FAIL		   1
+#define PA_STATUS_TIMEOUT	   2
+
+#endif /* PC302_PA_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/pc302.h b/arch/arm/mach-pc302/include/mach/pc302/pc302.h
new file mode 100644
index 0000000..c557138
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/pc302.h
@@ -0,0 +1,104 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __PC302_H__
+#define __PC302_H__
+
+#ifndef __ASSEMBLY__
+
+/**
+ * Read the system configuration register.
+ *
+ * \return Returns the value of the system configuration register.
+ */
+u32 syscfg_read(void);
+
+/**
+ * Update the system configuration register.
+ *
+ * \param mask Mask of the bits to update.
+ * \param val The value to write.
+ */
+void syscfg_update(u32 mask, u32 val);
+
+#endif /* __ASSEMBLY__ */
+
+/*****************************************************************************/
+/* Internal Boot ROM                                                         */
+/*****************************************************************************/
+#define BOOT_ROM_BASE           0xFFFF0000
+#define BOOT_ROM_SIZE           0x400
+/*****************************************************************************/
+/* AXI2PICO Buffers                                                          */
+/*****************************************************************************/
+#define AXI2PICO_BUFFERS_BASE   0xC0000000
+#define AXI2PICO_BUFFERS_SIZE   0x00010000
+
+/*****************************************************************************/
+/* Peripheral Bus                                                            */
+/*****************************************************************************/
+#define PC302_PERIPH_BASE             0x80000000
+#define PC302_PERIPH_LENGTH           0x00400000
+#define PC302_MEMIF_BASE              0x80000000
+#define PC302_EBI_BASE                0x80010000
+#define PC302_EMAC_BASE               0x80030000
+#define PC302_DMAC1_BASE              0x80040000
+#define PC302_DMAC2_BASE              0x80050000
+#define PC302_VIC0_BASE               0x80060000
+#define PC302_VIC1_BASE               0x80064000
+#define PC302_TZIC_BASE               0x80068000
+#define PC302_TZPC_BASE               0x80070000
+#define PC302_FUSE_BASE               0x80080000
+#define PC302_SSI_BASE                0x80090000
+#define PC302_AXI2CFG_BASE            0x800A0000
+#define PC302_IPSEC_BASE              0x80100000
+#define PC302_SRTP_BASE               0x80140000
+#define PC302_CIPHER_BASE             0x80180000
+#define PC302_RTCLK_BASE              0x80200000
+#define PC302_TIMER_BASE              0x80210000
+#define PC302_GPIO_BASE               0x80220000
+#define PC302_UART1_BASE              0x80230000
+#define PC302_UART2_BASE              0x80240000
+#define PC302_WDOG_BASE               0x80250000
+
+/*****************************************************************************/
+/* External Memory                                                           */
+/*****************************************************************************/
+#define DDRBANK0_BASE           0x00000000
+#define DDRBANK1_BASE           0x04000000
+#define DDRBANK2_BASE           0x08000000
+#define DDRBANK3_BASE           0x0C000000
+
+#define EBI_CS0_BASE            0x40000000
+#define EBI_CS1_BASE            0x48000000
+#define EBI_CS2_BASE            0x50000000
+#define EBI_CS3_BASE            0x58000000
+
+#define FLASH_BASE              EBI_CS0_BASE
+#define FLASH_START             EBI_CS0_BASE
+#define FLASH_SIZE              0x08000000
+
+/*****************************************************************************/
+/* Internal SRAM Memory                                                      */
+/*****************************************************************************/
+#define SRAM_BASE               0x20000000
+#define SRAM_START              0x20000000
+#define SRAM_SIZE               0x00020000
+
+#endif /* __PC302_H__ */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/rtc.h b/arch/arm/mach-pc302/include/mach/pc302/rtc.h
new file mode 100644
index 0000000..1d53431
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/rtc.h
@@ -0,0 +1,61 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_RTC_H
+#define PC302_RTC_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define RTCLK_CCV_REG_OFFSET                0x00
+#define RTCLK_CM_REG_OFFSET                 0x04
+#define RTCLK_CL_REG_OFFSET                 0x08
+#define RTCLK_CC_REG_OFFSET                 0x0C
+#define RTCLK_STAT_REG_OFFSET               0x10
+#define RTCLK_RSTAT_REG_OFFSET              0x14
+#define RTCLK_EOI_REG_OFFSET                0x18
+#define RTCLK_COMP_VERSION_REG_OFFSET       0x1C
+
+/*****************************************************************************/;
+/* Register Reset Values                                                     */;
+/*****************************************************************************/;
+
+#define RTCLK_CCV_REG_RESET                 0x00000000
+#define RTCLK_CM_REG_RESET                  0x00000000
+#define RTCLK_CL_REG_RESET                  0x00000000
+#define RTCLK_CC_REG_RESET                  0x00000000
+#define RTCLK_STAT_REG_RESET                0x00000000
+#define RTCLK_RSTAT_REG_RESET               0x00000000
+#define RTCLK_EOI_REG_RESET                 0x00000000
+#define RTCLK_COMP_VERSION_REG_RESET        0x3230312a
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define RTCLK_CC_REG_MASK_IDX	            1
+#define RTCLK_CC_REG_EN_IDX		    0
+
+#define RTCLK_CC_REG_MASK_MASK	            1 << RTCLK_CC_REG_MASK_IDX
+#define RTCLK_CC_REG_EN_MASK	            1 << RTCLK_CC_REG_EN_IDX
+
+#endif /* PC302_RTCG_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/spa.h b/arch/arm/mach-pc302/include/mach/pc302/spa.h
new file mode 100644
index 0000000..53e89ac
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/spa.h
@@ -0,0 +1,135 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_SPA_H
+#define PC302_SPA_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* base addresses */
+#define SPA_1_BASE                      IPSEC_BASE
+#define SPA_2_BASE                      SRTP_BASE
+#define SPA_3_BASE                      CIPHER_BASE
+
+/* Functional Registers */
+
+#define SPA_IRQ_EN_REG_OFFSET           0x00000000
+#define SPA_IRQ_STAT_REG_OFFSET         0x00000004
+#define SPA_IRQ_CTRL_REG_OFFSET         0x00000008
+#define SPA_FIFO_STAT_REG_OFFSET        0x0000000C
+#define SPA_SDMA_BRST_SZ_REG_OFFSET     0x00000010
+#define SPA_SRC_PTR_REG_OFFSET          0x00000020
+#define SPA_DST_PTR_REG_OFFSET          0x00000024
+#define SPA_OFFSET_REG_OFFSET           0x00000028
+#define SPA_AAD_LEN_REG_OFFSET          0x0000002C
+#define SPA_PROC_LEN_REG_OFFSET         0x00000030
+#define SPA_ICV_LEN_REG_OFFSET          0x00000034
+#define SPA_ICV_OFFSET_REG_OFFSET       0x00000038
+#define SPA_SW_CTRL_REG_OFFSET          0x0000003C
+#define SPA_CTRL_REG_OFFSET             0x00000040
+#define SPA_AUX_INFO_REG_OFFSET         0x0000004C
+#define SPA_STAT_POP_REG_OFFSET         0x00000050
+#define SPA_STATUS_REG_OFFSET           0x00000054
+#define SPA_KEY_SZ_REG_OFFSET           0x00000100
+#define SPA_CIPH_KEY_BASE_REG_OFFSET    0x00004000
+#define SPA_HASH_KEY_BASE_REG_OFFSET    0x00008000
+#define SPA_RC4_CTX_BASE_REG_OFFSET     0x00020000
+    
+    
+/*****************************************************************************/
+/* Register Reset Values                                                     */
+/*****************************************************************************/
+
+#define SPA_IRQ_EN_REG_RESET            0x00000000
+#define SPA_IRQ_CTRL_REG_RESET          0x00000000
+#define SPA_FIFO_STAT_REG_RESET         0x00000000
+#define SPA_SDMA_BRST_SZ_REG_RESET      0x00000000
+#define SPA_SRC_PTR_REG_RESET           0x00000000
+#define SPA_DST_PTR_REG_RESET           0x00000000
+#define SPA_OFFSET_REG_RESET            0x00000000
+#define SPA_AAD_LEN_REG_RESET           0x00000000
+#define SPA_PROC_LEN_REG_RESET          0x00000000
+#define SPA_ICV_LEN_REG_RESET           0x00000000
+#define SPA_ICV_OFFSET_REG_RESET        0x00000000
+#define SPA_SW_CTRL_REG_RESET           0x00000000
+#define SPA_CTRL_REG_RESET              0x00000000
+#define SPA_AUX_INFO_REG_RESET          0x00000000
+#define SPA_STAT_POP_REG_RESET          0x00000000
+#define SPA_STATUS_REG_RESET            0x00000000
+#define SPA_KEY_SZ_REG_RESET            0x00000000
+/* SPA_CIPH_KEY_BASE_REG_RESET    EQU Unknown reset value */
+/* SPA_HASH_KEY_BASE_REG_RESET    EQU Unknown reset value */
+/* SPA_RC4_CTX_BASE_REG_RESET     EQU Unknown reset value */
+
+
+/*****************************************************************************/
+/* Control Register Bit Definitions                                          */
+/*****************************************************************************/
+#define SPA_CTRL_HASH_ALG_IDX   4
+#define SPA_CTRL_CIPH_MODE_IDX  8
+#define SPA_CTRL_HASH_MODE_IDX 12
+#define SPA_CTRL_CTX_IDX       16
+#define SPA_CTRL_ENCRYPT_IDX   24
+
+/*****************************************************************************/
+/* Key Size Register Bit Definitions                                         */
+/*****************************************************************************/
+#define SPA_KEY_SZ_CXT_IDX     8
+#define SPA_KEY_SZ_CIPHER_IDX 31
+
+/*****************************************************************************/
+/* Control Cipher Algorithm Register Bit Definitions                         */
+/*****************************************************************************/
+#define SPA_CTRL_CIPH_ALG_NULL    0x00
+#define SPA_CTRL_CIPH_ALG_DES     0x01
+#define SPA_CTRL_CIPH_ALG_AES     0x02
+#define SPA_CTRL_CIPH_ALG_RC4     0x03
+#define SPA_CTRL_CIPH_ALG_MULTI2  0x04
+#define SPA_CTRL_CIPH_ALG_KASUMI  0x05
+
+#define SPA_CTRL_HASH_ALG_NULL    0x00 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_MD5     0x01 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA     0x02 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA224  0x03 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA256  0x04 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA384  0x05 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA512  0x06 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_AESMAC  0x07 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_AESCMAC 0x08 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_KASF9   0x09 << SPA_CTRL_HASH_ALG_IDX
+
+#define SPA_CTRL_CIPH_MODE_NULL   0x00 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_ECB    0x00 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_CBC    0x01 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_CTR    0x02 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_CCM    0x03 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_GCM    0x05 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_OFB    0x07 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_CFB    0x08 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_F8     0x09 << SPA_CTRL_CIPH_MODE_IDX
+
+#define SPA_CTRL_HASH_MODE_RAW    0x00 << SPA_CTRL_HASH_MODE_IDX
+#define SPA_CTRL_HASH_MODE_SSLMAC 0x01 << SPA_CTRL_HASH_MODE_IDX
+#define SPA_CTRL_HASH_MODE_HMAC   0x02 << SPA_CTRL_HASH_MODE_IDX
+
+#endif /* PC302_SPA_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/spacc.h b/arch/arm/mach-pc302/include/mach/pc302/spacc.h
new file mode 100644
index 0000000..9c912b8
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/spacc.h
@@ -0,0 +1,166 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_SPA_H
+#define PC302_SPA_H
+
+#include "pc302.h"
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* base addresses */
+#define SPA_1_BASE                      PC302_IPSEC_BASE
+#define SPA_2_BASE                      PC302_SRTP_BASE
+#define SPA_3_BASE                      PC302_CIPHER_BASE
+
+#define SPA_STATUS_OK                   ( 0 )
+#define SPA_STATUS_ICV_FAIL             ( 1 )
+#define SPA_STATUS_MEMORY_ERROR         ( 2 )
+#define SPA_STATUS_BLOCK_ERROR          ( 3 )
+
+#define SPA_IRQ_CTRL_STAT_CNT_OFFSET    ( 16 )
+#define SPA_IRQ_STAT_STAT_MASK          ( 1 << 4 )
+#define SPA_FIFO_STAT_STAT_OFFSET       ( 16 )
+#define SPA_FIFO_STAT_STAT_CNT_MASK     ( 0x3F << SPA_FIFO_STAT_STAT_OFFSET )
+#define SPA_STATUS_RES_CODE_OFFSET      ( 24 )
+#define SPA_STATUS_RES_CODE_MASK        ( 0x3 << SPA_STATUS_RES_CODE_OFFSET )
+#define SPA_KEY_SZ_CTX_INDEX_OFFSET     ( 8 )
+#define SPA_KEY_SZ_CIPHER_OFFSET        ( 31 )
+
+/* Functional Registers */
+
+#define SPA_IRQ_EN_REG_OFFSET           0x00000000
+#define SPA_IRQ_STAT_REG_OFFSET         0x00000004
+#define SPA_IRQ_CTRL_REG_OFFSET         0x00000008
+#define SPA_FIFO_STAT_REG_OFFSET        0x0000000C
+#define SPA_SDMA_BRST_SZ_REG_OFFSET     0x00000010
+#define SPA_SRC_PTR_REG_OFFSET          0x00000020
+#define SPA_DST_PTR_REG_OFFSET          0x00000024
+#define SPA_OFFSET_REG_OFFSET           0x00000028
+#define SPA_AAD_LEN_REG_OFFSET          0x0000002C
+#define SPA_PROC_LEN_REG_OFFSET         0x00000030
+#define SPA_ICV_LEN_REG_OFFSET          0x00000034
+#define SPA_ICV_OFFSET_REG_OFFSET       0x00000038
+#define SPA_SW_CTRL_REG_OFFSET          0x0000003C
+#define SPA_CTRL_REG_OFFSET             0x00000040
+#define SPA_AUX_INFO_REG_OFFSET         0x0000004C
+#define SPA_STAT_POP_REG_OFFSET         0x00000050
+#define SPA_STATUS_REG_OFFSET           0x00000054
+#define SPA_KEY_SZ_REG_OFFSET           0x00000100
+#define SPA_CIPH_KEY_BASE_REG_OFFSET    0x00004000
+#define SPA_HASH_KEY_BASE_REG_OFFSET    0x00008000
+#define SPA_RC4_CTX_BASE_REG_OFFSET     0x00020000
+
+
+/*****************************************************************************/
+/* Register Reset Values                                                     */
+/*****************************************************************************/
+
+#define SPA_IRQ_EN_REG_RESET            0x00000000
+#define SPA_IRQ_CTRL_REG_RESET          0x00000000
+#define SPA_FIFO_STAT_REG_RESET         0x00000000
+#define SPA_SDMA_BRST_SZ_REG_RESET      0x00000000
+#define SPA_SRC_PTR_REG_RESET           0x00000000
+#define SPA_DST_PTR_REG_RESET           0x00000000
+#define SPA_OFFSET_REG_RESET            0x00000000
+#define SPA_AAD_LEN_REG_RESET           0x00000000
+#define SPA_PROC_LEN_REG_RESET          0x00000000
+#define SPA_ICV_LEN_REG_RESET           0x00000000
+#define SPA_ICV_OFFSET_REG_RESET        0x00000000
+#define SPA_SW_CTRL_REG_RESET           0x00000000
+#define SPA_CTRL_REG_RESET              0x00000000
+#define SPA_AUX_INFO_REG_RESET          0x00000000
+#define SPA_STAT_POP_REG_RESET          0x00000000
+#define SPA_STATUS_REG_RESET            0x00000000
+#define SPA_KEY_SZ_REG_RESET            0x00000000
+/* SPA_CIPH_KEY_BASE_REG_RESET    EQU Unknown reset value */
+/* SPA_HASH_KEY_BASE_REG_RESET    EQU Unknown reset value */
+/* SPA_RC4_CTX_BASE_REG_RESET     EQU Unknown reset value */
+
+
+/*****************************************************************************/
+/* Control Register Bit Definitions                                          */
+/*****************************************************************************/
+#define SPA_CTRL_HASH_ALG_IDX   4
+#define SPA_CTRL_CIPH_MODE_IDX  8
+#define SPA_CTRL_HASH_MODE_IDX 12
+#define SPA_CTRL_CTX_IDX       16
+#define SPA_CTRL_ENCRYPT_IDX   24
+#define SPA_CTRL_AAD_COPY      25
+#define SPA_CTRL_ICV_PT        26
+#define SPA_CTRL_ICV_ENC       27
+#define SPA_CTRL_ICV_APPEND    28
+#define SPA_CTRL_KEY_EXP       29
+
+/*****************************************************************************/
+/* Key Size Register Bit Definitions                                         */
+/*****************************************************************************/
+#define SPA_KEY_SZ_CXT_IDX     8
+#define SPA_KEY_SZ_CIPHER_IDX 31
+
+/*
+ * IRQ_EN reigster bit definitions.
+ */
+#define SPA_IRQ_EN_CMD0_EN      ( 1 << 0 )
+#define SPA_IRQ_EN_STAT_EN      ( 1 << 4 )
+#define SPA_IRQ_EN_GLBL_EN      ( 1 << 31 )
+
+/*****************************************************************************/
+/* Control Cipher Algorithm Register Bit Definitions                         */
+/*****************************************************************************/
+#define SPA_CTRL_CIPH_ALG_NULL    0x00
+#define SPA_CTRL_CIPH_ALG_DES     0x01
+#define SPA_CTRL_CIPH_ALG_AES     0x02
+#define SPA_CTRL_CIPH_ALG_RC4     0x03
+#define SPA_CTRL_CIPH_ALG_MULTI2  0x04
+#define SPA_CTRL_CIPH_ALG_KASUMI  0x05
+
+#define SPA_CTRL_HASH_ALG_NULL    0x00 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_MD5     0x01 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA     0x02 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA224  0x03 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA256  0x04 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA384  0x05 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_SHA512  0x06 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_AESMAC  0x07 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_AESCMAC 0x08 << SPA_CTRL_HASH_ALG_IDX
+#define SPA_CTRL_HASH_ALG_KASF9   0x09 << SPA_CTRL_HASH_ALG_IDX
+
+#define SPA_CTRL_CIPH_MODE_NULL   0x00 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_ECB    0x00 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_CBC    0x01 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_CTR    0x02 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_CCM    0x03 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_GCM    0x05 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_OFB    0x07 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_CFB    0x08 << SPA_CTRL_CIPH_MODE_IDX
+#define SPA_CTRL_CIPH_MODE_F8     0x09 << SPA_CTRL_CIPH_MODE_IDX
+
+#define SPA_CTRL_HASH_MODE_RAW    0x00 << SPA_CTRL_HASH_MODE_IDX
+#define SPA_CTRL_HASH_MODE_SSLMAC 0x01 << SPA_CTRL_HASH_MODE_IDX
+#define SPA_CTRL_HASH_MODE_HMAC   0x02 << SPA_CTRL_HASH_MODE_IDX
+
+#define SPA_FIFO_STAT_EMPTY       ( 1 << 31 )
+#define SPA_FIFO_CMD_FULL         ( 1 << 7 )
+
+#endif /* PC302_SPA_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/ssi.h b/arch/arm/mach-pc302/include/mach/pc302/ssi.h
new file mode 100644
index 0000000..9b832a9
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/ssi.h
@@ -0,0 +1,97 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_SSI_H
+#define PC302_SSI_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define SSI_CTRL_REG_0_REG_OFFSET                   0x00
+#define SSI_CTRL_REG_1_REG_OFFSET                   0x04
+#define SSI_ENABLE_REG_REG_OFFSET                   0x08
+#define SSI_MW_CTRL_REG_OFFSET                      0x0C
+#define SSI_SLAVE_ENABLE_REG_OFFSET                 0x10
+#define SSI_BAUD_RATE_SEL_REG_OFFSET                0x14
+#define SSI_TX_FIFO_THRESHOLD_REG_OFFSET            0x18
+#define SSI_RX_FIFO_THRESHOLD_REG_OFFSET            0x1C
+#define SSI_TX_FIFO_LEVEL_REG_OFFSET                0x20
+#define SSI_RX_FIFO_LEVEL_REG_OFFSET                0x24
+#define SSI_STATUS_REG_OFFSET                       0x28
+#define SSI_IMR_REG_OFFSET                          0x2C
+#define SSI_ISR_REG_OFFSET                          0x30
+#define SSI_RAW_ISR_REG_OFFSET                      0x34
+#define SSI_TX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    0x38
+#define SSI_RX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    0x3C
+#define SSI_RX_FIFO_UNDFLOW_INT_CLEAR_REG_OFFSET    0x40
+#define SSI_MM_INT_CLEAR_REG_OFFSET                 0x44
+#define SSI_INT_CLEAR_REG_OFFSET                    0x48
+#define SSI_DMA_CTRL_REG_OFFSET                     0x4C
+#define SSI_DMA_TX_DATA_LEVEL_REG_OFFSET            0x50
+#define SSI_DMA_RX_DATA_LEVEL_REG_OFFSET            0x54
+#define SSI_DATA_REG_OFFSET                         0x60                        
+
+/* Identification Registers */
+
+#define SSI_ID_REG_OFFSET                           0x58
+#define SSI_COMP_VERSION_REG_OFFSET                 0x5C
+
+/*****************************************************************************/
+/* Register Reset Values                                                     */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define SSI_CTRL_REG_0_REG_RESET                    0x0000
+#define SSI_CTRL_REG_1_REG_RESET                    0x0000
+#define SSI_ENABLE_REG_REG_RESET                    0x0000
+#define SSI_MW_CTRL_REG_RESET                       0x0000
+#define SSI_SLAVE_ENABLE_REG_RESET                  0x0000
+#define SSI_BAUD_RATE_SEL_REG_RESET                 0x0000
+#define SSI_TX_FIFO_THRESHOLD_REG_RESET             0x0000
+#define SSI_RX_FIFO_THRESHOLD_REG_RESET             0x0000
+#define SSI_TX_FIFO_LEVEL_REG_RESET                 0x0000
+#define SSI_RX_FIFO_LEVEL_REG_RESET                 0x0000
+#define SSI_STATUS_REG_RESET                        0x0000
+#define SSI_IMR_REG_RESET                           0x003F
+#define SSI_ISR_REG_RESET                           0x0000
+#define SSI_RAW_ISR_REG_RESET                       0x0000
+#define SSI_TX_FIFO_OVRFLOW_INT_CLEAR_REG_RESET     0x0000
+#define SSI_RX_FIFO_OVRFLOW_INT_CLEAR_REG_RESET     0x0000
+#define SSI_RX_FIFO_UNDFLOW_INT_CLEAR_REG_RESET     0x0000
+#define SSI_MM_INT_CLEAR_REG_RESET                  0x0000
+#define SSI_INT_CLEAR_REG_RESET                     0x0000
+#define SSI_DMA_CTRL_REG_RESET                      0x0000
+#define SSI_DMA_TX_DATA_LEVEL_REG_RESET             0x0000
+#define SSI_DMA_RX_DATA_LEVEL_REG_RESET             0x0000
+#define SSI_DATA_REG_RESET                          0x0000
+
+/* Identification Registers */
+
+/* ** Need to check on these values */
+
+#define SSI_ID_REG_RESET                            0x44570007
+#define SSI_COMP_VERSION_REG_RESET                  0x3331312A
+
+#endif /* PC302_SSI_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/timer.h b/arch/arm/mach-pc302/include/mach/pc302/timer.h
new file mode 100644
index 0000000..185878d
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/timer.h
@@ -0,0 +1,120 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_TIMER_H
+#define PC302_TIMER_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Individual definitions */
+#define TIMER0_LOAD_COUNT_REG_OFFSET        0x00
+#define TIMER0_CURRENT_VALUE_REG_OFFSET     0x04
+#define TIMER0_CONTROL_REG_OFFSET           0x08
+#define TIMER0_EOI_REG_OFFSET               0x0c
+#define TIMER0_INT_STATUS_REG_OFFSET        0x10
+
+#define TIMER1_LOAD_COUNT_REG_OFFSET        0x14
+#define TIMER1_CURRENT_VALUE_REG_OFFSET     0x18
+#define TIMER1_CONTROL_REG_OFFSET           0x1c
+#define TIMER1_EOI_REG_OFFSET               0x20
+#define TIMER1_INT_STATUS_REG_OFFSET        0x24
+
+#define TIMER2_LOAD_COUNT_REG_OFFSET        0x28
+#define TIMER2_CURRENT_VALUE_REG_OFFSET     0x2c
+#define TIMER2_CONTROL_REG_OFFSET           0x30
+#define TIMER2_EOI_REG_OFFSET               0x34
+#define TIMER2_INT_STATUS_REG_OFFSET        0x38
+
+#define TIMER3_LOAD_COUNT_REG_OFFSET        0x3c
+#define TIMER3_CURRENT_VALUE_REG_OFFSET     0x40
+#define TIMER3_CONTROL_REG_OFFSET           0x44
+#define TIMER3_EOI_REG_OFFSET               0x48
+#define TIMER3_INT_STATUS_REG_OFFSET        0x4c
+
+#define TIMERS_INT_STATUS_REG_OFFSET        0xa0
+#define TIMERS_EOI_REG_OFFSET               0xa4
+#define TIMERS_RAW_INT_STATUS_REG_OFFSET    0xa8
+#define TIMERS_COMP_VERSION_REG_OFFSET      0xac
+
+/* Generic definitions 'borrowed' from U-Boot land */
+
+/* The number of timers in the hardware, numbered 0 to N-1 */
+#define TIMERNUMBEROFTIMERS                 4
+
+/* Register definitions for the timers */
+#define TIMERNLOADCOUNTREGOFFSET(__N)       (0x0000 + (0x14 * (__N)))
+#define TIMERNCURRENTVALUEREGOFFSET(__N)    (0x0004 + (0x14 * (__N)))
+#define TIMERNCONTROLREGOFFSET(__N)         (0x0008 + (0x14 * (__N)))
+#define TIMERNEOIREGOFFSET(__N)             (0x000c + (0x14 * (__N)))
+#define TIMERNINTERRUPTSTATUSREGOFFSET(__N) (0x0010 + (0x14 * (__N)))
+
+/* Timer N control register bit definitions */
+#define TIMERENABLE                         (0x00000001)
+#define TIMERMODE                           (0x00000002)
+#define TIMERINTERRUPTMASK                  (0x00000004)
+
+
+/* Register definitions for global timer registers */
+#define TIMERSINTERRUPTSTATUSREGOFFSET      (0x00a0)
+#define TIMERSEOIREGOFFSET                  (0x00a4)
+#define TIMERSRAWINTERRUPTSTATUSREGOFFSET   (0x00a8)
+
+/* Global Timer Registers bit definitions */
+#define TIMER(__N)                          (0x00000001 << (__N))
+
+/*****************************************************************************/
+/* Register Reset Values                                                     */
+/*****************************************************************************/
+
+#define TIMER0_LOAD_COUNT_REG_RESET         0x00000000
+#define TIMER0_CURRENT_VALUE_REG_RESET      0x00000000
+#define TIMER0_CONTROL_REG_RESET            0x00000000
+#define TIMER0_EOI_REG_RESET                0x00000000
+#define TIMER0_INT_STATUS_REG_RESET         0x00000000
+
+#define TIMER1_LOAD_COUNT_REG_RESET         0x00000000
+#define TIMER1_CURRENT_VALUE_REG_RESET      0x00000000
+#define TIMER1_CONTROL_REG_RESET            0x00000000
+#define TIMER1_EOI_REG_RESET                0x00000000
+#define TIMER1_INT_STATUS_REG_RESET         0x00000000
+
+#define TIMER2_LOAD_COUNT_REG_RESET         0x00000000
+#define TIMER2_CURRENT_VALUE_REG_RESET      0x00000000
+#define TIMER2_CONTROL_REG_RESET            0x00000000
+#define TIMER2_EOI_REG_RESET                0x00000000
+#define TIMER2_INT_STATUS_REG_RESET         0x00000000
+
+#define TIMER3_LOAD_COUNT_REG_RESET         0x00000000
+#define TIMER3_CURRENT_VALUE_REG_RESET      0x00000000
+#define TIMER3_CONTROL_REG_RESET            0x00000000
+#define TIMER3_EOI_REG_RESET                0x00000000
+#define TIMER3_INT_STATUS_REG_RESET         0x00000000
+
+#define TIMERS_INT_STATUS_REG_RESET         0x00000000
+#define TIMERS_EOI_REG_RESET                0x00000000
+#define TIMERS_RAW_INT_STATUS_REG_RESET     0x00000000
+#define TIMERS_COMP_VERSION_REG_RESET       0x3230322a
+
+#define TIMER_N_CURRENT_VALUE_REG_OFFSET(__N)       (0x0004 + (0x14 * (__N)))
+
+#endif /* PC302_TIMER_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/tzic.h b/arch/arm/mach-pc302/include/mach/pc302/tzic.h
new file mode 100644
index 0000000..2114b55
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/tzic.h
@@ -0,0 +1,93 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_TZIC_H
+#define PC302_TZIC_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define TZIC_FIQ_STATUS_REG_OFFSET              0x0000
+#define TZIC_RAW_INT_STATUS_REG_OFFSET          0x0004
+#define TZIC_INT_SELECT_REG_OFFSET              0x0008
+#define TZIC_FIQ_ENABLE_REG_OFFSET              0x000C
+#define TZIC_FIQ_ENABLE_CLEAR_REG_OFFSET        0x0010
+#define TZIC_FIQ_BYPASS_REG_OFFSET              0x0014
+#define TZIC_PROTECTION_REG_OFFSET              0x0018
+#define TZIC_LOCK_REG_OFFSET                    0x001C
+#define TZIC_LOCK_STATUS_REG_OFFSET             0x0020
+
+/* Identification Registers */
+
+#define TZIC_PERIPHERAL_ID_0_REG_OFFSET         0x0FE0
+#define TZIC_PERIPHERAL_ID_1_REG_OFFSET         0x0FE4
+#define TZIC_PERIPHERAL_ID_2_REG_OFFSET         0x0FE8
+#define TZIC_PERIPHERAL_ID_3_REG_OFFSET         0x0FEC
+#define TZIC_PRIMECELL_ID_0_REG_OFFSET          0x0FF0
+#define TZIC_PRIMECELL_ID_1_REG_OFFSET          0x0FF4
+#define TZIC_PRIMECELL_ID_2_REG_OFFSET          0x0FF8
+#define TZIC_PRIMECELL_ID_3_REG_OFFSET          0x0FFC
+
+
+/*****************************************************************************/
+/* Register Reset Values                                                     */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define TZIC_FIQ_STATUS_REG_RESET               0x00000000
+/* TZIC_RAW_INT_STATUS_REG_RESET  Unknown reset value */
+#define TZIC_INT_SELECT_REG_RESET               0x00000000
+#define TZIC_FIQ_ENABLE_REG_RESET               0x00000000
+/* TZIC_FIQ_ENABLE_CLEAR_REG_RESET  Unknown reset value */
+#define TZIC_FIQ_BYPASS_REG_RESET               0x00000000
+#define TZIC_PROTECTION_REG_RESET               0x00000000
+/* TZIC_LOCK_REG_RESET  Unknown reset value */
+#define TZIC_LOCK_STATUS_REG_RESET              0x00000001
+
+/* Identification Registers */
+
+#define TZIC_PERIPHERAL_ID_0_REG_RESET          0x00000090
+#define TZIC_PERIPHERAL_ID_1_REG_RESET          0x00000018
+#define TZIC_PERIPHERAL_ID_2_REG_RESET          0x00000004
+#define TZIC_PERIPHERAL_ID_3_REG_RESET          0x00000000
+#define TZIC_PRIMECELL_ID_0_REG_RESET           0x0000000D
+#define TZIC_PRIMECELL_ID_1_REG_RESET           0x000000F0
+#define TZIC_PRIMECELL_ID_2_REG_RESET           0x00000005
+#define TZIC_PRIMECELL_ID_3_REG_RESET           0x000000B1
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define TZIC_FIQ_BYPASS_REG_MASK                0x00000001
+#define TZIC_PROTECTION_REG_MASK                0x00000001
+#define TZIC_LOCK_STATUS_REG_MASK               0x00000001
+
+#define TZIC_PERIPHERAL_ID_MASK                 0x000000FF
+#define TZIC_PRIMECELL_ID_MASK                  0x000000FF  
+
+#define TZIC_UNLOCK_ACCESS_CODE                 0x0ACCE550
+
+#endif /* PC302_TZIC_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/tzpc.h b/arch/arm/mach-pc302/include/mach/pc302/tzpc.h
new file mode 100644
index 0000000..a334691
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/tzpc.h
@@ -0,0 +1,82 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_TZPC_H
+#define PC302_TZPC_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define TZPC_R0_SIZE_REG_OFFSET                 0x0000
+#define TZPC_DEC_PROT_0_STAT_REG_OFFSET         0x0800
+#define TZPC_DEC_PROT_0_SET_REG_OFFSET          0x0804
+#define TZPC_DEC_PROT_0_CLE_REG_OFFSET          0x0808
+#define TZPC_DEC_PROT_1_STAT_REG_OFFSET         0x080c
+#define TZPC_DEC_PROT_1_SET_REG_OFFSET          0x0810
+#define TZPC_DEC_PROT_1_CLE_REG_OFFSET          0x0814
+#define TZPC_DEC_PROT_2_STAT_REG_OFFSET         0x0818
+#define TZPC_DEC_PROT_2_SET_REG_OFFSET          0x081c
+#define TZPC_DEC_PROT_2_CLE_REG_OFFSET          0x0820
+
+/* Identification Registers */
+
+#define TZPC_PERIPHERAL_ID_0_REG_OFFSET         0x0FE0
+#define TZPC_PERIPHERAL_ID_1_REG_OFFSET         0x0FE4
+#define TZPC_PERIPHERAL_ID_2_REG_OFFSET         0x0FE8
+#define TZPC_PERIPHERAL_ID_3_REG_OFFSET         0x0FEC
+#define TZPC_PRIMECELL_ID_0_REG_OFFSET          0x0FF0
+#define TZPC_PRIMECELL_ID_1_REG_OFFSET          0x0FF4
+#define TZPC_PRIMECELL_ID_2_REG_OFFSET          0x0FF8
+#define TZPC_PRIMECELL_ID_3_REG_OFFSET          0x0FFC
+
+
+/*****************************************************************************/
+/* Register Reset Values                                                     */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define TZPC_R0_SIZE_REG_RESET                  0x00000200
+#define TZPC_DEC_PROT_0_STAT_REG_RESET          0x00000000
+/* TZPC_DEC_PROT_0_SET_REG_RESET         EQU Unknown reset value */
+/* TZPC_DEC_PROT_0_CLE_REG_RESET         EQU Unknown reset value */
+#define TZPC_DEC_PROT_1_STAT_REG_RESET          0x00000000
+/* TZPC_DEC_PROT_1_SET_REG_RESET         EQU Unknown reset value */
+/* TZPC_DEC_PROT_1_CLE_REG_RESET         EQU Unknown reset value */
+#define TZPC_DEC_PROT_2_STAT_REG_RESET          0x00000000
+/* TZPC_DEC_PROT_2_SET_REG_RESET         EQU Unknown reset value */
+/* TZPC_DEC_PROT_2_CLE_REG_RESET         EQU Unknown reset value */
+
+/* Identification Registers */
+
+#define TZPC_PERIPHERAL_ID_0_REG_RESET          0x00000070
+#define TZPC_PERIPHERAL_ID_1_REG_RESET          0x00000018
+#define TZPC_PERIPHERAL_ID_2_REG_RESET          0x00000004
+#define TZPC_PERIPHERAL_ID_3_REG_RESET          0x00000000
+#define TZPC_PRIMECELL_ID_0_REG_RESET           0x0000000D
+#define TZPC_PRIMECELL_ID_1_REG_RESET           0x000000F0
+#define TZPC_PRIMECELL_ID_2_REG_RESET           0x00000005
+#define TZPC_PRIMECELL_ID_3_REG_RESET           0x000000B1
+
+#endif /* PC302_TZPC_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/uart.h b/arch/arm/mach-pc302/include/mach/pc302/uart.h
new file mode 100644
index 0000000..801f854
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/uart.h
@@ -0,0 +1,166 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_UART_H
+#define PC302_UART_H
+
+/* Constants ---------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define UART_RX_BUFFER_REG_OFFSET               0x00
+#define UART_TX_HOLDING_REG_OFFSET		0x00
+#define UART_DIVISOR_LOW_REG_OFFSET		0x00
+#define UART_DIVISOR_HIGH_REG_OFFSET		0x04
+#define UART_INT_ENABLE_REG_OFFSET		0x04
+#define UART_INT_IDENTITY_REG_OFFSET		0x08
+#define UART_FIFO_CTRL_REG_OFFSET		0x08
+#define UART_LINE_CTRL_REG_OFFSET		0x0c
+#define UART_MODEM_CTRL_REG_OFFSET		0x10
+#define UART_LINE_STATUS_REG_OFFSET		0x14
+#define UART_MODEM_STATUS_REG_OFFSET		0x18
+#define UART_SCRATCH_REG_OFFSET			0x1c
+
+#define UART_UART_STATUS_REG_OFFSET             0x7c
+
+#define UART_SHADOW_RTS_REG_OFFSET		0x8c
+#define UART_SHADOW_BRK_CTRL_REG_OFFSET		0x90
+#define UART_SHADOW_DMA_MODE_REG_OFFSET		0x94
+#define UART_SHADOW_FIFO_ENABLE_REG_OFFSET	0x98
+#define UART_SHADOW_RCVR_TRIGGER_REG_OFFSET	0x9c
+#define UART_SHADOW_TX_EMPTY_TRIGGER_REG_OFFSET	0xa0
+#define UART_HALT_TX_REG_OFFSET			0xa4
+#define UART_DMA_SOFT_ACK_REG_OFFSET		0xa8
+#define UART_COMP_PARAM_REG_OFFSET		0xf4
+#define UART_UART_VERSION_REG_OFFSET		0xf8
+#define UART_COMP_TYPE_REG_OFFSET		0xfc
+
+/*****************************************************************************/
+/* Register Reset Values                                                     */
+/*****************************************************************************/
+
+#define UART_COMP_PARAM_REG_RESET               0x00021102 
+#define UART_UART_VERSION_REG_RESET             0x3330372A 
+#define UART_COMP_TYPE_REG_RESET                0x44570110 
+
+/* DLL & DLH */
+#define UARTDIVISORMASK                 0xFF
+
+/* IER */ 
+#define UARTINTENABLEPTIMEIDX		0x7	/* Programmable THRE Interrupt Mode Enable that can be */
+						/*  written to only when THRE_MODE_USER == Enabled, */
+						/*  always readable. This is used to enable/disable the */
+						/*  generation of THRE Interrupt. */
+#define UARTINTENABLEEDSSIIDX           0x3     /*  R/W Enable Modem Status Interrupt. */
+#define UARTINTENABLEELSIIDX            0x2     /*  R/W Enable Receiver Line Status Interrupt. */
+#define UARTINTENABLEETBEIIDX           0x1     /*  R/W Enable Transmit Holding Register Empty Interrupt. */
+#define UARTINTENABLEERBFIIDX           0x0     /*  R/W Enable Received Data Available Interrupt. */
+
+#define UARTINTENABLEPTIMEMASK          (1 << UARTINTENABLEPTIMEIDX)
+#define UARTINTENABLEEDSSIMASK          (1 << UARTINTENABLEEDSSIIDX)            
+#define UARTINTENABLEELSIMASK           (1 << UARTINTENABLEELSIIDX)             
+#define UARTINTENABLEETBEIMASK          (1 << UARTINTENABLEETBEIIDX)            
+#define UARTINTENABLEERBFIMASK          (1 << UARTINTENABLEERBFIIDX)            
+	
+/* IIR */
+#define UARTINTIDENTITYMASK	        0x0F
+#define UARTINTIDENTITYMODEMSTATUS      0x00
+#define UARTINTIDENTITYNONE	        0x01
+#define UARTINTIDENTITYTHREMPTY	        0x02
+#define UARTINTIDENTITYRXDATA	        0x04
+#define UARTINTIDENTITYRXLINESTATUS     0x06
+#define UARTINTIDENTITYBUSYDETECT       0x07
+#define UARTINTIDENTITYCHARACTERTIMEOUT 0x0C
+
+/* FCR */
+#define UARTFIFOCTRLRCVRMASK	        0xC0
+#define UARTFIFOCTRLRCVR1CHAR	        0x00    /* 00 = 1 character in the FIFO */
+#define UARTFIFOCTRLRCVRQUARTERFULL     0x40    /* 01 = FIFO  full */
+#define UARTFIFOCTRLRCVRHALFFULL        0x80    /* 10 = FIFO  full */
+#define UARTFIFOCTRLRCVR2LESSTHANFULL   0xC0    /* 11 = FIFO 2 less than full */
+
+#define UARTFIFOCTRLTXEMPTYMASK	        0x30
+#define UARTFIFOCTRLTXEMPTYEMPTY        0x00    /* 00 = FIFO empty */
+#define UARTFIFOCTRLTXEMPTY2CHARS       0x10    /* 01 = 2 characters in the FIFO */
+#define UARTFIFOCTRLTXEMPTYQUARTERFULL  0x20    /* 10 = FIFO  full */
+#define UARTFIFOCTRLTXEMPTYHALFFULL     0x30    /* 11 = FIFO  full */
+
+#define UartFIFOCtrlEnable		0x01	/* fifo enable bit */
+
+
+/* LCR indices */
+#define UARTLINECTRLDLABIDX             7       /* Divisor latch access bit */
+#define UARTLINECTRLBRKIDX              6 
+#define UARTLINECTRLEPSIDX              4 
+#define UARTLINECTRLPENIDX              3 
+#define UARTLINECTRLSTOPIDX             2 
+#define UARTLINECTRLDLSIDX              0 
+
+/* LCR bit masks */
+#define UARTLINECTRLDLABMASK	        (1 << UARTLINECTRLDLABIDX)
+#define UARTLINECTRLBRKMASK	        (1 << UARTLINECTRLBRKIDX)      
+#define UARTLINECTRLEPSMASK	        (1 << UARTLINECTRLEPSIDX)      
+#define UARTLINECTRLPENMASK	        (1 << UARTLINECTRLPENIDX)      
+#define UARTLINECTRLSTOPMASK            (1 << UARTLINECTRLSTOPIDX)
+#define UARTLINECTRLDLSMASK	        3 
+#define UARTLINECTRLDLS8BITS	        3       /* 8 bit data length */
+#define UARTLINECTRLDLS7BITS	        2       /* 7 bit data length */
+#define UARTLINECTRLDLS6BITS	        1       /* 6 bit data length */
+#define UARTLINECTRLDLS5BITS	        0       /* 5 bit data length */
+
+#define UARTLINECTRL1STOPBIT            ~(UARTLINECTRLSTOPMASK)
+#define UARTLINECTRLPARITYDISABLE       ~(UARTLINECTRLPENMASK)
+
+/* MCR indices */
+#define UARTMODEMCTRLLOOPBACKIDX	4
+#define UARTMODEMCTRLOUT2IDX		3
+#define UARTMODEMCTRLOUT1IDX		2
+#define UARTMODEMCTRLCTSIDX		1
+#define UARTMODEMCTRLDTRIDX		0
+
+/* MCR bit masks */
+#define UARTMODEMCTRLLOOPBACKMASK	(1 << UARTMODEMCTRLLOOPBACKIDX)
+#define UARTMODEMCTRLOUT2MASK		(1 << UARTMODEMCTRLOUT2IDX)    
+#define UARTMODEMCTRLOUT1MASK		(1 << UARTMODEMCTRLOUT1IDX)    
+#define UARTMODEMCTRLCTSMASK		(1 << UARTMODEMCTRLCTSIDX)     
+#define UARTMODEMCTRLDTRMASK		(1 << UARTMODEMCTRLDTRIDX)     
+
+#define UARTMODEMSTATUSCTSIDX           4       /* CTS input */
+#define UARTMODEMSTATUSDCTSIDX          0       /* change in CTS input since last read */
+
+#define UARTLINESTATUSTHREIDX	        5
+#define UARTLINESTATUSDATAREADYIDX      0
+#define UARTLINESTATUSTHREMASK	        (1 << UARTLINESTATUSTHREIDX)
+#define UARTLINESTATUSDATAREADYMASK     (1 << UARTLINESTATUSDATAREADYIDX)
+
+#define UARTUARTSTATUSRFFIDX            4       /* RX FIFO full */
+#define UARTUARTSTATUSRFNEIDX	        3       /* RX FIFO not empty */
+#define UARTUARTSTATUSTFEIDX	        2 
+#define UARTUARTSTATUSTFNFIDX	        1 
+#define UARTUARTSTATUSBUSYIDX	        0 
+
+#define UARTUARTSTATUSRFFMASK           (1 << UARTUARTSTATUSRFFIDX)    
+#define UARTUARTSTATUSRFNEMASK          (1 << UARTUARTSTATUSRFNEIDX)
+#define UARTUARTSTATUSTFEMASK           (1 << UARTUARTSTATUSTFEIDX)    
+#define UARTUARTSTATUSTFNFMASK          (1 << UARTUARTSTATUSTFNFIDX)
+#define UARTUARTSTATUSBUSYMASK          (1 << UARTUARTSTATUSBUSYIDX)
+
+#endif /* PC302_UART_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/vic.h b/arch/arm/mach-pc302/include/mach/pc302/vic.h
new file mode 100644
index 0000000..b295dd2
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/vic.h
@@ -0,0 +1,246 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_VIC_H
+#define PC302_VIC_H
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define VIC_IRQ_STATUS_REG_OFFSET               0x0000
+#define VIC_FIQ_STATUS_REG_OFFSET               0x0004
+#define VIC_RAW_INT_STATUS_REG_OFFSET           0x0008
+#define VIC_INT_SELECT_REG_OFFSET               0x000C
+#define VIC_INT_ENABLE_REG_OFFSET               0x0010
+#define VIC_INT_ENABLE_CLEAR_REG_OFFSET         0x0014
+#define VIC_SOFT_INT_REG_OFFSET                 0x0018
+#define VIC_SOFT_INT_CLEAR_REG_OFFSET           0x001C
+#define VIC_PROTECTION_REG_OFFSET               0x0020
+#define VIC_SW_PRIORITY_MASK_REG_OFFSET         0x0024
+#define VIC_VECT_PRIORITY_DAISYCHAIN_REG_OFFSET 0x0028
+#define VIC_ADDRESS_REG_OFFSET                  0x0F00
+#define VIC_VECT_ADDRESS_0_REG_OFFSET           0x0100
+#define VIC_VECT_ADDRESS_1_REG_OFFSET           0x0104
+#define VIC_VECT_ADDRESS_2_REG_OFFSET           0x0108
+#define VIC_VECT_ADDRESS_3_REG_OFFSET           0x010C
+#define VIC_VECT_ADDRESS_4_REG_OFFSET           0x0110
+#define VIC_VECT_ADDRESS_5_REG_OFFSET           0x0114
+#define VIC_VECT_ADDRESS_6_REG_OFFSET           0x0118
+#define VIC_VECT_ADDRESS_7_REG_OFFSET           0x011C
+#define VIC_VECT_ADDRESS_8_REG_OFFSET           0x0120
+#define VIC_VECT_ADDRESS_9_REG_OFFSET           0x0124
+#define VIC_VECT_ADDRESS_10_REG_OFFSET          0x0128
+#define VIC_VECT_ADDRESS_11_REG_OFFSET          0x012C
+#define VIC_VECT_ADDRESS_12_REG_OFFSET          0x0130
+#define VIC_VECT_ADDRESS_13_REG_OFFSET          0x0134
+#define VIC_VECT_ADDRESS_14_REG_OFFSET          0x0138
+#define VIC_VECT_ADDRESS_15_REG_OFFSET          0x013C
+#define VIC_VECT_ADDRESS_16_REG_OFFSET          0x0140
+#define VIC_VECT_ADDRESS_17_REG_OFFSET          0x0144
+#define VIC_VECT_ADDRESS_18_REG_OFFSET          0x0148
+#define VIC_VECT_ADDRESS_19_REG_OFFSET          0x014C
+#define VIC_VECT_ADDRESS_20_REG_OFFSET          0x0150
+#define VIC_VECT_ADDRESS_21_REG_OFFSET          0x0154
+#define VIC_VECT_ADDRESS_22_REG_OFFSET          0x0158
+#define VIC_VECT_ADDRESS_23_REG_OFFSET          0x015C
+#define VIC_VECT_ADDRESS_24_REG_OFFSET          0x0160
+#define VIC_VECT_ADDRESS_25_REG_OFFSET          0x0164
+#define VIC_VECT_ADDRESS_26_REG_OFFSET          0x0168
+#define VIC_VECT_ADDRESS_27_REG_OFFSET          0x016C
+#define VIC_VECT_ADDRESS_28_REG_OFFSET          0x0170
+#define VIC_VECT_ADDRESS_29_REG_OFFSET          0x0174
+#define VIC_VECT_ADDRESS_30_REG_OFFSET          0x0178
+#define VIC_VECT_ADDRESS_31_REG_OFFSET          0x017C
+#define VIC_VECT_PRIORITY_0_REG_OFFSET          0x0200
+#define VIC_VECT_PRIORITY_1_REG_OFFSET          0x0204
+#define VIC_VECT_PRIORITY_2_REG_OFFSET          0x0208
+#define VIC_VECT_PRIORITY_3_REG_OFFSET          0x020C
+#define VIC_VECT_PRIORITY_4_REG_OFFSET          0x0210
+#define VIC_VECT_PRIORITY_5_REG_OFFSET          0x0214
+#define VIC_VECT_PRIORITY_6_REG_OFFSET          0x0218
+#define VIC_VECT_PRIORITY_7_REG_OFFSET          0x021C
+#define VIC_VECT_PRIORITY_8_REG_OFFSET          0x0220
+#define VIC_VECT_PRIORITY_9_REG_OFFSET          0x0224
+#define VIC_VECT_PRIORITY_10_REG_OFFSET         0x0228
+#define VIC_VECT_PRIORITY_11_REG_OFFSET         0x022C
+#define VIC_VECT_PRIORITY_12_REG_OFFSET         0x0230
+#define VIC_VECT_PRIORITY_13_REG_OFFSET         0x0234
+#define VIC_VECT_PRIORITY_14_REG_OFFSET         0x0238
+#define VIC_VECT_PRIORITY_15_REG_OFFSET         0x023C
+#define VIC_VECT_PRIORITY_16_REG_OFFSET         0x0240
+#define VIC_VECT_PRIORITY_17_REG_OFFSET         0x0244
+#define VIC_VECT_PRIORITY_18_REG_OFFSET         0x0248
+#define VIC_VECT_PRIORITY_19_REG_OFFSET         0x024C
+#define VIC_VECT_PRIORITY_20_REG_OFFSET         0x0250
+#define VIC_VECT_PRIORITY_21_REG_OFFSET         0x0254
+#define VIC_VECT_PRIORITY_22_REG_OFFSET         0x0258
+#define VIC_VECT_PRIORITY_23_REG_OFFSET         0x025C
+#define VIC_VECT_PRIORITY_24_REG_OFFSET         0x0260
+#define VIC_VECT_PRIORITY_25_REG_OFFSET         0x0264
+#define VIC_VECT_PRIORITY_26_REG_OFFSET         0x0268
+#define VIC_VECT_PRIORITY_27_REG_OFFSET         0x026C
+#define VIC_VECT_PRIORITY_28_REG_OFFSET         0x0270
+#define VIC_VECT_PRIORITY_29_REG_OFFSET         0x0274
+#define VIC_VECT_PRIORITY_30_REG_OFFSET         0x0278
+#define VIC_VECT_PRIORITY_31_REG_OFFSET         0x027C
+
+/* Integration Test Registers */
+
+#define VIC_INTEGRATION_CONTROL_REG_OFFSET                  0x0300
+#define VIC_INTEGRATION_INPUT_1_REG_OFFSET                  0x0304
+#define VIC_INTEGRATION_INPUT_2_REG_OFFSET                  0x0308
+#define VIC_INTEGRATION_OUTPUT_1_REG_OFFSET                 0x030C
+#define VIC_INTEGRATION_OUTPUT_2_REG_OFFSET                 0x0310
+#define VIC_INTEGRATION_SAMPLED_SOURCE_STATUS_REG_OFFSET    0x0314
+#define VIC_INTEGRATION_SAMPLED_SOURCE_CLEAR_REG_OFFSET     0x0318
+
+/* Identification Registers */
+
+#define VIC_PERIPHERAL_ID_0_REG_OFFSET          0x0FE0
+#define VIC_PERIPHERAL_ID_1_REG_OFFSET          0x0FE4
+#define VIC_PERIPHERAL_ID_2_REG_OFFSET          0x0FE8
+#define VIC_PERIPHERAL_ID_3_REG_OFFSET          0x0FEC
+#define VIC_PRIMECELL_ID_0_REG_OFFSET           0x0FF0
+#define VIC_PRIMECELL_ID_1_REG_OFFSET           0x0FF4
+#define VIC_PRIMECELL_ID_2_REG_OFFSET           0x0FF8
+#define VIC_PRIMECELL_ID_3_REG_OFFSET           0x0FFC
+
+
+/*****************************************************************************/
+/* Register Reset Values                                                     */
+/*****************************************************************************/
+
+/* Functional Registers */
+#define VIC_IRQ_STATUS_REG_RESET                0x00000000
+#define VIC_FIQ_STATUS_REG_RESET                0x00000000
+/* VIC_RAW_INT_STATUS_REG_RESET Unknown reset value */
+#define VIC_INT_SELECT_REG_RESET                0x00000000
+#define VIC_INT_ENABLE_REG_RESET                0x00000000
+/* VIC_INT_ENABLE_CLEAR_REG_RESET Unknown reset value */
+#define VIC_SOFT_INT_REG_RESET                  0x00000000
+/* VIC_SOFT_INT_CLEAR_REG_RESET Unknown reset value */
+#define VIC_PROTECTION_REG_RESET                0x00000000
+#define VIC_SW_PRIORITY_MASK_REG_RESET          0x0000FFFF
+#define VIC_VECT_PRIORITY_DAISYCHAIN_REG_RESET  0x0000000F
+#define VIC_ADDRESS_REG_RESET                   0x00000000
+#define VIC_VECT_ADDRESS_0_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_1_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_2_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_3_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_4_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_5_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_6_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_7_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_8_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_9_REG_RESET            0x00000000
+#define VIC_VECT_ADDRESS_10_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_11_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_12_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_13_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_14_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_15_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_16_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_17_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_18_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_19_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_20_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_21_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_22_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_23_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_24_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_25_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_26_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_27_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_28_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_29_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_30_REG_RESET           0x00000000
+#define VIC_VECT_ADDRESS_31_REG_RESET           0x00000000
+#define VIC_VECT_PRIORITY_0_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_1_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_2_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_3_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_4_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_5_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_6_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_7_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_8_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_9_REG_RESET           0x0000000F
+#define VIC_VECT_PRIORITY_10_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_11_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_12_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_13_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_14_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_15_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_16_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_17_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_18_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_19_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_20_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_21_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_22_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_23_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_24_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_25_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_26_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_27_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_28_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_29_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_30_REG_RESET          0x0000000F
+#define VIC_VECT_PRIORITY_31_REG_RESET          0x0000000F
+
+/* Integration Test Registers */
+
+#define VIC_INTEGRATION_CONTROL_REG_RESET                   0x00000000
+/* VIC_INTEGRATION_INPUT_1_REG_RESET Unknown reset value */
+/* VIC_INTEGRATION_INPUT_2_REG_RESET Unknown reset value */
+#define VIC_INTEGRATION_OUTPUT_1_REG_RESET                  0x00000000
+#define VIC_INTEGRATION_OUTPUT_2_REG_RESET                  0x00000000
+#define VIC_INTEGRATION_SAMPLED_SOURCE_STATUS_REG_RESET     0x00000000
+/* VIC_INTEGRATION_SAMPLED_SOURCE_CLEAR_REG_RESET Unknown reset value */
+
+/* Identification Registers */
+
+#define VIC_PERIPHERAL_ID_0_REG_RESET           0x00000092
+#define VIC_PERIPHERAL_ID_1_REG_RESET           0x00000011
+#define VIC_PERIPHERAL_ID_2_REG_RESET           0x00000004
+#define VIC_PERIPHERAL_ID_3_REG_RESET           0x00000000
+#define VIC_PRIMECELL_ID_0_REG_RESET            0x0000000D
+#define VIC_PRIMECELL_ID_1_REG_RESET            0x000000F0
+#define VIC_PRIMECELL_ID_2_REG_RESET            0x00000005
+#define VIC_PRIMECELL_ID_3_REG_RESET            0x000000B1
+
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define VIC_PROTECTION_REG_MASK                 0x00000001
+#define VIC_SW_PRIORITY_MASK_REG_MASK           0x0000FFFF
+#define VIC_VECT_PRIORITY_DAISYCHAIN_REG_MASK   0x0000000F
+#define VIC_VECT_PRIORITY_REG_MASK              0x0000000F
+
+#define VIC_PERIPHERAL_ID_MASK                  0x000000FF
+#define VIC_PRIMECELL_ID_MASK                   0x000000FF
+
+#endif /* PC302_VIC_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302/wdog.h b/arch/arm/mach-pc302/include/mach/pc302/wdog.h
new file mode 100644
index 0000000..d8b2d49
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302/wdog.h
@@ -0,0 +1,71 @@
+/* Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PC302_WDOG_H
+#define PC302_WDOG_H
+
+/* Constants -------------------------------------------------------------- */
+
+#define WDOG_CONTROL_REG_OFFSET             0x00
+#define WDOG_TIMEOUT_RANGE_REG_OFFSET       0x04
+#define WDOG_CURRENT_COUNT_REG_OFFSET       0x08
+#define WDOG_COUNTER_RESTART_REG_OFFSET     0x0c
+#define WDOG_INT_STATUS_REG_OFFSET          0x10
+#define WDOG_CLEAR_REG_OFFSET               0x14
+
+#define WDOG_PARAMS_5_REG_OFFSET            0xe4
+#define WDOG_PARAMS_4_REG_OFFSET            0xe8
+#define WDOG_PARAMS_3_REG_OFFSET            0xec
+#define WDOG_PARAMS_2_REG_OFFSET            0xf0
+#define WDOG_PARAMS_1_REG_OFFSET            0xf4
+
+#define WDOG_COMP_VERSION_REG_OFFSET        0xf8
+#define WDOG_COMP_TYPE_REG_OFFSET           0xfc
+
+#define WDOG_CONTROL_REG_RESET              0x00000016
+#define WDOG_TIMEOUT_RANGE_REG_RESET        0x0000000c
+#define WDOG_CURRENT_COUNT_REG_RESET        0x0fffffff
+#define WDOG_COUNTER_RESTART_REG_RESET      0x00000000
+#define WDOG_INT_STATUS_REG_RESET           0x00000000
+#define WDOG_CLEAR_REG_RESET                0x00000000
+
+/* Calculated from spec document */
+#define WDOG_PARAMS_5_REG_RESET             0x7fffffff
+#define WDOG_PARAMS_4_REG_RESET             0x00000000
+#define WDOG_PARAMS_3_REG_RESET             0x0000000c
+#define WDOG_PARAMS_2_REG_RESET             0x0fffffff
+#define WDOG_PARAMS_1_REG_RESET             0x100c1602
+
+#define WDOG_COMP_VERSION_REG_RESET         0x3130332a
+#define WDOG_COMP_TYPE_REG_RESET            0x44570120
+
+/* Kick value */
+#define WDOG_COUNTER_RESTART_KICK_VALUE	    0x76
+
+/* Control bits */
+#define WDOGCONTROLREGWDT_ENIDX		    0
+#define WDOGCONTROLREGRMODIDX		    1
+#define WDOGCONTROLREGRPLIDX		    2
+
+/* Masks */
+#define WDOGCONTROLREGWDT_ENMASK	    1 << WDOGCONTROLREGWDT_ENIDX
+#define WDOGCONTROLREGRMODMASK		    1 << WDOGCONTROLREGRMODIDX
+#define WDOGCONTROLREGRPLMASK		    0x7 << WDOGCONTROLREGRPLIDX
+
+#endif /* PC302_WDOG_H */
diff --git a/arch/arm/mach-pc302/include/mach/pc302_dmac.h b/arch/arm/mach-pc302/include/mach/pc302_dmac.h
new file mode 100644
index 0000000..e6ebd32
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302_dmac.h
@@ -0,0 +1,909 @@
+/*******************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ ******************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All inquiries to support@picochip.com
+ *
+ */
+
+/*!
+ * \file pc302_dmac.h
+ * \brief This module provides the interface to the low level DMA functionality.
+ *
+ *\verbatim
+ *
+ * Introduction
+ * ------------
+ *
+ * This is an informal description of the software interface for the PC302 DMA
+ * driver. This API allows kernel modules to access the DMA capabilities of the
+ * PC302. No user space interface to the DMA driver is provided. The API is
+ * loosely based on the PC102 8560 DMA driver interfaces with the addition of
+ * the standard Linux ARM framework support.
+ * 
+ * Glossary
+ * --------
+ *
+ * Transfer -       A DMA transfer is the entire operation of moving data from
+ *                  one place to another, from start to finish. It is made up
+ *                  of 1 or more blocks, i.e. single vs multi-block.
+ *
+ * Block -          The transfer of a number of data items. The size of the
+ *                  block can be controlled either by the sending or receiving
+ *                  end or by the DMA controller itself. Blocks can be scatter/
+ *                  gather. A DMA transfer can be multi-block if either a multi-
+ *                  block transfer list is used or if auto-reloading at one end
+ *                  of the transfer is employed.
+ *
+ * Transaction -    For efficiency a number of data items can be moved at one
+ *                  time. This is also called Burst Transaction. A Block (or
+ *                  scatter / gather region) can be a whole number of
+ *                  transactions in size in which case it fits neatly into a
+ *                  number of burst transactions. Otherwise smaller transactions
+ *                  are needed at the end of the block. These single
+ *                  transactions transfer a single data item at one time.
+ *
+ * Transfer Width - The number of bytes in a data item.
+ *
+ * Handshaking -    In order to progress the movement of data, handshaking
+ *                  signals to the DMA hardware tell it when to start a new
+ *                  transaction. The handshaking signal can be generated in
+ *                  hardware (by a peripheral hardware signal), or by software
+ *                  (by setting a bit in a register).
+ *
+ * Notes:
+ *   The references to scatter / gather in these source files are inherited from
+ *   the Synopsys documentation. They are used in linked list multi-block
+ *   transfers and are equivalent to the term 'Striding' used in other DMA
+ *   controllers.
+ *
+ * References
+ * ----------
+ *
+ * The information in this document needs to be read along side the
+ * DesignWare DW_ahb_dmac Databook Version 2.11a April 11, 2008 Synopsys
+ *
+ * High Level interfaces
+ * ---------------------
+ *
+ * The driver software is layered as follows:
+ *
+ *                     -----------------------------------
+ *                     | One or more client applications |
+ *                     -----------------------------------
+ *                     |         PC302 DMA API           |
+ *                     -----------------------------------
+ *                     |         PC302 Hardware          |
+ *                     -----------------------------------
+ *\endverbatim
+ *
+ *****************************************************************************/
+
+#ifndef __PC302_DMAC__
+#define __PC302_DMAC__
+
+/*******************************************************************************
+ * Macros
+ ******************************************************************************/
+
+/*!
+ *  \brief Main flags used to configure optional transfer parameters
+ *
+ *  Flag values for setting the channel priority. Used in functions
+ *  pc302_dma_setup_direct_xfr() and pc302_dma_setup_list_xfr().
+ *  PC302_DMA_CH_PRIOR_7 is the highest priority and
+ *  PC302_DMA_CH_PRIOR the lowest.
+ */
+#define PC302_DMA_CH_PRIOR_0      (0x00000000)
+#define PC302_DMA_CH_PRIOR_1      (0x00000001)
+#define PC302_DMA_CH_PRIOR_2      (0x00000002)
+#define PC302_DMA_CH_PRIOR_3      (0x00000003)
+#define PC302_DMA_CH_PRIOR_4      (0x00000004)
+#define PC302_DMA_CH_PRIOR_5      (0x00000005)
+#define PC302_DMA_CH_PRIOR_6      (0x00000006)
+#define PC302_DMA_CH_PRIOR_7      (0x00000007)
+/*!
+ *  Flag values used to set the channel protection.
+ */
+#define PC302_DMA_PROTCTL_0       (0x00000000)
+#define PC302_DMA_PROTCTL_1       (0x00000010)
+#define PC302_DMA_PROTCTL_2       (0x00000020)
+#define PC302_DMA_PROTCTL_3       (0x00000030)
+/*!
+ *  Optional flag used to configure the internal DMA FIFO mode. When set a
+ *  transfer will only be requested or started when at least half the FIFO is
+ *  empty or full depending on the direction of transfer, or this is the end
+ *  of a burst transaction.
+ *  When unset (the default) a transfer is requested or started if there is
+ *  sufficient space or data available for a single transfer.
+ */
+#define PC302_DMA_FIFO_WAIT      (0x00000100)
+/*!
+ *  Optional flag for configuring the DMA Flow Control Mode. When unset (the
+ *  default), source transactions are processed as soon as they occur.
+ *  When set source transactions are not processed until after a destination
+ *  request has been received. The idea of this mode is that only data that can
+ *  transferred to the destination channel is read from the source.
+ */
+#define PC302_DMA_DST_WAIT       (0x00000200)
+
+/*******************************************************************************
+ * External Data structures & types
+ ******************************************************************************/
+
+/*!
+ * \brief This enum defines the flags that can be used to set the debugging
+ * level for a DMA
+ */
+typedef enum
+{
+    /** Report warning conditions only such as a unexpected return parameter */
+    PC302_DMA_LVL_WARNING,
+
+    /** Report normal but significant conditions */
+    PC302_DMA_LVL_NOTICE,
+
+    /** Provide informational messages such as external API calls */
+    PC302_DMA_LVL_INFO,
+
+    /** Provide debug level messages such as key register values */
+    PC302_DMA_LVL_DEBUG,
+
+    /** Provide trace messages such as internal function calls */
+    PC302_DMA_LVL_TRACE,
+
+    /** Provide register IO trace messages */
+    PC302_DMA_LVL_TRACE_IO
+} pc302_dma_lvl_t;
+
+/*!
+ * \brief This structure defines the context of the driver.
+ * It holds the internal state of the driver and is purposely hidden from
+ * client code.
+ */
+typedef struct pc302_dma_tag *pc302_dma_t;
+
+/*!
+ * \brief This structure defines the handle for representing a dma transfer.
+ * Internally it will hold a channel number and the state of the channel.
+ * It is hidden from the client code.
+*/
+typedef struct pc302_dma_xfr_tag *pc302_dma_xfr_t;
+
+/*!
+ * \brief This structure contains the context of a DMA multi-block list.
+ * It holds all internal state of the list and is hidden from client code.
+ */
+typedef struct pc302_dma_list_tag *pc302_dma_list_t;
+
+/*!
+ * \brief This enum defines the type of source or destination endpoint
+ */
+typedef enum
+{
+    /** Endpoint type is a source */
+    PC302_DMA_SRC,
+
+    /** Endpoint type is a destination */
+    PC302_DMA_DST
+} pc302_dma_endpoint_type_t;
+
+/*!
+ * \brief This enum selects the bus master to use for the transfer.
+ * It is used to define the CTLx.SMS and CTLx.DMS bits.
+ */
+typedef enum
+{
+    PC302_DMA_MASTER1     = 0x0,
+    PC302_DMA_MASTER2     = 0x1,
+    PC302_DMA_MASTER3     = 0x2,
+    PC302_DMA_MASTER4     = 0x3,
+} pc302_master_t;
+
+/*!
+ * \brief This enum determines how the address (source or destination) will be
+ * incremented after each read or write. It is used to define the CTLx.SINC and
+ * DINC bits.
+ */
+typedef enum
+{
+    /** Increment the address pointer between reads / writes */
+    PC302_DMA_ADDR_INCREMENT = 0x0,
+
+    /** Decrement the address pointer between reads / writes */
+    PC302_DMA_ADDR_DECREMENT = 0x1,
+
+    /** Do not increment or decrement the pointer between reads / writes.
+        (Scatter / gather is disabled with this option) */
+    PC302_DMA_ADDR_NO_CHANGE = 0x2
+} pc302_increment_t;
+
+/*!
+ * \brief This enum sets the bus width (in bits) to use for the transfer.
+ * It is used to define the CTLx.SRC_TR_WIDTH and DST_TR_WIDTH bits.
+ */
+typedef enum
+{
+    /** Use a bus width of 8 bits */
+    PC302_DMA_TR_WIDTH8 = 0x0,
+
+    /** Use a bus width of 16 bits */
+    PC302_DMA_TR_WIDTH16 = 0x1,
+
+    /** Use a bus width of 32 bits */
+    PC302_DMA_TR_WIDTH32 = 0x2,
+
+    /** Use a bus width of 64 bits */
+    PC302_DMA_TR_WIDTH64 = 0x3
+} pc302_tr_width_t;
+
+/*!
+ * \brief This enum sets the burst transaction length (in transfer bus widths) to use.
+ * The maximum size of the burst is limited by the FIFO size in hardware.
+ * It is used to define the CTLx.SRC_MSIZE and DST_MSIZE bits.
+ */
+typedef enum
+{
+    /** Use a burst transaction size of 1 transfer bus widths */
+    PC302_DMA_MS_1_TRW = 0x0,
+
+    /** Use a burst transaction size of 4 transfer bus widths */
+    PC302_DMA_MS_4_TRW = 0x1,
+
+    /** Use a burst transaction size of 8 transfer bus widths */
+    PC302_DMA_MS_8_TRW = 0x2,
+
+    /** Use a burst transaction size of 16 transfer bus widths */
+    PC302_DMA_MS_16_TRW = 0x3,
+
+    /** Use a burst transaction size of 32 transfer bus widths. This is the maximum
+        size permitted */
+    PC302_DMA_MS_32_TRW = 0x4,
+
+    /** Automatic setting of the burst transaction. With this option the burst
+        transaction Length will be set according to the number of bytes (the
+        count) to be transferred and the chosen transfer width. The burst length
+        is chosen to minimise the total number of transactions, that is the
+        number of burst transactions plus the number of single transactions
+        required to complete the transfer. */
+    PC302_DMA_MS_AUTO
+} pc302_msize_t;
+
+/*!
+ * \brief This structure is used to specify the scatter/gather parameters of a
+ * channel. This information is required when a transfer is set up and is used
+ * in the * SGRx and DSRx registers. Note, these SG settings apply to the entire
+ * DMA transfer i.e. all blocks of a multi block transfer (where enabled).
+ */
+typedef struct
+{
+    /** Length of the scatter / gather frame in bytes */
+    size_t count;
+
+    /** The number of bytes between frames */
+    unsigned interval;
+} pc302_dma_sg_t;
+
+/*!
+ * /brief This structure is used to specify the hardware handshaking for the
+ * source or destination of a DMA transfer. The data is used to setup the
+ * CFGx registers. If the handshaking is not setup for a transfer (by not
+ * calling pc302_dma_setup_handshaking()), the DMA will default to software
+ * handshaking.
+ */
+typedef struct
+{
+    /** The handshaking interface to be used * (0-(DMA_HANDSHAKING_IFS-1)) */
+    unsigned hwInterface;
+
+    /** The polarity of the handshaking, 1 for active low. */
+    int active_low;
+} pc302_dma_handshake_t;
+
+/*!
+ * /brief This enum contains bit flags used to define the interrupt types to be
+ * enabled, disabled or queried. Each field is a bit-mask that can be logically
+ * ORed together to specify more than one interrupt type.
+ */
+typedef enum
+{
+    /** Generate an interrupt on DMA block transfer completion to the
+        destination endpoint. If this interrupt is enabled and the DMA is a
+        multi-block type (either via multi-block list or auto-reloading), then
+        the DMA will wait after transferring each block for this interrupt to be
+        cleared. */
+    PC302_DMA_INT_BLOCK           = 1,
+
+    /** Generate an interrupt on completion of the last transfer to the
+        destination endpoint that concludes a transaction (single or burst).
+        It is triggered by software or hardware handshaking, and is typically
+        used in software handshaking to generate a request for the next
+        transaction. */
+    PC302_DMA_INT_DST_TRANSACTION = 2,
+
+    /** Interrupt set when an ERROR response is received by the DMA.
+        The transfer is canceled and the channel disabled. */
+    PC302_DMA_INT_ERROR           = 4,
+
+    /** Generate an interrupt on DMA block transfer completion from the
+        source endpoint. If this interrupt is enabled and the DMA is a
+        multi-block type (either via multi-block list or auto-reloading), then
+        the DMA will wait after transferring each block for this interrupt to be
+        cleared. */
+    PC302_DMA_INT_SRC_TRANSACTION = 8,
+
+    /** Interrupt generated on DMA transfer completion to the destination
+        endpoint */
+    PC302_DMA_INT_TRANSFER        = 16,
+
+    /** Enable all  interrupt types. */
+    PC302_DMA_INT_ALL             = 31,
+} dma_irq_type_t;
+
+/*!
+ * \brief This type is used to specify the source or destination of a DMA
+ * transfer
+ *
+ * At its simplest, it holds the physical address of the data buffer. This data
+ * is used to configure the source/destination address and control registers
+ * (SARx, DARx and CTLx). This does not control the channel configuration or
+ * scatter/gather registers (see note 3). The structure is used in configuring
+ * single or multi-block list type transfers as the information within is used
+ * in each element of the multi-block list.
+ *
+ * Notes:
+ *
+ * 1. Either the source or destination can be the flow controller, or neither
+ *  but not both. If neither is the flow controller, the DMA is defaulted to be
+ *  the controller. The flow controller will determine the block size
+ *  transferred. If a flow controller is assigned which employs hardware
+ *  handshaking the 'count' size specified by pc302_dma_setup_direct_xfr() or
+ *  pc302_dma_list_add() is ignored. A memory endpoint cannot be a flow
+ *  controller. The memory endpoint does not require handshaking (hardware or
+ *  software) and will proceed to transfer immediately without waiting for a
+ *  transaction request.
+ *
+ * 2. Auto reload mode and direct transfers. If auto-reload is set for either
+ *  the source or destination end points (or both), the transfer will restart
+ *  again at the end of the last transaction. The transfer will be one-time only
+ *  if both source and destination auto_reload is false. If one of the end
+ *  points is not set to auto-reload (but the other is), its physical address
+ *  will not be reloaded. Instead the address used will continue from where it
+ *  stopped at the end of the last transaction. This is known as continuous
+ *  mode.
+ *
+ * 3. Auto reload and list transfers. When applied to multi-block lists, either
+ *  the source or destination (but not both) end points can be set to
+ *  auto_reload. Only the first block of a multi-block list can be set when its
+ *  auto_reload flags is true. Thereafter the end point must not be set in the
+ *  subsequent blocks of the list (pass NULL as the pc302_dma_list_add endpoint
+ *  param). If the first element of the multi-block list is the only one with
+ *  the end points set but the auto_reload flag is not set, the DMA will be in
+ *  continuous mode where the physical address will continue from the end of the
+ *  last block.
+ *
+ * 4. The auto_reload information is set in the configuration register. This is
+ *  the only information passed to that register from this structure. All other
+ *  data goes into the writing the control register.
+ *
+ * 5. Scatter/Gather will not be enabled unless the SG parameters are set by
+ *  calling pc302_dma_setup_sg().
+ */
+typedef struct
+{
+    /** Physical address of the data */
+    dma_addr_t dma_addr;
+
+    /** The interface layer used for communications */
+    pc302_master_t master;
+
+    /** True if the endpoint is peripheral not memory */
+    int periph_not_mem;
+
+    /** True if the endpoint is the flow controller */
+    int flow_controller;
+
+    /** True if Scatter/gather enabled */
+    int enable_sg;
+
+    /** Increment/decrement or fixed addr */
+    pc302_increment_t addr_inc;
+
+    /** The endpoint Transfer Width */
+    pc302_tr_width_t tr_width;
+
+    /** The Burst Transaction size */
+    pc302_msize_t msize;
+
+    /** True if auto-reload the physical address at end of block */
+    int auto_reload;
+} pc302_dma_endpoint_t;
+
+/*******************************************************************************
+ * Public function declarations
+ *****************************************************************************/
+
+/*!
+ * \brief Set up a DMA transfer between source and destination.
+ *
+ * The DMA set up by this call will not start transferring data until
+ * pc302_dma_start() is called.
+ *
+ * The data structure pointed to by the src and dst parameters are copied
+ * by the call so can be destroyed once the call returns.
+ *
+ * The DMA channel set up by this call will have:
+ *  - All interrupts disabled
+ *  - Channel disabled but not suspended
+ *  - Source and Destination address set to the parameters
+ *  - Single block transfer mode
+ *  - Transfer size set to count
+ *  - Source and Destination Master interface set to the parameters
+ *  - Transfer Type and Flow control set according to parameters
+ *  - No Scatter or Gather.
+ *  - Source/Dest Burst Length set according to parameters
+ *  - Source/Dest address increment set according to parameters
+ *  - Source/Dest Transfer Width set according to parameters
+ *  - Protocol Control set according to flags
+ *  - Transfer FIFO mode set according to flags
+ *  - Data pre-fetching is set according to flags
+ *  - Automatic source/destination reload set by the parameters
+ *  - Channel priority set according to flags
+ *  - Source/Dest handshaking setup according to parameters.
+ *
+ * If neither the src or dst are auto-reload, the transfer setup by this call is
+ * once only and will stop when the data has been transferred. Multi-block
+ * transfers will wait between blocks if the block interrupt is enabled.
+ *
+ * The 'count' parameter is used in one of three ways:
+ *
+ * 1. If neither end of the transfer is a flow controller (the DMA engine is
+ *    flow controller), the count parameter is used to set the block size in the
+ *    DMA control register.
+ *
+ * 2. If one end of the transfer is the flow controller and has hardware
+ *    handshaking, the count is ignored as the flow controller will control the
+ *    amount of data in the block.
+ *
+ * 3. If one end of the transfer is a flow controller but software handshaking
+ *    is used, the count parameter is ignored. In this situation client software
+ *    may not know the size of the block at the point when the transfer is
+ *    setup. The bytes_left parameter of pc302_dma_request_transaction function
+ *    is used to tell the driver the data left in the block when each
+ *    transaction is requested. pc302_dma_request_transaction() can then decide
+ *    the type of transaction to request.
+ *
+ * \param dma The dma handle
+ * \param src Transfer source details
+ * \param dst Transfer destination details
+ * \param src_handshaking The handshaking parameters for transfer source or NULL
+ *                      if hardware handshaking is not used
+ * \param dst_handshaking The handshaking parameters for transfer destination or
+ *                      NULL if hardware handshaking is not used.
+ * \param count The number of bytes to transfer. If either end of the transfer
+ *              is a hardware handshaking flow controller, this is ignored.
+ * \param flags A logical OR of one or more of the following flags:
+ * \verbatim
+                 PC302_DMA_PROTCTL_0   - Sets the PROTCTL bits (only 1 of these
+                 PC302_DMA_PROTCTL_1     may be selected)
+                 PC302_DMA_PROTCTL_2
+                 PC302_DMA_PROTCTL_3
+                 PC302_DMA_FIFO_MODE   - Sets the FIFO mode
+                 PC302_DMA_FC_MODE     - Sets the Flow Control mode
+                 PC302_DMA_CH_PRIOR_0  \
+                 PC302_DMA_CH_PRIOR_1
+                 PC302_DMA_CH_PRIOR_1  - Sets the channel priority
+                 PC302_DMA_CH_PRIOR_2    from PC302_DMA_CH_PRIOR_0
+                 PC302_DMA_CH_PRIOR_3    (lowest) to
+                 PC302_DMA_CH_PRIOR_4    PC302_DMA_CH_PRIOR_7
+                 PC302_DMA_CH_PRIOR_5    (highest)
+                 PC302_DMA_CH_PRIOR_6
+                 PC302_DMA_CH_PRIOR_7  /
+ * \endverbatim
+ * \param handler The handler function to call on interrupt
+ * \param cookie Pointer to be returned as client data in the callback function
+ *
+ * \return Handle to the new transfer created or NULL if something went wrong.
+ */
+__must_check pc302_dma_xfr_t
+pc302_dma_setup_direct_xfr(pc302_dma_t dma,
+			   pc302_dma_endpoint_t *src,
+			   pc302_dma_endpoint_t *dst,
+                           pc302_dma_handshake_t *src_handshaking,
+                           pc302_dma_handshake_t *dst_handshaking,
+                           size_t count,
+                           u32 flags,
+                           int ( *handler )( void *cookie,
+                                             int errno ),
+                           void *cookie);
+
+/*!
+ * \brief Start a DMA transfer on a channel previously set up with the
+ * pc302_dma_setup_direct_xfr() or pc302_dma_setup_list_xfr() functions.
+ *
+ * Once started, the transfer is locked and will not be modifiable. This
+ * includes a DMA multi-block list that is associated with a transfer. Transfers
+ * will continue to completion asynchronously. Once finished, they can be
+ * restarted.
+ *
+ * \param dma_xfr The transfer handle.
+ *
+ * \return OK on success, EINVAL if the transfer is already running
+ */
+__must_check int
+pc302_dma_start(pc302_dma_xfr_t dma_xfr);
+
+/*!
+ * \brief Abort a DMA transfer.
+ *
+ * Once aborted, the transfer can be restarted. Also the transfer can be
+ * modified once aborted. If the transfer is restarted, it will continue from
+ * the start of the single transfer buffer or multi-block list.
+ *
+ * \param dma_xfr The transfer handle.
+ *
+ * \return OK on success, or EINVAL if the transfer is not running
+ */
+__must_check int
+pc302_dma_abort(pc302_dma_xfr_t dma_xfr);
+
+/*!
+ * \brief Stop a DMA transfer and release resources.
+ *
+ * Once released, the transfer can not be restarted and has to be setup once
+ * more. The transfer handle will become invalid on exit of this function.
+ *
+ * \param dma_xfr The transfer handle.
+ *
+ * \return OK on success, or the appropriate error code
+ */
+__must_check int
+pc302_dma_release(pc302_dma_xfr_t dma_xfr);
+
+/*!
+ * \brief Set a debug level for the DMA handle
+ *
+ * Default debug levels for all DMA handles may be specified at compile time
+ * using the macro CONFIG_PC302_DMA_DEBUG. This function will change the debug
+ * level for the DMA specified.
+ *
+ * \param dma The dma handle
+ * \param lvl The debug level to apply. Can be any of pc302_dma_lvl_t
+ */
+void
+pc302_dma_set_debug_level(pc302_dma_t dma,
+                          pc302_dma_lvl_t lvl);
+
+/*!
+ * \brief Allocate the list for multi-block transfers.
+ *
+ * The heap memory is utilised and the list is initialised. The length of the
+ * list allocated is set at the calling time.
+ *
+ * \param dma The DMA handle
+ * \param count The maximum number of elements to the list.
+ *
+ * \return Handle of the newly allocated list
+ */
+__must_check pc302_dma_list_t
+pc302_dma_list_create(pc302_dma_t dma,
+                      size_t count);
+
+/*!
+ * \brief Add an entry to the end of a DMA multi-block list.
+ *
+ * The entry added to the list specifies a simple block transfer. The data
+ * pointed to by the src and dst parameters are copied by the call so can be
+ * destroyed once the call returns. This function will not modify a list that is
+ * currently in use with a DMA operation.
+ *
+ * The first element of the list must have both src and dst endpoints. If either
+ * endpoint (not both) is to be continuous, subsequent elements need to set the
+ * endpoint to NULL. If either endpoint (not both) is to be auto-reload, the
+ * first element needs to set the auto_reload flag and subsequent elements need
+ * to set the endpoint to NULL.
+ *
+ * Note: Each block of the list can set a transfer width. Transfer width affects
+ * the setting of scatter/gather which is set globally for the transfer.
+ * Scatter / gather is setup in the hardware based on the transfer widths of the
+ * first element of the block list. It is recommended that subsequent blocks use
+ * the same transfer width (if SG is enabled), otherwise there will be undefined
+ * effects.
+ *
+ * \param list The DMA multi-block list to add a new block to
+ * \param src The source DMA endpoint parameters, or NULL if auto-reload or
+ *            continuous modes selected
+ * \param dst The destination endpoint parameters,or NULL if auto-reload or
+ *            continuous modes selected
+ * \param src_handshaking The handshaking parameters for transfer source or NULL
+ *                      if hardware handshaking is not used
+ * \param dst_handshaking The handshaking parameters for transfer destination or
+ *                      NULL if hardware handshaking is not used.
+ * \param count The number of bytes to transfer. If either end of the transfer
+ *              is a hardware flow controller this parameter is ignored.
+ *
+ * \return
+ * -       ENOMEM The list is full, no more items can be added
+ * -       EBUSY  If the list is in use with a DMA transfer
+ * -       ENOMEM The list is full, no more items can be added
+ * -       EBUSY  If the list is in use with a DMA transfer
+ * -       EINVAL The combination of source and destination endpoints is invalid
+ */
+__must_check int
+pc302_dma_list_add(pc302_dma_list_t list,
+                   pc302_dma_endpoint_t *src,
+                   pc302_dma_endpoint_t *dst,
+                   pc302_dma_handshake_t *src_handshaking,
+                   pc302_dma_handshake_t *dst_handshaking,
+                   size_t count);
+
+/*!
+ * \brief Reset a list to the state that it was in just after it was created
+ * with pc302_dma_list_create().
+ *
+ * This function does not free the memory associated by the list, and it will
+ * not modify a list that is currently in use with a DMA operation.
+ *
+ * \param list The DMA list returned from pc302_dma_list_create
+ *
+ * \return 0 on success, or EBUSY If the list is in use with a DMA transfer
+ */
+__must_check int
+pc302_dma_list_clear(pc302_dma_list_t list);
+
+/*!
+ * \brief Frees the resources allocated by a list.
+ *
+ * Lists need to be freed after use to avoid a memory leak. This function will
+ * not modify a list that is currently in use with a DMA operation.
+ *
+ * \param list The DMA list returned from pc302_dma_list_create()
+ *
+ * \return 0 on success, OR EBUSY If the list is in use with a DMA transfer
+ */
+__must_check int
+pc302_dma_list_destroy(pc302_dma_list_t list);
+
+/*!
+ * \brief Set up a multi-block DMA transfer.
+ *
+ * The transfer is controlled by the list provided. The DMA list can be modified
+ * once this function has been called but when the DMA operations is started
+ * (by calling pc302_dma_start) the list will be locked and any attempt to
+ * modify it will not be allowed. Data transfer is not started until the
+ * pc302_dma_start() is called. The transfer setup by this call is multi-block
+ * only and will stop when the end of the multi-block list is reached. In
+ * addition the transfer will wait between blocks if the block interrupt is
+ * enabled. Source and destination handshaking is setup according to the
+ * parameters.
+ *
+ * \param list The DMA multi-block list containing the data blocks
+ *             to be transferred.
+ * \param src_handshaking The handshaking parameters for transfer source or NULL
+ *                      if hardware handshaking is not used
+ * \param dst_handshaking The handshaking parameters for transfer destination or
+ *                      NULL if hardware handshaking is not used.
+ * \param flags A logical OR of one or more flags:
+ * \verbatim
+              PC302_DMA_PROTCTL_0   - Sets the PROTCTL bits (only one of these)
+              PC302_DMA_PROTCTL_1
+              PC302_DMA_PROTCTL_2
+              PC302_DMA_PROTCTL_3
+              PC302_DMA_FIFO_MODE   - Sets the FIFO mode
+              PC302_DMA_FC_MODE     - Sets the Flow Control mode
+              PC302_DMA_CH_PRIOR_0  \
+              PC302_DMA_CH_PRIOR_1
+              PC302_DMA_CH_PRIOR_1  - Sets the channel priority
+              PC302_DMA_CH_PRIOR_2    from PC302_DMA_CH_PRIOR_0
+              PC302_DMA_CH_PRIOR_3    (lowest) to
+              PC302_DMA_CH_PRIOR_4    PC302_DMA_CH_PRIOR_7
+              PC302_DMA_CH_PRIOR_5    (highest)
+              PC302_DMA_CH_PRIOR_6
+              PC302_DMA_CH_PRIOR_7  /
+ * \endverbatim
+ * \param handler (DMA handler function to call on interrupt
+ * \param cookie Pointer to be returned as client data in callback function
+ *
+ * \return
+ * -       0 on success, or
+ * -       ENOMEM No enough resources to complete the call
+ * -       EBUSY  If the list is already in use with a DMA transfer
+ * -       EINVAL Combination of parameters is illegal.
+ */
+__must_check pc302_dma_xfr_t
+pc302_dma_setup_list_xfr(pc302_dma_list_t list,
+                         pc302_dma_handshake_t *src_handshaking,
+                         pc302_dma_handshake_t *dst_handshaking,
+                         u32 flags,
+                         int ( *handler )( void *cookie,
+                                           int errno ),
+                         void *cookie);
+
+/*!
+ * \brief Get the handle of specified of the PC302 DMA.
+ *
+ * This handle is to be used as a parameter to all other driver API functions.
+ *
+ *\param dmaNumber The DMA number, (0 or 1)
+ *
+ * return DMA handle, or NULL on error
+ */
+__must_check pc302_dma_t
+pc302_dma_get_dma_handle(unsigned dmaNumber);
+
+/*!
+ * \brief Enable interrupt generation of a number of types of interrupt on a DMA
+ * transfer.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param irq_types The types of interrupt, any logical OR combination of
+ *                 bit field in enum dma_irq_type_t
+ * \return 0 on success, or EINVAL on error
+ */
+__must_check int
+pc302_dma_enable_int(pc302_dma_xfr_t dma_xfr,
+                     unsigned irq_types);
+
+/*!
+ * \brief Disable interrupt generation of a number of types of interrupt on a
+ * DMA transfer.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param irq_types The types of interrupt, any logical OR combination of
+ *                  bit field in enum dma_irq_type_t
+ * \return 0 on success, or EINVAL on error
+ */
+__must_check int
+pc302_dma_disable_int(pc302_dma_xfr_t dma_xfr,
+                      unsigned irq_types);
+
+/*!
+ * \brief Clears a number of interrupt status bits, ready for new interrupt
+ * generation.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param irq_types The types of interrupt, any logical OR combination of
+ *                  bit field in enum dma_irq_type_t
+ */
+void
+pc302_dma_clear_int(pc302_dma_xfr_t dma_xfr,
+                    unsigned irq_types);
+
+/*!
+ * \brief Get the raw status of a DMA transfer
+ *
+ * This function can be used to see if one or more of the specified interrupts
+ * have become set. The value returned is a logical OR of the dma_irq_type_t
+ * type, and can by used by the client application as a polling function.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param irq_types The types of interrupt, any logical OR combination of
+ *                  bit field in enum dma_irq_type_t
+ *
+ * \return
+ * -       A bit mask where a '1' bit indicates the status type is set.
+ * -       Any combination irq_types is permitted
+ */
+__must_check unsigned
+pc302_dma_get_raw_status(pc302_dma_xfr_t dma_xfr,
+                         unsigned irq_types);
+
+/*!
+ * \brief This function is used to setup the scatter or gather parameters of a
+ * DMA transfer.
+ *
+ * If SG is not setup, the DMA transfer defaults to switching the SG capability
+ * off. The following diagram and note describes how the parameters in
+ * pc302_dma_sg_t configure the scatter / gather.
+ * \verbatim
+  
+                        |                   |
+                        |                   |
+                        |-------------------|   ^
+                        |    frame 0        |   |-- count (bytes)
+                     ^  |-------------------|   v
+         interval  --|  |                   |
+          (bytes)    |  |                   |
+                     |  |                   |
+                     |  |                   |
+                     v  |-------------------|
+                        |    frame 1        |
+                        |-------------------|
+                        |                   |
+                        |                   |
+ * \endverbatim
+ * Note the alignment of the interval (sg_stride) and count (sg_count) settings
+ * for a transfer affect the automatic Burst Transaction Length settings as the
+ * hardware has to be set up for transfer in bursts. Both count (the number of
+ * bytes to scatter or gather) and stride (the interval between frames) must be
+ * a multiple of the Transfer Width of the endpoint. To achieve this the
+ * sg_count and sg_stride will values will be truncated as necessary.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param sg The scatter / gather  parameters
+ * \param src_dst 1 for source, and 0 for destination scatter / gather.
+ *
+ * \return 0 on success, or EBUSY if the DMA transfer is in progress and so
+ *         cannot be modified at this time
+ *
+ */
+__must_check int
+pc302_dma_setup_sg(pc302_dma_xfr_t dma_xfr,
+                   pc302_dma_sg_t *sg,
+                   pc302_dma_endpoint_type_t src_dst);
+
+/*!
+ * \brief Request a new transaction on the source or destination of a transfer.
+ *
+ * The DMA endpoint (source or destination) needs to be configured for software
+ * handshaking, otherwise this function has no effect. For flow controlling
+ * endpoints the type of transaction, burst, single or last is calculated from
+ * the bytes_left parameter. For non-flow controlling endpoints the type of
+ * transfer is calculated by the hardware (the endpoint enters the single
+ * transaction region automatically).
+ *
+ * Notes:
+ *
+ * 1. When requesting transactions of a flow controlling endpoint the bytes_left
+ * parameter can be set to a high value (say 1000) if it is not known how big
+ * the block is. This will cause burst endpoints.
+ *
+ * 2. Once the size of the block is known the bytes_left should be set
+ * appropriately. The bytes_left will be updated by the function and the new
+ * updated value should be used in the next call to this function.
+ *
+ * 3. Once the block size is known client code should continue to call this
+ * function with the value of bytes_left returned from the previous call. The
+ * call must not revert to setting a high value (as in 1).
+ *
+ * 4. Client code should not call this function with zero bytes left if the last
+ * call specified many bytes left (as in 1). The reason is that the function
+ * needs to have prior knowledge of the end of the block so that it can set the
+ * last transaction flag on the last transaction.
+ *
+ * 5. The bytes_left must be divisible by the transfer width of the source and
+ * destination endpoints.
+ *
+ * 6. Burst transactions are chosen up to the point where the last burst
+ * transaction would spill over the end of the DMA buffer (size indicated by
+ * 'count'). Then single transactions are chosen for the remaining data.
+ * Finally, a last transaction is chosen for the final transaction.
+ *
+ * \param dma_xfr The transfer handle.
+ * \param src_dst 1 for source and 0 for destination
+ * \param bytes_left The number of bytes left to transfer in the block. This is
+ *                   used only for flow controlling endpoints and is updated
+ *                   when the function returns. When this reached zero, no more
+ *                   transactions should be requested for this endpoint.
+ * \return
+ * -       0 on success, or
+ * -       EBUSY The DMA transfer is not in progress and so transaction cannot
+ *               be requested at this time.
+ * -       EFAULT Something went wrong and the driver did not keep track of the
+ *                state of the hardware.
+ * -       EINVAL The transfer is not running.
+ */
+__must_check int
+pc302_dma_request_transaction(pc302_dma_xfr_t dma_xfr,
+                              pc302_dma_endpoint_type_t src_dst,
+                              unsigned *bytes_left);
+
+/*!
+ * \brief Output all DMA configuration registers for all channels, including the
+ * information held in multi-block lists.
+ *
+ * \param dma The DMA handle.
+ */
+void
+pc302_dma_dump_regs(
+    pc302_dma_t dma);
+
+#endif /* __PC302_DMAC__ */
+
diff --git a/arch/arm/mach-pc302/include/mach/pc302fracn.h b/arch/arm/mach-pc302/include/mach/pc302fracn.h
new file mode 100644
index 0000000..577def4
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/pc302fracn.h
@@ -0,0 +1,147 @@
+/**
+ * \file pc302fracn.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright 2008 picoChip Designs LTD, All Rights Reserved.
+ * http://www.picochip.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This file defines an API for configuring the Fractional-N synthesizer in
+ * the picoChip PC302 device.
+ */
+#ifndef __PC302FRACN_H__
+#define __PC302FRACN_H__
+
+/* Frac-N status register bits. */
+
+/* Running fast offset and mask. */
+#define FRACN_RUNNING_FAST_OFFSET ( 15 )
+#define FRACN_RUNNING_FAST_MASK ( 1 << FRACN_RUNNING_FAST_OFFSET )
+
+/* Running slow offset and mask. */
+#define FRACN_RUNNING_SLOW_OFFSET ( 14 )
+#define FRACN_RUNNING_SLOW_MASK ( 1 << FRACN_RUNNING_SLOW_OFFSET )
+
+/* Control voltage pulse width offset and mask. */
+#define FRACN_CTRL_V_PULSE_WIDTH_OFFSET ( 3 )
+#define FRACN_CTRL_V_PULSE_WIDTH_MASK \
+    ( 0x1FFF << FRACN_CTRL_V_PULSE_WIDTH_OFFSET )
+
+/* VCXO control voltage under limit offset and mask. */
+#define FRACN_CTRL_V_UNDER_LIMIT_OFFSET ( 2 )
+#define FRACN_CTRL_V_UNDER_LIMIT_MASK ( 1 << FRACN_CTRL_V_UNDER_LIMIT_OFFSET )
+
+/* VCXO control voltage over limit offset and mask. */
+#define FRACN_CTRL_V_OVER_LIMIT_OFFSET ( 1 )
+#define FRACN_CTRL_V_OVER_LIMIT_MASK ( 1 << FRACN_CTRL_V_OVER_LIMIT_OFFSET )
+
+/* Frequency synthesizer not locked offset and mask. */
+#define FRACN_NOT_LOCKED_OFFSET ( 0 )
+#define FRACN_NOT_LOCKED_MASK ( 1 << FRACN_NOT_LOCKED_OFFSET )
+
+/**
+ * Get the current M value.
+ *
+ * \param val The destination to store the value of M.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_get_m( u8 *val );
+
+/**
+ * Set a new value of M.
+ *
+ * \param val The new value of M.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_set_m( u8 val );
+
+/**
+ * Get the current N value.
+ *
+ * \param val The destination to store the value of N.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_get_n( u8 *val );
+
+/**
+ * Store a new value of N.
+ *
+ * \param val The new value of N.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_set_n( u8 val );
+
+/**
+ * Get the current K value.
+ *
+ * \param val The destination to store the value of K.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_get_k( u32 *val );
+
+/**
+ * Store a new value of K.
+ *
+ * \param val The new value of K.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_set_k( u32 val );
+
+/**
+ * Get the current control voltage pulse lower limit.
+ *
+ * \param val The destination to store the result in.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_get_cv_pulse_ll( u16 *val );
+
+/**
+ * Set a new control voltage pulse lower limit.
+ *
+ * \param val The new value to set.
+ * \return Returns zero on success, non-zero on failure. */
+static int fracn_set_cv_pulse_ll( u16 val );
+
+/**
+ * Get the current control voltage pulse upper limit.
+ *
+ * \param val The destination to store the result in.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_get_cv_pulse_ul( u16 *val );
+
+/**
+ * Set a new control voltage pulse upper limit.
+ *
+ * \param val The new value to set.
+ * \return Returns zero on success, non-zero on failure. */
+static int fracn_set_cv_pulse_ul( u16 val );
+
+/**
+ * Get the contents of the Frac-N status register.
+ *
+ * \param val The destination to store the status in.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_get_status( u16 *val );
+
+/**
+ * Reset the Frac-N synth.
+ *
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_reset( void );
+
+/**
+ * Load the new values of M, N and K into the Frac-N synth.
+ *
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int fracn_load( void );
+
+#endif /* __PC302FRACN_H__ */
diff --git a/arch/arm/mach-pc302/include/mach/platform.h b/arch/arm/mach-pc302/include/mach/platform.h
new file mode 100644
index 0000000..067927c
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/platform.h
@@ -0,0 +1,56 @@
+/*
+ * platform.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ARCH_PC302_PLATFORM_H
+#define __ARCH_PC302_PLATFORM_H
+
+#include <asm/sizes.h>
+
+/* Flash size and position */
+/* Physical address of the Flash in the ARM sub-system memory map */
+#define PC302_FLASH_BASE        0x40000000
+
+/* Size of the Flash (in bytes */
+#define PC302_FLASH_SIZE        SZ_128M
+
+/* Data bus width of the Flash (in bytes */
+#define PC302_FLASH_WIDTH       1
+
+/* SDRAM size and position - the ram in the PC302 is split into 4 banks.
+ * 64M spread over 4 banks, starting at zero with 64M between each bank.
+ * NOTE: The actual ram available is 128M on the SVB but half of it is reserved
+ * for the picoArray.
+ * NOTE: The size here is the default, set if the pc302_mem= parameter is not
+ * used.
+ */
+#define PC302_RAM_START         0x00000000
+#define PC302_RAM_SIZE          SZ_64M      /* Default */
+#define PC302_RAM_BANKS         4
+#define PC302_RAM_BANK_STRIDE   SZ_64M
+
+/* The clock frequency for the UARTs */
+#define PC302_BASE_BAUD         3686400     /* 3.6864 MHz */
+
+/* The clock frequency for the timers on the various boards */
+#define PC302_TIMER_FREQ        200000000   /* 200 MHz */
+
+#endif /* __ARCH_PC302_PLATFORM_H */
diff --git a/arch/arm/mach-pc302/include/mach/reset.h b/arch/arm/mach-pc302/include/mach/reset.h
new file mode 100644
index 0000000..e55d8a3
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/reset.h
@@ -0,0 +1,30 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * pc302 - Reset handler
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_RESET_H
+#define __ASM_ARCH_RESET_H __FILE__
+
+/* Function pointer to a function able to reset the board. This function
+ * is passed to the kernel by a driver.
+ */
+typedef void (*reset_t)(char mode, void *cookie);
+
+/* Trigger a reset (called by kernel) */
+void pc302_reset(char mode);
+
+/* Reset registration (called by drivers) */
+void register_reset_handler(reset_t reset, void *cookie);
+void deregister_reset_handler(reset_t reset, void *cookie);
+
+
+#endif /* __ASM_ARCH_RESET_H */
+
diff --git a/arch/arm/mach-pc302/include/mach/system.h b/arch/arm/mach-pc302/include/mach/system.h
new file mode 100644
index 0000000..0ec4eeb
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/system.h
@@ -0,0 +1,39 @@
+/*
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <mach/reset.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+    pc302_reset(mode);
+}
+
+#endif
diff --git a/arch/arm/mach-pc302/include/mach/timex.h b/arch/arm/mach-pc302/include/mach/timex.h
new file mode 100644
index 0000000..86a89c8
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/timex.h
@@ -0,0 +1,47 @@
+/*
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ *  PC302 architecture timex specifications
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* This is the rate at which the timer that controls the linux tick runs.
+ * It is used to calculate the actual tick frequency that is achieved as
+ * it is not always possible to divide this frequency down to the configured
+ * HZ value.
+ * See jiffies.h.
+ */
+
+#ifndef __TIMEX_H__
+#define __TIMEX_H__
+
+#include <mach/platform.h>
+
+/* The frequency at which the timer gets clocked is dependent on the
+ * machine type we are running on.
+ * Unfortunately the machine we are running on is not known until run time
+ * when the bootloader tells us. Therefore we do not have a known clock
+ * tick rate. 
+ * *** Fake the tick rate! ***
+ * By setting the CLOCK_TICK_RATE to HZ, the kernel is built assuming that
+ * the clock is incremented once every 'tick'. We will have to configure the
+ * hardware (at run time) to make this true.
+ */
+#define CLOCK_TICK_RATE		(HZ)
+
+#endif /* __TIMEX_H__ */
+
diff --git a/arch/arm/mach-pc302/include/mach/uncompress.h b/arch/arm/mach-pc302/include/mach/uncompress.h
new file mode 100644
index 0000000..0c9ecff
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/uncompress.h
@@ -0,0 +1,60 @@
+/*
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <mach/hardware.h>
+#include <mach/pc302/uart.h>
+#include <linux/serial_reg.h>
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	volatile u32 * uart = (volatile u32 *)(PC302_UART1_BASE);
+
+	while (!(uart[UART_LSR] & UART_LSR_THRE))
+		barrier();
+	uart[UART_TX] = c & 0xFF;
+}
+
+static inline void flush(void)
+{
+}
+
+static inline void arch_decomp_setup(void)
+{
+        volatile u32 *uart = (volatile u32 *)(PC302_UART1_BASE);
+        /* Reset and enable the FIFO's. */
+        uart[UART_FCR] = 0x1;
+        /* Wait for the FIFO's to be enabled. */
+        while (!(uart[UART_FCR] & 0xc0))
+            continue;
+        /* Enable divisor access, set length to 8 bits. */
+        uart[UART_LCR] = 0x83;
+        /* Set for 115200 baud. */
+        uart[UART_DLL] = 0x2;
+        uart[UART_DLM] = 0x0;
+        uart[UART_LCR] = 0x3;
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_wdog()
diff --git a/arch/arm/mach-pc302/include/mach/vmalloc.h b/arch/arm/mach-pc302/include/mach/vmalloc.h
new file mode 100644
index 0000000..c17847b
--- /dev/null
+++ b/arch/arm/mach-pc302/include/mach/vmalloc.h
@@ -0,0 +1,21 @@
+/*
+ *  BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		(PAGE_OFFSET + 0x18000000)
+
diff --git a/arch/arm/mach-pc302/pc302_core.c b/arch/arm/mach-pc302/pc302_core.c
new file mode 100644
index 0000000..463ac5a
--- /dev/null
+++ b/arch/arm/mach-pc302/pc302_core.c
@@ -0,0 +1,711 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <mach/dma.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/div64.h>
+#include <linux/cnt32_to_63.h>
+#include <linux/mm.h>
+#include <linux/sched.h>	/* just for sched_clock() - funny that */
+#include <linux/bug.h>
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <mach/pc302/vic.h>
+#include <mach/pc302/axi2cfg.h>
+
+#include "core.h"
+
+/* Converts a physical address number into a pointer to the virtual location */
+#define _ioa(n)     __io(IO_ADDRESS(n))
+
+/** The system config register pointer (32 bit reg). */
+static void __iomem *syscfg_reg;
+
+/*!
+ * Initialise the AXI bus error handling
+ */
+static void
+pc302_axi_bus_error_init (void);
+
+/* INTERRUPTS:
+ */
+static void pc302_mask_irq(u32 irq)
+{
+    u32 base = irq >= 32 ? PC302_VIC0_BASE : PC302_VIC1_BASE;
+    u32 mask;
+
+    if (irq >= 32)
+        mask = (1 << (irq - 32));
+    else
+        mask = (1 << irq);
+
+    iowrite32(mask, _ioa(base + VIC_INT_ENABLE_CLEAR_REG_OFFSET));
+}
+
+static void pc302_unmask_irq(u32 irq)
+{
+    u32 mask;
+    u32 base = irq >= 32 ? PC302_VIC0_BASE : PC302_VIC1_BASE;
+
+    mask = ioread32(_ioa(base + VIC_INT_ENABLE_REG_OFFSET));
+
+    if (irq >= 32)
+        mask |= (1 << (irq - 32));
+    else
+        mask |= (1 << irq);
+
+    iowrite32(mask, _ioa(base + VIC_INT_ENABLE_REG_OFFSET));
+}
+
+static struct irq_chip pc302_vic0_chip = {
+    .ack    = pc302_mask_irq, /* Level triggering -> mask is ack */
+    .mask   = pc302_mask_irq,
+    .unmask = pc302_unmask_irq,
+};
+
+static struct irq_chip pc302_vic1_chip = {
+    .ack    = pc302_mask_irq, /* Level triggering -> mask is ack */
+    .mask   = pc302_mask_irq,
+    .unmask = pc302_unmask_irq,
+};
+
+void __init pc302_init_irq(void)
+{
+    unsigned int irq;
+
+    /* Disable all interrupts initially. */
+    iowrite32(0, _ioa(PC302_VIC0_BASE + VIC_INT_ENABLE_REG_OFFSET));
+    iowrite32(0, _ioa(PC302_VIC1_BASE + VIC_INT_ENABLE_REG_OFFSET));
+
+    /* Make sure that all interrupts are normal IRQs and not FIQs. */
+    iowrite32(0, _ioa(PC302_VIC0_BASE + VIC_INT_ENABLE_REG_OFFSET));
+    iowrite32(0, _ioa(PC302_VIC1_BASE + VIC_INT_ENABLE_REG_OFFSET));
+
+    /*
+     * Make sure we clear all existing interrupts...
+     * As interrupts are asserted by peripherals, individual driver code
+     * should ensure the interrupts are initially cleared.
+     */
+
+    /*
+     * Set up the interrupt helper functions for the interrupts
+     */
+    for (irq = 0; irq < 32; irq++) {
+        /* Skip interrupts that are unused */
+        if (VIC1_IRQ_USED_MASK & (1 << irq)) {
+            set_irq_chip(irq, &pc302_vic1_chip);
+            set_irq_handler(irq, handle_level_irq);
+            set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+        }
+    }
+
+    for (irq = 32; irq < 64; irq++) {
+        /* Skip interrupts that are unused */
+        if (VIC0_IRQ_USED_MASK & (u64)((u64)1LLU << irq)) {
+            set_irq_chip(irq, &pc302_vic0_chip);
+            set_irq_handler(irq, handle_level_irq);
+            set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+        }
+    }
+}
+
+/* IO MAPPING: we have most of the peripherals at 0x80000000, but the AXI2Pico
+ * buffers live at 0xC0000000. */
+static struct map_desc pc302_io_desc[] __initdata = {
+    {
+        .virtual    = IO_ADDRESS(AXI2PICO_BUFFERS_BASE),
+        .pfn        = __phys_to_pfn(AXI2PICO_BUFFERS_BASE),
+        .length     = AXI2PICO_BUFFERS_SIZE,
+        .type       = MT_DEVICE,
+    },
+    {
+        .virtual    =  IO_ADDRESS(PC302_PERIPH_BASE),
+        .pfn        = __phys_to_pfn(PC302_PERIPH_BASE),
+        .length     = PC302_PERIPH_LENGTH,
+        .type       = MT_DEVICE,
+    },
+};
+
+void __init pc302_map_io(void)
+{
+    iotable_init(pc302_io_desc, ARRAY_SIZE(pc302_io_desc));
+}
+
+/* UARTS */
+static struct plat_serial8250_port serial_platform_data[] = {
+    {
+        .membase    = (char*)IO_ADDRESS(PC302_UART1_BASE),
+        .mapbase    = (unsigned long)PC302_UART1_BASE,
+        .irq        = IRQ_UART1,
+        .flags      = UPF_BOOT_AUTOCONF,
+        .iotype     = UPIO_MEM32,
+        .regshift   = 2,
+        .uartclk    = PC302_BASE_BAUD,
+    },
+    {
+        .membase    = (char*)IO_ADDRESS(PC302_UART2_BASE),
+        .mapbase    = (unsigned long)PC302_UART2_BASE,
+        .irq        = IRQ_UART2,
+        .flags      = UPF_BOOT_AUTOCONF,
+        .iotype     = UPIO_MEM32,
+        .regshift   = 2,
+        .uartclk    = PC302_BASE_BAUD,
+    },
+    { },
+};
+
+static struct platform_device serial_device = {
+    .name           = "serial8250",
+    .id             = 0,
+    .dev            = {
+        .platform_data = serial_platform_data,
+    },
+};
+
+/* Watchdog */
+static void
+pc302wdt_platform_release( struct device *dev )
+{
+    /* This function is intentionally left blank. */
+}
+
+static struct resource pc302wdt_resources[] = {
+    {
+        .start = PC302_WDOG_BASE,
+        .end   = PC302_WDOG_BASE + 0xffff,
+        .flags = IORESOURCE_MEM,
+    },
+    {
+        .start = IRQ_WDG,
+        .end   = IRQ_WDG,
+        .flags = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device pc302wdt_device = {
+    .name = "pc302wdt",
+    .id = 0,
+    .dev = {
+        .coherent_dma_mask = 0xffffffff,
+        .release = pc302wdt_platform_release,
+    },
+    .num_resources = ARRAY_SIZE( pc302wdt_resources ),
+    .resource = pc302wdt_resources,
+};
+
+/* Fuses */
+static void
+pc302fuse_platform_release( struct device *dev )
+{
+    /* This function is intentionally left blank. */
+}
+
+static struct resource pc302fuse_resources[] = {
+    {
+        .start = PC302_FUSE_BASE,
+        .end   = PC302_FUSE_BASE + 0xFFFF,
+        .flags = IORESOURCE_MEM,
+    },
+};
+
+static struct platform_device pc302fuse_device = {
+    .name = "pc302-fuse",
+    .id = -1,
+    .dev = {
+        .release = pc302fuse_platform_release,
+    },
+    .resource = pc302fuse_resources,
+    .num_resources = ARRAY_SIZE( pc302fuse_resources ),
+};
+
+/* EMAC */
+static void
+pc302emac_platform_release(struct device *dev)
+{
+    /* This function is intentionally left blank. */
+}
+
+static struct resource pc302emac_resources[] =
+{
+    {
+        .start  = PC302_EMAC_BASE,
+        .end    = PC302_EMAC_BASE + 0xFFFF,
+        .flags  = IORESOURCE_MEM,
+    },
+    {
+        .start  = IRQ_EMAC,
+        .end    = IRQ_EMAC,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device pc302emac_device =
+{
+    .name = "pc302-emac",
+    .id = 0,
+    .dev =
+    {
+        .coherent_dma_mask = 0xffffffff,
+        .release = pc302emac_platform_release,
+    },
+    .num_resources = ARRAY_SIZE(pc302emac_resources),
+    .resource = pc302emac_resources,
+};
+
+/* GPIO */
+static void
+pc302gpio_platform_release( struct device *dev )
+{
+    /* This function is intentionally left blank. */
+}
+
+static struct resource pc302gpio_resources[] = {
+    {
+        .start = PC302_GPIO_BASE,
+        .end   = PC302_GPIO_BASE + 0xFFFF,
+        .flags = IORESOURCE_MEM,
+    },
+};
+
+static struct platform_device pc302gpio_device = {
+    .name = "pc302gpio",
+    .id = -1,
+    .dev = {
+        .release = pc302gpio_platform_release,
+    },
+    .resource = pc302gpio_resources,
+    .num_resources = ARRAY_SIZE( pc302gpio_resources ),
+};
+
+/* DMACs */
+static void
+pc302_dma_platform_release(struct device *dev)
+{
+    /* This function is intentionally left blank. */
+}
+
+static struct resource pc302dmac_resources0[] =
+{
+    {
+        .start  = PC302_DMAC1_BASE,
+        .end    = PC302_DMAC1_BASE + 0xFFFF,
+        .flags  = IORESOURCE_MEM,
+    },
+    {
+        .start  = IRQ_DMAC1,
+        .end    = IRQ_DMAC1,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct resource pc302dmac_resources1[] =
+{
+    {
+        .start  = PC302_DMAC2_BASE,
+        .end    = PC302_DMAC2_BASE + 0xFFFF,
+        .flags  = IORESOURCE_MEM,
+    },
+    {
+        .start  = IRQ_DMAC2,
+        .end    = IRQ_DMAC2,
+        .flags  = IORESOURCE_IRQ,
+    },
+};
+
+static struct platform_device dmac_device0 =
+{
+    .name       = "pc302-dmac",
+    .id         = 0,
+    .dev        =
+    {
+        .coherent_dma_mask = 0xffffffff,
+        .release = pc302_dma_platform_release,
+    },
+    .num_resources = ARRAY_SIZE(pc302dmac_resources0),
+    .resource = pc302dmac_resources0,
+};
+
+static struct platform_device dmac_device1 =
+{
+    .name       = "pc302-dmac",
+    .id         = 1,
+    .dev        =
+    {
+        .coherent_dma_mask = 0xffffffff,
+        .release = pc302_dma_platform_release,
+    },
+    .num_resources = ARRAY_SIZE(pc302dmac_resources1),
+    .resource = pc302dmac_resources1,
+};
+
+/* picoArray driver */
+struct resource pa0_resources[] = {
+    {
+        .start = AXI2PICO_BUFFERS_BASE,
+        .end = AXI2PICO_BUFFERS_BASE + (AXI2PICO_BUFFERS_SIZE-1),
+        .flags = IORESOURCE_MEM,
+        .name = "ahb2pico_axi2pico",
+    },
+    {
+        /* Take ownership of: Purge config port, DMAC config */
+        .start = PC302_AXI2CFG_BASE + AXI2CFG_PURGE_CFG_PORT_REG_OFFSET,
+        .end = PC302_AXI2CFG_BASE + AXI2CFG_DEVICE_ID_REG_OFFSET-1,
+        .flags = IORESOURCE_MEM,
+        .name = "procif",
+    },
+    {
+        /* Take ownership of: Config write and read ports */
+        .start = PC302_AXI2CFG_BASE +AXI2CFG_CONFIG_WRITE_REG_OFFSET,
+        .end = PC302_AXI2CFG_BASE +AXI2CFG_DMAC1_CONFIG_REG_OFFSET-1,
+        .flags = IORESOURCE_MEM,
+        .name = "procif2",
+    },
+    {
+        .start = IRQ_AXI2PICO8, /* Interrupt for GPRs */
+        .end = IRQ_AXI2PICO8,
+        .flags = IORESOURCE_IRQ,
+        .name = "gpr_irq",
+    },
+};
+
+static struct platform_device pa0 = {
+    .name           = "picoArray",
+    .id             = 0,
+    .dev            = {
+                .coherent_dma_mask = 0xffffffff,
+    },
+    .resource       = pa0_resources,
+    .num_resources  = ARRAY_SIZE(pa0_resources),
+};
+
+static struct resource ipsec_resources[] = {
+    {
+        .start  = PC302_IPSEC_BASE,
+        .end    = PC302_IPSEC_BASE + 0xFFFF,
+        .flags  = IORESOURCE_MEM,
+        .name   = "ipsec_engine",
+    },
+    {
+        .start  = IRQ_IPSEC,
+        .end    = IRQ_IPSEC,
+        .flags  = IORESOURCE_IRQ,
+        .name   = "ipsec_engine",
+    },
+};
+
+static struct platform_device ipsec_device = {
+    .dev            = {
+        .coherent_dma_mask = 0xFFFFFFFF,
+    },
+    .name           = "ipsec_engine",
+    .id             = -1,
+    .resource       = ipsec_resources,
+    .num_resources  = ARRAY_SIZE( ipsec_resources ),
+};
+
+static struct resource l2_resources[] = {
+    {
+        .start  = PC302_CIPHER_BASE,
+        .end    = PC302_CIPHER_BASE + 0xFFFF,
+        .flags  = IORESOURCE_MEM,
+        .name   = "l2_engine",
+    },
+    {
+        .start  = IRQ_AES,
+        .end    = IRQ_AES,
+        .flags  = IORESOURCE_IRQ,
+        .name   = "l2_engine",
+    },
+};
+
+static struct platform_device l2_device = {
+    .dev            = {
+        .coherent_dma_mask = 0xFFFFFFFF,
+    },
+    .name           = "l2_engine",
+    .id             = -1,
+    .resource       = l2_resources,
+    .num_resources  = ARRAY_SIZE( l2_resources ),
+};
+
+/* SPI Master */
+static struct resource spi_resources[] = {
+    {
+        .start  = PC302_SSI_BASE,
+        .end    = PC302_SSI_BASE + 0xFFFF,
+        .flags  = IORESOURCE_MEM,
+    },
+};
+
+static struct platform_device spi_device = {
+    .dev            = {
+        .coherent_dma_mask = 0xFFFFFFFF,
+    },
+    .name           = "pc302-spi",
+    .id             = 0,
+    .resource       = spi_resources,
+    .num_resources  = ARRAY_SIZE( spi_resources ),
+};
+
+/* AXI2CFG System Configuration Register */
+static void __init
+map_syscfg(void)
+{
+    syscfg_reg = ioremap(PC302_AXI2CFG_BASE + AXI2CFG_SYS_CONFIG_REG_OFFSET,
+                         sizeof(u32));
+}
+
+u32
+syscfg_read(void)
+{
+    BUG_ON(!syscfg_reg);
+    return ioread32(syscfg_reg);
+}
+EXPORT_SYMBOL(syscfg_read);
+
+void
+syscfg_update(u32 mask,
+              u32 val)
+{
+    u32 tmp = syscfg_read();
+    tmp &= ~mask;
+    tmp |= (val & mask);
+    iowrite32(tmp, syscfg_reg);
+}
+EXPORT_SYMBOL(syscfg_update);
+
+void __init pc302_core_init(void)
+{
+    platform_device_register(&serial_device);
+    platform_device_register(&pc302wdt_device);
+    platform_device_register(&pc302fuse_device);
+    platform_device_register(&pc302emac_device);
+    platform_device_register(&pc302gpio_device);
+    platform_device_register(&dmac_device0);
+    platform_device_register(&dmac_device1);
+    platform_device_register(&pa0);
+    platform_device_register(&ipsec_device);
+    platform_device_register(&l2_device);
+    platform_device_register(&spi_device);
+
+    map_syscfg();
+    pc302_axi_bus_error_init();
+}
+
+/* TIMERS */
+
+/* clock_tick_rate is the tick rate set at runtime. RT_LATCH is the derived
+ * timer reload latch value. */
+static unsigned long clock_tick_rate = PC302_TIMER_FREQ;
+#define RT_LATCH() ((clock_tick_rate + HZ/2) / HZ)
+
+/* Use timer 0 for the linux tick */
+#define TICK_TIMER 0
+#define TICK_TIMER_IRQ IRQ_TIMER0
+
+static void
+timer_set_mode(enum clock_event_mode mode,
+        struct clock_event_device *clk)
+{
+    switch (mode) {
+        case CLOCK_EVT_MODE_PERIODIC:
+            iowrite32(RT_LATCH(), _ioa(PC302_TIMER_BASE +
+                        TIMERNLOADCOUNTREGOFFSET(0)));
+            iowrite32(TIMERENABLE | TIMERMODE,
+                    _ioa(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(0)));
+            break;
+        case CLOCK_EVT_MODE_UNUSED:
+        case CLOCK_EVT_MODE_SHUTDOWN:
+        default:
+            break;
+            iowrite32(0,
+                    _ioa(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(0)));
+    }
+}
+
+static int
+timer_set_next_event(unsigned long evt,
+		     struct clock_event_device *unused)
+{
+    /* Disable the timer. */
+    iowrite32(0, _ioa(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(0)));
+    /* Write the new event. */
+    iowrite32(evt, _ioa(PC302_TIMER_BASE + TIMERNLOADCOUNTREGOFFSET(0)));
+    /* Re-enable the timer. */
+    iowrite32(TIMERENABLE | TIMERMODE,
+            _ioa(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(0)));
+
+    return 0;
+}
+
+static struct clock_event_device timer0_clockevent = {
+    .name		= "timer0",
+    .shift	    	= 20,
+    .features   	= CLOCK_EVT_FEAT_PERIODIC,
+    .set_mode   	= timer_set_mode,
+    .set_next_event	= timer_set_next_event,
+};
+
+/* IRQ handler for the timer. */
+static irqreturn_t
+pc302_timer_interrupt(int irq,
+                      void *dev_id)
+{
+    struct clock_event_device *evt = &timer0_clockevent;
+
+    /* Clear the interrupt. */
+    ioread32(_ioa(PC302_TIMER_BASE + TIMERNEOIREGOFFSET(TICK_TIMER)));
+
+    evt->event_handler(evt);
+
+    return IRQ_HANDLED;
+}
+
+static struct irqaction pc302_timer_irq = {
+    .name       = "pc302 Timer Tick",
+    .flags      = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+    .handler    = pc302_timer_interrupt,
+};
+
+static cycle_t
+pc302_rtc_get_cycles(void)
+{
+    return ioread32(_ioa(PC302_RTCLK_BASE + RTCLK_CCV_REG_OFFSET));
+}
+
+static struct clocksource clocksource_pc302 = {
+    .name       = "rtc",
+    .rating     = 300,
+    .read       = pc302_rtc_get_cycles,
+    .mask       = CLOCKSOURCE_MASK(32),
+    .shift      = 2,
+    .flags      = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+#define PC302_RTC_FREQ PC302_TIMER_FREQ
+
+static void __init
+pc302_clocksource_init(void)
+{
+    /* The RTC is always running. We don't need to do any initialization. */
+    clocksource_pc302.mult =
+        clocksource_hz2mult(PC302_RTC_FREQ, clocksource_pc302.shift);
+    clocksource_register(&clocksource_pc302);
+}
+
+/* Set up the timer and interrupt.  */
+static void __init
+pc302_timer_init(void)
+{
+    iowrite32(0, _ioa(PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(0)));
+    /* Make irqs happen for the system timer */
+    setup_irq(TICK_TIMER_IRQ, &pc302_timer_irq);
+    timer0_clockevent.mult =
+        div_sc(clock_tick_rate, NSEC_PER_SEC, timer0_clockevent.shift);
+    timer0_clockevent.max_delta_ns =
+        clockevent_delta2ns(0xffffffff, &timer0_clockevent);
+    timer0_clockevent.min_delta_ns =
+        clockevent_delta2ns(0x1, &timer0_clockevent);
+    timer0_clockevent.cpumask = cpumask_of_cpu(0);
+    clockevents_register_device(&timer0_clockevent);
+    pc302_clocksource_init();
+}
+
+struct sys_timer pc302_timer = {
+    .init	= pc302_timer_init,
+};
+
+/* AXI Bus Read / Write Error Handling */
+
+/* AXI Bus read errors */
+static irqreturn_t pc302_axi_bus_read_error_interrupt(int irq, void *dev_id)
+{
+    /* If we ever get one of these interrupts
+       then we are in big trouble, they should never happen.
+       The error condition is non recoverable. */
+
+    u32 axi_read_error =
+    ioread32(_ioa(PC302_AXI2CFG_BASE + AXI2CFG_AXI_ERR_STATE_REG_OFFSET));
+
+    axi_read_error &= AXI2CFG_AXI_RD_ERR_MASK;
+
+    printk (KERN_ERR "AXI Bus Read Error 0x%08x has happened.\n", axi_read_error);
+
+    /* There is no way back, therefore...*/
+    BUG();
+
+     /* Should never get here ! */
+    return IRQ_HANDLED;
+}
+
+static struct irqaction pc302_axi_read_error_irq = {
+    .name       = "pc302 Axi Bus Read Error",
+    .flags      = IRQF_DISABLED,
+    .handler    = pc302_axi_bus_read_error_interrupt,
+};
+
+/* AXI Bus write errors */
+static irqreturn_t pc302_axi_bus_write_error_interrupt(int irq, void *dev_id)
+{
+    /* If we ever get one of these interrupts
+       then we are in big trouble, they should never happen.
+       The error condition is non recoverable. */
+
+    u32 axi_write_error =
+    ioread32(_ioa(PC302_AXI2CFG_BASE + AXI2CFG_AXI_ERR_STATE_REG_OFFSET));
+
+    axi_write_error &= AXI2CFG_AXI_WR_ERR_MASK;
+
+    printk (KERN_ERR "AXI Bus Write Error 0x%08x has happened.\n", axi_write_error);
+
+    /* There is no way back, therefore...*/
+    BUG();
+
+    /* Should never get here ! */
+    return IRQ_HANDLED;
+}
+
+static struct irqaction pc302_axi_write_error_irq = {
+    .name       = "pc302 Axi Bus Write Error",
+    .flags      = IRQF_DISABLED,
+    .handler    = pc302_axi_bus_write_error_interrupt,
+};
+
+/* Initialise AXI Bus error handling */
+static void
+pc302_axi_bus_error_init (void)
+{
+    /* Setup the irq handler for AXI read errors */
+    setup_irq(IRQ_AXI_RD_ERR, &pc302_axi_read_error_irq);
+
+    /* Setup the irq handler for AXI write errors */
+    setup_irq(IRQ_AXI_WR_ERR, &pc302_axi_write_error_irq);
+
+    /* Make sure no AXI errors are masked */
+    iowrite32(AXI2CFG_AXI_ERR_MASK_NONE,
+            _ioa(PC302_AXI2CFG_BASE + AXI2CFG_AXI_ERR_MASK_REG_OFFSET));
+
+    /* Enable interrupts for all AXI Read & Write errors */
+    iowrite32(AXI2CFG_AXI_ERR_ENABLE_ALL,
+            _ioa(PC302_AXI2CFG_BASE + AXI2CFG_AXI_ERR_ENABLE_REG_OFFSET));
+}
diff --git a/arch/arm/mach-pc302/pc302_cpe.c b/arch/arm/mach-pc302/pc302_cpe.c
new file mode 100644
index 0000000..1cc1cad
--- /dev/null
+++ b/arch/arm/mach-pc302/pc302_cpe.c
@@ -0,0 +1,93 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ *  linux/arch/arm/mach-pc302/pc302_cpe.c
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/amba/bus.h>
+#include <linux/picochip/fpga_cpe20x.h>
+#include <linux/mtd/physmap.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+
+#include "core.h"
+
+/* PC7302 platforms have had a variety of different SPI Flash devices fitted.
+ *
+ * Spansion S25FL128P (128 Mbit) devices
+ * Numonyx M25P05 (512 Kbit) devices
+ *
+ * This setup should be fine for all of them with the proviso that the
+ * partition called "SPI: Data" may not actually be available for use.
+ *
+ * Note: When this BSP is ported to other hardware platforms this structure
+ *       will need to be modified appropriately.
+ */
+static struct mtd_partition pc7302_spi_flash_partitions[] = {
+    {
+        .name   = "SPI: First Stage Boot Loader",
+        .offset = 0,
+        .size   = SZ_64K,
+    },
+    {
+        .name   = "SPI: Data",
+        .offset = MTDPART_OFS_APPEND,
+        .size   = MTDPART_SIZ_FULL,
+    },
+};
+
+static struct flash_platform_data pc7302_spi_flash_data = {
+
+    .name       = "pc7302 spi flash",
+    .parts      = pc7302_spi_flash_partitions,
+    .nr_parts   = ARRAY_SIZE(pc7302_spi_flash_partitions),
+};
+
+static struct spi_board_info pc7302_spi_board_info[] __initdata = {
+    {
+	.modalias	= "m25p80",
+	.platform_data  = &pc7302_spi_flash_data,
+        .mode           = SPI_MODE_3,
+        .max_speed_hz	= 2000000,
+        .chip_select	= 0,
+    }
+};
+
+static int __init pc7302_init(void)
+{
+    spi_register_board_info(pc7302_spi_board_info,
+                            ARRAY_SIZE(pc7302_spi_board_info));
+    return 0;
+}
+arch_initcall(pc7302_init);
+
+MACHINE_START(PC7302, "PC7302")
+    /* Maintainer: picoChip */
+    .phys_io        = 0x80000000,
+    .io_pg_offst    = (IO_ADDRESS(0x80000000) >> 18) & 0xfffc,
+    .boot_params    = 0x00000100,
+    .map_io         = pc302_map_io,
+    .init_irq       = pc302_init_irq,
+    .timer          = &pc302_timer,
+    .init_machine   = pc302_core_init,
+MACHINE_END
diff --git a/arch/arm/mach-pc302/pc302_reset.c b/arch/arm/mach-pc302/pc302_reset.c
new file mode 100644
index 0000000..3f9e9ab
--- /dev/null
+++ b/arch/arm/mach-pc302/pc302_reset.c
@@ -0,0 +1,83 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * linux/arch/arm/mach-pc302/pc302.c
+ *
+ * Copyright (c) 2007 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#include <linux/semaphore.h>
+#include <linux/module.h>
+#include <mach/reset.h>
+
+static void *external_reset_cookie = NULL;
+static reset_t external_reset_fn = NULL;
+static DECLARE_MUTEX(reg_lock);
+
+/* pc302_reset is called from the kernel when it wishes to reset.
+ * This function will initiate a reset if an external reset handler
+ * has been registered. Typically, the CPE20X FPGA driver registers a reset
+ * handler as it is able to perform hardware resets of the board
+ */
+void pc302_reset(char mode)
+{
+    if (!down_interruptible(&reg_lock)) {
+        if (external_reset_fn != NULL) {
+            external_reset_fn(mode, external_reset_cookie);
+        }
+        else {
+            printk(KERN_WARNING "No reset handler installed. Entering infinite loop\n");
+        }
+        up(&reg_lock);
+    }
+}
+
+/* register_reset_handler is used by drivers that want to advertise 
+ * their ability to hard reset the kernel.
+ * This is first-come-first-served. The first driver to register
+ * the reset handler is the one that will actually be used when
+ * a reset is requested.
+ * Subsequent registrations are ignored.
+ * The reset param is a finction pointer. See reset_t.
+ * The cookie is passed to the reset function when called.
+ */
+void register_reset_handler(reset_t reset, void *cookie)
+{
+    if (!down_interruptible(&reg_lock)) {
+        if (external_reset_fn == NULL) {
+            external_reset_fn = reset;
+            external_reset_cookie = cookie;
+        }
+        up(&reg_lock);
+    }
+}
+
+/* deregister_reset_handler tells the kernel that the reset handler
+ * has disappeared and it can no longer be used. The same parameters
+ * as the register_reset_handler need to be passed.
+ * If the handler was not the first to register and therefore was ignored,
+ * it will not be de registered either.
+ */
+void deregister_reset_handler(reset_t reset, void *cookie)
+{
+    if (!down_interruptible(&reg_lock)) {
+        if (external_reset_fn == reset && external_reset_cookie == cookie) {
+            external_reset_fn = NULL;
+            external_reset_cookie = NULL;
+        }
+        up(&reg_lock);
+    }
+}
+
+EXPORT_SYMBOL(pc302_reset);
+EXPORT_SYMBOL(register_reset_handler);
+EXPORT_SYMBOL(deregister_reset_handler);
+
diff --git a/arch/arm/mach-realview/Kconfig b/arch/arm/mach-realview/Kconfig
index 5ccde7c..3b5f6c7 100644
--- a/arch/arm/mach-realview/Kconfig
+++ b/arch/arm/mach-realview/Kconfig
@@ -7,6 +7,13 @@ config MACH_REALVIEW_EB
 	help
 	  Include support for the ARM(R) RealView Emulation Baseboard platform.
 
+config REALVIEW_EB_A9MP
+	bool "Support Multicore Cortex-A9"
+	depends on MACH_REALVIEW_EB
+	select CPU_V7
+	help
+	  Enable support for the Cortex-A9MPCore tile on the Realview platform.
+
 config REALVIEW_EB_ARM11MP
 	bool "Support ARM11MPCore tile"
 	depends on MACH_REALVIEW_EB
@@ -26,6 +33,7 @@ config REALVIEW_EB_ARM11MP_REVB
 config MACH_REALVIEW_PB11MP
 	bool "Support RealView/PB11MPCore platform"
 	select ARM_GIC
+	select HAVE_PATA_PLATFORM
 	help
 	  Include support for the ARM(R) RealView MPCore Platform Baseboard.
 	  PB11MPCore is a platform with an on-board ARM11MPCore and has
@@ -37,4 +45,61 @@ config MACH_REALVIEW_PB1176
 	help
 	  Include support for the ARM(R) RealView ARM1176 Platform Baseboard.
 
+config REALVIEW_PB1176_SECURE_FLASH
+	bool "Allow access to the secure flash memory block"
+	depends on MACH_REALVIEW_PB1176
+	default n
+	help
+	  Select this option if Linux will only run in secure mode on the
+	  RealView PB1176 platform and access to the secure flash memory
+	  block (64MB @ 0x3c000000) is required.
+
+config MACH_REALVIEW_PBA8
+	bool "Support RealView/PB-A8 platform"
+	select ARM_GIC
+	select HAVE_PATA_PLATFORM
+	help
+	  Include support for the ARM(R) RealView Cortex-A8 Platform Baseboard.
+	  PB-A8 is a platform with an on-board Cortex-A8 and has support for
+	  PCI-E and Compact Flash.
+
+config MACH_REALVIEW_PBX
+	bool "Support RealView/PBX platform"
+	select ARM_GIC
+	select HAVE_PATA_PLATFORM
+	select ARCH_SPARSEMEM_ENABLE if REALVIEW_HIGH_PHYS_OFFSET
+	select ZONE_DMA if SPARSEMEM
+	help
+	  Include support for the ARM(R) RealView PBX platform.
+
+config REALVIEW_HIGH_PHYS_OFFSET
+	bool "High physical base address for the RealView platform"
+	depends on MMU && !MACH_REALVIEW_PB1176
+	default y
+	help
+	  RealView boards other than PB1176 have the RAM available at
+	  0x70000000, 256MB of which being mirrored at 0x00000000. If
+	  the board supports 512MB of RAM, this option allows the
+	  memory to be accessed contiguously at the high physical
+	  offset.
+
+config ARCH_FLATMEM_ENABLE
+	bool
+	default y if ARCH_SPARSEMEM_ENABLE
+
+config ZONE_DMA_IDX
+	int
+	default 1
+	depends on MACH_REALVIEW_PBX && ZONE_DMA
+
+config ZONE_NORMAL_IDX
+	int
+	default 0
+	depends on MACH_REALVIEW_PBX && ZONE_DMA
+
+config ZONE_MOVABLE_IDX
+	int
+	default 2
+	depends on MACH_REALVIEW_PBX && ZONE_DMA
+
 endmenu
diff --git a/arch/arm/mach-realview/Makefile b/arch/arm/mach-realview/Makefile
index d2ae077..9c5ef5f 100644
--- a/arch/arm/mach-realview/Makefile
+++ b/arch/arm/mach-realview/Makefile
@@ -6,5 +6,8 @@ obj-y					:= core.o clock.o
 obj-$(CONFIG_MACH_REALVIEW_EB)		+= realview_eb.o
 obj-$(CONFIG_MACH_REALVIEW_PB11MP)	+= realview_pb11mp.o
 obj-$(CONFIG_MACH_REALVIEW_PB1176)	+= realview_pb1176.o
+obj-$(CONFIG_MACH_REALVIEW_PBA8)	+= realview_pba8.o
+obj-$(CONFIG_MACH_REALVIEW_PBX)		+= realview_pbx.o
 obj-$(CONFIG_SMP)			+= platsmp.o headsmp.o localtimer.o
 obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
+obj-$(CONFIG_CPU_FREQ_REALVIEW)		+= iec.o
diff --git a/arch/arm/mach-realview/Makefile.boot b/arch/arm/mach-realview/Makefile.boot
index c7e75ac..d97e003 100644
--- a/arch/arm/mach-realview/Makefile.boot
+++ b/arch/arm/mach-realview/Makefile.boot
@@ -1,4 +1,9 @@
+ifeq ($(CONFIG_REALVIEW_HIGH_PHYS_OFFSET),y)
+   zreladdr-y	:= 0x70008000
+params_phys-y	:= 0x70000100
+initrd_phys-y	:= 0x70800000
+else
    zreladdr-y	:= 0x00008000
 params_phys-y	:= 0x00000100
 initrd_phys-y	:= 0x00800000
-
+endif
diff --git a/arch/arm/mach-realview/core.c b/arch/arm/mach-realview/core.c
index 2f04d54..1206bae 100644
--- a/arch/arm/mach-realview/core.c
+++ b/arch/arm/mach-realview/core.c
@@ -28,11 +28,15 @@
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
 #include <linux/io.h>
+#include <linux/smc911x.h>
+#include <linux/ata_platform.h>
+#include <linux/delay.h>
 
 #include <asm/system.h>
 #include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/leds.h>
+#include <asm/mach-types.h>
 #include <asm/hardware/arm_timer.h>
 #include <asm/hardware/icst307.h>
 
@@ -49,9 +53,30 @@
 
 #define REALVIEW_REFCOUNTER	(__io_address(REALVIEW_SYS_BASE) + REALVIEW_SYS_24MHz_OFFSET)
 
-/* used by entry-macro.S */
+/* used by entry-macro.S and platsmp.c */
 void __iomem *gic_cpu_base_addr;
 
+#ifdef CONFIG_ZONE_DMA
+/*
+ * Adjust the zones if there are restrictions for DMA access.
+ */
+void __init realview_adjust_zones(int node, unsigned long *size,
+				  unsigned long *hole)
+{
+	if (machine_is_realview_pbx()) {
+		/*
+		 * Allow at least 16MB for ZONE_NORMAL. Note that ZONE_DMA is
+		 * after ZONE_NORMAL in this configuration.
+		 */
+		unsigned long dma_size = min(UL(SZ_512M) >> PAGE_SHIFT,
+					     size[0] - hole[0] -
+					     (UL(SZ_16M) >> PAGE_SHIFT));
+		size[ZONE_NORMAL] -= dma_size;
+		size[ZONE_DMA] = dma_size;
+	}
+}
+#endif
+
 /*
  * This is the RealView sched_clock implementation.  This has
  * a resolution of 41.7ns, and a maximum value of about 179s.
@@ -124,6 +149,67 @@ int realview_flash_register(struct resource *res, u32 num)
 	return platform_device_register(&realview_flash_device);
 }
 
+static struct smc911x_platdata realview_smc911x_platdata = {
+	.flags		= SMC911X_USE_32BIT,
+	.irq_flags	= IRQF_SHARED,
+	.irq_polarity	= 1,
+};
+
+static struct platform_device realview_eth_device = {
+	.name		= "smc911x",
+	.id		= 0,
+	.num_resources	= 2,
+};
+
+int realview_eth_register(const char *name, struct resource *res)
+{
+	if (name)
+		realview_eth_device.name = name;
+	realview_eth_device.resource = res;
+	if (strcmp(realview_eth_device.name, "smc911x") == 0)
+		realview_eth_device.dev.platform_data = &realview_smc911x_platdata;
+
+	return platform_device_register(&realview_eth_device);
+}
+
+struct platform_device realview_usb_device = {
+	.name			= "isp1760",
+	.num_resources		= 2,
+};
+
+int realview_usb_register(struct resource *res)
+{
+	realview_usb_device.resource = res;
+	return platform_device_register(&realview_usb_device);
+}
+
+static struct pata_platform_info pata_platform_data = {
+	.ioport_shift		= 1,
+};
+
+static struct resource pata_resources[] = {
+	[0] = {
+		.start		= REALVIEW_CF_BASE,
+		.end		= REALVIEW_CF_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= REALVIEW_CF_BASE + 0x100,
+		.end		= REALVIEW_CF_BASE + SZ_4K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+struct platform_device realview_cf_device = {
+	.name			= "pata_platform",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(pata_resources),
+	.resource		= pata_resources,
+	.dev			= {
+		.platform_data	= &pata_platform_data,
+	},
+};
+
 static struct resource realview_i2c_resource = {
 	.start		= REALVIEW_I2C_BASE,
 	.end		= REALVIEW_I2C_BASE + SZ_4K - 1,
@@ -132,24 +218,48 @@ static struct resource realview_i2c_resource = {
 
 struct platform_device realview_i2c_device = {
 	.name		= "versatile-i2c",
-	.id		= -1,
+	.id		= 0,
 	.num_resources	= 1,
 	.resource	= &realview_i2c_resource,
 };
 
-#define REALVIEW_SYSMCI	(__io_address(REALVIEW_SYS_BASE) + REALVIEW_SYS_MCI_OFFSET)
+static struct i2c_board_info realview_i2c_board_info[] = {
+	{
+		I2C_BOARD_INFO("rtc-ds1307", 0xd0 >> 1),
+		.type = "ds1338",
+	},
+};
+
+static int __init realview_i2c_init(void)
+{
+	return i2c_register_board_info(0, realview_i2c_board_info,
+				       ARRAY_SIZE(realview_i2c_board_info));
+}
+arch_initcall(realview_i2c_init);
 
+/*
+ * All boards except RealView/PB1176 use MCI for the MMC/SD card detect.
+ * PB1176 has to use GPIO.
+ */
 static unsigned int realview_mmc_status(struct device *dev)
 {
 	struct amba_device *adev = container_of(dev, struct amba_device, dev);
 	u32 mask;
+	void __iomem *mmc_detect;
 
-	if (adev->res.start == REALVIEW_MMCI0_BASE)
+	if (machine_is_realview_pb1176()) {
+		mmc_detect = __io_address(REALVIEW_GPIO2_BASE + 0x04);
 		mask = 1;
-	else
-		mask = 2;
+	} else {
+		mmc_detect =__io_address(REALVIEW_SYS_BASE) +
+			REALVIEW_SYS_MCI_OFFSET;
+		if (adev->res.start == REALVIEW_MMCI0_BASE)
+			mask = 1;
+		else
+			mask = 2;
+	}
 
-	return readl(REALVIEW_SYSMCI) & mask;
+	return readl(mmc_detect) & mask;
 }
 
 struct mmc_platform_data realview_mmc0_plat_data = {
@@ -177,9 +287,14 @@ static const struct icst307_params realview_oscvco_params = {
 static void realview_oscvco_set(struct clk *clk, struct icst307_vco vco)
 {
 	void __iomem *sys_lock = __io_address(REALVIEW_SYS_BASE) + REALVIEW_SYS_LOCK_OFFSET;
-	void __iomem *sys_osc = __io_address(REALVIEW_SYS_BASE) + REALVIEW_SYS_OSC4_OFFSET;
+	void __iomem *sys_osc;
 	u32 val;
 
+	if (machine_is_realview_pb1176())
+		sys_osc = __io_address(REALVIEW_SYS_BASE) + REALVIEW_SYS_OSC0_OFFSET;
+	else
+		sys_osc = __io_address(REALVIEW_SYS_BASE) + REALVIEW_SYS_OSC4_OFFSET;
+
 	val = readl(sys_osc) & ~0x7ffff;
 	val |= vco.v | (vco.r << 9) | (vco.s << 16);
 
@@ -214,19 +329,42 @@ static struct clcd_panel vga = {
 		.xres		= 640,
 		.yres		= 480,
 		.pixclock	= 39721,
-		.left_margin	= 40,
-		.right_margin	= 24,
-		.upper_margin	= 32,
-		.lower_margin	= 11,
-		.hsync_len	= 96,
-		.vsync_len	= 2,
+		.left_margin	= 64,
+		.right_margin	= 16,
+		.upper_margin	= 13,
+		.lower_margin	= 3,
+		.hsync_len	= 80,
+		.vsync_len	= 4,
 		.sync		= 0,
 		.vmode		= FB_VMODE_NONINTERLACED,
 	},
 	.width		= -1,
 	.height		= -1,
 	.tim2		= TIM2_BCD | TIM2_IPC,
-	.cntl		= CNTL_LCDTFT | CNTL_LCDVCOMP(1),
+	.cntl		= CNTL_LCDTFT | CNTL_BGR | CNTL_LCDVCOMP(1),
+	.bpp		= 16,
+};
+
+static struct clcd_panel xvga = {
+	.mode		= {
+		.name		= "XVGA",
+		.refresh	= 60,
+		.xres		= 1024,
+		.yres		= 768,
+		.pixclock	= 15748,
+		.left_margin	= 152,
+		.right_margin	= 48,
+		.upper_margin	= 23,
+		.lower_margin	= 3,
+		.hsync_len	= 104,
+		.vsync_len	= 4,
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+	.width		= -1,
+	.height		= -1,
+	.tim2		= TIM2_BCD | TIM2_IPC,
+	.cntl		= CNTL_LCDTFT | CNTL_BGR | CNTL_LCDVCOMP(1),
 	.bpp		= 16,
 };
 
@@ -249,7 +387,7 @@ static struct clcd_panel sanyo_3_8_in = {
 	.width		= -1,
 	.height		= -1,
 	.tim2		= TIM2_BCD,
-	.cntl		= CNTL_LCDTFT | CNTL_LCDVCOMP(1),
+	.cntl		= CNTL_LCDTFT | CNTL_BGR | CNTL_LCDVCOMP(1),
 	.bpp		= 16,
 };
 
@@ -272,7 +410,7 @@ static struct clcd_panel sanyo_2_5_in = {
 	.width		= -1,
 	.height		= -1,
 	.tim2		= TIM2_IVS | TIM2_IHS | TIM2_IPC,
-	.cntl		= CNTL_LCDTFT | CNTL_LCDVCOMP(1),
+	.cntl		= CNTL_LCDTFT | CNTL_BGR | CNTL_LCDVCOMP(1),
 	.bpp		= 16,
 };
 
@@ -295,7 +433,7 @@ static struct clcd_panel epson_2_2_in = {
 	.width		= -1,
 	.height		= -1,
 	.tim2		= TIM2_BCD | TIM2_IPC,
-	.cntl		= CNTL_LCDTFT | CNTL_LCDVCOMP(1),
+	.cntl		= CNTL_LCDTFT | CNTL_BGR | CNTL_LCDVCOMP(1),
 	.bpp		= 16,
 };
 
@@ -308,9 +446,15 @@ static struct clcd_panel epson_2_2_in = {
 static struct clcd_panel *realview_clcd_panel(void)
 {
 	void __iomem *sys_clcd = __io_address(REALVIEW_SYS_BASE) + REALVIEW_SYS_CLCD_OFFSET;
-	struct clcd_panel *panel = &vga;
+	struct clcd_panel *vga_panel;
+	struct clcd_panel *panel;
 	u32 val;
 
+	if (machine_is_realview_eb())
+		vga_panel = &vga;
+	else
+		vga_panel = &xvga;
+
 	val = readl(sys_clcd) & SYS_CLCD_ID_MASK;
 	if (val == SYS_CLCD_ID_SANYO_3_8)
 		panel = &sanyo_3_8_in;
@@ -319,11 +463,11 @@ static struct clcd_panel *realview_clcd_panel(void)
 	else if (val == SYS_CLCD_ID_EPSON_2_2)
 		panel = &epson_2_2_in;
 	else if (val == SYS_CLCD_ID_VGA)
-		panel = &vga;
+		panel = vga_panel;
 	else {
 		printk(KERN_ERR "CLCD: unknown LCD panel ID 0x%08x, using VGA\n",
 			val);
-		panel = &vga;
+		panel = vga_panel;
 	}
 
 	return panel;
@@ -358,16 +502,26 @@ static void realview_clcd_enable(struct clcd_fb *fb)
 	writel(val, sys_clcd);
 }
 
-static unsigned long framesize = SZ_1M;
-
 static int realview_clcd_setup(struct clcd_fb *fb)
 {
+	unsigned long framesize;
 	dma_addr_t dma;
 
+	if (machine_is_realview_pb1176())
+		/* delay required on PB1176 */
+		mdelay(100);
+
+	if (machine_is_realview_eb())
+		/* VGA, 16bpp */
+		framesize = 640 * 480 * 2;
+	else
+		/* XVGA, 16bpp */
+		framesize = 1024 * 768 * 2;
+
 	fb->panel		= realview_clcd_panel();
 
 	fb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev, framesize,
-						    &dma, GFP_KERNEL);
+						    &dma, GFP_KERNEL | GFP_DMA);
 	if (!fb->fb.screen_base) {
 		printk(KERN_ERR "CLCD: unable to map framebuffer\n");
 		return -ENOMEM;
@@ -411,21 +565,22 @@ void realview_leds_event(led_event_t ledevt)
 {
 	unsigned long flags;
 	u32 val;
+	u32 led = 1 << smp_processor_id();
 
 	local_irq_save(flags);
 	val = readl(VA_LEDS_BASE);
 
 	switch (ledevt) {
 	case led_idle_start:
-		val = val & ~REALVIEW_SYS_LED0;
+		val = val & ~led;
 		break;
 
 	case led_idle_end:
-		val = val | REALVIEW_SYS_LED0;
+		val = val | led;
 		break;
 
 	case led_timer:
-		val = val ^ REALVIEW_SYS_LED1;
+		val = val ^ REALVIEW_SYS_LED7;
 		break;
 
 	case led_halted:
@@ -588,7 +743,7 @@ void __init realview_timer_init(unsigned int timer_irq)
 	 * The dummy clock device has to be registered before the main device
 	 * so that the latter will broadcast the clock events
 	 */
-	local_timer_setup(smp_processor_id());
+	local_timer_setup();
 #endif
 
 	/* 
diff --git a/arch/arm/mach-realview/core.h b/arch/arm/mach-realview/core.h
index 3cea92c..59d4fee 100644
--- a/arch/arm/mach-realview/core.h
+++ b/arch/arm/mach-realview/core.h
@@ -45,6 +45,7 @@ static struct amba_device name##_device = {			\
 }
 
 extern struct platform_device realview_flash_device;
+extern struct platform_device realview_cf_device;
 extern struct platform_device realview_i2c_device;
 extern struct mmc_platform_data realview_mmc0_plat_data;
 extern struct mmc_platform_data realview_mmc1_plat_data;
@@ -52,8 +53,7 @@ extern struct clk realview_clcd_clk;
 extern struct clcd_board clcd_plat_data;
 extern void __iomem *gic_cpu_base_addr;
 #ifdef CONFIG_LOCAL_TIMERS
-extern void __iomem *twd_base_addr;
-extern unsigned int twd_size;
+extern void __iomem *twd_base;
 #endif
 extern void __iomem *timer0_va_base;
 extern void __iomem *timer1_va_base;
@@ -63,5 +63,7 @@ extern void __iomem *timer3_va_base;
 extern void realview_leds_event(led_event_t ledevt);
 extern void realview_timer_init(unsigned int timer_irq);
 extern int realview_flash_register(struct resource *res, u32 num);
+extern int realview_eth_register(const char *name, struct resource *res);
+extern int realview_usb_register(struct resource *res);
 
 #endif
diff --git a/arch/arm/mach-realview/hotplug.c b/arch/arm/mach-realview/hotplug.c
index 09748cb..be048e3 100644
--- a/arch/arm/mach-realview/hotplug.c
+++ b/arch/arm/mach-realview/hotplug.c
@@ -13,6 +13,8 @@
 #include <linux/smp.h>
 #include <linux/completion.h>
 
+#include <asm/cacheflush.h>
+
 extern volatile int pen_release;
 
 static DECLARE_COMPLETION(cpu_killed);
@@ -21,7 +23,8 @@ static inline void cpu_enter_lowpower(void)
 {
 	unsigned int v;
 
-	asm volatile(	"mcr	p15, 0, %1, c7, c14, 0\n"
+	flush_cache_all();
+	asm volatile(
 	"	mcr	p15, 0, %1, c7, c5, 0\n"
 	"	mcr	p15, 0, %1, c7, c10, 4\n"
 	/*
diff --git a/arch/arm/mach-realview/iec.c b/arch/arm/mach-realview/iec.c
new file mode 100644
index 0000000..a452567
--- /dev/null
+++ b/arch/arm/mach-realview/iec.c
@@ -0,0 +1,285 @@
+/*
+ * arch/arm/mach-realview/iec.c
+ *
+ * Copyright (C) 2009 ARM Limited
+ * Written by Turhan Oz <turhan.oz@gmail.com>
+ * Maintained by Catalin Marinas <catalin.marinas@arm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/cpufreq.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/amba/bus.h>
+
+#include <asm/io.h>
+
+#define	CPU_TRANSITION_LATENCY	100000
+
+/*
+ * IEC OFFSET
+ */
+#define	IEC_CFGCPUFREQ_OFFSET	0x020   /* max Freq (ro)*/
+#define	IEC_DPCTGTPERF_OFFSET	0x008   /* target performance (wo)*/
+#define	IEC_DPCCRNTPERF_OFFSET	0x00C   /* current performance (ro)*/
+
+#define	IEC_ID0_OFFSET		0xFF0	/* identification register 0 */
+#define	IEC_ID1_OFFSET		0xFF4	/* identification register 1 */
+#define	IEC_ID2_OFFSET		0xFF8	/* identification register 2 */
+#define	IEC_ID3_OFFSET		0xFFC	/* identification register 3 */
+
+#define	IEC_PERIFID0_OFFSET	0xFE0	/* Peripheral id register 0 */
+#define	IEC_PERIFID1_OFFSET	0xFE4	/* Peripheral id register 1 */
+#define	IEC_PERIFID2_OFFSET	0xFE8	/* Peripheral id register 2 */
+#define	IEC_PERIFID3_OFFSET	0xFEC	/* Peripheral id register 3 */
+#define	IEC_PERIFID4_OFFSET	0xFD0	/* Peripheral id register 4 */
+#define	IEC_PERIFID5_OFFSET	0xFD4	/* Peripheral id register 5 */
+#define	IEC_PERIFID6_OFFSET	0xFD8	/* Peripheral id register 6 */
+#define	IEC_PERIFID7_OFFSET	0xFDC	/* Peripheral id register 7 */
+
+static void __iomem *iec_base;
+
+/*
+ * This function returns a performance (4 - 128) out of a frequency within
+ * the boundaries (min/max).
+ */
+static u32 get_performance(struct cpufreq_policy *policy,
+		        	unsigned int target_freq)
+{
+	unsigned int perf = 0;
+
+	if(target_freq < policy->min)
+		target_freq = (u32)policy->min;
+	if(target_freq > policy->max)
+		target_freq = (u32)policy->max;
+
+	perf = (target_freq*0x80)/policy->cpuinfo.max_freq;
+	if (perf < 4)
+		perf = 4;
+
+	return perf;
+}
+
+/*
+ * This function set the IECDPCTGTPERF register out of the performance level
+ * (4 - 128).
+ */
+static void set_performance(u32 perf)
+{
+	if(perf > 0x80)
+		perf = 0x80;
+	if(perf < 4)
+		perf = 4;
+	writel(perf, iec_base + IEC_DPCTGTPERF_OFFSET);
+}
+
+/*
+ * Verify if the requested policy is within the limits.
+ */
+static int iec_verify_policy(struct cpufreq_policy *policy)
+{
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+		policy->cpuinfo.max_freq);
+	return 0;
+}
+
+/*
+ * Return the current IEC performance (4-128).
+ */
+static inline u32 iec_get_current_perf(void){
+	return (unsigned int)readl(iec_base + IEC_DPCCRNTPERF_OFFSET);
+}
+
+/*
+ * Return the current speed (i.e the current freq) of the CPU The register
+ * DPCCRNTPERF returns the performance (4 - 128).
+ */
+static unsigned int iec_get_speed(unsigned int cpu)
+{
+	unsigned int freq = 0;
+	unsigned int current_perf = 0;
+	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+
+	if (cpu)
+		return 0;
+
+	current_perf = iec_get_current_perf();
+	pr_debug("iec: current performance value (from register): %u\n",
+		 current_perf);
+
+	freq = (current_perf*policy->cpuinfo.max_freq)/0x80;
+	pr_debug("iec: current frequency (from register) : %u\n", freq);
+
+	return freq;
+}
+
+/*
+ * Here is where the Freq changes.  The CPUFreq driver must set the new
+ * frequency when called here.
+ */
+static int iec_set_target(struct cpufreq_policy *policy,
+                          unsigned int target_freq,
+                          unsigned int relation)
+{
+	struct cpufreq_freqs freqs;
+	unsigned int cur = iec_get_speed(0);
+	unsigned int perf;
+
+	/*
+	 * Some governors do not respects CPU and policy lower limits which
+	 * leads to bad things (division by zero etc), ensure that such things
+	 * do not happen.
+	 */
+	if(target_freq < policy->cpuinfo.min_freq)
+		target_freq = policy->cpuinfo.min_freq;
+	if(target_freq < policy->min)
+		target_freq = policy->min;
+
+	switch(relation){
+	case CPUFREQ_RELATION_L:
+		pr_debug("iec: try to select a freq higher than or equal to %u\n", 
+			 target_freq);
+		break;
+	case CPUFREQ_RELATION_H:
+		pr_debug("iec: try to select a freq lower than or equal to %u\n", 
+			 target_freq);
+		break;
+	}
+
+	perf =  get_performance(policy, target_freq);
+	pr_debug("iec: new frequency %u (-> perf level %u)\n", target_freq,
+		 perf);
+
+	freqs.old = cur;
+	freqs.new = target_freq;
+	freqs.cpu = 0;
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+	set_performance(perf);
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	return 0;
+}
+
+/*
+ * Whenever a new CPU is registered with the device model, or after the
+ * cpufreq driver registers itself, the per-CPU initialization function
+ * cpufreq_driver.init is called.
+ */
+static int __init iec_cpu_init(struct cpufreq_policy *policy)
+{
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+	policy->cpuinfo.max_freq = (unsigned int)readl(iec_base + IEC_CFGCPUFREQ_OFFSET);
+	policy->cpuinfo.min_freq = policy->cpuinfo.max_freq/2; /* 50% of cpuinfo.max_freq */ 
+	policy->cpuinfo.transition_latency = CPU_TRANSITION_LATENCY;
+
+	policy->max = policy->cpuinfo.max_freq;
+	policy->min = policy->cpuinfo.min_freq;
+	policy->cur = (iec_get_current_perf()*policy->cpuinfo.max_freq)/0x80;
+
+	pr_debug("iec: cpu_max : %u, cpu_min : %u, cpu_latency : %u \n",
+		 policy->cpuinfo.max_freq, policy->cpuinfo.min_freq,
+		 policy->cpuinfo.transition_latency);
+
+	return 0;
+}
+
+/*
+ * CPUFreq Driver Interface.
+ */
+static struct cpufreq_driver iec_cpufreq_driver = {
+	.name		= "iec",
+	.flags		= CPUFREQ_STICKY,
+	.verify		= iec_verify_policy,
+	.target		= iec_set_target,
+	.get		= iec_get_speed,
+	.init		= iec_cpu_init,
+};
+
+static int __init iec_probe(struct amba_device *dev, void *id)
+{
+	int ret;
+
+	ret = amba_request_regions(dev, NULL);
+	if (ret)
+		goto out;
+
+	iec_base = ioremap(dev->res.start, resource_size(&dev->res));
+	if (!iec_base) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	ret = cpufreq_register_driver(&iec_cpufreq_driver);
+	if (ret == 0)
+		goto out;
+
+	iounmap(iec_base);
+release:
+	amba_release_regions(dev);
+out:
+	return ret;
+}
+
+static int iec_remove(struct amba_device *dev)
+{
+	cpufreq_unregister_driver(&iec_cpufreq_driver);
+	iounmap(iec_base);
+	amba_release_regions(dev);
+
+	return 0;
+}
+
+static struct amba_id iec_ids[] __initdata = {
+	{
+		.id	= 0x08041750,
+		.mask	= 0xffffffff
+	},
+	{ 0, 0 }
+};
+
+static struct amba_driver iec_driver = {
+	.drv = {
+		.name	= "iec",
+	},
+	.id_table	= iec_ids,
+	.probe		= iec_probe,
+	.remove		= iec_remove,
+};
+
+static int __init iec_init(void)
+{
+	return amba_driver_register(&iec_driver);
+}
+
+static void __exit iec_exit(void)
+{
+	amba_driver_unregister(&iec_driver);
+}
+
+module_init(iec_init);
+module_exit(iec_exit);
+
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-realview/include/mach/board-eb.h b/arch/arm/mach-realview/include/mach/board-eb.h
index 8d699fd..268d770 100644
--- a/arch/arm/mach-realview/include/mach/board-eb.h
+++ b/arch/arm/mach-realview/include/mach/board-eb.h
@@ -49,16 +49,14 @@
 #ifdef CONFIG_REALVIEW_EB_ARM11MP_REVB
 #define REALVIEW_EB11MP_SCU_BASE	0x10100000	/* SCU registers */
 #define REALVIEW_EB11MP_GIC_CPU_BASE	0x10100100	/* Generic interrupt controller CPU interface */
-#define REALVIEW_EB11MP_TWD_BASE	0x10100700
-#define REALVIEW_EB11MP_TWD_SIZE	0x00000100
+#define REALVIEW_EB11MP_TWD_BASE	0x10100600
 #define REALVIEW_EB11MP_GIC_DIST_BASE	0x10101000	/* Generic interrupt controller distributor */
 #define REALVIEW_EB11MP_L220_BASE	0x10102000	/* L220 registers */
 #define REALVIEW_EB11MP_SYS_PLD_CTRL1	0xD8		/* Register offset for MPCore sysctl */
 #else
 #define REALVIEW_EB11MP_SCU_BASE	0x1F000000	/* SCU registers */
 #define REALVIEW_EB11MP_GIC_CPU_BASE	0x1F000100	/* Generic interrupt controller CPU interface */
-#define REALVIEW_EB11MP_TWD_BASE	0x1F000700
-#define REALVIEW_EB11MP_TWD_SIZE	0x00000100
+#define REALVIEW_EB11MP_TWD_BASE	0x1F000600
 #define REALVIEW_EB11MP_GIC_DIST_BASE	0x1F001000	/* Generic interrupt controller distributor */
 #define REALVIEW_EB11MP_L220_BASE	0x1F002000	/* L220 registers */
 #define REALVIEW_EB11MP_SYS_PLD_CTRL1	0x74		/* Register offset for MPCore sysctl */
@@ -163,7 +161,7 @@
 #define NR_IRQS			NR_IRQS_EB
 #endif
 
-#if defined(CONFIG_REALVIEW_EB_ARM11MP) \
+#if defined(CONFIG_REALVIEW_EB_ARM11MP) || defined(CONFIG_REALVIEW_EB_A9MP) \
 	&& (!defined(MAX_GIC_NR) || (MAX_GIC_NR < NR_GIC_EB11MP))
 #undef MAX_GIC_NR
 #define MAX_GIC_NR		NR_GIC_EB11MP
@@ -177,6 +175,7 @@
 #define REALVIEW_EB_PROC_ARM9		0x02000000
 #define REALVIEW_EB_PROC_ARM11		0x04000000
 #define REALVIEW_EB_PROC_ARM11MP	0x06000000
+#define REALVIEW_EB_PROC_A9MP		0x0C000000
 
 #define check_eb_proc(proc_type)						\
 	((readl(__io_address(REALVIEW_SYS_PROCID)) & REALVIEW_EB_PROC_MASK)	\
@@ -188,4 +187,13 @@
 #define core_tile_eb11mp()	0
 #endif
 
+#ifdef CONFIG_REALVIEW_EB_A9MP
+#define core_tile_a9mp()	check_eb_proc(REALVIEW_EB_PROC_A9MP)
+#else
+#define core_tile_a9mp()	0
+#endif
+
+#define machine_is_realview_eb_mp() \
+	(machine_is_realview_eb() && (core_tile_eb11mp() || core_tile_a9mp()))
+
 #endif	/* __ASM_ARCH_BOARD_EB_H */
diff --git a/arch/arm/mach-realview/include/mach/board-pb1176.h b/arch/arm/mach-realview/include/mach/board-pb1176.h
index 858eea7..1400132 100644
--- a/arch/arm/mach-realview/include/mach/board-pb1176.h
+++ b/arch/arm/mach-realview/include/mach/board-pb1176.h
@@ -32,7 +32,10 @@
 #define REALVIEW_PB1176_SDRAM67_BASE		0x70000000 /* SDRAM banks 6 and 7 */
 #define REALVIEW_PB1176_FLASH_BASE		0x30000000
 #define REALVIEW_PB1176_FLASH_SIZE		SZ_64M
+#define REALVIEW_PB1176_SEC_FLASH_BASE		0x3C000000 /* Secure flash */
+#define REALVIEW_PB1176_SEC_FLASH_SIZE		SZ_64M
 
+#define REALVIEW_PB1176_IEC_BASE		0x10103000 /* IEC */
 #define REALVIEW_PB1176_TIMER0_1_BASE		0x10104000 /* Timer 0 and 1 */
 #define REALVIEW_PB1176_TIMER2_3_BASE		0x10105000 /* Timer 2 and 3 */
 #define REALVIEW_PB1176_TIMER4_5_BASE		0x10106000 /* Timer 4 and 5 */
diff --git a/arch/arm/mach-realview/include/mach/board-pb11mp.h b/arch/arm/mach-realview/include/mach/board-pb11mp.h
index ecd80e5..53ea0e7 100644
--- a/arch/arm/mach-realview/include/mach/board-pb11mp.h
+++ b/arch/arm/mach-realview/include/mach/board-pb11mp.h
@@ -77,8 +77,7 @@
  */
 #define REALVIEW_TC11MP_SCU_BASE		0x1F000000	/* IRQ, Test chip */
 #define REALVIEW_TC11MP_GIC_CPU_BASE		0x1F000100	/* Test chip interrupt controller CPU interface */
-#define REALVIEW_TC11MP_TWD_BASE		0x1F000700
-#define REALVIEW_TC11MP_TWD_SIZE		0x00000100
+#define REALVIEW_TC11MP_TWD_BASE		0x1F000600
 #define REALVIEW_TC11MP_GIC_DIST_BASE		0x1F001000	/* Test chip interrupt controller distributor */
 #define REALVIEW_TC11MP_L220_BASE		0x1F002000	/* L220 registers */
 
diff --git a/arch/arm/mach-realview/include/mach/board-pba8.h b/arch/arm/mach-realview/include/mach/board-pba8.h
new file mode 100644
index 0000000..307f97b
--- /dev/null
+++ b/arch/arm/mach-realview/include/mach/board-pba8.h
@@ -0,0 +1,150 @@
+/*
+ * include/asm-arm/arch-realview/board-pba8.h
+ *
+ * Copyright (C) 2008 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifndef __ASM_ARCH_BOARD_PBA8_H
+#define __ASM_ARCH_BOARD_PBA8_H
+
+#include <mach/platform.h>
+
+/*
+ * Peripheral addresses
+ */
+#define REALVIEW_PBA8_UART0_BASE		0x10009000	/* UART 0 */
+#define REALVIEW_PBA8_UART1_BASE		0x1000A000	/* UART 1 */
+#define REALVIEW_PBA8_UART2_BASE		0x1000B000	/* UART 2 */
+#define REALVIEW_PBA8_UART3_BASE		0x1000C000	/* UART 3 */
+#define REALVIEW_PBA8_SSP_BASE			0x1000D000	/* Synchronous Serial Port */
+#define REALVIEW_PBA8_WATCHDOG0_BASE		0x1000F000	/* Watchdog 0 */
+#define REALVIEW_PBA8_WATCHDOG_BASE		0x10010000	/* watchdog interface */
+#define REALVIEW_PBA8_TIMER0_1_BASE		0x10011000	/* Timer 0 and 1 */
+#define REALVIEW_PBA8_TIMER2_3_BASE		0x10012000	/* Timer 2 and 3 */
+#define REALVIEW_PBA8_GPIO0_BASE		0x10013000	/* GPIO port 0 */
+#define REALVIEW_PBA8_RTC_BASE			0x10017000	/* Real Time Clock */
+#define REALVIEW_PBA8_TIMER4_5_BASE		0x10018000	/* Timer 4/5 */
+#define REALVIEW_PBA8_TIMER6_7_BASE		0x10019000	/* Timer 6/7 */
+#define REALVIEW_PBA8_SCTL_BASE			0x1001A000	/* System Controller */
+#define REALVIEW_PBA8_CLCD_BASE			0x10020000	/* CLCD */
+#define REALVIEW_PBA8_ONB_SRAM_BASE		0x10060000	/* On-board SRAM */
+#define REALVIEW_PBA8_DMC_BASE			0x100E0000	/* DMC configuration */
+#define REALVIEW_PBA8_SMC_BASE			0x100E1000	/* SMC configuration */
+#define REALVIEW_PBA8_CAN_BASE			0x100E2000	/* CAN bus */
+#define REALVIEW_PBA8_GIC_CPU_BASE		0x1E000000	/* Generic interrupt controller CPU interface */
+#define REALVIEW_PBA8_FLASH0_BASE		0x40000000
+#define REALVIEW_PBA8_FLASH0_SIZE		SZ_64M
+#define REALVIEW_PBA8_FLASH1_BASE		0x44000000
+#define REALVIEW_PBA8_FLASH1_SIZE		SZ_64M
+#define REALVIEW_PBA8_ETH_BASE			0x4E000000	/* Ethernet */
+#define REALVIEW_PBA8_USB_BASE			0x4F000000	/* USB */
+#define REALVIEW_PBA8_GIC_DIST_BASE		0x1E001000	/* Generic interrupt controller distributor */
+#define REALVIEW_PBA8_LT_BASE			0xC0000000	/* Logic Tile expansion */
+#define REALVIEW_PBA8_SDRAM6_BASE		0x70000000	/* SDRAM bank 6 256MB */
+#define REALVIEW_PBA8_SDRAM7_BASE		0x80000000	/* SDRAM bank 7 256MB */
+
+#define REALVIEW_PBA8_SYS_PLD_CTRL1		0x74
+
+/*
+ * PBA8 PCI regions
+ */
+#define REALVIEW_PBA8_PCI_BASE			0x90040000	/* PCI-X Unit base */
+#define REALVIEW_PBA8_PCI_IO_BASE		0x90050000	/* IO Region on AHB */
+#define REALVIEW_PBA8_PCI_MEM_BASE		0xA0000000	/* MEM Region on AHB */
+
+#define REALVIEW_PBA8_PCI_BASE_SIZE		0x10000		/* 16 Kb */
+#define REALVIEW_PBA8_PCI_IO_SIZE		0x1000		/* 4 Kb */
+#define REALVIEW_PBA8_PCI_MEM_SIZE		0x20000000	/* 512 MB */
+
+/*
+ * Irqs
+ */
+#define IRQ_PBA8_GIC_START			32
+
+/* L220
+#define IRQ_PBA8_L220_EVENT	(IRQ_PBA8_GIC_START + 29)
+#define IRQ_PBA8_L220_SLAVE	(IRQ_PBA8_GIC_START + 30)
+#define IRQ_PBA8_L220_DECODE	(IRQ_PBA8_GIC_START + 31)
+*/
+
+/*
+ * PB-A8 on-board gic irq sources
+ */
+#define IRQ_PBA8_WATCHDOG	(IRQ_PBA8_GIC_START + 0)	/* Watchdog timer */
+#define IRQ_PBA8_SOFT		(IRQ_PBA8_GIC_START + 1)	/* Software interrupt */
+#define IRQ_PBA8_COMMRx		(IRQ_PBA8_GIC_START + 2)	/* Debug Comm Rx interrupt */
+#define IRQ_PBA8_COMMTx		(IRQ_PBA8_GIC_START + 3)	/* Debug Comm Tx interrupt */
+#define IRQ_PBA8_TIMER0_1	(IRQ_PBA8_GIC_START + 4)	/* Timer 0/1 (default timer) */
+#define IRQ_PBA8_TIMER2_3	(IRQ_PBA8_GIC_START + 5)	/* Timer 2/3 */
+#define IRQ_PBA8_GPIO0		(IRQ_PBA8_GIC_START + 6)	/* GPIO 0 */
+#define IRQ_PBA8_GPIO1		(IRQ_PBA8_GIC_START + 7)	/* GPIO 1 */
+#define IRQ_PBA8_GPIO2		(IRQ_PBA8_GIC_START + 8)	/* GPIO 2 */
+								/* 9 reserved */
+#define IRQ_PBA8_RTC		(IRQ_PBA8_GIC_START + 10)	/* Real Time Clock */
+#define IRQ_PBA8_SSP		(IRQ_PBA8_GIC_START + 11)	/* Synchronous Serial Port */
+#define IRQ_PBA8_UART0		(IRQ_PBA8_GIC_START + 12)	/* UART 0 on development chip */
+#define IRQ_PBA8_UART1		(IRQ_PBA8_GIC_START + 13)	/* UART 1 on development chip */
+#define IRQ_PBA8_UART2		(IRQ_PBA8_GIC_START + 14)	/* UART 2 on development chip */
+#define IRQ_PBA8_UART3		(IRQ_PBA8_GIC_START + 15)	/* UART 3 on development chip */
+#define IRQ_PBA8_SCI		(IRQ_PBA8_GIC_START + 16)	/* Smart Card Interface */
+#define IRQ_PBA8_MMCI0A		(IRQ_PBA8_GIC_START + 17)	/* Multimedia Card 0A */
+#define IRQ_PBA8_MMCI0B		(IRQ_PBA8_GIC_START + 18)	/* Multimedia Card 0B */
+#define IRQ_PBA8_AACI		(IRQ_PBA8_GIC_START + 19)	/* Audio Codec */
+#define IRQ_PBA8_KMI0		(IRQ_PBA8_GIC_START + 20)	/* Keyboard/Mouse port 0 */
+#define IRQ_PBA8_KMI1		(IRQ_PBA8_GIC_START + 21)	/* Keyboard/Mouse port 1 */
+#define IRQ_PBA8_CHARLCD	(IRQ_PBA8_GIC_START + 22)	/* Character LCD */
+#define IRQ_PBA8_CLCD		(IRQ_PBA8_GIC_START + 23)	/* CLCD controller */
+#define IRQ_PBA8_DMAC		(IRQ_PBA8_GIC_START + 24)	/* DMA controller */
+#define IRQ_PBA8_PWRFAIL	(IRQ_PBA8_GIC_START + 25)	/* Power failure */
+#define IRQ_PBA8_PISMO		(IRQ_PBA8_GIC_START + 26)	/* PISMO interface */
+#define IRQ_PBA8_DoC		(IRQ_PBA8_GIC_START + 27)	/* Disk on Chip memory controller */
+#define IRQ_PBA8_ETH		(IRQ_PBA8_GIC_START + 28)	/* Ethernet controller */
+#define IRQ_PBA8_USB		(IRQ_PBA8_GIC_START + 29)	/* USB controller */
+#define IRQ_PBA8_TSPEN		(IRQ_PBA8_GIC_START + 30)	/* Touchscreen pen */
+#define IRQ_PBA8_TSKPAD		(IRQ_PBA8_GIC_START + 31)	/* Touchscreen keypad */
+
+/* ... */
+#define IRQ_PBA8_PCI0		(IRQ_PBA8_GIC_START + 50)
+#define IRQ_PBA8_PCI1		(IRQ_PBA8_GIC_START + 51)
+#define IRQ_PBA8_PCI2		(IRQ_PBA8_GIC_START + 52)
+#define IRQ_PBA8_PCI3		(IRQ_PBA8_GIC_START + 53)
+
+#define IRQ_PBA8_SMC		-1
+#define IRQ_PBA8_SCTL		-1
+
+#define NR_GIC_PBA8		1
+
+/*
+ * Only define NR_IRQS if less than NR_IRQS_PBA8
+ */
+#define NR_IRQS_PBA8		(IRQ_PBA8_GIC_START + 64)
+
+#if defined(CONFIG_MACH_REALVIEW_PBA8)
+
+#if !defined(NR_IRQS) || (NR_IRQS < NR_IRQS_PBA8)
+#undef NR_IRQS
+#define NR_IRQS			NR_IRQS_PBA8
+#endif
+
+#if !defined(MAX_GIC_NR) || (MAX_GIC_NR < NR_GIC_PBA8)
+#undef MAX_GIC_NR
+#define MAX_GIC_NR		NR_GIC_PBA8
+#endif
+
+#endif	/* CONFIG_MACH_REALVIEW_PBA8 */
+
+#endif	/* __ASM_ARCH_BOARD_PBA8_H */
diff --git a/arch/arm/mach-realview/include/mach/board-pbx.h b/arch/arm/mach-realview/include/mach/board-pbx.h
new file mode 100644
index 0000000..c265093
--- /dev/null
+++ b/arch/arm/mach-realview/include/mach/board-pbx.h
@@ -0,0 +1,203 @@
+/*
+ * arch/arm/mach-realview/include/mach/board-pbx.h
+ *
+ * Copyright (C) 2009 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_BOARD_PBX_H
+#define __ASM_ARCH_BOARD_PBX_H
+
+#include <mach/platform.h>
+
+/*
+ * Peripheral addresses
+ */
+#define REALVIEW_PBX_UART0_BASE			0x10009000	/* UART 0 */
+#define REALVIEW_PBX_UART1_BASE			0x1000A000	/* UART 1 */
+#define REALVIEW_PBX_UART2_BASE			0x1000B000	/* UART 2 */
+#define REALVIEW_PBX_UART3_BASE			0x1000C000	/* UART 3 */
+#define REALVIEW_PBX_SSP_BASE			0x1000D000	/* Synchronous Serial Port */
+#define REALVIEW_PBX_WATCHDOG0_BASE		0x1000F000	/* Watchdog 0 */
+#define REALVIEW_PBX_WATCHDOG_BASE		0x10010000	/* watchdog interface */
+#define REALVIEW_PBX_TIMER0_1_BASE		0x10011000	/* Timer 0 and 1 */
+#define REALVIEW_PBX_TIMER2_3_BASE		0x10012000	/* Timer 2 and 3 */
+#define REALVIEW_PBX_GPIO0_BASE			0x10013000	/* GPIO port 0 */
+#define REALVIEW_PBX_RTC_BASE			0x10017000	/* Real Time Clock */
+#define REALVIEW_PBX_TIMER4_5_BASE		0x10018000	/* Timer 4/5 */
+#define REALVIEW_PBX_TIMER6_7_BASE		0x10019000	/* Timer 6/7 */
+#define REALVIEW_PBX_SCTL_BASE			0x1001A000	/* System Controller */
+#define REALVIEW_PBX_CLCD_BASE			0x10020000	/* CLCD */
+#define REALVIEW_PBX_ONB_SRAM_BASE		0x10060000	/* On-board SRAM */
+#define REALVIEW_PBX_DMC_BASE			0x100E0000	/* DMC configuration */
+#define REALVIEW_PBX_SMC_BASE			0x100E1000	/* SMC configuration */
+#define REALVIEW_PBX_CAN_BASE			0x100E2000	/* CAN bus */
+#define REALVIEW_PBX_GIC_CPU_BASE		0x1E000000	/* Generic interrupt controller CPU interface */
+#define REALVIEW_PBX_FLASH0_BASE		0x40000000
+#define REALVIEW_PBX_FLASH0_SIZE		SZ_64M
+#define REALVIEW_PBX_FLASH1_BASE		0x44000000
+#define REALVIEW_PBX_FLASH1_SIZE		SZ_64M
+#define REALVIEW_PBX_ETH_BASE			0x4E000000	/* Ethernet */
+#define REALVIEW_PBX_USB_BASE			0x4F000000	/* USB */
+#define REALVIEW_PBX_GIC_DIST_BASE		0x1E001000	/* Generic interrupt controller distributor */
+#define REALVIEW_PBX_LT_BASE			0xC0000000	/* Logic Tile expansion */
+#define REALVIEW_PBX_SDRAM6_BASE		0x70000000	/* SDRAM bank 6 256MB */
+#define REALVIEW_PBX_SDRAM7_BASE		0x80000000	/* SDRAM bank 7 256MB */
+
+/*
+ * Tile-specific addresses
+ */
+#define REALVIEW_PBX_TILE_SCU_BASE		0x1F000000      /* SCU registers */
+#define REALVIEW_PBX_TILE_GIC_CPU_BASE		0x1F000100      /* Private Generic interrupt controller CPU interface */
+#define REALVIEW_PBX_TILE_TWD_BASE		0x1F000600
+#define REALVIEW_PBX_TILE_TWD_PERCPU_BASE	0x1F000700
+#define REALVIEW_PBX_TILE_TWD_SIZE		0x00000100
+#define REALVIEW_PBX_TILE_GIC_DIST_BASE		0x1F001000      /* Private Generic interrupt controller distributor */
+#define REALVIEW_PBX_TILE_L220_BASE		0x1F002000      /* L220 registers */
+
+#define REALVIEW_PBX_SYS_PLD_CTRL1		0x74
+
+/*
+ * PBX PCI regions
+ */
+#define REALVIEW_PBX_PCI_BASE			0x90040000	/* PCI-X Unit base */
+#define REALVIEW_PBX_PCI_IO_BASE		0x90050000	/* IO Region on AHB */
+#define REALVIEW_PBX_PCI_MEM_BASE		0xA0000000	/* MEM Region on AHB */
+
+#define REALVIEW_PBX_PCI_BASE_SIZE		0x10000		/* 16 Kb */
+#define REALVIEW_PBX_PCI_IO_SIZE		0x1000		/* 4 Kb */
+#define REALVIEW_PBX_PCI_MEM_SIZE		0x20000000	/* 512 MB */
+
+/*
+ * Irqs
+ */
+#define IRQ_PBX_GIC_START			32
+
+/* L220
+#define IRQ_PBX_L220_EVENT	(IRQ_PBX_GIC_START + 29)
+#define IRQ_PBX_L220_SLAVE	(IRQ_PBX_GIC_START + 30)
+#define IRQ_PBX_L220_DECODE	(IRQ_PBX_GIC_START + 31)
+*/
+
+/*
+ * PB-X on-board gic irq sources
+ */
+#define IRQ_PBX_WATCHDOG	(IRQ_PBX_GIC_START + 0)	/* Watchdog timer */
+#define IRQ_PBX_SOFT		(IRQ_PBX_GIC_START + 1)	/* Software interrupt */
+#define IRQ_PBX_COMMRx		(IRQ_PBX_GIC_START + 2)	/* Debug Comm Rx interrupt */
+#define IRQ_PBX_COMMTx		(IRQ_PBX_GIC_START + 3)	/* Debug Comm Tx interrupt */
+#define IRQ_PBX_TIMER0_1	(IRQ_PBX_GIC_START + 4)	/* Timer 0/1 (default timer) */
+#define IRQ_PBX_TIMER2_3	(IRQ_PBX_GIC_START + 5)	/* Timer 2/3 */
+#define IRQ_PBX_GPIO0		(IRQ_PBX_GIC_START + 6)	/* GPIO 0 */
+#define IRQ_PBX_GPIO1		(IRQ_PBX_GIC_START + 7)	/* GPIO 1 */
+#define IRQ_PBX_GPIO2		(IRQ_PBX_GIC_START + 8)	/* GPIO 2 */
+								/* 9 reserved */
+#define IRQ_PBX_RTC		(IRQ_PBX_GIC_START + 10)	/* Real Time Clock */
+#define IRQ_PBX_SSP		(IRQ_PBX_GIC_START + 11)	/* Synchronous Serial Port */
+#define IRQ_PBX_UART0		(IRQ_PBX_GIC_START + 12)	/* UART 0 on development chip */
+#define IRQ_PBX_UART1		(IRQ_PBX_GIC_START + 13)	/* UART 1 on development chip */
+#define IRQ_PBX_UART2		(IRQ_PBX_GIC_START + 14)	/* UART 2 on development chip */
+#define IRQ_PBX_UART3		(IRQ_PBX_GIC_START + 15)	/* UART 3 on development chip */
+#define IRQ_PBX_SCI		(IRQ_PBX_GIC_START + 16)	/* Smart Card Interface */
+#define IRQ_PBX_MMCI0A		(IRQ_PBX_GIC_START + 17)	/* Multimedia Card 0A */
+#define IRQ_PBX_MMCI0B		(IRQ_PBX_GIC_START + 18)	/* Multimedia Card 0B */
+#define IRQ_PBX_AACI		(IRQ_PBX_GIC_START + 19)	/* Audio Codec */
+#define IRQ_PBX_KMI0		(IRQ_PBX_GIC_START + 20)	/* Keyboard/Mouse port 0 */
+#define IRQ_PBX_KMI1		(IRQ_PBX_GIC_START + 21)	/* Keyboard/Mouse port 1 */
+#define IRQ_PBX_CHARLCD		(IRQ_PBX_GIC_START + 22)	/* Character LCD */
+#define IRQ_PBX_CLCD		(IRQ_PBX_GIC_START + 23)	/* CLCD controller */
+#define IRQ_PBX_DMAC		(IRQ_PBX_GIC_START + 24)	/* DMA controller */
+#define IRQ_PBX_PWRFAIL		(IRQ_PBX_GIC_START + 25)	/* Power failure */
+#define IRQ_PBX_PISMO		(IRQ_PBX_GIC_START + 26)	/* PISMO interface */
+#define IRQ_PBX_DoC		(IRQ_PBX_GIC_START + 27)	/* Disk on Chip memory controller */
+#define IRQ_PBX_ETH		(IRQ_PBX_GIC_START + 28)	/* Ethernet controller */
+#define IRQ_PBX_USB		(IRQ_PBX_GIC_START + 29)	/* USB controller */
+#define IRQ_PBX_TSPEN		(IRQ_PBX_GIC_START + 30)	/* Touchscreen pen */
+#define IRQ_PBX_TSKPAD		(IRQ_PBX_GIC_START + 31)	/* Touchscreen keypad */
+
+#define IRQ_PBX_PMU_SCU0        (IRQ_PBX_GIC_START + 32)        /* SCU PMU Interrupts (11mp) */
+#define IRQ_PBX_PMU_SCU1        (IRQ_PBX_GIC_START + 33)
+#define IRQ_PBX_PMU_SCU2        (IRQ_PBX_GIC_START + 34)
+#define IRQ_PBX_PMU_SCU3        (IRQ_PBX_GIC_START + 35)
+#define IRQ_PBX_PMU_SCU4        (IRQ_PBX_GIC_START + 36)
+#define IRQ_PBX_PMU_SCU5        (IRQ_PBX_GIC_START + 37)
+#define IRQ_PBX_PMU_SCU6        (IRQ_PBX_GIC_START + 38)
+#define IRQ_PBX_PMU_SCU7        (IRQ_PBX_GIC_START + 39)
+
+#define IRQ_PBX_WATCHDOG1       (IRQ_PBX_GIC_START + 40)        /* Watchdog1 timer */
+#define IRQ_PBX_TIMER4_5        (IRQ_PBX_GIC_START + 41)        /* Timer 0/1 (default timer) */
+#define IRQ_PBX_TIMER6_7        (IRQ_PBX_GIC_START + 42)        /* Timer 2/3 */
+/* ... */
+#define IRQ_PBX_PMU_CPU3        (IRQ_PBX_GIC_START + 44)        /* CPU PMU Interrupts */
+#define IRQ_PBX_PMU_CPU2        (IRQ_PBX_GIC_START + 45)
+#define IRQ_PBX_PMU_CPU1        (IRQ_PBX_GIC_START + 46)
+#define IRQ_PBX_PMU_CPU0        (IRQ_PBX_GIC_START + 47)
+
+/* ... */
+#define IRQ_PBX_PCI0		(IRQ_PBX_GIC_START + 50)
+#define IRQ_PBX_PCI1		(IRQ_PBX_GIC_START + 51)
+#define IRQ_PBX_PCI2		(IRQ_PBX_GIC_START + 52)
+#define IRQ_PBX_PCI3		(IRQ_PBX_GIC_START + 53)
+
+#define IRQ_PBX_SMC		-1
+#define IRQ_PBX_SCTL		-1
+
+#define NR_GIC_PBX		1
+
+/*
+ * Only define NR_IRQS if less than NR_IRQS_PBX
+ */
+#define NR_IRQS_PBX		(IRQ_PBX_GIC_START + 96)
+
+#if defined(CONFIG_MACH_REALVIEW_PBX)
+
+#if !defined(NR_IRQS) || (NR_IRQS < NR_IRQS_PBX)
+#undef NR_IRQS
+#define NR_IRQS			NR_IRQS_PBX
+#endif
+
+#if !defined(MAX_GIC_NR) || (MAX_GIC_NR < NR_GIC_PBX)
+#undef MAX_GIC_NR
+#define MAX_GIC_NR		NR_GIC_PBX
+#endif
+
+#endif	/* CONFIG_MACH_REALVIEW_PBX */
+
+/*
+ * Core tile identification (REALVIEW_SYS_PROCID)
+ */
+#define REALVIEW_PBX_PROC_MASK          0xFF000000
+#define REALVIEW_PBX_PROC_ARM7TDMI      0x00000000
+#define REALVIEW_PBX_PROC_ARM9          0x02000000
+#define REALVIEW_PBX_PROC_ARM11         0x04000000
+#define REALVIEW_PBX_PROC_ARM11MP       0x06000000
+#define REALVIEW_PBX_PROC_A9MP          0x0C000000
+#define REALVIEW_PBX_PROC_A8            0x0E000000
+
+#define check_pbx_proc(proc_type)                                            \
+	((readl(__io_address(REALVIEW_SYS_PROCID)) & REALVIEW_PBX_PROC_MASK) \
+	== proc_type)
+
+#ifdef CONFIG_MACH_REALVIEW_PBX
+#define core_tile_pbx11mp()     check_pbx_proc(REALVIEW_PBX_PROC_ARM11MP)
+#define core_tile_pbxa9mp()     check_pbx_proc(REALVIEW_PBX_PROC_A9MP)
+#define core_tile_pbxa8()       check_pbx_proc(REALVIEW_PBX_PROC_A8)
+#else
+#define core_tile_pbx11mp()     0
+#define core_tile_pbxa9mp()     0
+#define core_tile_pbxa8()       0
+#endif
+
+#endif	/* __ASM_ARCH_BOARD_PBX_H */
diff --git a/arch/arm/mach-realview/include/mach/debug-macro.S b/arch/arm/mach-realview/include/mach/debug-macro.S
index 7196bca..59a0396 100644
--- a/arch/arm/mach-realview/include/mach/debug-macro.S
+++ b/arch/arm/mach-realview/include/mach/debug-macro.S
@@ -8,15 +8,38 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
- *
-*/
+ */
+
+#if defined(CONFIG_MACH_REALVIEW_EB) || \
+    defined(CONFIG_MACH_REALVIEW_PB11MP) || \
+    defined(CONFIG_MACH_REALVIEW_PBA8) || \
+    defined(CONFIG_MACH_REALVIEW_PBX)
+#ifndef DEBUG_LL_UART_OFFSET
+#define DEBUG_LL_UART_OFFSET	0x00009000
+#elif DEBUG_LL_UART_OFFSET != 0x00009000
+#warning "DEBUG_LL_UART_OFFSET already defined to a different value"
+#endif
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB1176
+#ifndef DEBUG_LL_UART_OFFSET
+#define DEBUG_LL_UART_OFFSET	0x0010c000
+#elif DEBUG_LL_UART_OFFSET != 0x0010c000
+#warning "DEBUG_LL_UART_OFFSET already defined to a different value"
+#endif
+#endif
+
+#ifndef DEBUG_LL_UART_OFFSET
+#error "Unknown RealView platform"
+#endif
 
 		.macro	addruart,rx
 		mrc	p15, 0, \rx, c1, c0
 		tst	\rx, #1			@ MMU enabled?
+		ite	eq
 		moveq	\rx,      #0x10000000
-		movne	\rx,      #0xf0000000	@ virtual base
-		orr	\rx, \rx, #0x00009000
+		movne	\rx,      #0xfb000000	@ virtual base
+		orr	\rx, \rx, #DEBUG_LL_UART_OFFSET
 		.endm
 
 #include <asm/hardware/debug-pl01x.S>
diff --git a/arch/arm/mach-realview/include/mach/entry-macro.S b/arch/arm/mach-realview/include/mach/entry-macro.S
index 340a5c2..7bf198c 100644
--- a/arch/arm/mach-realview/include/mach/entry-macro.S
+++ b/arch/arm/mach-realview/include/mach/entry-macro.S
@@ -49,8 +49,11 @@
 		bic     \irqnr, \irqstat, #0x1c00
 
 		cmp     \irqnr, #29
+		it	cc
 		cmpcc	\irqnr, \irqnr
+		it	ne
 		cmpne	\irqnr, \tmp
+		it	cs
 		cmpcs	\irqnr, \irqnr
 
 		.endm
@@ -65,7 +68,9 @@
 		.macro test_for_ipi, irqnr, irqstat, base, tmp
 		bic	\irqnr, \irqstat, #0x1c00
 		cmp	\irqnr, #16
+		it	cc
 		strcc	\irqstat, [\base, #GIC_CPU_EOI]
+		it	cs
 		cmpcs	\irqnr, \irqnr
 		.endm
 
@@ -75,6 +80,7 @@
 		bic	\irqnr, \irqstat, #0x1c00
 		mov 	\tmp, #0
 		cmp	\irqnr, #29
+		itt	eq
 		moveq	\tmp, #1
 		streq	\irqstat, [\base, #GIC_CPU_EOI]
 		cmp	\tmp, #0
diff --git a/arch/arm/mach-realview/include/mach/hardware.h b/arch/arm/mach-realview/include/mach/hardware.h
index 79a93b3..a47aefb 100644
--- a/arch/arm/mach-realview/include/mach/hardware.h
+++ b/arch/arm/mach-realview/include/mach/hardware.h
@@ -25,7 +25,18 @@
 #include <asm/sizes.h>
 
 /* macro to get at IO space when running virtually */
-#define IO_ADDRESS(x)		(((x) & 0x0fffffff) + 0xf0000000)
+/*
+ * Statically mapped addresses:
+ *
+ * 10xx xxxx -> fbxx xxxx
+ * 1exx xxxx -> fdxx xxxx
+ * 1fxx xxxx -> fexx xxxx
+ */
+#ifdef CONFIG_MMU
+#define IO_ADDRESS(x)		(((x) & 0x03ffffff) + 0xfb000000)
+#else
+#define IO_ADDRESS(x)		(x)
+#endif
 #define __io_address(n)		__io(IO_ADDRESS(n))
 
 #endif
diff --git a/arch/arm/mach-realview/include/mach/irqs.h b/arch/arm/mach-realview/include/mach/irqs.h
index 02a9185..e9e3826 100644
--- a/arch/arm/mach-realview/include/mach/irqs.h
+++ b/arch/arm/mach-realview/include/mach/irqs.h
@@ -25,6 +25,8 @@
 #include <mach/board-eb.h>
 #include <mach/board-pb11mp.h>
 #include <mach/board-pb1176.h>
+#include <mach/board-pba8.h>
+#include <mach/board-pbx.h>
 
 #define IRQ_LOCALTIMER		29
 #define IRQ_LOCALWDOG		30
diff --git a/arch/arm/mach-realview/include/mach/memory.h b/arch/arm/mach-realview/include/mach/memory.h
index 0e67348..f00bde1 100644
--- a/arch/arm/mach-realview/include/mach/memory.h
+++ b/arch/arm/mach-realview/include/mach/memory.h
@@ -23,7 +23,65 @@
 /*
  * Physical DRAM offset.
  */
+#ifdef CONFIG_REALVIEW_HIGH_PHYS_OFFSET
+#define PHYS_OFFSET		UL(0x70000000)
+#else
 #define PHYS_OFFSET		UL(0x00000000)
+#endif
+
+#if !defined(__ASSEMBLY__) && defined(CONFIG_ZONE_DMA)
+extern void realview_adjust_zones(int node, unsigned long *size,
+				  unsigned long *hole);
+#define arch_adjust_zones(node, size, hole) \
+	realview_adjust_zones(node, size, hole)
+#endif
+
+/*
+ * Sparsemem definitions, only valid for high PHYS_OFFSET.
+ *
+ * Most RealView boards (except PB1176) have 512MB of RAM at 0x70000000. The
+ * PBX board has another block of 512MB of RAM at 0x20000000, however only the
+ * block at 0x70000000 may be used for DMA.
+ *
+ * The macros below define a section size of 256MB and a non-linear virtual to
+ * physical mapping:
+ *
+ * 0x70000000 -> PAGE_OFFSET
+ * 0x20000000 -> PAGE_OFFSET + 0x20000000
+ * 0x90000000 -> PAGE_OFFSET + 0x40000000 (required for high_memory)
+ */
+#ifdef CONFIG_SPARSEMEM
+
+#ifndef CONFIG_REALVIEW_HIGH_PHYS_OFFSET
+#error "SPARSEMEM only available with REALVIEW_HIGH_PHYS_OFFSET"
+#endif
+
+#define MAX_PHYSMEM_BITS	32
+#define SECTION_SIZE_BITS	28
+
+#define __phys_to_virt(phys) ({					\
+	unsigned long virt = 0;					\
+	if ((phys) >= 0x90000000UL)				\
+		virt = (phys) - 0x50000000UL + PAGE_OFFSET;	\
+	else if ((phys) >= 0x70000000UL)			\
+		virt = (phys) - 0x70000000UL + PAGE_OFFSET;	\
+	else if ((phys) >= 0x20000000UL)			\
+		virt = (phys) + PAGE_OFFSET;			\
+	virt;							\
+})
+
+#define __virt_to_phys(virt) ({					\
+	unsigned long phys = 0;					\
+	if ((virt) >= PAGE_OFFSET + 0x40000000UL)		\
+		phys = (virt) - PAGE_OFFSET + 0x50000000UL;	\
+	else if ((virt) >= PAGE_OFFSET + 0x20000000UL)		\
+		phys = (virt) - PAGE_OFFSET;			\
+	else if ((virt) >= PAGE_OFFSET)				\
+		phys = (virt) - PAGE_OFFSET + 0x70000000UL;	\
+	phys;							\
+})
+
+#endif
 
 /*
  * Virtual view <-> DMA view memory address translations
@@ -32,7 +90,7 @@
  * bus_to_virt: Used to convert an address for DMA operations
  *              to an address that the kernel can use.
  */
-#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
-#define __bus_to_virt(x)	((x) + PAGE_OFFSET)
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
 
 #endif
diff --git a/arch/arm/mach-realview/include/mach/platform.h b/arch/arm/mach-realview/include/mach/platform.h
index 793a3a3..df6b993 100644
--- a/arch/arm/mach-realview/include/mach/platform.h
+++ b/arch/arm/mach-realview/include/mach/platform.h
@@ -203,6 +203,12 @@
 #define REALVIEW_SDRAM67_BASE         0x70000000	/* SDRAM banks 6 and 7 */
 #define REALVIEW_LT_BASE              0x80000000	/* Logic Tile expansion */
 
+/* 
+ * CompactFlash
+ */
+#define REALVIEW_CF_BASE		0x18000000	/* CompactFlash */
+#define REALVIEW_CF_MEM_BASE		0x18003000	/* SMC for CompactFlash */
+
 /*
  * Disk on Chip
  */
diff --git a/arch/arm/mach-realview/include/mach/uncompress.h b/arch/arm/mach-realview/include/mach/uncompress.h
index 79f50f2..8305037 100644
--- a/arch/arm/mach-realview/include/mach/uncompress.h
+++ b/arch/arm/mach-realview/include/mach/uncompress.h
@@ -23,6 +23,8 @@
 #include <mach/board-eb.h>
 #include <mach/board-pb11mp.h>
 #include <mach/board-pb1176.h>
+#include <mach/board-pba8.h>
+#include <mach/board-pbx.h>
 
 #define AMBA_UART_DR(base)	(*(volatile unsigned char *)((base) + 0x00))
 #define AMBA_UART_LCRH(base)	(*(volatile unsigned char *)((base) + 0x2c))
@@ -40,6 +42,10 @@ static inline unsigned long get_uart_base(void)
 		return REALVIEW_PB11MP_UART0_BASE;
 	else if (machine_is_realview_pb1176())
 		return REALVIEW_PB1176_UART0_BASE;
+	else if (machine_is_realview_pba8())
+		return REALVIEW_PBA8_UART0_BASE;
+	else if (machine_is_realview_pbx())
+		return REALVIEW_PBX_UART0_BASE;
 	else
 		return 0;
 }
diff --git a/arch/arm/mach-realview/include/mach/vmalloc.h b/arch/arm/mach-realview/include/mach/vmalloc.h
index 48cbcc8..fe0de1b 100644
--- a/arch/arm/mach-realview/include/mach/vmalloc.h
+++ b/arch/arm/mach-realview/include/mach/vmalloc.h
@@ -18,4 +18,4 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
-#define VMALLOC_END		(PAGE_OFFSET + 0x18000000)
+#define VMALLOC_END		0xf8000000
diff --git a/arch/arm/mach-realview/localtimer.c b/arch/arm/mach-realview/localtimer.c
index 44d178c..9019ef2 100644
--- a/arch/arm/mach-realview/localtimer.c
+++ b/arch/arm/mach-realview/localtimer.c
@@ -38,18 +38,14 @@ void local_timer_interrupt(void)
 
 #ifdef CONFIG_LOCAL_TIMERS
 
-#define TWD_BASE(cpu)	(twd_base_addr + (cpu) * twd_size)
-
 /* set up by the platform code */
-void __iomem *twd_base_addr;
-unsigned int twd_size;
+void __iomem *twd_base;
 
 static unsigned long mpcore_timer_rate;
 
 static void local_timer_set_mode(enum clock_event_mode mode,
 				 struct clock_event_device *clk)
 {
-	void __iomem *base = TWD_BASE(smp_processor_id());
 	unsigned long ctrl;
 
 	switch(mode) {
@@ -68,17 +64,16 @@ static void local_timer_set_mode(enum clock_event_mode mode,
 		ctrl = 0;
 	}
 
-	__raw_writel(ctrl, base + TWD_TIMER_CONTROL);
+	__raw_writel(ctrl, twd_base + TWD_TIMER_CONTROL);
 }
 
 static int local_timer_set_next_event(unsigned long evt,
 				      struct clock_event_device *unused)
 {
-	void __iomem *base = TWD_BASE(smp_processor_id());
-	unsigned long ctrl = __raw_readl(base + TWD_TIMER_CONTROL);
+	unsigned long ctrl = __raw_readl(twd_base + TWD_TIMER_CONTROL);
 
-	__raw_writel(evt, base + TWD_TIMER_COUNTER);
-	__raw_writel(ctrl | TWD_TIMER_CONTROL_ENABLE, base + TWD_TIMER_CONTROL);
+	__raw_writel(evt, twd_base + TWD_TIMER_COUNTER);
+	__raw_writel(ctrl | TWD_TIMER_CONTROL_ENABLE, twd_base + TWD_TIMER_CONTROL);
 
 	return 0;
 }
@@ -91,19 +86,16 @@ static int local_timer_set_next_event(unsigned long evt,
  */
 int local_timer_ack(void)
 {
-	void __iomem *base = TWD_BASE(smp_processor_id());
-
-	if (__raw_readl(base + TWD_TIMER_INTSTAT)) {
-		__raw_writel(1, base + TWD_TIMER_INTSTAT);
+	if (__raw_readl(twd_base + TWD_TIMER_INTSTAT)) {
+		__raw_writel(1, twd_base + TWD_TIMER_INTSTAT);
 		return 1;
 	}
 
 	return 0;
 }
 
-static void __cpuinit twd_calibrate_rate(unsigned int cpu)
+static void __cpuinit twd_calibrate_rate(void)
 {
-	void __iomem *base = TWD_BASE(cpu);
 	unsigned long load, count;
 	u64 waitjiffies;
 
@@ -124,15 +116,15 @@ static void __cpuinit twd_calibrate_rate(unsigned int cpu)
 		waitjiffies += 5;
 
 				 /* enable, no interrupt or reload */
-		__raw_writel(0x1, base + TWD_TIMER_CONTROL);
+		__raw_writel(0x1, twd_base + TWD_TIMER_CONTROL);
 
 				 /* maximum value */
-		__raw_writel(0xFFFFFFFFU, base + TWD_TIMER_COUNTER);
+		__raw_writel(0xFFFFFFFFU, twd_base + TWD_TIMER_COUNTER);
 
 		while (get_jiffies_64() < waitjiffies)
 			udelay(10);
 
-		count = __raw_readl(base + TWD_TIMER_COUNTER);
+		count = __raw_readl(twd_base + TWD_TIMER_COUNTER);
 
 		mpcore_timer_rate = (0xFFFFFFFFU - count) * (HZ / 5);
 
@@ -142,18 +134,19 @@ static void __cpuinit twd_calibrate_rate(unsigned int cpu)
 
 	load = mpcore_timer_rate / HZ;
 
-	__raw_writel(load, base + TWD_TIMER_LOAD);
+	__raw_writel(load, twd_base + TWD_TIMER_LOAD);
 }
 
 /*
  * Setup the local clock events for a CPU.
  */
-void __cpuinit local_timer_setup(unsigned int cpu)
+void __cpuinit local_timer_setup(void)
 {
+	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *clk = &per_cpu(local_clockevent, cpu);
 	unsigned long flags;
 
-	twd_calibrate_rate(cpu);
+	twd_calibrate_rate();
 
 	clk->name		= "local_timer";
 	clk->features		= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;
@@ -178,9 +171,9 @@ void __cpuinit local_timer_setup(unsigned int cpu)
 /*
  * take a local timer down
  */
-void __cpuexit local_timer_stop(unsigned int cpu)
+void __cpuexit local_timer_stop(void)
 {
-	__raw_writel(0, TWD_BASE(cpu) + TWD_TIMER_CONTROL);
+	__raw_writel(0, twd_base + TWD_TIMER_CONTROL);
 }
 
 #else	/* CONFIG_LOCAL_TIMERS */
@@ -190,8 +183,9 @@ static void dummy_timer_set_mode(enum clock_event_mode mode,
 {
 }
 
-void __cpuinit local_timer_setup(unsigned int cpu)
+void __cpuinit local_timer_setup(void)
 {
+	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *clk = &per_cpu(local_clockevent, cpu);
 
 	clk->name		= "dummy_timer";
diff --git a/arch/arm/mach-realview/platsmp.c b/arch/arm/mach-realview/platsmp.c
index e102aeb..4954a45 100644
--- a/arch/arm/mach-realview/platsmp.c
+++ b/arch/arm/mach-realview/platsmp.c
@@ -18,11 +18,14 @@
 #include <asm/cacheflush.h>
 #include <mach/hardware.h>
 #include <asm/mach-types.h>
+#include <asm/unified.h>
 
 #include <mach/board-eb.h>
 #include <mach/board-pb11mp.h>
 #include <mach/scu.h>
 
+#include "core.h"
+
 extern void realview_secondary_startup(void);
 
 /*
@@ -31,15 +34,23 @@ extern void realview_secondary_startup(void);
  */
 volatile int __cpuinitdata pen_release = -1;
 
+static void __iomem *scu_base_addr(void)
+{
+	if (machine_is_realview_eb_mp())
+		return __io_address(REALVIEW_EB11MP_SCU_BASE);
+	else if (machine_is_realview_pb11mp())
+		return __io_address(REALVIEW_TC11MP_SCU_BASE);
+	else if (machine_is_realview_pbx() &&
+		 (core_tile_pbx11mp() || core_tile_pbxa9mp()))
+		return __io_address(REALVIEW_PBX_TILE_SCU_BASE);
+	else
+		return (void __iomem *)0;
+}
+
 static unsigned int __init get_core_count(void)
 {
 	unsigned int ncores;
-	void __iomem *scu_base = 0;
-
-	if (machine_is_realview_eb() && core_tile_eb11mp())
-		scu_base = __io_address(REALVIEW_EB11MP_SCU_BASE);
-	else if (machine_is_realview_pb11mp())
-		scu_base = __io_address(REALVIEW_TC11MP_SCU_BASE);
+	void __iomem *scu_base = scu_base_addr();
 
 	if (scu_base) {
 		ncores = __raw_readl(scu_base + SCU_CONFIG);
@@ -56,18 +67,14 @@ static unsigned int __init get_core_count(void)
 static void scu_enable(void)
 {
 	u32 scu_ctrl;
-	void __iomem *scu_base;
-
-	if (machine_is_realview_eb() && core_tile_eb11mp())
-		scu_base = __io_address(REALVIEW_EB11MP_SCU_BASE);
-	else if (machine_is_realview_pb11mp())
-		scu_base = __io_address(REALVIEW_TC11MP_SCU_BASE);
-	else
-		BUG();
+	void __iomem *scu_base = scu_base_addr();
 
 	scu_ctrl = __raw_readl(scu_base + SCU_CTRL);
-	scu_ctrl |= 1;
-	__raw_writel(scu_ctrl, scu_base + SCU_CTRL);
+	if (!(scu_ctrl & 1)) {
+		/* not enabled yet */
+		scu_ctrl |= 1;
+		__raw_writel(scu_ctrl, scu_base + SCU_CTRL);
+	}
 }
 
 static DEFINE_SPINLOCK(boot_lock);
@@ -88,10 +95,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	 * core (e.g. timer irq), then they will not have been enabled
 	 * for us: do so
 	 */
-	if (machine_is_realview_eb() && core_tile_eb11mp())
-		gic_cpu_init(0, __io_address(REALVIEW_EB11MP_GIC_CPU_BASE));
-	else if (machine_is_realview_pb11mp())
-		gic_cpu_init(0, __io_address(REALVIEW_TC11MP_GIC_CPU_BASE));
+	gic_cpu_init(0, gic_cpu_base_addr);
 
 	/*
 	 * let the primary processor know we're out of the
@@ -125,8 +129,11 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * Note that "pen_release" is the hardware CPU ID, whereas
 	 * "cpu" is Linux's internal ID.
 	 */
+	flush_cache_all();
+	outer_clean_range(__pa(&secondary_data), __pa(&secondary_data + 1));
 	pen_release = cpu;
 	flush_cache_all();
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
 
 	/*
 	 * XXX
@@ -160,26 +167,20 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 
 static void __init poke_milo(void)
 {
-	extern void secondary_startup(void);
-
 	/* nobody is to be released from the pen yet */
 	pen_release = -1;
 
 	/*
-	 * write the address of secondary startup into the system-wide
-	 * flags register, then clear the bottom two bits, which is what
-	 * BootMonitor is waiting for
+	 * Write the address of secondary startup into the system-wide flags
+	 * register. The BootMonitor waits for this register to become
+	 * non-zero.
 	 */
-#if 1
+
 #define REALVIEW_SYS_FLAGSS_OFFSET 0x30
-	__raw_writel(virt_to_phys(realview_secondary_startup),
-		     __io_address(REALVIEW_SYS_BASE) +
-		     REALVIEW_SYS_FLAGSS_OFFSET);
 #define REALVIEW_SYS_FLAGSC_OFFSET 0x34
-	__raw_writel(3,
+	__raw_writel(BSYM(virt_to_phys(realview_secondary_startup)),
 		     __io_address(REALVIEW_SYS_BASE) +
-		     REALVIEW_SYS_FLAGSC_OFFSET);
-#endif
+		     REALVIEW_SYS_FLAGSS_OFFSET);
 
 	mb();
 }
@@ -232,9 +233,7 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	 * dummy (!CONFIG_LOCAL_TIMERS), it was already registers in
 	 * realview_timer_init
 	 */
-	if ((machine_is_realview_eb() && core_tile_eb11mp()) ||
-	    machine_is_realview_pb11mp())
-		local_timer_setup(cpu);
+	local_timer_setup();
 #endif
 
 	/*
@@ -253,6 +252,11 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	 */
 	if (max_cpus > 1) {
 		scu_enable();
+		/*
+		 * Ensure that the data accessed by CPU0 before the SCU was
+		 * initialised is visible to the other CPUs.
+		 */
+		flush_cache_all();
 		poke_milo();
 	}
 }
diff --git a/arch/arm/mach-realview/realview_eb.c b/arch/arm/mach-realview/realview_eb.c
index eb829eb..f439cca 100644
--- a/arch/arm/mach-realview/realview_eb.c
+++ b/arch/arm/mach-realview/realview_eb.c
@@ -108,7 +108,7 @@ static struct map_desc realview_eb11mp_io_desc[] __initdata = {
 static void __init realview_eb_map_io(void)
 {
 	iotable_init(realview_eb_io_desc, ARRAY_SIZE(realview_eb_io_desc));
-	if (core_tile_eb11mp())
+	if (core_tile_eb11mp() || core_tile_a9mp())
 		iotable_init(realview_eb11mp_io_desc, ARRAY_SIZE(realview_eb11mp_io_desc));
 }
 
@@ -242,12 +242,6 @@ static struct resource realview_eb_eth_resources[] = {
 	},
 };
 
-static struct platform_device realview_eb_eth_device = {
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(realview_eb_eth_resources),
-	.resource	= realview_eb_eth_resources,
-};
-
 /*
  * Detect and register the correct Ethernet device. RealView/EB rev D
  * platforms use the newer SMSC LAN9118 Ethernet chip
@@ -255,26 +249,37 @@ static struct platform_device realview_eb_eth_device = {
 static int eth_device_register(void)
 {
 	void __iomem *eth_addr = ioremap(REALVIEW_EB_ETH_BASE, SZ_4K);
+	const char *name = NULL;
 	u32 idrev;
 
 	if (!eth_addr)
 		return -ENOMEM;
 
 	idrev = readl(eth_addr + 0x50);
-	if ((idrev & 0xFFFF0000) == 0x01180000)
-		/* SMSC LAN9118 chip present */
-		realview_eb_eth_device.name = "smc911x";
-	else
-		/* SMSC 91C111 chip present */
-		realview_eb_eth_device.name = "smc91x";
+	if ((idrev & 0xFFFF0000) != 0x01180000)
+		/* SMSC LAN9118 not present, use LAN91C111 instead */
+		name = "smc91x";
 
 	iounmap(eth_addr);
-	return platform_device_register(&realview_eb_eth_device);
+	return realview_eth_register(name, realview_eb_eth_resources);
 }
 
+static struct resource realview_eb_isp1761_resources[] = {
+	[0] = {
+		.start		= REALVIEW_EB_USB_BASE,
+		.end		= REALVIEW_EB_USB_BASE + SZ_128K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_EB_USB,
+		.end		= IRQ_EB_USB,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
 static void __init gic_init_irq(void)
 {
-	if (core_tile_eb11mp()) {
+	if (core_tile_eb11mp() || core_tile_a9mp()) {
 		unsigned int pldctrl;
 
 		/* new irq mode */
@@ -331,6 +336,8 @@ static void realview_eb11mp_fixup(void)
 	/* platform devices */
 	realview_eb_eth_resources[1].start	= IRQ_EB11MP_ETH;
 	realview_eb_eth_resources[1].end	= IRQ_EB11MP_ETH;
+	realview_eb_isp1761_resources[1].start	= IRQ_EB11MP_USB;
+	realview_eb_isp1761_resources[1].end	= IRQ_EB11MP_USB;
 }
 
 static void __init realview_eb_timer_init(void)
@@ -342,10 +349,9 @@ static void __init realview_eb_timer_init(void)
 	timer2_va_base = __io_address(REALVIEW_EB_TIMER2_3_BASE);
 	timer3_va_base = __io_address(REALVIEW_EB_TIMER2_3_BASE) + 0x20;
 
-	if (core_tile_eb11mp()) {
+	if (core_tile_eb11mp() || core_tile_a9mp()) {
 #ifdef CONFIG_LOCAL_TIMERS
-		twd_base_addr = __io_address(REALVIEW_EB11MP_TWD_BASE);
-		twd_size = REALVIEW_EB11MP_TWD_SIZE;
+		twd_base = __io_address(REALVIEW_EB11MP_TWD_BASE);
 #endif
 		timer_irq = IRQ_EB11MP_TIMER0_1;
 	} else
@@ -358,25 +364,34 @@ static struct sys_timer realview_eb_timer = {
 	.init		= realview_eb_timer_init,
 };
 
+#ifdef CONFIG_CACHE_L2X0
+static int __init realview_eb_l2x0_init(void)
+{
+	if (machine_is_realview_eb_mp())
+		/*
+		 * 1MB (128KB/way), 8-way associativity, evmon/parity/share
+		 * Bits:  .... ...0 0111 1001 0000 .... .... ....
+		 */
+		l2x0_init(__io_address(REALVIEW_EB11MP_L220_BASE),
+			  0x00790000, 0xfe000fff);
+	return 0;
+}
+early_initcall(realview_eb_l2x0_init);
+#endif
+
 static void __init realview_eb_init(void)
 {
 	int i;
 
-	if (core_tile_eb11mp()) {
+	if (core_tile_eb11mp() || core_tile_a9mp())
 		realview_eb11mp_fixup();
 
-#ifdef CONFIG_CACHE_L2X0
-		/* 1MB (128KB/way), 8-way associativity, evmon/parity/share enabled
-		 * Bits:  .... ...0 0111 1001 0000 .... .... .... */
-		l2x0_init(__io_address(REALVIEW_EB11MP_L220_BASE), 0x00790000, 0xfe000fff);
-#endif
-	}
-
 	clk_register(&realview_clcd_clk);
 
 	realview_flash_register(&realview_eb_flash_resource, 1);
 	platform_device_register(&realview_i2c_device);
 	eth_device_register();
+	realview_usb_register(realview_eb_isp1761_resources);
 
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
 		struct amba_device *d = amba_devs[i];
@@ -392,7 +407,7 @@ MACHINE_START(REALVIEW_EB, "ARM-RealView EB")
 	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
 	.phys_io	= REALVIEW_EB_UART0_BASE,
 	.io_pg_offst	= (IO_ADDRESS(REALVIEW_EB_UART0_BASE) >> 18) & 0xfffc,
-	.boot_params	= 0x00000100,
+	.boot_params	= PHYS_OFFSET + 0x00000100,
 	.map_io		= realview_eb_map_io,
 	.init_irq	= gic_init_irq,
 	.timer		= &realview_eb_timer,
diff --git a/arch/arm/mach-realview/realview_pb1176.c b/arch/arm/mach-realview/realview_pb1176.c
index cccdb3e..237ce3c 100644
--- a/arch/arm/mach-realview/realview_pb1176.c
+++ b/arch/arm/mach-realview/realview_pb1176.c
@@ -91,6 +91,12 @@ static struct map_desc realview_pb1176_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(REALVIEW_PB1176_L220_BASE),
 		.length		= SZ_8K,
 		.type		= MT_DEVICE,
+	}, {
+		/* needed for SD/MMC detection */
+		.virtual	= IO_ADDRESS(REALVIEW_GPIO2_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_GPIO2_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
 	},
 #ifdef CONFIG_DEBUG_LL
 	{
@@ -152,6 +158,8 @@ static void __init realview_pb1176_map_io(void)
 #define PB1176_UART3_DMA	{ 0x86, 0x87 }
 #define PB1176_SSP_IRQ		{ IRQ_PB1176_SSP, NO_IRQ }
 #define PB1176_SSP_DMA		{ 9, 8 }
+#define PB1176_IEC_IRQ	{ IRQ_DC1176_IEC, NO_IRQ }
+#define PB1176_IEC_DMA	{ 0, 0 }
 
 /* FPGA Primecells */
 AMBA_DEVICE(aaci,	"fpga:04",	AACI,		NULL);
@@ -173,6 +181,7 @@ AMBA_DEVICE(uart0,	"dev:f1",	PB1176_UART0,	NULL);
 AMBA_DEVICE(uart1,	"dev:f2",	PB1176_UART1,	NULL);
 AMBA_DEVICE(uart2,	"dev:f3",	PB1176_UART2,	NULL);
 AMBA_DEVICE(ssp0,	"dev:f4",	PB1176_SSP,	NULL);
+AMBA_DEVICE(iec,	"dev:f5",	PB1176_IEC,	NULL);
 
 /* Primecells on the NEC ISSP chip */
 AMBA_DEVICE(clcd,	"issp:20",	PB1176_CLCD,	&clcd_plat_data);
@@ -198,16 +207,29 @@ static struct amba_device *amba_devs[] __initdata = {
 	&mmc0_device,
 	&kmi0_device,
 	&kmi1_device,
+	&iec_device,
 };
 
 /*
  * RealView PB1176 platform devices
  */
-static struct resource realview_pb1176_flash_resource = {
-	.start			= REALVIEW_PB1176_FLASH_BASE,
-	.end			= REALVIEW_PB1176_FLASH_BASE + REALVIEW_PB1176_FLASH_SIZE - 1,
-	.flags			= IORESOURCE_MEM,
+static struct resource realview_pb1176_flash_resources[] = {
+	[0] = {
+		.start		= REALVIEW_PB1176_FLASH_BASE,
+		.end		= REALVIEW_PB1176_FLASH_BASE + REALVIEW_PB1176_FLASH_SIZE - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= REALVIEW_PB1176_SEC_FLASH_BASE,
+		.end		= REALVIEW_PB1176_SEC_FLASH_BASE + REALVIEW_PB1176_SEC_FLASH_SIZE - 1,
+		.flags		= IORESOURCE_MEM,
+	},
 };
+#ifdef CONFIG_REALVIEW_PB1176_SECURE_FLASH
+#define PB1176_FLASH_BLOCKS	2
+#else
+#define PB1176_FLASH_BLOCKS	1
+#endif
 
 static struct resource realview_pb1176_smsc911x_resources[] = {
 	[0] = {
@@ -222,11 +244,17 @@ static struct resource realview_pb1176_smsc911x_resources[] = {
 	},
 };
 
-static struct platform_device realview_pb1176_smsc911x_device = {
-	.name		= "smc911x",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(realview_pb1176_smsc911x_resources),
-	.resource	= realview_pb1176_smsc911x_resources,
+static struct resource realview_pb1176_isp1761_resources[] = {
+	[0] = {
+		.start		= REALVIEW_PB1176_USB_BASE,
+		.end		= REALVIEW_PB1176_USB_BASE + SZ_128K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_PB1176_USB,
+		.end		= IRQ_PB1176_USB,
+		.flags		= IORESOURCE_IRQ,
+	},
 };
 
 static void __init gic_init_irq(void)
@@ -267,8 +295,11 @@ static void __init realview_pb1176_init(void)
 
 	clk_register(&realview_clcd_clk);
 
-	realview_flash_register(&realview_pb1176_flash_resource, 1);
-	platform_device_register(&realview_pb1176_smsc911x_device);
+	realview_flash_register(realview_pb1176_flash_resources,
+				PB1176_FLASH_BLOCKS);
+	realview_eth_register(NULL, realview_pb1176_smsc911x_resources);
+	platform_device_register(&realview_i2c_device);
+	realview_usb_register(realview_pb1176_isp1761_resources);
 
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
 		struct amba_device *d = amba_devs[i];
@@ -284,7 +315,7 @@ MACHINE_START(REALVIEW_PB1176, "ARM-RealView PB1176")
 	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
 	.phys_io	= REALVIEW_PB1176_UART0_BASE,
 	.io_pg_offst	= (IO_ADDRESS(REALVIEW_PB1176_UART0_BASE) >> 18) & 0xfffc,
-	.boot_params	= 0x00000100,
+	.boot_params	= PHYS_OFFSET + 0x00000100,
 	.map_io		= realview_pb1176_map_io,
 	.init_irq	= gic_init_irq,
 	.timer		= &realview_pb1176_timer,
diff --git a/arch/arm/mach-realview/realview_pb11mp.c b/arch/arm/mach-realview/realview_pb11mp.c
index 8b86314..95e48e1 100644
--- a/arch/arm/mach-realview/realview_pb11mp.c
+++ b/arch/arm/mach-realview/realview_pb11mp.c
@@ -230,38 +230,19 @@ static struct resource realview_pb11mp_smsc911x_resources[] = {
 	},
 };
 
-static struct platform_device realview_pb11mp_smsc911x_device = {
-	.name		= "smc911x",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(realview_pb11mp_smsc911x_resources),
-	.resource	= realview_pb11mp_smsc911x_resources,
-};
-
-struct resource realview_pb11mp_cf_resources[] = {
+static struct resource realview_pb11mp_isp1761_resources[] = {
 	[0] = {
-		.start		= REALVIEW_PB11MP_CF_BASE,
-		.end		= REALVIEW_PB11MP_CF_BASE + SZ_4K - 1,
+		.start		= REALVIEW_PB11MP_USB_BASE,
+		.end		= REALVIEW_PB11MP_USB_BASE + SZ_128K - 1,
 		.flags		= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start		= REALVIEW_PB11MP_CF_MEM_BASE,
-		.end		= REALVIEW_PB11MP_CF_MEM_BASE + SZ_4K - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	[2] = {
-		.start		= -1,		/* FIXME: Find correct irq */
-		.end		= -1,
+		.start		= IRQ_TC11MP_USB,
+		.end		= IRQ_TC11MP_USB,
 		.flags		= IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device realview_pb11mp_cf_device = {
-	.name		= "compactflash",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(realview_pb11mp_cf_resources),
-	.resource	= realview_pb11mp_cf_resources,
-};
-
 static void __init gic_init_irq(void)
 {
 	unsigned int pldctrl;
@@ -292,8 +273,7 @@ static void __init realview_pb11mp_timer_init(void)
 	timer3_va_base = __io_address(REALVIEW_PB11MP_TIMER2_3_BASE) + 0x20;
 
 #ifdef CONFIG_LOCAL_TIMERS
-	twd_base_addr = __io_address(REALVIEW_TC11MP_TWD_BASE);
-	twd_size = REALVIEW_TC11MP_TWD_SIZE;
+	twd_base = __io_address(REALVIEW_TC11MP_TWD_BASE);
 #endif
 	realview_timer_init(IRQ_TC11MP_TIMER0_1);
 }
@@ -302,23 +282,34 @@ static struct sys_timer realview_pb11mp_timer = {
 	.init		= realview_pb11mp_timer_init,
 };
 
+#ifdef CONFIG_CACHE_L2X0
+static int __init realview_pb11mp_l2x0_init(void)
+{
+	if (machine_is_realview_pb11mp()) {
+		/*
+		 * 1MB (128KB/way), 8-way associativity, evmon/parity/share
+		 * Bits:  .... ...0 0111 1001 0000 .... .... ....
+		 */
+		l2x0_init(__io_address(REALVIEW_TC11MP_L220_BASE),
+			  0x00790000, 0xfe000fff);
+	}
+	return 0;
+}
+early_initcall(realview_pb11mp_l2x0_init);
+#endif
+
 static void __init realview_pb11mp_init(void)
 {
 	int i;
 
-#ifdef CONFIG_CACHE_L2X0
-	/* 1MB (128KB/way), 8-way associativity, evmon/parity/share enabled
-	 * Bits:  .... ...0 0111 1001 0000 .... .... .... */
-	l2x0_init(__io_address(REALVIEW_TC11MP_L220_BASE), 0x00790000, 0xfe000fff);
-#endif
-
 	clk_register(&realview_clcd_clk);
 
 	realview_flash_register(realview_pb11mp_flash_resource,
 				ARRAY_SIZE(realview_pb11mp_flash_resource));
-	platform_device_register(&realview_pb11mp_smsc911x_device);
+	realview_eth_register(NULL, realview_pb11mp_smsc911x_resources);
 	platform_device_register(&realview_i2c_device);
-	platform_device_register(&realview_pb11mp_cf_device);
+	platform_device_register(&realview_cf_device);
+	realview_usb_register(realview_pb11mp_isp1761_resources);
 
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
 		struct amba_device *d = amba_devs[i];
@@ -334,7 +325,7 @@ MACHINE_START(REALVIEW_PB11MP, "ARM-RealView PB11MPCore")
 	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
 	.phys_io	= REALVIEW_PB11MP_UART0_BASE,
 	.io_pg_offst	= (IO_ADDRESS(REALVIEW_PB11MP_UART0_BASE) >> 18) & 0xfffc,
-	.boot_params	= 0x00000100,
+	.boot_params	= PHYS_OFFSET + 0x00000100,
 	.map_io		= realview_pb11mp_map_io,
 	.init_irq	= gic_init_irq,
 	.timer		= &realview_pb11mp_timer,
diff --git a/arch/arm/mach-realview/realview_pba8.c b/arch/arm/mach-realview/realview_pba8.c
new file mode 100644
index 0000000..ae0ab4c
--- /dev/null
+++ b/arch/arm/mach-realview/realview_pba8.c
@@ -0,0 +1,291 @@
+/*
+ *  linux/arch/arm/mach-realview/realview_pba8.c
+ *
+ *  Copyright (C) 2008 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/amba/bus.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/icst307.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/mmc.h>
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/board-pba8.h>
+#include <mach/irqs.h>
+
+#include "core.h"
+#include "clock.h"
+
+static struct map_desc realview_pba8_io_desc[] __initdata = {
+	{
+		.virtual	= IO_ADDRESS(REALVIEW_SYS_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_SYS_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_PBA8_GIC_CPU_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBA8_GIC_CPU_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_PBA8_GIC_DIST_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBA8_GIC_DIST_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_SCTL_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_SCTL_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_PBA8_TIMER0_1_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBA8_TIMER0_1_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_PBA8_TIMER2_3_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBA8_TIMER2_3_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	},
+#ifdef CONFIG_PCI
+	{
+		.virtual	= PCIX_UNIT_BASE,
+		.pfn		= __phys_to_pfn(REALVIEW_PBA8_PCI_BASE),
+		.length		= REALVIEW_PBA8_PCI_BASE_SIZE,
+		.type		= MT_DEVICE
+	},
+#endif
+#ifdef CONFIG_DEBUG_LL
+	{
+		.virtual	= IO_ADDRESS(REALVIEW_PBA8_UART0_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBA8_UART0_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	},
+#endif
+};
+
+static void __init realview_pba8_map_io(void)
+{
+	iotable_init(realview_pba8_io_desc, ARRAY_SIZE(realview_pba8_io_desc));
+}
+
+/*
+ * RealView PBA8Core AMBA devices
+ */
+
+#define GPIO2_IRQ		{ IRQ_PBA8_GPIO2, NO_IRQ }
+#define GPIO2_DMA		{ 0, 0 }
+#define GPIO3_IRQ		{ IRQ_PBA8_GPIO3, NO_IRQ }
+#define GPIO3_DMA		{ 0, 0 }
+#define AACI_IRQ		{ IRQ_PBA8_AACI, NO_IRQ }
+#define AACI_DMA		{ 0x80, 0x81 }
+#define MMCI0_IRQ		{ IRQ_PBA8_MMCI0A, IRQ_PBA8_MMCI0B }
+#define MMCI0_DMA		{ 0x84, 0 }
+#define KMI0_IRQ		{ IRQ_PBA8_KMI0, NO_IRQ }
+#define KMI0_DMA		{ 0, 0 }
+#define KMI1_IRQ		{ IRQ_PBA8_KMI1, NO_IRQ }
+#define KMI1_DMA		{ 0, 0 }
+#define PBA8_SMC_IRQ		{ NO_IRQ, NO_IRQ }
+#define PBA8_SMC_DMA		{ 0, 0 }
+#define MPMC_IRQ		{ NO_IRQ, NO_IRQ }
+#define MPMC_DMA		{ 0, 0 }
+#define PBA8_CLCD_IRQ		{ IRQ_PBA8_CLCD, NO_IRQ }
+#define PBA8_CLCD_DMA		{ 0, 0 }
+#define DMAC_IRQ		{ IRQ_PBA8_DMAC, NO_IRQ }
+#define DMAC_DMA		{ 0, 0 }
+#define SCTL_IRQ		{ NO_IRQ, NO_IRQ }
+#define SCTL_DMA		{ 0, 0 }
+#define PBA8_WATCHDOG_IRQ	{ IRQ_PBA8_WATCHDOG, NO_IRQ }
+#define PBA8_WATCHDOG_DMA	{ 0, 0 }
+#define PBA8_GPIO0_IRQ		{ IRQ_PBA8_GPIO0, NO_IRQ }
+#define PBA8_GPIO0_DMA		{ 0, 0 }
+#define GPIO1_IRQ		{ IRQ_PBA8_GPIO1, NO_IRQ }
+#define GPIO1_DMA		{ 0, 0 }
+#define PBA8_RTC_IRQ		{ IRQ_PBA8_RTC, NO_IRQ }
+#define PBA8_RTC_DMA		{ 0, 0 }
+#define SCI_IRQ			{ IRQ_PBA8_SCI, NO_IRQ }
+#define SCI_DMA			{ 7, 6 }
+#define PBA8_UART0_IRQ		{ IRQ_PBA8_UART0, NO_IRQ }
+#define PBA8_UART0_DMA		{ 15, 14 }
+#define PBA8_UART1_IRQ		{ IRQ_PBA8_UART1, NO_IRQ }
+#define PBA8_UART1_DMA		{ 13, 12 }
+#define PBA8_UART2_IRQ		{ IRQ_PBA8_UART2, NO_IRQ }
+#define PBA8_UART2_DMA		{ 11, 10 }
+#define PBA8_UART3_IRQ		{ IRQ_PBA8_UART3, NO_IRQ }
+#define PBA8_UART3_DMA		{ 0x86, 0x87 }
+#define PBA8_SSP_IRQ		{ IRQ_PBA8_SSP, NO_IRQ }
+#define PBA8_SSP_DMA		{ 9, 8 }
+
+/* FPGA Primecells */
+AMBA_DEVICE(aaci,	"fpga:04",	AACI,		NULL);
+AMBA_DEVICE(mmc0,	"fpga:05",	MMCI0,		&realview_mmc0_plat_data);
+AMBA_DEVICE(kmi0,	"fpga:06",	KMI0,		NULL);
+AMBA_DEVICE(kmi1,	"fpga:07",	KMI1,		NULL);
+AMBA_DEVICE(uart3,	"fpga:09",	PBA8_UART3,	NULL);
+
+/* DevChip Primecells */
+AMBA_DEVICE(smc,	"dev:00",	PBA8_SMC,	NULL);
+AMBA_DEVICE(sctl,	"dev:e0",	SCTL,		NULL);
+AMBA_DEVICE(wdog,	"dev:e1",	PBA8_WATCHDOG, NULL);
+AMBA_DEVICE(gpio0,	"dev:e4",	PBA8_GPIO0,	NULL);
+AMBA_DEVICE(gpio1,	"dev:e5",	GPIO1,		NULL);
+AMBA_DEVICE(gpio2,	"dev:e6",	GPIO2,		NULL);
+AMBA_DEVICE(rtc,	"dev:e8",	PBA8_RTC,	NULL);
+AMBA_DEVICE(sci0,	"dev:f0",	SCI,		NULL);
+AMBA_DEVICE(uart0,	"dev:f1",	PBA8_UART0,	NULL);
+AMBA_DEVICE(uart1,	"dev:f2",	PBA8_UART1,	NULL);
+AMBA_DEVICE(uart2,	"dev:f3",	PBA8_UART2,	NULL);
+AMBA_DEVICE(ssp0,	"dev:f4",	PBA8_SSP,	NULL);
+
+/* Primecells on the NEC ISSP chip */
+AMBA_DEVICE(clcd,	"issp:20",	PBA8_CLCD,	&clcd_plat_data);
+AMBA_DEVICE(dmac,	"issp:30",	DMAC,		NULL);
+
+static struct amba_device *amba_devs[] __initdata = {
+	&dmac_device,
+	&uart0_device,
+	&uart1_device,
+	&uart2_device,
+	&uart3_device,
+	&smc_device,
+	&clcd_device,
+	&sctl_device,
+	&wdog_device,
+	&gpio0_device,
+	&gpio1_device,
+	&gpio2_device,
+	&rtc_device,
+	&sci0_device,
+	&ssp0_device,
+	&aaci_device,
+	&mmc0_device,
+	&kmi0_device,
+	&kmi1_device,
+};
+
+/*
+ * RealView PB-A8 platform devices
+ */
+static struct resource realview_pba8_flash_resource[] = {
+	[0] = {
+		.start		= REALVIEW_PBA8_FLASH0_BASE,
+		.end		= REALVIEW_PBA8_FLASH0_BASE + REALVIEW_PBA8_FLASH0_SIZE - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= REALVIEW_PBA8_FLASH1_BASE,
+		.end		= REALVIEW_PBA8_FLASH1_BASE + REALVIEW_PBA8_FLASH1_SIZE - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+static struct resource realview_pba8_smsc911x_resources[] = {
+	[0] = {
+		.start		= REALVIEW_PBA8_ETH_BASE,
+		.end		= REALVIEW_PBA8_ETH_BASE + SZ_64K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_PBA8_ETH,
+		.end		= IRQ_PBA8_ETH,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource realview_pba8_isp1761_resources[] = {
+	[0] = {
+		.start		= REALVIEW_PBA8_USB_BASE,
+		.end		= REALVIEW_PBA8_USB_BASE + SZ_128K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_PBA8_USB,
+		.end		= IRQ_PBA8_USB,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static void __init gic_init_irq(void)
+{
+	/* ARM PB-A8 on-board GIC */
+	gic_cpu_base_addr = __io_address(REALVIEW_PBA8_GIC_CPU_BASE);
+	gic_dist_init(0, __io_address(REALVIEW_PBA8_GIC_DIST_BASE), IRQ_PBA8_GIC_START);
+	gic_cpu_init(0, __io_address(REALVIEW_PBA8_GIC_CPU_BASE));
+}
+
+static void __init realview_pba8_timer_init(void)
+{
+	timer0_va_base = __io_address(REALVIEW_PBA8_TIMER0_1_BASE);
+	timer1_va_base = __io_address(REALVIEW_PBA8_TIMER0_1_BASE) + 0x20;
+	timer2_va_base = __io_address(REALVIEW_PBA8_TIMER2_3_BASE);
+	timer3_va_base = __io_address(REALVIEW_PBA8_TIMER2_3_BASE) + 0x20;
+
+	realview_timer_init(IRQ_PBA8_TIMER0_1);
+}
+
+static struct sys_timer realview_pba8_timer = {
+	.init		= realview_pba8_timer_init,
+};
+
+static void __init realview_pba8_init(void)
+{
+	int i;
+
+	clk_register(&realview_clcd_clk);
+
+	realview_flash_register(realview_pba8_flash_resource,
+				ARRAY_SIZE(realview_pba8_flash_resource));
+	realview_eth_register(NULL, realview_pba8_smsc911x_resources);
+	platform_device_register(&realview_i2c_device);
+	platform_device_register(&realview_cf_device);
+	realview_usb_register(realview_pba8_isp1761_resources);
+
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+
+#ifdef CONFIG_LEDS
+	leds_event = realview_leds_event;
+#endif
+}
+
+MACHINE_START(REALVIEW_PBA8, "ARM-RealView PB-A8")
+	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
+	.phys_io	= REALVIEW_PBA8_UART0_BASE,
+	.io_pg_offst	= (IO_ADDRESS(REALVIEW_PBA8_UART0_BASE) >> 18) & 0xfffc,
+	.boot_params	= PHYS_OFFSET + 0x00000100,
+	.map_io		= realview_pba8_map_io,
+	.init_irq	= gic_init_irq,
+	.timer		= &realview_pba8_timer,
+	.init_machine	= realview_pba8_init,
+MACHINE_END
diff --git a/arch/arm/mach-realview/realview_pbx.c b/arch/arm/mach-realview/realview_pbx.c
new file mode 100644
index 0000000..b6af0dc
--- /dev/null
+++ b/arch/arm/mach-realview/realview_pbx.c
@@ -0,0 +1,346 @@
+/*
+ *  arch/arm/mach-realview/realview_pbx.c
+ *
+ *  Copyright (C) 2009 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/amba/bus.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/icst307.h>
+#include <asm/hardware/cache-l2x0.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/mmc.h>
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/board-pbx.h>
+#include <mach/irqs.h>
+
+#include "core.h"
+#include "clock.h"
+
+static struct map_desc realview_pbx_io_desc[] __initdata = {
+	{
+		.virtual	= IO_ADDRESS(REALVIEW_SYS_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_SYS_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_PBX_GIC_CPU_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBX_GIC_CPU_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_PBX_GIC_DIST_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBX_GIC_DIST_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_SCTL_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_SCTL_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_PBX_TIMER0_1_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBX_TIMER0_1_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= IO_ADDRESS(REALVIEW_PBX_TIMER2_3_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBX_TIMER2_3_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	},
+#ifdef CONFIG_PCI
+	{
+		.virtual	= PCIX_UNIT_BASE,
+		.pfn		= __phys_to_pfn(REALVIEW_PBX_PCI_BASE),
+		.length		= REALVIEW_PBX_PCI_BASE_SIZE,
+		.type		= MT_DEVICE
+	},
+#endif
+#ifdef CONFIG_DEBUG_LL
+	{
+		.virtual	= IO_ADDRESS(REALVIEW_PBX_UART0_BASE),
+		.pfn		= __phys_to_pfn(REALVIEW_PBX_UART0_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	},
+#endif
+};
+
+static struct map_desc realview_local_io_desc[] __initdata = {
+	{
+		.virtual        = IO_ADDRESS(REALVIEW_PBX_TILE_GIC_CPU_BASE),
+		.pfn            = __phys_to_pfn(REALVIEW_PBX_TILE_GIC_CPU_BASE),
+		.length         = SZ_4K,
+		.type           = MT_DEVICE,
+	}, {
+		.virtual        = IO_ADDRESS(REALVIEW_PBX_TILE_GIC_DIST_BASE),
+		.pfn            = __phys_to_pfn(REALVIEW_PBX_TILE_GIC_DIST_BASE),
+		.length         = SZ_4K,
+		.type           = MT_DEVICE,
+	}, {
+		.virtual        = IO_ADDRESS(REALVIEW_PBX_TILE_L220_BASE),
+		.pfn            = __phys_to_pfn(REALVIEW_PBX_TILE_L220_BASE),
+		.length         = SZ_8K,
+		.type           = MT_DEVICE,
+	}
+};
+
+static void __init realview_pbx_map_io(void)
+{
+	iotable_init(realview_pbx_io_desc, ARRAY_SIZE(realview_pbx_io_desc));
+	if (core_tile_pbx11mp() || core_tile_pbxa9mp())
+		iotable_init(realview_local_io_desc, ARRAY_SIZE(realview_local_io_desc));
+}
+
+/*
+ * RealView PBXCore AMBA devices
+ */
+
+#define GPIO2_IRQ		{ IRQ_PBX_GPIO2, NO_IRQ }
+#define GPIO2_DMA		{ 0, 0 }
+#define GPIO3_IRQ		{ IRQ_PBX_GPIO3, NO_IRQ }
+#define GPIO3_DMA		{ 0, 0 }
+#define AACI_IRQ		{ IRQ_PBX_AACI, NO_IRQ }
+#define AACI_DMA		{ 0x80, 0x81 }
+#define MMCI0_IRQ		{ IRQ_PBX_MMCI0A, IRQ_PBX_MMCI0B }
+#define MMCI0_DMA		{ 0x84, 0 }
+#define KMI0_IRQ		{ IRQ_PBX_KMI0, NO_IRQ }
+#define KMI0_DMA		{ 0, 0 }
+#define KMI1_IRQ		{ IRQ_PBX_KMI1, NO_IRQ }
+#define KMI1_DMA		{ 0, 0 }
+#define PBX_SMC_IRQ		{ NO_IRQ, NO_IRQ }
+#define PBX_SMC_DMA		{ 0, 0 }
+#define MPMC_IRQ		{ NO_IRQ, NO_IRQ }
+#define MPMC_DMA		{ 0, 0 }
+#define PBX_CLCD_IRQ		{ IRQ_PBX_CLCD, NO_IRQ }
+#define PBX_CLCD_DMA		{ 0, 0 }
+#define DMAC_IRQ		{ IRQ_PBX_DMAC, NO_IRQ }
+#define DMAC_DMA		{ 0, 0 }
+#define SCTL_IRQ		{ NO_IRQ, NO_IRQ }
+#define SCTL_DMA		{ 0, 0 }
+#define PBX_WATCHDOG_IRQ	{ IRQ_PBX_WATCHDOG, NO_IRQ }
+#define PBX_WATCHDOG_DMA	{ 0, 0 }
+#define PBX_GPIO0_IRQ		{ IRQ_PBX_GPIO0, NO_IRQ }
+#define PBX_GPIO0_DMA		{ 0, 0 }
+#define GPIO1_IRQ		{ IRQ_PBX_GPIO1, NO_IRQ }
+#define GPIO1_DMA		{ 0, 0 }
+#define PBX_RTC_IRQ		{ IRQ_PBX_RTC, NO_IRQ }
+#define PBX_RTC_DMA		{ 0, 0 }
+#define SCI_IRQ			{ IRQ_PBX_SCI, NO_IRQ }
+#define SCI_DMA			{ 7, 6 }
+#define PBX_UART0_IRQ		{ IRQ_PBX_UART0, NO_IRQ }
+#define PBX_UART0_DMA		{ 15, 14 }
+#define PBX_UART1_IRQ		{ IRQ_PBX_UART1, NO_IRQ }
+#define PBX_UART1_DMA		{ 13, 12 }
+#define PBX_UART2_IRQ		{ IRQ_PBX_UART2, NO_IRQ }
+#define PBX_UART2_DMA		{ 11, 10 }
+#define PBX_UART3_IRQ		{ IRQ_PBX_UART3, NO_IRQ }
+#define PBX_UART3_DMA		{ 0x86, 0x87 }
+#define PBX_SSP_IRQ		{ IRQ_PBX_SSP, NO_IRQ }
+#define PBX_SSP_DMA		{ 9, 8 }
+
+/* FPGA Primecells */
+AMBA_DEVICE(aaci,	"fpga:04",	AACI,		NULL);
+AMBA_DEVICE(mmc0,	"fpga:05",	MMCI0,		&realview_mmc0_plat_data);
+AMBA_DEVICE(kmi0,	"fpga:06",	KMI0,		NULL);
+AMBA_DEVICE(kmi1,	"fpga:07",	KMI1,		NULL);
+AMBA_DEVICE(uart3,	"fpga:09",	PBX_UART3,	NULL);
+
+/* DevChip Primecells */
+AMBA_DEVICE(smc,	"dev:00",	PBX_SMC,	NULL);
+AMBA_DEVICE(sctl,	"dev:e0",	SCTL,		NULL);
+AMBA_DEVICE(wdog,	"dev:e1",	PBX_WATCHDOG, 	NULL);
+AMBA_DEVICE(gpio0,	"dev:e4",	PBX_GPIO0,	NULL);
+AMBA_DEVICE(gpio1,	"dev:e5",	GPIO1,		NULL);
+AMBA_DEVICE(gpio2,	"dev:e6",	GPIO2,		NULL);
+AMBA_DEVICE(rtc,	"dev:e8",	PBX_RTC,	NULL);
+AMBA_DEVICE(sci0,	"dev:f0",	SCI,		NULL);
+AMBA_DEVICE(uart0,	"dev:f1",	PBX_UART0,	NULL);
+AMBA_DEVICE(uart1,	"dev:f2",	PBX_UART1,	NULL);
+AMBA_DEVICE(uart2,	"dev:f3",	PBX_UART2,	NULL);
+AMBA_DEVICE(ssp0,	"dev:f4",	PBX_SSP,	NULL);
+
+/* Primecells on the NEC ISSP chip */
+AMBA_DEVICE(clcd,	"issp:20",	PBX_CLCD,	&clcd_plat_data);
+AMBA_DEVICE(dmac,	"issp:30",	DMAC,		NULL);
+
+static struct amba_device *amba_devs[] __initdata = {
+	&dmac_device,
+	&uart0_device,
+	&uart1_device,
+	&uart2_device,
+	&uart3_device,
+	&smc_device,
+	&clcd_device,
+	&sctl_device,
+	&wdog_device,
+	&gpio0_device,
+	&gpio1_device,
+	&gpio2_device,
+	&rtc_device,
+	&sci0_device,
+	&ssp0_device,
+	&aaci_device,
+	&mmc0_device,
+	&kmi0_device,
+	&kmi1_device,
+};
+
+/*
+ * RealView PB-X platform devices
+ */
+static struct resource realview_pbx_flash_resources[] = {
+	[0] = {
+		.start          = REALVIEW_PBX_FLASH0_BASE,
+		.end            = REALVIEW_PBX_FLASH0_BASE + REALVIEW_PBX_FLASH0_SIZE - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = REALVIEW_PBX_FLASH1_BASE,
+		.end            = REALVIEW_PBX_FLASH1_BASE + REALVIEW_PBX_FLASH1_SIZE - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+};
+
+static struct resource realview_pbx_smsc911x_resources[] = {
+	[0] = {
+		.start		= REALVIEW_PBX_ETH_BASE,
+		.end		= REALVIEW_PBX_ETH_BASE + SZ_64K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_PBX_ETH,
+		.end		= IRQ_PBX_ETH,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource realview_pbx_isp1761_resources[] = {
+	[0] = {
+		.start		= REALVIEW_PBX_USB_BASE,
+		.end		= REALVIEW_PBX_USB_BASE + SZ_128K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_PBX_USB,
+		.end		= IRQ_PBX_USB,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static void __init gic_init_irq(void)
+{
+	/* ARM PBX on-board GIC */
+	if (core_tile_pbx11mp() || core_tile_pbxa9mp()) {
+		gic_cpu_base_addr = __io_address(REALVIEW_PBX_TILE_GIC_CPU_BASE);
+		gic_dist_init(0, __io_address(REALVIEW_PBX_TILE_GIC_DIST_BASE),
+			      29);
+		gic_cpu_init(0, __io_address(REALVIEW_PBX_TILE_GIC_CPU_BASE));
+	} else {
+		gic_cpu_base_addr = __io_address(REALVIEW_PBX_GIC_CPU_BASE);
+		gic_dist_init(0, __io_address(REALVIEW_PBX_GIC_DIST_BASE),
+			      IRQ_PBX_GIC_START);
+		gic_cpu_init(0, __io_address(REALVIEW_PBX_GIC_CPU_BASE));
+	}
+}
+
+static void __init realview_pbx_timer_init(void)
+{
+	timer0_va_base = __io_address(REALVIEW_PBX_TIMER0_1_BASE);
+	timer1_va_base = __io_address(REALVIEW_PBX_TIMER0_1_BASE) + 0x20;
+	timer2_va_base = __io_address(REALVIEW_PBX_TIMER2_3_BASE);
+	timer3_va_base = __io_address(REALVIEW_PBX_TIMER2_3_BASE) + 0x20;
+
+#ifdef CONFIG_LOCAL_TIMERS
+	if (core_tile_pbx11mp() || core_tile_pbxa9mp())
+		twd_base = __io_address(REALVIEW_PBX_TILE_TWD_BASE);
+#endif
+	realview_timer_init(IRQ_PBX_TIMER0_1);
+}
+
+static struct sys_timer realview_pbx_timer = {
+	.init		= realview_pbx_timer_init,
+};
+
+#ifdef CONFIG_CACHE_L2X0
+static int __init realview_pbx_l2x0_init(void)
+{
+	if (machine_is_realview_pbx() && core_tile_pbxa9mp()) {
+		void __iomem *l2x0_base =
+			__io_address(REALVIEW_PBX_TILE_L220_BASE);
+
+		if (!(readl(l2x0_base + L2X0_CTRL) & 1)) {
+			/* set RAM latencies to 1 cycle for eASIC */
+			writel(0, l2x0_base + L2X0_TAG_LATENCY_CTRL);
+			writel(0, l2x0_base + L2X0_DATA_LATENCY_CTRL);
+		}
+
+		/* 16KB way size, 8-way associativity, parity disabled
+		 * Bits:  .. 0 0 0 0 1 00 1 0 1 001 0 000 0 .... .... .... */
+		l2x0_init(l2x0_base, 0x02520000, 0xc0000fff);
+	}
+	return 0;
+}
+early_initcall(realview_pbx_l2x0_init);
+#endif
+
+static void __init realview_pbx_init(void)
+{
+	int i;
+
+	clk_register(&realview_clcd_clk);
+
+	realview_flash_register(realview_pbx_flash_resources,
+				ARRAY_SIZE(realview_pbx_flash_resources));
+	realview_eth_register(NULL, realview_pbx_smsc911x_resources);
+	platform_device_register(&realview_i2c_device);
+	platform_device_register(&realview_cf_device);
+	realview_usb_register(realview_pbx_isp1761_resources);
+
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+
+#ifdef CONFIG_LEDS
+	leds_event = realview_leds_event;
+#endif
+}
+
+MACHINE_START(REALVIEW_PBX, "ARM-RealView PBX")
+	/* Maintainer: ARM Ltd/Deep Blue Solutions Ltd */
+	.phys_io	= REALVIEW_PBX_UART0_BASE,
+	.io_pg_offst	= (IO_ADDRESS(REALVIEW_PBX_UART0_BASE) >> 18) & 0xfffc,
+	.boot_params	= PHYS_OFFSET + 0x00000100,
+	.map_io		= realview_pbx_map_io,
+	.init_irq	= gic_init_irq,
+	.timer		= &realview_pbx_timer,
+	.init_machine	= realview_pbx_init,
+MACHINE_END
diff --git a/arch/arm/mach-versatile/core.c b/arch/arm/mach-versatile/core.c
index 565e0ba..9209de3 100644
--- a/arch/arm/mach-versatile/core.c
+++ b/arch/arm/mach-versatile/core.c
@@ -334,11 +334,25 @@ static struct resource versatile_i2c_resource = {
 
 static struct platform_device versatile_i2c_device = {
 	.name			= "versatile-i2c",
-	.id			= -1,
+	.id			= 0,
 	.num_resources		= 1,
 	.resource		= &versatile_i2c_resource,
 };
 
+static struct i2c_board_info versatile_i2c_board_info[] = {
+	{
+		I2C_BOARD_INFO("rtc-ds1307", 0xd0 >> 1),
+		.type = "ds1338",
+	},
+};
+
+static int __init versatile_i2c_init(void)
+{
+	return i2c_register_board_info(0, versatile_i2c_board_info,
+				       ARRAY_SIZE(versatile_i2c_board_info));
+}
+arch_initcall(versatile_i2c_init);
+
 #define VERSATILE_SYSMCI	(__io_address(VERSATILE_SYS_BASE) + VERSATILE_SYS_MCI_OFFSET)
 
 unsigned int mmc_status(struct device *dev)
@@ -416,12 +430,12 @@ static struct clcd_panel vga = {
 		.xres		= 640,
 		.yres		= 480,
 		.pixclock	= 39721,
-		.left_margin	= 40,
-		.right_margin	= 24,
-		.upper_margin	= 32,
-		.lower_margin	= 11,
-		.hsync_len	= 96,
-		.vsync_len	= 2,
+		.left_margin	= 64,
+		.right_margin	= 16,
+		.upper_margin	= 13,
+		.lower_margin	= 3,
+		.hsync_len	= 80,
+		.vsync_len	= 4,
 		.sync		= 0,
 		.vmode		= FB_VMODE_NONINTERLACED,
 	},
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index ab5f7a2..824e832 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -172,7 +172,7 @@ config CPU_ARM925T
  	help
  	  The ARM925T is a mix between the ARM920T and ARM926T, but with
 	  different instruction and data caches. It is used in TI's OMAP
- 	  device family.
+ 	  device family.'
 
  	  Say Y if you want support for the ARM925T processor.
  	  Otherwise, say N.
@@ -187,14 +187,14 @@ config CPU_ARM926T
 		ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || \
 		ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || \
 		ARCH_AT91SAM9G20 || ARCH_AT91CAP9 || \
-		ARCH_NS9XXX || ARCH_DAVINCI || ARCH_MX2
+		ARCH_NS9XXX || ARCH_DAVINCI || ARCH_MX2 || ARCH_FIRECRACKER
 	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || \
 		ARCH_OMAP730 || ARCH_OMAP16XX || \
 		ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || \
 		ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || \
 		ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || \
 		ARCH_AT91SAM9G20 || ARCH_AT91CAP9 || \
-		ARCH_NS9XXX || ARCH_DAVINCI || ARCH_MX2
+		ARCH_NS9XXX || ARCH_DAVINCI || ARCH_MX2 || ARCH_FIRECRACKER
 	select CPU_32v5
 	select CPU_ABRT_EV5TJ
 	select CPU_PABRT_NOIFAR
@@ -400,7 +400,7 @@ config CPU_FEROCEON_OLD_ID
 # ARMv6
 config CPU_V6
 	bool "Support ARM V6 processor"
-	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP2 || ARCH_MX3 || ARCH_MSM || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176
+	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP2 || ARCH_MX3 || ARCH_MSM || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PBX || ARCH_PC302
 	default y if ARCH_MX3
 	default y if ARCH_MSM
 	select CPU_32v6
@@ -428,7 +428,7 @@ config CPU_32v6K
 # ARMv7
 config CPU_V7
 	bool "Support ARM V7 processor"
-	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP3
+	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP3 || MACH_REALVIEW_PBA8 || MACH_REALVIEW_PBX
 	select CPU_32v6K
 	select CPU_32v7
 	select CPU_ABRT_EV7
@@ -525,6 +525,11 @@ config CPU_CACHE_VIVT
 config CPU_CACHE_VIPT
 	bool
 
+config CPU_NO_CACHE_BCAST
+	bool
+	depends on SMP
+	default y if CPU_V6
+
 if MMU
 # The copy-page model
 config CPU_COPY_V3
@@ -638,6 +643,13 @@ config CPU_BIG_ENDIAN
 	  port must properly enable any big-endian related features
 	  of your chipset/board/processor.
 
+config CPU_ENDIAN_BE8
+	bool
+	depends on CPU_V6 || CPU_V7
+	default y if CPU_BIG_ENDIAN
+	help
+	  Support for the BE-8 (big-endian) mode on ARMv6 and ARMv7 CPUs.
+
 config CPU_HIGH_VECTOR
 	depends on !MMU && CPU_CP15 && !CPU_ARM740T
 	bool "Select the High exception vector"
@@ -745,7 +757,7 @@ config CACHE_FEROCEON_L2_WRITETHROUGH
 
 config CACHE_L2X0
 	bool "Enable the L2x0 outer cache controller"
-	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176
+	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || REALVIEW_EB_A9MP || MACH_REALVIEW_PBX
 	default y
 	select OUTER_CACHE
 	help
diff --git a/arch/arm/mm/Makefile b/arch/arm/mm/Makefile
index 480f78a..702b3bc 100644
--- a/arch/arm/mm/Makefile
+++ b/arch/arm/mm/Makefile
@@ -77,4 +77,3 @@ obj-$(CONFIG_CPU_V7)		+= proc-v7.o
 obj-$(CONFIG_CACHE_FEROCEON_L2)	+= cache-feroceon-l2.o
 obj-$(CONFIG_CACHE_L2X0)	+= cache-l2x0.o
 obj-$(CONFIG_CACHE_XSC3L2)	+= cache-xsc3l2.o
-
diff --git a/arch/arm/mm/abort-ev6.S b/arch/arm/mm/abort-ev6.S
index 8a7f65b..c7b258d 100644
--- a/arch/arm/mm/abort-ev6.S
+++ b/arch/arm/mm/abort-ev6.S
@@ -28,10 +28,10 @@ ENTRY(v6_early_abort)
 	mrc	p15, 0, r1, c5, c0, 0		@ get FSR
 	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
 /*
- * Faulty SWP instruction on 1136 doesn't set bit 11 in DFSR.
+ * Faulty SWP instruction on 1136 doesn't set bit 11 in DFSR (erratum 326103).
  * The test below covers all the write situations, including Java bytecodes
  */
-	bic	r1, r1, #1 << 11 | 1 << 10	@ clear bits 11 and 10 of FSR
+	bic	r1, r1, #1 << 11		@ clear bit 11 of FSR
 	tst	r3, #PSR_J_BIT			@ Java?
 	movne	pc, lr
 	do_thumb_abort
diff --git a/arch/arm/mm/alignment.c b/arch/arm/mm/alignment.c
index 2d5884c..e0464c9 100644
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@ -152,7 +152,9 @@ union offset_union {
 
 #define __get8_unaligned_check(ins,val,addr,err)	\
 	__asm__(					\
-	"1:	"ins"	%1, [%2], #1\n"			\
+ ARM(	"1:	"ins"	%1, [%2], #1\n"	)		\
+ THUMB(	"1:	"ins"	%1, [%2]\n"	)		\
+ THUMB(	"	add	%2, %2, #1\n"	)		\
 	"2:\n"						\
 	"	.section .fixup,\"ax\"\n"		\
 	"	.align	2\n"				\
@@ -208,7 +210,9 @@ union offset_union {
 	do {							\
 		unsigned int err = 0, v = val, a = addr;	\
 		__asm__( FIRST_BYTE_16				\
-		"1:	"ins"	%1, [%2], #1\n"			\
+	 ARM(	"1:	"ins"	%1, [%2], #1\n"	)		\
+	 THUMB(	"1:	"ins"	%1, [%2]\n"	)		\
+	 THUMB(	"	add	%2, %2, #1\n"	)		\
 		"	mov	%1, %1, "NEXT_BYTE"\n"		\
 		"2:	"ins"	%1, [%2]\n"			\
 		"3:\n"						\
@@ -238,11 +242,17 @@ union offset_union {
 	do {							\
 		unsigned int err = 0, v = val, a = addr;	\
 		__asm__( FIRST_BYTE_32				\
-		"1:	"ins"	%1, [%2], #1\n"			\
+	 ARM(	"1:	"ins"	%1, [%2], #1\n"	)		\
+	 THUMB(	"1:	"ins"	%1, [%2]\n"	)		\
+	 THUMB(	"	add	%2, %2, #1\n"	)		\
 		"	mov	%1, %1, "NEXT_BYTE"\n"		\
-		"2:	"ins"	%1, [%2], #1\n"			\
+	 ARM(	"2:	"ins"	%1, [%2], #1\n"	)		\
+	 THUMB(	"2:	"ins"	%1, [%2]\n"	)		\
+	 THUMB(	"	add	%2, %2, #1\n"	)		\
 		"	mov	%1, %1, "NEXT_BYTE"\n"		\
-		"3:	"ins"	%1, [%2], #1\n"			\
+	 ARM(	"3:	"ins"	%1, [%2], #1\n"	)		\
+	 THUMB(	"3:	"ins"	%1, [%2]\n"	)		\
+	 THUMB(	"	add	%2, %2, #1\n"	)		\
 		"	mov	%1, %1, "NEXT_BYTE"\n"		\
 		"4:	"ins"	%1, [%2]\n"			\
 		"5:\n"						\
diff --git a/arch/arm/mm/cache-l2x0.c b/arch/arm/mm/cache-l2x0.c
index b480f1d..49ec9ee 100644
--- a/arch/arm/mm/cache-l2x0.c
+++ b/arch/arm/mm/cache-l2x0.c
@@ -34,7 +34,11 @@ static inline void sync_writel(unsigned long val, unsigned long reg,
 	unsigned long flags;
 
 	spin_lock_irqsave(&l2x0_lock, flags);
+#ifdef CONFIG_ARM_ERRATA_484863
+	asm volatile("swp %0, %0, [%1]\n" : "+r" (val) : "r" (l2x0_base + reg));
+#else
 	writel(val, l2x0_base + reg);
+#endif
 	/* wait for the operation to complete */
 	while (readl(l2x0_base + reg) & complete_mask)
 		;
@@ -99,18 +103,18 @@ void __init l2x0_init(void __iomem *base, __u32 aux_val, __u32 aux_mask)
 
 	l2x0_base = base;
 
-	/* disable L2X0 */
-	writel(0, l2x0_base + L2X0_CTRL);
+	if (!(readl(l2x0_base + L2X0_CTRL) & 1)) {
+		/* L2X0 cache controller disabled */
+		aux = readl(l2x0_base + L2X0_AUX_CTRL);
+		aux &= aux_mask;
+		aux |= aux_val;
+		writel(aux, l2x0_base + L2X0_AUX_CTRL);
 
-	aux = readl(l2x0_base + L2X0_AUX_CTRL);
-	aux &= aux_mask;
-	aux |= aux_val;
-	writel(aux, l2x0_base + L2X0_AUX_CTRL);
+		l2x0_inv_all();
 
-	l2x0_inv_all();
-
-	/* enable L2X0 */
-	writel(1, l2x0_base + L2X0_CTRL);
+		/* enable L2X0 */
+		writel(1, l2x0_base + L2X0_CTRL);
+	}
 
 	outer_cache.inv_range = l2x0_inv_range;
 	outer_cache.clean_range = l2x0_clean_range;
diff --git a/arch/arm/mm/cache-v6.S b/arch/arm/mm/cache-v6.S
index 2c6c2a7..8364f6c 100644
--- a/arch/arm/mm/cache-v6.S
+++ b/arch/arm/mm/cache-v6.S
@@ -20,6 +20,39 @@
 #define D_CACHE_LINE_SIZE	32
 #define BTB_FLUSH_SIZE		8
 
+#ifdef CONFIG_ARM_ERRATA_411920
+/*
+ * Invalidate the entire I cache (this code is a workaround for the ARM1136
+ * Errata 411920 - Invalidate Instruction Cache operation can fail. This
+ * Errata is present in 1136, 1156 and 1176. It does not affect the MPCore
+ *
+ * Registers:
+ *   r0 - set to 0
+ *   r1 - corrupted
+ */
+ENTRY(v6_icache_inval_all)
+	mov	r0, #0
+	mrs	r1, cpsr
+	cpsid	ifa				@ disable interrupts
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	msr	cpsr_cx, r1			@ restore interrupts
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	mov	pc, lr
+#endif
+
 /*
  *	v6_flush_cache_all()
  *
@@ -31,8 +64,12 @@ ENTRY(v6_flush_kern_cache_all)
 	mov	r0, #0
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c14, 0		@ D cache clean+invalidate
+#ifndef CONFIG_ARM_ERRATA_411920
 	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
 #else
+	b	v6_icache_inval_all
+#endif
+#else
 	mcr	p15, 0, r0, c7, c15, 0		@ Cache clean+invalidate
 #endif
 	mov	pc, lr
@@ -103,8 +140,12 @@ ENTRY(v6_coherent_user_range)
 	mov	r0, #0
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+#ifndef CONFIG_ARM_ERRATA_411920
 	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
 #else
+	b	v6_icache_inval_all
+#endif
+#else
 	mcr	p15, 0, r0, c7, c5, 6		@ invalidate BTB
 #endif
 	mov	pc, lr
diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
index d19c2be..29e6904 100644
--- a/arch/arm/mm/cache-v7.S
+++ b/arch/arm/mm/cache-v7.S
@@ -21,11 +21,12 @@
  *
  *	Flush the whole D-cache.
  *
- *	Corrupted registers: r0-r5, r7, r9-r11
+ *	Corrupted registers: r0-r7, r9-r11 (r6 only in Thumb mode)
  *
  *	- mm    - mm_struct describing address space
  */
 ENTRY(v7_flush_dcache_all)
+	dmb					@ ensure ordering with previous memory accesses
 	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
 	ands	r3, r0, #0x7000000		@ extract loc from clidr
 	mov	r3, r3, lsr #23			@ left align loc bit field
@@ -50,8 +51,12 @@ loop1:
 loop2:
 	mov	r9, r4				@ create working copy of max way size
 loop3:
-	orr	r11, r10, r9, lsl r5		@ factor way and cache number into r11
-	orr	r11, r11, r7, lsl r2		@ factor index number into r11
+ ARM(	orr	r11, r10, r9, lsl r5	)	@ factor way and cache number into r11
+ THUMB(	lsl	r6, r9, r5		)
+ THUMB(	orr	r11, r10, r6		)	@ factor way and cache number into r11
+ ARM(	orr	r11, r11, r7, lsl r2	)	@ factor index number into r11
+ THUMB(	lsl	r6, r7, r2		)
+ THUMB(	orr	r11, r11, r6		)	@ factor index number into r11
 	mcr	p15, 0, r11, c7, c14, 2		@ clean & invalidate by set/way
 	subs	r9, r9, #1			@ decrement the way
 	bge	loop3
@@ -64,6 +69,7 @@ skip:
 finished:
 	mov	r10, #0				@ swith back to cache level 0
 	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
+	dsb
 	isb
 	mov	pc, lr
 ENDPROC(v7_flush_dcache_all)
@@ -80,11 +86,13 @@ ENDPROC(v7_flush_dcache_all)
  *
  */
 ENTRY(v7_flush_kern_cache_all)
-	stmfd	sp!, {r4-r5, r7, r9-r11, lr}
+ ARM(	stmfd	sp!, {r4-r5, r7, r9-r11, lr}	)
+ THUMB(	stmfd	sp!, {r4-r7, r9-r11, lr}	)
 	bl	v7_flush_dcache_all
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
-	ldmfd	sp!, {r4-r5, r7, r9-r11, lr}
+ ARM(	ldmfd	sp!, {r4-r5, r7, r9-r11, lr}	)
+ THUMB(	ldmfd	sp!, {r4-r7, r9-r11, lr}	)
 	mov	pc, lr
 ENDPROC(v7_flush_kern_cache_all)
 
@@ -197,10 +205,12 @@ ENTRY(v7_dma_inv_range)
 	sub	r3, r2, #1
 	tst	r0, r3
 	bic	r0, r0, r3
+	it	ne
 	mcrne	p15, 0, r0, c7, c14, 1		@ clean & invalidate D / U line
 
 	tst	r1, r3
 	bic	r1, r1, r3
+	it	ne
 	mcrne	p15, 0, r1, c7, c14, 1		@ clean & invalidate D / U line
 1:
 	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D / U line
diff --git a/arch/arm/mm/context.c b/arch/arm/mm/context.c
index fc84fcc..661de18 100644
--- a/arch/arm/mm/context.c
+++ b/arch/arm/mm/context.c
@@ -10,12 +10,17 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/percpu.h>
 
 #include <asm/mmu_context.h>
 #include <asm/tlbflush.h>
 
 static DEFINE_SPINLOCK(cpu_asid_lock);
 unsigned int cpu_last_asid = ASID_FIRST_VERSION;
+#ifdef CONFIG_SMP
+DEFINE_PER_CPU(struct mm_struct *, current_mm);
+#endif
 
 /*
  * We fork()ed a process, and we need a new context for the child
@@ -26,13 +31,105 @@ unsigned int cpu_last_asid = ASID_FIRST_VERSION;
 void __init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
 	mm->context.id = 0;
+	spin_lock_init(&mm->context.id_lock);
 }
 
+static void flush_context(void)
+{
+	/* set the reserved ASID before flushing the TLB */
+	asm("mcr	p15, 0, %0, c13, c0, 1\n" : : "r" (0));
+	isb();
+	local_flush_tlb_all();
+	if (icache_is_vivt_asid_tagged()) {
+		__flush_icache_all();
+		dsb();
+	}
+}
+
+#ifdef CONFIG_SMP
+
+static void set_mm_context(struct mm_struct *mm, unsigned int asid)
+{
+	/*
+	 * Locking needed for multi-threaded applications where the
+	 * same mm->context.id could be set from different CPUs during
+	 * the broadcast.
+	 */
+	spin_lock(&mm->context.id_lock);
+	if (likely((mm->context.id ^ cpu_last_asid) >> ASID_BITS)) {
+		/*
+		 * Old version of ASID found. Set the new one and
+		 * reset mm->cpu_vm_mask.
+		 */
+		mm->context.id = asid;
+		cpus_clear(mm->cpu_vm_mask);
+	}
+	spin_unlock(&mm->context.id_lock);
+
+	/*
+	 * Set the cpu_vm_mask bit for the current CPU.
+	 */
+	cpu_set(smp_processor_id(), mm->cpu_vm_mask);
+}
+
+/*
+ * Reset the ASID on the current CPU. This function call is broadcast
+ * from the CPU handling the ASID rollover and holding cpu_asid_lock.
+ */
+static void reset_context(void *info)
+{
+	unsigned int asid;
+	unsigned int cpu = smp_processor_id();
+	struct mm_struct *mm = per_cpu(current_mm, cpu);
+
+	/*
+	 * Check if a current_mm was set on this CPU as it might still
+	 * be in the early booting stages and using the reserved ASID.
+	 */
+	if (!mm)
+		return;
+
+	smp_rmb();
+	asid = cpu_last_asid + cpu + 1;
+
+	flush_context();
+	set_mm_context(mm, asid);
+
+	/* set the new ASID */
+	asm("mcr	p15, 0, %0, c13, c0, 1\n" : : "r" (mm->context.id));
+}
+
+#else
+
+static inline void set_mm_context(struct mm_struct *mm, unsigned int asid)
+{
+	mm->context.id = asid;
+	mm->cpu_vm_mask = cpumask_of_cpu(smp_processor_id());
+}
+
+#endif
+
 void __new_context(struct mm_struct *mm)
 {
 	unsigned int asid;
 
 	spin_lock(&cpu_asid_lock);
+#ifdef CONFIG_SMP
+	/*
+	 * Check the ASID again, in case the change was broadcast from
+	 * another CPU before we acquired the lock.
+	 */
+	if (unlikely(((mm->context.id ^ cpu_last_asid) >> ASID_BITS) == 0)) {
+		cpu_set(smp_processor_id(), mm->cpu_vm_mask);
+		spin_unlock(&cpu_asid_lock);
+		return;
+	}
+#endif
+	/*
+	 * At this point, it is guaranteed that the current mm (with
+	 * an old ASID) isn't active on any other CPU since the ASIDs
+	 * are changed simultaneously via IPI.
+	 */
 	asid = ++cpu_last_asid;
 	if (asid == 0)
 		asid = cpu_last_asid = ASID_FIRST_VERSION;
@@ -42,23 +139,15 @@ void __new_context(struct mm_struct *mm)
 	 * to start a new version and flush the TLB.
 	 */
 	if (unlikely((asid & ~ASID_MASK) == 0)) {
-		asid = ++cpu_last_asid;
-		/* set the reserved ASID before flushing the TLB */
-		asm("mcr	p15, 0, %0, c13, c0, 1	@ set reserved context ID\n"
-		    :
-		    : "r" (0));
-		isb();
-		flush_tlb_all();
-		if (icache_is_vivt_asid_tagged()) {
-			asm("mcr	p15, 0, %0, c7, c5, 0	@ invalidate I-cache\n"
-			    "mcr	p15, 0, %0, c7, c5, 6	@ flush BTAC/BTB\n"
-			    :
-			    : "r" (0));
-			dsb();
-		}
+		asid = cpu_last_asid + smp_processor_id() + 1;
+		flush_context();
+#ifdef CONFIG_SMP
+		smp_wmb();
+		smp_call_function(reset_context, NULL, 1);
+#endif
+		cpu_last_asid += NR_CPUS;
 	}
-	spin_unlock(&cpu_asid_lock);
 
-	mm->cpu_vm_mask = cpumask_of_cpu(smp_processor_id());
-	mm->context.id = asid;
+	set_mm_context(mm, asid);
+	spin_unlock(&cpu_asid_lock);
 }
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 6796001..4e2a7c1 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -35,7 +35,13 @@
 #define CONSISTENT_PTE_INDEX(x) (((unsigned long)(x) - CONSISTENT_BASE) >> PGDIR_SHIFT)
 #define NUM_CONSISTENT_PTES (CONSISTENT_DMA_SIZE >> PGDIR_SHIFT)
 
+#ifdef CONFIG_MMU
+#define arch_is_nommu()		0
+#else
+#define arch_is_nommu()		1
+#endif
 
+#ifdef CONFIG_MMU
 /*
  * These are the page tables (2MB each) covering uncached, DMA consistent allocations
  */
@@ -67,8 +73,7 @@ static DEFINE_SPINLOCK(consistent_lock);
  *	.vm_end		= VMALLOC_END,
  *  };
  *
- * However, vmalloc_head.vm_start is variable (typically, it is dependent on
- * the amount of RAM found at boot time.)  I would imagine that get_vm_area()
+ * However, vmalloc_head.vm_start is variable (typically, it is depen* the amount of RAM found at boot time.)  I would imagine that get_vm_area()
  * would have to initialise this each time prior to calling vm_region_alloc().
  */
 struct vm_region {
@@ -139,6 +144,7 @@ static struct vm_region *vm_region_find(struct vm_region *head, unsigned long ad
  out:
 	return c;
 }
+#endif	/* CONFIG_MMU */
 
 #ifdef CONFIG_HUGETLB_PAGE
 #error ARM Coherent DMA allocator does not (yet) support huge TLB
@@ -148,6 +154,7 @@ static void *
 __dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp,
 	    pgprot_t prot)
 {
+#ifdef CONFIG_MMU
 	struct page *page;
 	struct vm_region *c;
 	unsigned long order;
@@ -207,7 +214,7 @@ __dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp,
 	{
 		void *ptr = page_address(page);
 		memset(ptr, 0, size);
-		dmac_flush_range(ptr, ptr + size);
+		smp_dma_flush_range(ptr, ptr + size);
 		outer_flush_range(__pa(ptr), __pa(ptr) + size);
 	}
 
@@ -264,6 +271,7 @@ __dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp,
 		__free_pages(page, order);
  no_page:
 	*handle = ~0;
+#endif	/* CONFIG_MMU */
 	return NULL;
 }
 
@@ -279,7 +287,7 @@ dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gf
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
 		return memory;
 
-	if (arch_is_coherent()) {
+	if (arch_is_coherent() || arch_is_nommu()) {
 		void *virt;
 
 		virt = kmalloc(size, gfp);
@@ -302,6 +310,9 @@ EXPORT_SYMBOL(dma_alloc_coherent);
 void *
 dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
 {
+	if (arch_is_nommu())
+		return dma_alloc_coherent(dev, size, handle, gfp);
+
 	return __dma_alloc(dev, size, handle, gfp,
 			   pgprot_writecombine(pgprot_kernel));
 }
@@ -310,9 +321,10 @@ EXPORT_SYMBOL(dma_alloc_writecombine);
 static int dma_mmap(struct device *dev, struct vm_area_struct *vma,
 		    void *cpu_addr, dma_addr_t dma_addr, size_t size)
 {
+	int ret = -ENXIO;
+#ifdef CONFIG_MMU
 	unsigned long flags, user_size, kern_size;
 	struct vm_region *c;
-	int ret = -ENXIO;
 
 	user_size = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
 
@@ -333,6 +345,7 @@ static int dma_mmap(struct device *dev, struct vm_area_struct *vma,
 					      vma->vm_page_prot);
 		}
 	}
+#endif	/* CONFIG_MMU */
 
 	return ret;
 }
@@ -359,22 +372,25 @@ EXPORT_SYMBOL(dma_mmap_writecombine);
  */
 void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t handle)
 {
+#ifdef CONFIG_MMU
 	struct vm_region *c;
 	unsigned long flags, addr;
 	pte_t *ptep;
 	int idx;
 	u32 off;
+#endif
 
 	WARN_ON(irqs_disabled());
 
 	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
 		return;
 
-	if (arch_is_coherent()) {
+	if (arch_is_coherent() || arch_is_nommu()) {
 		kfree(cpu_addr);
 		return;
 	}
 
+#ifdef CONFIG_MMU
 	size = PAGE_ALIGN(size);
 
 	spin_lock_irqsave(&consistent_lock, flags);
@@ -442,6 +458,7 @@ void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr
 	printk(KERN_ERR "%s: trying to free invalid coherent area: %p\n",
 	       __func__, cpu_addr);
 	dump_stack();
+#endif	/* CONFIG_MMU */
 }
 EXPORT_SYMBOL(dma_free_coherent);
 
@@ -450,10 +467,12 @@ EXPORT_SYMBOL(dma_free_coherent);
  */
 static int __init consistent_init(void)
 {
+	int ret = 0;
+#ifdef CONFIG_MMU
 	pgd_t *pgd;
 	pmd_t *pmd;
 	pte_t *pte;
-	int ret = 0, i = 0;
+	int i = 0;
 	u32 base = CONSISTENT_BASE;
 
 	do {
@@ -476,6 +495,7 @@ static int __init consistent_init(void)
 		consistent_pte[i++] = pte;
 		base += (1 << PGDIR_SHIFT);
 	} while (base < CONSISTENT_END);
+#endif	/* !CONFIG_MMU */
 
 	return ret;
 }
@@ -496,15 +516,15 @@ void dma_cache_maint(const void *start, size_t size, int direction)
 
 	switch (direction) {
 	case DMA_FROM_DEVICE:		/* invalidate only */
-		dmac_inv_range(start, end);
+		smp_dma_inv_range(start, end);
 		outer_inv_range(__pa(start), __pa(end));
 		break;
 	case DMA_TO_DEVICE:		/* writeback only */
-		dmac_clean_range(start, end);
+		smp_dma_clean_range(start, end);
 		outer_clean_range(__pa(start), __pa(end));
 		break;
 	case DMA_BIDIRECTIONAL:		/* writeback and invalidate */
-		dmac_flush_range(start, end);
+		smp_dma_flush_range(start, end);
 		outer_flush_range(__pa(start), __pa(end));
 		break;
 	default:
@@ -585,8 +605,12 @@ void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
 	int i;
 
 	for_each_sg(sg, s, nents, i) {
-		dmabounce_sync_for_cpu(dev, sg_dma_address(s), 0,
-					sg_dma_len(s), dir);
+		if (!dmabounce_sync_for_cpu(dev, sg_dma_address(s), 0,
+					sg_dma_len(s), dir))
+			continue;
+
+		if (!arch_is_coherent())
+			dma_cache_maint(sg_virt(s), s->length, dir);
 	}
 }
 EXPORT_SYMBOL(dma_sync_sg_for_cpu);
diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c
index 22c9530..0d0ed05 100644
--- a/arch/arm/mm/fault.c
+++ b/arch/arm/mm/fault.c
@@ -22,6 +22,7 @@
 
 #include "fault.h"
 
+#ifdef CONFIG_MMU
 
 #ifdef CONFIG_KPROBES
 static inline int notify_page_fault(struct pt_regs *regs, unsigned int fsr)
@@ -95,6 +96,10 @@ void show_pte(struct mm_struct *mm, unsigned long addr)
 
 	printk("\n");
 }
+#else					/* CONFIG_MMU */
+void show_pte(struct mm_struct *mm, unsigned long addr)
+{ }
+#endif					/* CONFIG_MMU */
 
 /*
  * Oops.  The kernel tried to access some page that wasn't present.
@@ -169,6 +174,7 @@ void do_bad_area(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 		__do_kernel_fault(mm, addr, fsr, regs);
 }
 
+#ifdef CONFIG_MMU
 #define VM_FAULT_BADMAP		0x010000
 #define VM_FAULT_BADACCESS	0x020000
 
@@ -320,6 +326,13 @@ no_context:
 	__do_kernel_fault(mm, addr, fsr, regs);
 	return 0;
 }
+#else					/* CONFIG_MMU */
+static int
+do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
+{
+	return 0;
+}
+#endif					/* CONFIG_MMU */
 
 /*
  * First Level Translation Fault Handler
@@ -338,6 +351,7 @@ no_context:
  * interrupt or a critical region, and should only copy the information
  * from the master page table, nothing more.
  */
+#ifdef CONFIG_MMU
 static int __kprobes
 do_translation_fault(unsigned long addr, unsigned int fsr,
 		     struct pt_regs *regs)
@@ -376,6 +390,14 @@ bad_area:
 	do_bad_area(addr, fsr, regs);
 	return 0;
 }
+#else					/* CONFIG_MMU */
+static int
+do_translation_fault(unsigned long addr, unsigned int fsr,
+		     struct pt_regs *regs)
+{
+	return 0;
+}
+#endif					/* CONFIG_MMU */
 
 /*
  * Some section permission faults need to be handled gracefully.
diff --git a/arch/arm/mm/flush.c b/arch/arm/mm/flush.c
index 0fa9bf3..73b886e 100644
--- a/arch/arm/mm/flush.c
+++ b/arch/arm/mm/flush.c
@@ -32,10 +32,14 @@ static void flush_pfn_alias(unsigned long pfn, unsigned long vaddr)
 
 	asm(	"mcrr	p15, 0, %1, %0, c14\n"
 	"	mcr	p15, 0, %2, c7, c10, 4\n"
+#ifndef CONFIG_ARM_ERRATA_411920
 	"	mcr	p15, 0, %2, c7, c5, 0\n"
+#else
+	"	bl	v6_icache_inval_all\n"
+#endif
 	    :
 	    : "r" (to), "r" (to + PAGE_SIZE - L1_CACHE_BYTES), "r" (zero)
-	    : "cc");
+	    : "r0", "r1", "lr");
 }
 
 void flush_cache_mm(struct mm_struct *mm)
@@ -48,11 +52,15 @@ void flush_cache_mm(struct mm_struct *mm)
 
 	if (cache_is_vipt_aliasing()) {
 		asm(	"mcr	p15, 0, %0, c7, c14, 0\n"
+		"	mcr	p15, 0, %0, c7, c10, 4\n"
+#ifndef CONFIG_ARM_ERRATA_411920
 		"	mcr	p15, 0, %0, c7, c5, 0\n"
-		"	mcr	p15, 0, %0, c7, c10, 4"
+#else
+		"	bl	v6_icache_inval_all\n"
+#endif
 		    :
 		    : "r" (0)
-		    : "cc");
+		    : "r0", "r1", "lr", "cc");
 	}
 }
 
@@ -67,11 +75,15 @@ void flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned
 
 	if (cache_is_vipt_aliasing()) {
 		asm(	"mcr	p15, 0, %0, c7, c14, 0\n"
+		"	mcr	p15, 0, %0, c7, c10, 4\n"
+#ifndef CONFIG_ARM_ERRATA_411920
 		"	mcr	p15, 0, %0, c7, c5, 0\n"
-		"	mcr	p15, 0, %0, c7, c10, 4"
+#else
+		"	bl	v6_icache_inval_all\n"
+#endif
 		    :
 		    : "r" (0)
-		    : "cc");
+		    : "r0", "r1", "lr", "cc");
 	}
 }
 
diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index 82c4b42..b0423b7 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -419,7 +419,7 @@ free_memmap(int node, unsigned long start_pfn, unsigned long end_pfn)
 	/*
 	 * Convert start_pfn/end_pfn to a struct page pointer.
 	 */
-	start_pg = pfn_to_page(start_pfn);
+	start_pg = pfn_to_page(start_pfn - 1) + 1;
 	end_pg = pfn_to_page(end_pfn);
 
 	/*
diff --git a/arch/arm/mm/nommu.c b/arch/arm/mm/nommu.c
index 07b62b2..fd26a44 100644
--- a/arch/arm/mm/nommu.c
+++ b/arch/arm/mm/nommu.c
@@ -11,6 +11,7 @@
 
 #include <asm/cacheflush.h>
 #include <asm/page.h>
+#include <asm/setup.h>
 #include <asm/mach/arch.h>
 
 #include "mm.h"
diff --git a/arch/arm/mm/proc-macros.S b/arch/arm/mm/proc-macros.S
index 54b1f72..f1559c2 100644
--- a/arch/arm/mm/proc-macros.S
+++ b/arch/arm/mm/proc-macros.S
@@ -77,6 +77,7 @@
  * Sanity check the PTE configuration for the code below - which makes
  * certain assumptions about how these bits are layed out.
  */
+#ifdef CONFIG_MMU
 #if L_PTE_SHARED != PTE_EXT_SHARED
 #error PTE shared bit mismatch
 #endif
@@ -90,6 +91,7 @@
      L_PTE_FILE+L_PTE_PRESENT) > L_PTE_SHARED
 #error Invalid Linux PTE bit settings
 #endif
+#endif	/* CONFIG_MMU */
 
 /*
  * The ARMv6 and ARMv7 set_pte_ext translation function.
diff --git a/arch/arm/mm/proc-v6.S b/arch/arm/mm/proc-v6.S
index 294943b..7959567 100644
--- a/arch/arm/mm/proc-v6.S
+++ b/arch/arm/mm/proc-v6.S
@@ -71,6 +71,8 @@ ENTRY(cpu_v6_reset)
  *	IRQs are already disabled.
  */
 ENTRY(cpu_v6_do_idle)
+	mov	r1, #0
+	mcr	p15, 0, r1, c7, c10, 4		@ DWB - WFI may enter a low-power mode
 	mcr	p15, 0, r1, c7, c0, 4		@ wait for interrupt
 	mov	pc, lr
 
@@ -167,9 +169,28 @@ __v6_setup:
 #endif /* CONFIG_MMU */
 	adr	r5, v6_crval
 	ldmia	r5, {r5, r6}
+#ifdef CONFIG_CPU_ENDIAN_BE8
+	orr	r6, r6, #1 << 25		@ big-endian page tables
+#endif
 	mrc	p15, 0, r0, c1, c0, 0		@ read control register
 	bic	r0, r0, r5			@ clear bits them
 	orr	r0, r0, r6			@ set them
+#ifdef CONFIG_ARM_ERRATA_364296
+	/* Workaround for the 364296 ARM1136 r0pX errata (possible cache data
+	 * corruption with hit-under-miss enabled). The conditional code below
+	 * (setting the undocumented bit 31 in the auxiliary control register
+	 * and the FI bit in the control register) disables hit-under-miss
+	 * without putting the processor into full low interrupt latency mode.
+	 */
+	ldr	r6, =0x4107b360			@ id for ARM1136 r0pX
+	mrc	p15, 0, r5, c0, c0, 0		@ get processor id
+	bic	r5, r5, #0xf			@ mask out part bits [3:0]
+	teq	r5, r6				@ check for the faulty core
+	mrceq	p15, 0, r5, c1, c0, 1		@ load aux control reg
+	orreq	r5, r5, #(1 << 31)		@ set the undocumented bit 31
+	mcreq	p15, 0, r5, c1, c0, 1		@ write aux control reg
+	orreq	r0, r0, #(1 << 21)		@ low interrupt latency configuration
+#endif
 	mov	pc, lr				@ return to head.S:__ret
 
 	/*
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index 4d3c0a7..71b9ec1 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -18,10 +18,21 @@
 
 #include "proc-macros.S"
 
-#define TTB_C		(1 << 0)
 #define TTB_S		(1 << 1)
+#define TTB_RGN_NC	(0 << 3)
+#define TTB_RGN_OC_WBWA	(1 << 3)
 #define TTB_RGN_OC_WT	(2 << 3)
 #define TTB_RGN_OC_WB	(3 << 3)
+#define TTB_IRGN_NC	((0 << 0) | (0 << 6))
+#define TTB_IRGN_WBWA	((0 << 0) | (1 << 6))
+#define TTB_IRGN_WT	((1 << 0) | (0 << 6))
+#define TTB_IRGN_WB	((1 << 0) | (1 << 6))
+
+#ifndef CONFIG_SMP
+#define TTB_FLAGS	TTB_IRGN_WB|TTB_RGN_OC_WB		@ mark PTWs cacheable, outer WB
+#else
+#define TTB_FLAGS	TTB_IRGN_WBWA|TTB_S|TTB_RGN_OC_WBWA	@ mark PTWs cacheable and shared, outer WBWA
+#endif
 
 ENTRY(cpu_v7_proc_init)
 	mov	pc, lr
@@ -55,6 +66,7 @@ ENDPROC(cpu_v7_reset)
  *	IRQs are already disabled.
  */
 ENTRY(cpu_v7_do_idle)
+	dsb					@ WFI may enter a low-power mode
 	wfi
 	mov	pc, lr
 ENDPROC(cpu_v7_do_idle)
@@ -85,7 +97,10 @@ ENTRY(cpu_v7_switch_mm)
 #ifdef CONFIG_MMU
 	mov	r2, #0
 	ldr	r1, [r1, #MM_CONTEXT_ID]	@ get mm->context.id
-	orr	r0, r0, #TTB_RGN_OC_WB		@ mark PTWs outer cacheable, WB
+	orr	r0, r0, #TTB_FLAGS
+#ifdef CONFIG_ARM_ERRATA_430973
+	mcr	p15, 0, r2, c7, c5, 6		@ flush BTAC/BTB
+#endif
 	mcr	p15, 0, r2, c13, c0, 1		@ set reserved context ID
 	isb
 1:	mcr	p15, 0, r0, c2, c0, 0		@ set TTB 0
@@ -108,7 +123,9 @@ ENDPROC(cpu_v7_switch_mm)
  */
 ENTRY(cpu_v7_set_pte_ext)
 #ifdef CONFIG_MMU
-	str	r1, [r0], #-2048		@ linux version
+ ARM(	str	r1, [r0], #-2048	)	@ linux version
+ THUMB(	str	r1, [r0]		)	@ linux version
+ THUMB(	sub	r0, r0, #2048		)
 
 	bic	r3, r1, #0x000003f0
 	bic	r3, r3, #PTE_TYPE_MASK
@@ -116,21 +133,26 @@ ENTRY(cpu_v7_set_pte_ext)
 	orr	r3, r3, #PTE_EXT_AP0 | 2
 
 	tst	r1, #1 << 4
+	it	ne
 	orrne	r3, r3, #PTE_EXT_TEX(1)
 
 	tst	r1, #L_PTE_WRITE
+	ite	ne
 	tstne	r1, #L_PTE_DIRTY
 	orreq	r3, r3, #PTE_EXT_APX
 
 	tst	r1, #L_PTE_USER
+	ittt	ne
 	orrne	r3, r3, #PTE_EXT_AP1
 	tstne	r3, #PTE_EXT_APX
 	bicne	r3, r3, #PTE_EXT_APX | PTE_EXT_AP0
 
 	tst	r1, #L_PTE_EXEC
+	it	eq
 	orreq	r3, r3, #PTE_EXT_XN
 
 	tst	r1, #L_PTE_YOUNG
+	ite	ne
 	tstne	r1, #L_PTE_PRESENT
 	moveq	r3, #0
 
@@ -162,10 +184,33 @@ cpu_v7_name:
  *	- cache type register is implemented
  */
 __v7_setup:
+#ifdef CONFIG_SMP
+	mrc	p15, 0, r0, c1, c0, 1		@ Enable SMP/nAMP mode
+	tst	r0, #(0x1 << 6)			@ already enabled?
+	itt	eq
+	orreq	r0, r0, #(0x1 << 6)
+	mcreq	p15, 0, r0, c1, c0, 1
+#endif
 	adr	r12, __v7_setup_stack		@ the local stack
 	stmia	r12, {r0-r5, r7, r9, r11, lr}
 	bl	v7_flush_dcache_all
 	ldmia	r12, {r0-r5, r7, r9, r11, lr}
+#ifdef CONFIG_ARM_ERRATA_430973
+	mrc	p15, 0, r10, c1, c0, 1		@ read aux control register
+	orr	r10, r10, #(1 << 6)		@ set IBE to 1
+	mcr	p15, 0, r10, c1, c0, 1		@ write aux control register
+#endif
+#ifdef CONFIG_ARM_ERRATA_458693
+	mrc	p15, 0, r10, c1, c0, 1		@ read aux control register
+	orr	r10, r10, #(1 << 5)		@ set L1NEON to 1
+	orr	r10, r10, #(1 << 9)		@ set PLDNOP to 1
+	mcr	p15, 0, r10, c1, c0, 1		@ write aux control register
+#endif
+#ifdef CONFIG_ARM_ERRATA_460075
+	mrc	p15, 1, r10, c9, c0, 2		@ read L2 cache aux ctrl register
+	orr	r10, r10, #(1 << 22)		@ set the Write Allocate disable bit
+	mcr	p15, 1, r10, c9, c0, 2		@ write the L2 cache aux ctrl register
+#endif
 	mov	r10, #0
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r10, c7, c5, 0		@ I+BTB cache invalidate
@@ -174,18 +219,23 @@ __v7_setup:
 #ifdef CONFIG_MMU
 	mcr	p15, 0, r10, c8, c7, 0		@ invalidate I + D TLBs
 	mcr	p15, 0, r10, c2, c0, 2		@ TTB control register
-	orr	r4, r4, #TTB_RGN_OC_WB		@ mark PTWs outer cacheable, WB
-	mcr	p15, 0, r4, c2, c0, 0		@ load TTB0
+	orr	r4, r4, #TTB_FLAGS
 	mcr	p15, 0, r4, c2, c0, 1		@ load TTB1
 	mov	r10, #0x1f			@ domains 0, 1 = manager
 	mcr	p15, 0, r10, c3, c0, 0		@ load domain access register
-#endif
 	ldr	r5, =0xff0aa1a8
 	ldr	r6, =0x40e040e0
 	mcr	p15, 0, r5, c10, c2, 0		@ write PRRR
 	mcr	p15, 0, r6, c10, c2, 1		@ write NMRR
+#endif
 	adr	r5, v7_crval
 	ldmia	r5, {r5, r6}
+#if !defined(CONFIG_AEABI) || defined(CONFIG_OABI_COMPAT)
+	orr	r6, r6, #1 << 10		@ enable the SWP instruction
+#endif
+#ifdef CONFIG_CPU_ENDIAN_BE8
+	orr	r6, r6, #1 << 25		@ big-endian page tables
+#endif
    	mrc	p15, 0, r0, c1, c0, 0		@ read control register
 	bic	r0, r0, r5			@ clear bits them
 	orr	r0, r0, r6			@ set them
@@ -200,7 +250,8 @@ ENDPROC(__v7_setup)
 	 */
 	.type	v7_crval, #object
 v7_crval:
-	crval	clear=0x0120c302, mmuset=0x10c0387d, ucset=0x00c0187c
+ ARM(	crval	clear=0x0120c302, mmuset=0x10c0387d, ucset=0x00c0187c	)
+ THUMB(	crval	clear=0x0120c302, mmuset=0x50c0387d, ucset=0x40c0187c	)
 
 __v7_setup_stack:
 	.space	4 * 11				@ 11 registers
diff --git a/arch/arm/mm/tlb-v7.S b/arch/arm/mm/tlb-v7.S
index 24ba510..010c478 100644
--- a/arch/arm/mm/tlb-v7.S
+++ b/arch/arm/mm/tlb-v7.S
@@ -41,9 +41,11 @@ ENTRY(v7wbi_flush_user_tlb_range)
 	mov	r1, r1, lsl #PAGE_SHIFT
 	vma_vm_flags r2, r2			@ get vma->vm_flags
 1:
-	mcr	p15, 0, r0, c8, c6, 1		@ TLB invalidate D MVA (was 1)
-	tst	r2, #VM_EXEC			@ Executable area ?
-	mcrne	p15, 0, r0, c8, c5, 1		@ TLB invalidate I MVA (was 1)
+#ifdef CONFIG_SMP
+	mcr	p15, 0, r0, c8, c3, 1		@ TLB invalidate U MVA (shareable) 
+#else
+	mcr	p15, 0, r0, c8, c7, 1		@ TLB invalidate U MVA
+#endif
 	add	r0, r0, #PAGE_SZ
 	cmp	r0, r1
 	blo	1b
@@ -68,8 +70,11 @@ ENTRY(v7wbi_flush_kern_tlb_range)
 	mov	r0, r0, lsl #PAGE_SHIFT
 	mov	r1, r1, lsl #PAGE_SHIFT
 1:
-	mcr	p15, 0, r0, c8, c6, 1		@ TLB invalidate D MVA
-	mcr	p15, 0, r0, c8, c5, 1		@ TLB invalidate I MVA
+#ifdef CONFIG_SMP
+	mcr	p15, 0, r0, c8, c3, 1		@ TLB invalidate U MVA (shareable)
+#else
+	mcr	p15, 0, r0, c8, c7, 1		@ TLB invalidate U MVA
+#endif
 	add	r0, r0, #PAGE_SZ
 	cmp	r0, r1
 	blo	1b
@@ -86,5 +91,5 @@ ENDPROC(v7wbi_flush_kern_tlb_range)
 ENTRY(v7wbi_tlb_fns)
 	.long	v7wbi_flush_user_tlb_range
 	.long	v7wbi_flush_kern_tlb_range
-	.long	v6wbi_tlb_flags
+	.long	v7wbi_tlb_flags
 	.size	v7wbi_tlb_fns, . - v7wbi_tlb_fns
diff --git a/arch/arm/oprofile/backtrace.c b/arch/arm/oprofile/backtrace.c
index cefc21c..d805a52 100644
--- a/arch/arm/oprofile/backtrace.c
+++ b/arch/arm/oprofile/backtrace.c
@@ -18,15 +18,14 @@
 #include <linux/mm.h>
 #include <linux/uaccess.h>
 #include <asm/ptrace.h>
-
-#include "../kernel/stacktrace.h"
+#include <asm/stacktrace.h>
 
 static int report_trace(struct stackframe *frame, void *d)
 {
 	unsigned int *depth = d;
 
 	if (*depth) {
-		oprofile_add_trace(frame->lr);
+		oprofile_add_trace(frame->pc);
 		(*depth)--;
 	}
 
@@ -70,9 +69,12 @@ void arm_backtrace(struct pt_regs * const regs, unsigned int depth)
 	struct frame_tail *tail = ((struct frame_tail *) regs->ARM_fp) - 1;
 
 	if (!user_mode(regs)) {
-		unsigned long base = ((unsigned long)regs) & ~(THREAD_SIZE - 1);
-		walk_stackframe(regs->ARM_fp, base, base + THREAD_SIZE,
-				report_trace, &depth);
+		struct stackframe frame;
+		frame.fp = regs->ARM_fp;
+		frame.sp = regs->ARM_sp;
+		frame.lr = regs->ARM_lr;
+		frame.pc = regs->ARM_pc;
+		walk_stackframe(&frame, report_trace, &depth);
 		return;
 	}
 
diff --git a/arch/arm/oprofile/op_model_v6.c b/arch/arm/oprofile/op_model_v6.c
index fe58138..814a214 100644
--- a/arch/arm/oprofile/op_model_v6.c
+++ b/arch/arm/oprofile/op_model_v6.c
@@ -33,6 +33,9 @@ static int irqs[] = {
 #ifdef CONFIG_ARCH_OMAP2
 	3,
 #endif
+#ifdef CONFIG_ARCH_PC302
+        IRQ_NPMUIRQ,
+#endif
 };
 
 static void armv6_pmu_stop(void)
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 43aa202..930240b 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1899,3 +1899,6 @@ rut100			MACH_RUT100		RUT100			1908
 asusp535		MACH_ASUSP535		ASUSP535		1909
 htcraphael		MACH_HTCRAPHAEL		HTCRAPHAEL		1910
 sygdg1			MACH_SYGDG1		SYGDG1			1911
+pc7302                  MACH_PC7302             PC7302                  2220
+pc7802                  MACH_PC7802             PC7802                  2436
+pc72052_i10_revb	MACH_PC72052_I10_REVB 	PC72052_I10_REVB	9997
diff --git a/arch/arm/vfp/entry.S b/arch/arm/vfp/entry.S
index ba592a9..4fa9903 100644
--- a/arch/arm/vfp/entry.S
+++ b/arch/arm/vfp/entry.S
@@ -15,13 +15,16 @@
  *  r10 = thread_info structure
  *  lr  = failure return
  */
-#include <linux/linkage.h>
-#include <linux/init.h>
-#include <asm/asm-offsets.h>
-#include <asm/assembler.h>
+#include <asm/thread_info.h>
 #include <asm/vfpmacros.h>
+#include "../kernel/entry-header.S"
 
 ENTRY(do_vfp)
+#ifdef CONFIG_PREEMPT
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	add	r11, r4, #1		@ increment it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	enable_irq
  	ldr	r4, .LCvfp
 	ldr	r11, [r10, #TI_CPU]	@ CPU number
@@ -30,9 +33,16 @@ ENTRY(do_vfp)
 ENDPROC(do_vfp)
 
 ENTRY(vfp_null_entry)
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	mov	pc, lr
 ENDPROC(vfp_null_entry)
 
+	.align	2
 .LCvfp:
 	.word	vfp_vector
 
@@ -41,11 +51,18 @@ ENDPROC(vfp_null_entry)
 
 	__INIT
 ENTRY(vfp_testing_entry)
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	ldr	r0, VFP_arch_address
 	str	r5, [r0]		@ known non-zero value
 	mov	pc, r9			@ we have handled the fault
 ENDPROC(vfp_testing_entry)
 
+	.align	2
 VFP_arch_address:
 	.word	VFP_arch
 
diff --git a/arch/arm/vfp/vfp.h b/arch/arm/vfp/vfp.h
index c85860b..8a5fe9c 100644
--- a/arch/arm/vfp/vfp.h
+++ b/arch/arm/vfp/vfp.h
@@ -37,6 +37,7 @@ static inline u32 vfp_hi64to32jamming(u64 val)
 
 	asm(
 	"cmp	%Q1, #1		@ vfp_hi64to32jamming\n\t"
+	"ite	cc\n\t"
 	"movcc	%0, %R1\n\t"
 	"orrcs	%0, %R1, #1"
 	: "=r" (v) : "r" (val) : "cc");
@@ -377,6 +378,4 @@ struct op {
 	u32 flags;
 };
 
-#ifdef CONFIG_SMP
 extern void vfp_save_state(void *location, u32 fpexc);
-#endif
diff --git a/arch/arm/vfp/vfphw.S b/arch/arm/vfp/vfphw.S
index a62dcf7..f570411 100644
--- a/arch/arm/vfp/vfphw.S
+++ b/arch/arm/vfp/vfphw.S
@@ -1,5 +1,4 @@
-/*
- *  linux/arch/arm/vfp/vfphw.S
+/*  linux/arch/arm/vfp/vfphw.S
  *
  *  Copyright (C) 2004 ARM Limited.
  *  Written by Deep Blue Solutions Limited.
@@ -101,9 +100,12 @@ ENTRY(vfp_support_entry)
 	VFPFSTMIA r4, r5		@ save the working registers
 	VFPFMRX	r5, FPSCR		@ current status
 	tst	r1, #FPEXC_EX		@ is there additional state to save?
-	VFPFMRX	r6, FPINST, NE		@ FPINST (only if FPEXC.EX is set)
-	tstne	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
-	VFPFMRX	r8, FPINST2, NE		@ FPINST2 if needed (and present)
+	beq	1f
+	VFPFMRX	r6, FPINST		@ FPINST (only if FPEXC.EX is set)
+	tst	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
+	beq	1f
+	VFPFMRX	r8, FPINST2		@ FPINST2 if needed (and present)
+1:
 	stmia	r4, {r1, r5, r6, r8}	@ save FPEXC, FPSCR, FPINST, FPINST2
 					@ and point r4 at the word at the
 					@ start of the register dump
@@ -117,9 +119,12 @@ no_old_VFP_process:
 					@ FPEXC is in a safe state
 	ldmia	r10, {r1, r5, r6, r8}	@ load FPEXC, FPSCR, FPINST, FPINST2
 	tst	r1, #FPEXC_EX		@ is there additional state to restore?
-	VFPFMXR	FPINST, r6, NE		@ restore FPINST (only if FPEXC.EX is set)
-	tstne	r1, #FPEXC_FP2V		@ is there an FPINST2 to write?
-	VFPFMXR	FPINST2, r8, NE		@ FPINST2 if needed (and present)
+	beq	1f
+	VFPFMXR	FPINST, r6		@ restore FPINST (only if FPEXC.EX is set)
+	tst	r1, #FPEXC_FP2V		@ is there an FPINST2 to write?
+	beq	1f
+	VFPFMXR	FPINST2, r8		@ FPINST2 if needed (and present)
+1:
 	VFPFMXR	FPSCR, r5		@ restore status
 
 check_for_exception:
@@ -131,6 +136,12 @@ check_for_exception:
 	VFPFMXR	FPEXC, r1		@ restore FPEXC last
 	sub	r2, r2, #4
 	str	r2, [sp, #S_PC]		@ retry the instruction
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	mov	pc, r9			@ we think we have handled things
 
 
@@ -149,6 +160,12 @@ look_for_VFP_exceptions:
 	@ not recognised by VFP
 
 	DBGSTR	"not VFP"
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	mov	pc, lr
 
 process_exception:
@@ -166,7 +183,6 @@ process_exception:
 					@ retry the faulted instruction
 ENDPROC(vfp_support_entry)
 
-#ifdef CONFIG_SMP
 ENTRY(vfp_save_state)
 	@ Save the current VFP state
 	@ r0 - save location
@@ -175,51 +191,65 @@ ENTRY(vfp_save_state)
 	VFPFSTMIA r0, r2		@ save the working registers
 	VFPFMRX	r2, FPSCR		@ current status
 	tst	r1, #FPEXC_EX		@ is there additional state to save?
-	VFPFMRX	r3, FPINST, NE		@ FPINST (only if FPEXC.EX is set)
-	tstne	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
-	VFPFMRX	r12, FPINST2, NE	@ FPINST2 if needed (and present)
+	beq	1f
+	VFPFMRX	r3, FPINST		@ FPINST (only if FPEXC.EX is set)
+	tst	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
+	beq	1f
+	VFPFMRX	r12, FPINST2		@ FPINST2 if needed (and present)
+1:
 	stmia	r0, {r1, r2, r3, r12}	@ save FPEXC, FPSCR, FPINST, FPINST2
 	mov	pc, lr
 ENDPROC(vfp_save_state)
-#endif
 
 last_VFP_context_address:
 	.word	last_VFP_context
 
+	.macro	tbl_branch, base, tmp, shift
+ ARM(	add	pc, pc, \base, lsl \shift	)
+ ARM(	mov	r0, r0				)
+ THUMB(	adr	\tmp, 1f			)
+ THUMB(	add	\tmp, \tmp, \base, lsl \shift	)
+ THUMB(	mov	pc, \tmp			)
+1:
+	.endm
+
 ENTRY(vfp_get_float)
-	add	pc, pc, r0, lsl #3
-	mov	r0, r0
+	tbl_branch r0, r3, #3
 	.irp	dr,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
-	mrc	p10, 0, r0, c\dr, c0, 0	@ fmrs	r0, s0
+1:	mrc	p10, 0, r0, c\dr, c0, 0	@ fmrs	r0, s0
 	mov	pc, lr
-	mrc	p10, 0, r0, c\dr, c0, 4	@ fmrs	r0, s1
+	.org	1b + 8
+1:	mrc	p10, 0, r0, c\dr, c0, 4	@ fmrs	r0, s1
 	mov	pc, lr
+	.org	1b + 8
 	.endr
 ENDPROC(vfp_get_float)
 
 ENTRY(vfp_put_float)
-	add	pc, pc, r1, lsl #3
-	mov	r0, r0
+	tbl_branch r1, r3, #3
 	.irp	dr,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
-	mcr	p10, 0, r0, c\dr, c0, 0	@ fmsr	r0, s0
+1:	mcr	p10, 0, r0, c\dr, c0, 0	@ fmsr	r0, s0
 	mov	pc, lr
-	mcr	p10, 0, r0, c\dr, c0, 4	@ fmsr	r0, s1
+	.org	1b + 8
+1:	mcr	p10, 0, r0, c\dr, c0, 4	@ fmsr	r0, s1
 	mov	pc, lr
+	.org	1b + 8
 	.endr
 ENDPROC(vfp_put_float)
 
 ENTRY(vfp_get_double)
-	add	pc, pc, r0, lsl #3
-	mov	r0, r0
+	tbl_branch r0, r3, #3
 	.irp	dr,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
-	fmrrd	r0, r1, d\dr
+1:	fmrrd	r0, r1, d\dr
 	mov	pc, lr
+	.org	1b + 8
 	.endr
 #ifdef CONFIG_VFPv3
 	@ d16 - d31 registers
 	.irp	dr,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
-	mrrc	p11, 3, r0, r1, c\dr	@ fmrrd	r0, r1, d\dr
+1:	mrrc	p11, 3, r0, r1, c\dr	@ fmrrd	r0, r1, d\dr
 	mov	pc, lr
+	.org	1b + 8
 	.endr
 #endif
 
@@ -230,17 +260,18 @@ ENTRY(vfp_get_double)
 ENDPROC(vfp_get_double)
 
 ENTRY(vfp_put_double)
-	add	pc, pc, r2, lsl #3
-	mov	r0, r0
+	tbl_branch r2, r3, #3
 	.irp	dr,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
-	fmdrr	d\dr, r0, r1
+1:	fmdrr	d\dr, r0, r1
 	mov	pc, lr
+	.org	1b + 8
 	.endr
 #ifdef CONFIG_VFPv3
 	@ d16 - d31 registers
 	.irp	dr,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
-	mcrr	p11, 3, r1, r2, c\dr	@ fmdrr	r1, r2, d\dr
+1:	mcrr	p11, 3, r1, r2, c\dr	@ fmdrr	r1, r2, d\dr
 	mov	pc, lr
+	.org	1b + 8
 	.endr
 #endif
 ENDPROC(vfp_put_double)
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index c0d2c9b..9c1c287 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -14,6 +14,7 @@
 #include <linux/signal.h>
 #include <linux/sched.h>
 #include <linux/init.h>
+#include <linux/rcupdate.h>
 
 #include <asm/thread_notify.h>
 #include <asm/vfp.h>
@@ -49,14 +50,21 @@ static int vfp_notifier(struct notifier_block *self, unsigned long cmd, void *v)
 
 #ifdef CONFIG_SMP
 		/*
+		 * RCU locking is needed in case last_VFP_context[cpu] is
+		 * released on a different CPU.
+		 */
+		rcu_read_lock();
+		vfp = last_VFP_context[cpu];
+		/*
 		 * On SMP, if VFP is enabled, save the old state in
 		 * case the thread migrates to a different CPU. The
 		 * restoring is done lazily.
 		 */
-		if ((fpexc & FPEXC_EN) && last_VFP_context[cpu]) {
-			vfp_save_state(last_VFP_context[cpu], fpexc);
-			last_VFP_context[cpu]->hard.cpu = cpu;
+		if ((fpexc & FPEXC_EN) && vfp) {
+			vfp_save_state(vfp, fpexc);
+			vfp->hard.cpu = cpu;
 		}
+		rcu_read_unlock();
 		/*
 		 * Thread migration, just force the reloading of the
 		 * state on the new CPU in case the VFP registers
@@ -91,8 +99,19 @@ static int vfp_notifier(struct notifier_block *self, unsigned long cmd, void *v)
 	}
 
 	/* flush and release case: Per-thread VFP cleanup. */
+#ifndef CONFIG_SMP
 	if (last_VFP_context[cpu] == vfp)
 		last_VFP_context[cpu] = NULL;
+#else
+	/*
+	 * Since release_thread() may be called from a different CPU, we use
+	 * cmpxchg() here to avoid a race with the vfp_support_entry() code
+	 * which modifies last_VFP_context[cpu]. Note that on SMP systems, a
+	 * STR instruction on a different CPU clears the global exclusive
+	 * monitor state.
+	 */
+	(void)cmpxchg(&last_VFP_context[cpu], vfp, NULL);
+#endif
 
 	return NOTIFY_DONE;
 }
@@ -266,7 +285,7 @@ void VFP_bounce(u32 trigger, u32 fpexc, struct pt_regs *regs)
 		 * on VFP subarch 1.
 		 */
 		 vfp_raise_exceptions(VFP_EXCEPTION_ERROR, trigger, fpscr, regs);
-		 return;
+		goto exit;
 	}
 
 	/*
@@ -297,7 +316,7 @@ void VFP_bounce(u32 trigger, u32 fpexc, struct pt_regs *regs)
 	 * the FPEXC.FP2V bit is valid only if FPEXC.EX is 1.
 	 */
 	if (fpexc ^ (FPEXC_EX | FPEXC_FP2V))
-		return;
+		goto exit;
 
 	/*
 	 * The barrier() here prevents fpinst2 being read
@@ -310,6 +329,8 @@ void VFP_bounce(u32 trigger, u32 fpexc, struct pt_regs *regs)
 	exceptions = vfp_emulate_instruction(trigger, orig_fpscr, regs);
 	if (exceptions)
 		vfp_raise_exceptions(exceptions, trigger, orig_fpscr, regs);
+ exit:
+	preempt_enable();
 }
 
 static void vfp_enable(void *unused)
@@ -322,6 +343,55 @@ static void vfp_enable(void *unused)
 	set_copro_access(access | CPACC_FULL(10) | CPACC_FULL(11));
 }
 
+/*
+ * Synchronise the hardware VFP state of a thread other than current with the
+ * saved one. This function is used by the ptrace mechanism.
+ */
+#ifdef CONFIG_SMP
+void vfp_sync_state(struct thread_info *thread)
+{
+	/*
+	 * On SMP systems, the VFP state is automatically saved at every
+	 * context switch. We mark the thread VFP state as belonging to a
+	 * non-existent CPU so that the saved one will be reloaded when
+	 * needed.
+	 */
+	thread->vfpstate.hard.cpu = NR_CPUS;
+}
+#else
+void vfp_sync_state(struct thread_info *thread)
+{
+	unsigned int cpu = get_cpu();
+	u32 fpexc = fmrx(FPEXC);
+
+	/*
+	 * If VFP is enabled, the previous state was already saved and
+	 * last_VFP_context updated.
+	 */
+	if (fpexc & FPEXC_EN)
+		goto out;
+
+	if (!last_VFP_context[cpu])
+		goto out;
+
+	/*
+	 * Save the last VFP state on this CPU.
+	 */
+	fmxr(FPEXC, fpexc | FPEXC_EN);
+	vfp_save_state(last_VFP_context[cpu], fpexc);
+	fmxr(FPEXC, fpexc);
+
+	/*
+	 * Set the context to NULL to force a reload the next time the thread
+	 * uses the VFP.
+	 */
+	last_VFP_context[cpu] = NULL;
+
+out:
+	put_cpu();
+}
+#endif
+
 #include <linux/smp.h>
 
 /*
@@ -371,6 +441,27 @@ static int __init vfp_init(void)
 		 * in place; report VFP support to userspace.
 		 */
 		elf_hwcap |= HWCAP_VFP;
+#ifdef CONFIG_VFPv3
+		if (VFP_arch >= 3) {
+			elf_hwcap |= HWCAP_VFPv3;
+
+			/*
+			 * Check for VFPv3 D16. CPUs in this configuration
+			 * only have 16 x 64bit registers.
+			 */
+			if (((fmrx(MVFR0) & MVFR0_A_SIMD_MASK)) == 1)
+				elf_hwcap |= HWCAP_VFPv3D16;
+		}
+#endif
+#ifdef CONFIG_NEON
+		/*
+		 * Check for the presence of the Advanced SIMD
+		 * load/store instructions, integer and single
+		 * precision floating point operations.
+		 */
+		if ((fmrx(MVFR1) & 0x000fff00) == 0x00011100)
+			elf_hwcap |= HWCAP_NEON;
+#endif
 	}
 	return 0;
 }
diff --git a/arch/powerpc/boot/Makefile b/arch/powerpc/boot/Makefile
index 3d3daa6..66f55b1 100644
--- a/arch/powerpc/boot/Makefile
+++ b/arch/powerpc/boot/Makefile
@@ -267,6 +267,7 @@ image-$(CONFIG_TQM8560)			+= cuImage.tqm8560
 image-$(CONFIG_SBC8548)			+= cuImage.sbc8548
 image-$(CONFIG_SBC8560)			+= cuImage.sbc8560
 image-$(CONFIG_KSI8560)			+= cuImage.ksi8560
+image-$(CONFIG_PICOHDP203)		+= cuImage.picohdp203
 
 # Board ports in arch/powerpc/platform/embedded6xx/Kconfig
 image-$(CONFIG_STORCENTER)		+= cuImage.storcenter
diff --git a/arch/powerpc/boot/dts/picohdp203.dts b/arch/powerpc/boot/dts/picohdp203.dts
new file mode 100644
index 0000000..bda8e9f
--- /dev/null
+++ b/arch/powerpc/boot/dts/picohdp203.dts
@@ -0,0 +1,348 @@
+/*
+ * MPC8560 ADS Device Tree Source
+ *
+ * Copyright 2006, 2008 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+/dts-v1/;
+
+/ {
+	model = "MPC8560ADS";
+	compatible = "MPC8560ADS", "MPC85xxADS";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	aliases {
+		ethernet0 = &enet0;
+		ethernet1 = &enet1;
+		serial0 = &serial0;
+		serial1 = &serial1;
+		pci0 = &pci0;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		PowerPC,8560@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			d-cache-line-size = <32>;	// 32 bytes
+			i-cache-line-size = <32>;	// 32 bytes
+			d-cache-size = <0x8000>;		// L1, 32K
+			i-cache-size = <0x8000>;		// L1, 32K
+			timebase-frequency = <80000000>;
+			bus-frequency = <330000000>;
+			clock-frequency = <800000000>;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x10000000>;
+	};
+
+	soc8560@80000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		device_type = "soc";
+		compatible = "simple-bus";
+		ranges = <0x0 0x80000000 0x100000>;
+		reg = <0x80000000 0x200>;
+		bus-frequency = <330000000>;
+
+		memory-controller@2000 {
+			compatible = "fsl,8540-memory-controller";
+			reg = <0x2000 0x1000>;
+			interrupt-parent = <&mpic>;
+			interrupts = <18 2>;
+		};
+
+		L2: l2-cache-controller@20000 {
+			compatible = "fsl,8540-l2-cache-controller";
+			reg = <0x20000 0x1000>;
+			cache-line-size = <32>;	// 32 bytes
+			cache-size = <0x40000>;	// L2, 256K
+			interrupt-parent = <&mpic>;
+			interrupts = <16 2>;
+		};
+
+		dma@21300 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "fsl,mpc8560-dma", "fsl,eloplus-dma";
+			reg = <0x21300 0x4>;
+			ranges = <0x0 0x21100 0x200>;
+			cell-index = <0>;
+			dma-channel@0 {
+				compatible = "fsl,mpc8560-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x0 0x80>;
+				cell-index = <0>;
+				interrupt-parent = <&mpic>;
+				interrupts = <20 2>;
+			};
+			dma-channel@80 {
+				compatible = "fsl,mpc8560-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x80 0x80>;
+				cell-index = <1>;
+				interrupt-parent = <&mpic>;
+				interrupts = <21 2>;
+			};
+			dma-channel@100 {
+				compatible = "fsl,mpc8560-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x100 0x80>;
+				cell-index = <2>;
+				interrupt-parent = <&mpic>;
+				interrupts = <22 2>;
+			};
+			dma-channel@180 {
+				compatible = "fsl,mpc8560-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x180 0x80>;
+				cell-index = <3>;
+				interrupt-parent = <&mpic>;
+				interrupts = <23 2>;
+			};
+		};
+
+		mdio@24520 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,gianfar-mdio";
+			reg = <0x24520 0x20>;
+
+			phy0: ethernet-phy@0 {
+				interrupt-parent = <&mpic>;
+				interrupts = <5 1>;
+				reg = <0x0>;
+				device_type = "ethernet-phy";
+			};
+			phy1: ethernet-phy@1 {
+				interrupt-parent = <&mpic>;
+				interrupts = <5 1>;
+				reg = <0x1>;
+				device_type = "ethernet-phy";
+			};
+			phy2: ethernet-phy@2 {
+				interrupt-parent = <&mpic>;
+				interrupts = <7 1>;
+				reg = <0x2>;
+				device_type = "ethernet-phy";
+			};
+			phy3: ethernet-phy@3 {
+				interrupt-parent = <&mpic>;
+				interrupts = <7 1>;
+				reg = <0x3>;
+				device_type = "ethernet-phy";
+			};
+		};
+
+		enet0: ethernet@24000 {
+			cell-index = <0>;
+			device_type = "network";
+			model = "TSEC";
+			compatible = "gianfar";
+			reg = <0x24000 0x1000>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <29 2 30 2 34 2>;
+			interrupt-parent = <&mpic>;
+			phy-handle = <&phy0>;
+		};
+
+		enet1: ethernet@25000 {
+			cell-index = <1>;
+			device_type = "network";
+			model = "TSEC";
+			compatible = "gianfar";
+			reg = <0x25000 0x1000>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <35 2 36 2 40 2>;
+			interrupt-parent = <&mpic>;
+			phy-handle = <&phy1>;
+		};
+
+		mpic: pic@40000 {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <2>;
+			compatible = "chrp,open-pic";
+			reg = <0x40000 0x40000>;
+			device_type = "open-pic";
+		};
+
+		cpm@919c0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "fsl,mpc8560-cpm", "fsl,cpm2";
+			reg = <0x919c0 0x30>;
+			ranges;
+
+			muram@80000 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x0 0x80000 0x10000>;
+
+				data@0 {
+					compatible = "fsl,cpm-muram-data";
+					reg = <0x0 0x4000 0x9000 0x2000>;
+				};
+			};
+
+			brg@919f0 {
+				compatible = "fsl,mpc8560-brg",
+				             "fsl,cpm2-brg",
+				             "fsl,cpm-brg";
+				reg = <0x919f0 0x10 0x915f0 0x10>;
+				clock-frequency = <133340000>;
+			};
+
+                        cpmpic: pic@90c00 {
+                                interrupt-controller;
+                                #address-cells = <0>;
+                                #interrupt-cells = <2>;
+                                interrupts = <46 2>;
+                                interrupt-parent = <&mpic>;
+                                reg = <0x90c00 0x80>;
+                                compatible = "fsl,mpc8560-cpm-pic", "fsl,cpm2-pic";
+                        };
+
+			serial0: serial@91a40 {
+				device_type = "serial";
+				compatible = "fsl,mpc8560-scc-uart",
+				             "fsl,cpm2-scc-uart";
+				reg = <0x91a40 0x20 0x88200 0x100>;
+				fsl,cpm-brg = <1>;
+				fsl,cpm-command = <0x8c00000>;
+				current-speed = <115200>;
+				interrupts = <42 8>;
+				interrupt-parent = <&cpmpic>;
+			};
+
+			serial1: serial@91a60 {
+				device_type = "serial";
+				compatible = "fsl,mpc8560-scc-uart",
+				             "fsl,cpm2-scc-uart";
+				reg = <0x91a60 0x20 0x88300 0x100>;
+				fsl,cpm-brg = <1>;
+				fsl,cpm-command = <0xce00000>;
+				current-speed = <115200>;
+				interrupts = <43 8>;
+				interrupt-parent = <&cpmpic>;
+			};
+		};
+
+		global-utilities@e0000 {
+			compatible = "fsl,mpc8560-guts";
+			reg = <0xe0000 0x1000>;
+			fsl,has-rstcr;
+		};
+        };
+
+	pci0: pci@80008000 {
+		cell-index = <0>;
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		compatible = "fsl,mpc8540-pcix", "fsl,mpc8540-pci";
+		device_type = "pci";
+		reg = <0x80008000 0x1000>;
+		clock-frequency = <66666666>;
+                interrupts = <24 2>;
+
+		interrupt-parent = <&mpic>;
+                ranges = <0x02000000            /* Flag for IO space. */
+                          0x00000000 0x40000000 /* PCI address. */
+                          0x40000000            /* Address to map into CPU space. */
+                          0x00000000 0x01000000 /* Size. */
+
+                          0x01000000            /* Flag for memory space. */
+                          0x00000000 0x48000000 /* PCI address. */
+                          0x48000000            /* Address to map into CPU space. */
+                          0x00000000 0x01000000 /* Size. */
+                          >;
+                interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
+
+                /* This map is for the security processor sitting on IDSEL 17
+                 * and uses external interrupt 8. The numbers (in order) are:
+                 *   - IDSEL (top 5 bits)
+                 *   - unused
+                 *   - unused
+                 *   - interrupt number (INTA)
+                 *   - parent interrupt controller
+                 *   - interrupt number (EXT8)
+                 *   - sense level (active low)
+                 */
+		interrupt-map = <
+			/* IDSEL 0x11 func 0 - PCI slot 1 */
+			0x8800 0x0 0x0 0x1 &mpic 0x8 0x1
+                        >;
+	};
+
+        picoArray0: picoArray@d0000000 {
+                device_type = "picoArray";
+                compatible = "picoArray";
+                #address-cells = <1>;
+                #size-cells = <1>;
+                interrupts = <1 1>;
+                interrupt-parent = <&mpic>;
+                cell-index = <0>;
+
+		procif = <0xd0000000 0x80>;
+                dma_base = <0xc0000000 0x40000>;
+                ccr_base = <0xd0002000 0x80>;
+                dma_spacing = <0x10000>;
+        };
+
+        picoArray1: picoArray@d0004000 {
+                device_type = "picoArray";
+                compatible = "picoArray";
+                #address-cells = <1>;
+                #size-cells = <1>;
+                interrupts = <2 1>;
+                interrupt-parent = <&mpic>;
+                cell-index = <1>;
+
+		procif = <0xd0004000 0x80>;
+                dma_base = <0xc0040000 0x40000>;
+                ccr_base = <0xd0006000 0x80>;
+                dma_spacing = <0x10000>;
+        };
+
+        picoArray2: picoArray@d0008000 {
+                device_type = "picoArray";
+                compatible = "picoArray";
+                #address-cells = <1>;
+                #size-cells = <1>;
+                interrupts = <7 1>;
+                interrupt-parent = <&mpic>;
+                cell-index = <2>;
+
+		procif = <0xd0008000 0x80>;
+                dma_base = <0xc0080000 0x40000>;
+                ccr_base = <0xd000a000 0x80>;
+                dma_spacing = <0x10000>;
+        };
+
+        picoArray3: picoArray@d000c000 {
+                device_type = "picoArray";
+                compatible = "picoArray";
+                #address-cells = <1>;
+                #size-cells = <1>;
+                interrupts = <8 1>;
+                interrupt-parent = <&mpic>;
+                cell-index = <3>;
+
+		procif = <0xd000c000 0x80>;
+                dma_base = <0xc00c0000 0x40000>;
+                ccr_base = <0xd000e000 0x80>;
+                dma_spacing = <0x10000>;
+        };
+};
diff --git a/arch/powerpc/boot/simple/m85xx_tty.c b/arch/powerpc/boot/simple/m85xx_tty.c
new file mode 100644
index 0000000..4817249
--- /dev/null
+++ b/arch/powerpc/boot/simple/m85xx_tty.c
@@ -0,0 +1,330 @@
+/* Minimal serial functions needed to send messages out the serial
+ * port on SMC1.
+ */
+#include <linux/types.h>
+#include <asm/mpc85xx.h>
+#include <asm/cpm2.h>
+#include <asm/immap_cpm2.h>
+
+uint	no_print;
+extern char	*params[];
+extern int	nparams;
+static		u_char	cons_hold[128], *sgptr;
+static		int	cons_hold_cnt;
+
+/* If defined, enables serial console.  The value (1 through 4)
+ * should designate which SCC is used, but this isn't complete.  Only
+ * SCC1 is known to work at this time.
+ * We're only linked if SERIAL_CPM_CONSOLE=y, so we only need to test
+ * SERIAL_CPM_SCC1.
+ */
+#ifdef CONFIG_SERIAL_CPM_SCC1
+#define SCC_CONSOLE 1
+#endif
+
+/* I need SCC3 (this works...) */
+#ifdef CONFIG_SERIAL_CPM_SCC3
+#define SCC_CONSOLE 3
+#endif
+
+unsigned long
+serial_init(int ignored, bd_t *bd)
+{
+#ifdef SCC_CONSOLE
+	volatile scc_t		*sccp;
+	volatile scc_uart_t	*sup;
+#else
+	volatile smc_t		*sp;
+	volatile smc_uart_t	*up;
+#endif
+	volatile cbd_t	*tbdf, *rbdf;
+	volatile cpm2_map_t	*ip;
+	volatile iop_cpm2_t	*io;
+	volatile cpm_cpm2_t	*cp;
+	uint	dpaddr, memaddr;
+
+	ip = (cpm2_map_t *)CPM_MAP_ADDR;
+	cp = &ip->im_cpm;
+	io = &ip->im_ioport;
+
+	/* Perform a reset.
+	*/
+	cp->cp_cpcr = (CPM_CR_RST | CPM_CR_FLG);
+
+	/* Wait for it.
+	*/
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+#ifdef SCC_CONSOLE
+	sccp = (scc_t *)&(ip->im_scc[SCC_CONSOLE-1]);
+	sup = (scc_uart_t *)&ip->im_dprambase[PROFF_SCC1 + ((SCC_CONSOLE-1) << 8)];
+	sccp->scc_sccm &= ~(UART_SCCM_TX | UART_SCCM_RX);
+	sccp->scc_gsmrl &= ~(SCC_GSMRL_ENR | SCC_GSMRL_ENT);
+
+#if SCC_CONSOLE == 1
+	/* Use Port D for SCC1 instead of other functions.
+	*/
+	io->iop_ppard |= 0x00000003;
+	io->iop_psord &= ~0x00000001;	/* Rx */
+	io->iop_psord |= 0x00000002;	/* Tx */
+	io->iop_pdird &= ~0x00000001;	/* Rx */
+	io->iop_pdird |= 0x00000002;	/* Tx */
+/* Otherwise rely on bootstrap to set up IO */
+#endif
+
+#else
+	sp = (smc_t*)&(ip->im_smc[0]);
+	*(ushort *)(&ip->im_dprambase[PROFF_SMC1_BASE]) = PROFF_SMC1;
+	up = (smc_uart_t *)&ip->im_dprambase[PROFF_SMC1];
+
+	/* Disable transmitter/receiver.
+	*/
+	sp->smc_smcmr &= ~(SMCMR_REN | SMCMR_TEN);
+
+	/* Use Port D for SMC1 instead of other functions.
+	*/
+	io->iop_ppard |= 0x00c00000;
+	io->iop_pdird |= 0x00400000;
+	io->iop_pdird &= ~0x00800000;
+	io->iop_psord &= ~0x00c00000;
+#endif
+
+	/* Allocate space for two buffer descriptors in the DP ram.
+	 * For now, this address seems OK, but it may have to
+	 * change with newer versions of the firmware.
+	 */
+	dpaddr = 0x0800;
+
+	/* Grab a few bytes from the top of memory.
+	 */
+	memaddr = (bd->bi_memsize - 256) & ~15;
+
+	/* Set the physical address of the host memory buffers in
+	 * the buffer descriptors.
+	 */
+	rbdf = (cbd_t *)&ip->im_dprambase[dpaddr];
+	rbdf->cbd_bufaddr = memaddr;
+	rbdf->cbd_sc = 0;
+	tbdf = rbdf + 1;
+	tbdf->cbd_bufaddr = memaddr+128;
+	tbdf->cbd_sc = 0;
+
+	/* Set up the uart parameters in the parameter ram.
+	*/
+#ifdef SCC_CONSOLE
+	sup->scc_genscc.scc_rbase = dpaddr;
+	sup->scc_genscc.scc_tbase = dpaddr + sizeof(cbd_t);
+
+	/* Set up the uart parameters in the
+	 * parameter ram.
+	 */
+	sup->scc_genscc.scc_rfcr = CPMFCR_GBL | CPMFCR_EB;
+	sup->scc_genscc.scc_tfcr = CPMFCR_GBL | CPMFCR_EB;
+
+	sup->scc_genscc.scc_mrblr = 128;
+	sup->scc_maxidl = 8;
+	sup->scc_brkcr = 1;
+	sup->scc_parec = 0;
+	sup->scc_frmec = 0;
+	sup->scc_nosec = 0;
+	sup->scc_brkec = 0;
+	sup->scc_uaddr1 = 0;
+	sup->scc_uaddr2 = 0;
+	sup->scc_toseq = 0;
+	sup->scc_char1 = 0x8000;
+	sup->scc_char2 = 0x8000;
+	sup->scc_char3 = 0x8000;
+	sup->scc_char4 = 0x8000;
+	sup->scc_char5 = 0x8000;
+	sup->scc_char6 = 0x8000;
+	sup->scc_char7 = 0x8000;
+	sup->scc_char8 = 0x8000;
+	sup->scc_rccm = 0xc0ff;
+
+	/* Send the CPM an initialize command.
+	*/
+	cp->cp_cpcr = mk_cr_cmd(CPM_CR_SCC1_PAGE, CPM_CR_SCC1_SBLOCK, 0,
+			CPM_CR_INIT_TRX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* Set UART mode, 8 bit, no parity, one stop.
+	 * Enable receive and transmit.
+	 */
+	sccp->scc_gsmrh = 0;
+	sccp->scc_gsmrl =
+		(SCC_GSMRL_MODE_UART | SCC_GSMRL_TDCR_16 | SCC_GSMRL_RDCR_16);
+
+	/* Disable all interrupts and clear all pending
+	 * events.
+	 */
+	sccp->scc_sccm = 0;
+	sccp->scc_scce = 0xffff;
+	sccp->scc_dsr = 0x7e7e;
+	sccp->scc_psmr = 0x3000;
+
+	/* Wire BRG1 to SCC1, BRG2 to SCC2, BRG3 to SCC3 etc.  
+	 * The console driver will take care of the others.
+	 */
+	ip->im_cpmux.cmx_scr = 0;
+
+#else
+	up->smc_rbase = dpaddr;
+	up->smc_tbase = dpaddr+sizeof(cbd_t);
+	up->smc_rfcr = CPMFCR_EB;
+	up->smc_tfcr = CPMFCR_EB;
+	up->smc_brklen = 0;
+	up->smc_brkec = 0;
+	up->smc_brkcr = 0;
+	up->smc_mrblr = 128;
+	up->smc_maxidl = 8;
+
+	/* Set UART mode, 8 bit, no parity, one stop.
+	 * Enable receive and transmit.
+	 */
+	sp->smc_smcmr = smcr_mk_clen(9) |  SMCMR_SM_UART;
+
+	/* Mask all interrupts and remove anything pending.
+	*/
+	sp->smc_smcm = 0;
+	sp->smc_smce = 0xff;
+
+	/* Set up the baud rate generator.
+	 */
+	ip->im_cpmux.cmx_smr = 0;
+#endif
+
+	/* The baud rate is not set by this driver: we assume that there
+	 * is a bootstrap which has correctly configured the serial port.
+	 */
+#if 0
+	ip->im_brgc1 =
+		(((bd->bi_brgfreq/16) / bd->bi_baudrate) << 1) |
+								CPM_BRG_EN;
+#endif
+
+	/* Make the first buffer the only buffer.
+	*/
+	tbdf->cbd_sc |= BD_SC_WRAP;
+	rbdf->cbd_sc |= BD_SC_EMPTY | BD_SC_WRAP;
+
+	/* Initialize Tx/Rx parameters.
+	*/
+#ifdef SCC_CONSOLE
+	sccp->scc_gsmrl |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);
+#else
+	cp->cp_cpcr = mk_cr_cmd(CPM_CR_SMC1_PAGE, CPM_CR_SMC1_SBLOCK, 0, CPM_CR_INIT_TRX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG);
+
+	/* Enable transmitter/receiver.
+	*/
+	sp->smc_smcmr |= SMCMR_REN | SMCMR_TEN;
+#endif
+
+	/* This is ignored.
+	*/
+	return 0;
+}
+
+int
+serial_readbuf(u_char *cbuf)
+{
+	volatile cbd_t		*rbdf;
+	volatile char		*buf;
+#ifdef SCC_CONSOLE
+	volatile scc_uart_t	*sup;
+#else
+	volatile smc_uart_t	*up;
+#endif
+	volatile cpm2_map_t	*ip;
+	int	i, nc;
+
+	ip = (cpm2_map_t *)CPM_MAP_ADDR;
+
+#ifdef SCC_CONSOLE
+	sup = (scc_uart_t *)&ip->im_dprambase[PROFF_SCC1 + ((SCC_CONSOLE-1) << 8)];
+	rbdf = (cbd_t *)&ip->im_dprambase[sup->scc_genscc.scc_rbase];
+#else
+	up = (smc_uart_t *)&(ip->im_dprambase[PROFF_SMC1]);
+	rbdf = (cbd_t *)&ip->im_dprambase[up->smc_rbase];
+#endif
+
+	/* Wait for character to show up.
+	*/
+	buf = (char *)rbdf->cbd_bufaddr;
+	while (rbdf->cbd_sc & BD_SC_EMPTY);
+	nc = rbdf->cbd_datlen;
+	for (i=0; i<nc; i++)
+		*cbuf++ = *buf++;
+	rbdf->cbd_sc |= BD_SC_EMPTY;
+
+	return(nc);
+}
+
+void
+serial_putc(void *ignored, const char c)
+{
+	volatile cbd_t		*tbdf;
+	volatile char		*buf;
+#ifdef SCC_CONSOLE
+	volatile scc_uart_t	*sup;
+#else
+	volatile smc_uart_t	*up;
+#endif
+	volatile cpm2_map_t	*ip;
+
+	ip = (cpm2_map_t *)CPM_MAP_ADDR;
+#ifdef SCC_CONSOLE
+	sup = (scc_uart_t *)&ip->im_dprambase[PROFF_SCC1 + ((SCC_CONSOLE-1) << 8)];
+	tbdf = (cbd_t *)&ip->im_dprambase[sup->scc_genscc.scc_tbase];
+#else
+	up = (smc_uart_t *)&(ip->im_dprambase[PROFF_SMC1]);
+	tbdf = (cbd_t *)&ip->im_dprambase[up->smc_tbase];
+#endif
+
+	/* Wait for last character to go.
+	*/
+	buf = (char *)tbdf->cbd_bufaddr;
+	while (tbdf->cbd_sc & BD_SC_READY);
+
+	*buf = c;
+	tbdf->cbd_datlen = 1;
+	tbdf->cbd_sc |= BD_SC_READY;
+}
+
+char
+serial_getc(void *ignored)
+{
+	char	c;
+
+	if (cons_hold_cnt <= 0) {
+		cons_hold_cnt = serial_readbuf(cons_hold);
+		sgptr = cons_hold;
+	}
+	c = *sgptr++;
+	cons_hold_cnt--;
+
+	return(c);
+}
+
+int
+serial_tstc(void *ignored)
+{
+	volatile cbd_t		*rbdf;
+#ifdef SCC_CONSOLE
+	volatile scc_uart_t	*sup;
+#else
+	volatile smc_uart_t	*up;
+#endif
+	volatile cpm2_map_t	*ip;
+
+	ip = (cpm2_map_t *)CPM_MAP_ADDR;
+#ifdef SCC_CONSOLE
+	sup = (scc_uart_t *)&ip->im_dprambase[PROFF_SCC1 + ((SCC_CONSOLE-1) << 8)];
+	rbdf = (cbd_t *)&ip->im_dprambase[sup->scc_genscc.scc_rbase];
+#else
+	up = (smc_uart_t *)&(ip->im_dprambase[PROFF_SMC1]);
+	rbdf = (cbd_t *)&ip->im_dprambase[up->smc_rbase];
+#endif
+
+	return(!(rbdf->cbd_sc & BD_SC_EMPTY));
+}
diff --git a/arch/powerpc/boot/wrapper b/arch/powerpc/boot/wrapper
index 965c237..74dcc5b 100755
--- a/arch/powerpc/boot/wrapper
+++ b/arch/powerpc/boot/wrapper
@@ -117,6 +117,8 @@ while [ "$#" -gt 0 ]; do
     shift
 done
 
+echo "DTS is $dts"
+
 if [ -n "$dts" ]; then
     if [ ! -r "$dts" -a -r "$object/dts/$dts" ]; then
 	dts="$object/dts/$dts"
@@ -180,7 +182,7 @@ cuboot*)
     *-mpc83*|*-asp834x*)
         platformo=$object/cuboot-83xx.o
         ;;
-    *-tqm8541|*-mpc8560*|*-tqm8560|*-tqm8555|*-ksi8560*)
+    *-tqm8541|*-mpc8560*|*-tqm8560|*-tqm8555|*-ksi8560*|*-picohdp*)
         platformo=$object/cuboot-85xx-cpm2.o
         ;;
     *-mpc85*|*-tqm85*|*-sbc85*)
diff --git a/arch/powerpc/configs/picohdp203_defconfig b/arch/powerpc/configs/picohdp203_defconfig
new file mode 100644
index 0000000..4b73d90
--- /dev/null
+++ b/arch/powerpc/configs/picohdp203_defconfig
@@ -0,0 +1,1178 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28
+# Wed Mar 25 11:45:39 2009
+#
+# CONFIG_PPC64 is not set
+
+#
+# Processor support
+#
+# CONFIG_6xx is not set
+CONFIG_PPC_85xx=y
+# CONFIG_PPC_8xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_E200 is not set
+CONFIG_E500=y
+# CONFIG_PPC_E500MC is not set
+CONFIG_BOOKE=y
+CONFIG_FSL_BOOKE=y
+CONFIG_FSL_EMB_PERFMON=y
+# CONFIG_PHYS_64BIT is not set
+CONFIG_SPE=y
+# CONFIG_PPC_MM_SLICES is not set
+CONFIG_PPC32=y
+CONFIG_WORD_SIZE=32
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_MMU=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_HARDIRQS=y
+# CONFIG_HAVE_SETUP_PER_CPU_AREA is not set
+CONFIG_IRQ_PER_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_ILOG2_U32=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_NO_VIRT_TO_BUS is not set
+CONFIG_PPC=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_GENERIC_NVRAM=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_PPC_OF=y
+CONFIG_OF=y
+CONFIG_PPC_UDBG_16550=y
+# CONFIG_GENERIC_TBSYNC is not set
+CONFIG_AUDIT_ARCH=y
+CONFIG_GENERIC_BUG=y
+# CONFIG_DEFAULT_UIMAGE is not set
+# CONFIG_PPC_DCR_NATIVE is not set
+# CONFIG_PPC_DCR_MMIO is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-picochip-3.2.4"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+# CONFIG_SYSCTL_SYSCALL is not set
+# CONFIG_KALLSYMS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+# CONFIG_EPOLL is not set
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_MARKERS=y
+CONFIG_OPROFILE=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_CLK=y
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
+
+#
+# Platform support
+#
+# CONFIG_PPC_CELL is not set
+# CONFIG_PPC_CELL_NATIVE is not set
+# CONFIG_PQ2ADS is not set
+CONFIG_MPC85xx=y
+# CONFIG_MPC8540_ADS is not set
+# CONFIG_MPC8560_ADS is not set
+# CONFIG_MPC85xx_CDS is not set
+# CONFIG_MPC85xx_MDS is not set
+# CONFIG_MPC8536_DS is not set
+# CONFIG_MPC85xx_DS is not set
+# CONFIG_KSI8560 is not set
+# CONFIG_STX_GP3 is not set
+# CONFIG_TQM8540 is not set
+# CONFIG_TQM8541 is not set
+# CONFIG_TQM8548 is not set
+# CONFIG_TQM8555 is not set
+# CONFIG_TQM8560 is not set
+# CONFIG_SBC8548 is not set
+# CONFIG_SBC8560 is not set
+CONFIG_PICOHDP203=y
+# CONFIG_IPIC is not set
+CONFIG_MPIC=y
+# CONFIG_MPIC_WEIRD is not set
+# CONFIG_PPC_I8259 is not set
+# CONFIG_PPC_RTAS is not set
+# CONFIG_MMIO_NVRAM is not set
+# CONFIG_PPC_MPC106 is not set
+# CONFIG_PPC_970_NAP is not set
+# CONFIG_PPC_INDIRECT_IO is not set
+# CONFIG_GENERIC_IOMAP is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_QUICC_ENGINE is not set
+CONFIG_CPM2=y
+# CONFIG_FSL_ULI1575 is not set
+CONFIG_CPM=y
+# CONFIG_MPC8xxx_GPIO is not set
+
+#
+# Kernel options
+#
+# CONFIG_HIGHMEM is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+# CONFIG_SCHED_HRTICK is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_MATH_EMULATION=y
+# CONFIG_IOMMU_HELPER is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_ARCH_HAS_WALK_MEMORY=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_MIGRATION=y
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_PROC_DEVICETREE=y
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyCPM0,115200 root=/dev/nfs rw nfsroot=192.168.9.1:/var/nfs ip=192.168.9.10:192.168.9.1::255.255.255.0:picohdp:eth0:any"
+CONFIG_EXTRA_TARGETS=""
+# CONFIG_PM is not set
+CONFIG_SECCOMP=y
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+CONFIG_ZONE_DMA=y
+CONFIG_PPC_INDIRECT_PCI=y
+CONFIG_FSL_SOC=y
+CONFIG_FSL_PCI=y
+CONFIG_PPC_PCI_CHOICE=y
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_SYSCALL=y
+# CONFIG_PCIEPORTBUS is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
+# CONFIG_PCI_MSI is not set
+CONFIG_PCI_LEGACY=y
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_HAS_RAPIDIO is not set
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_PAGE_OFFSET=0xc0000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_PHYSICAL_START=0x00000000
+CONFIG_PHYSICAL_ALIGN=0x10000000
+CONFIG_TASK_SIZE=0xc0000000
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=y
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_OF_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PHYSMAP_OF is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_PICOHDP=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+CONFIG_OF_DEVICE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_I2C=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=32768
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_PHANTOM is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# Enable only one of the two stacks, unless you know what you are doing
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+CONFIG_BROADCOM_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+# CONFIG_MDIO_OF_GPIO is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_B44 is not set
+# CONFIG_ATL2 is not set
+CONFIG_FS_ENET=y
+CONFIG_FS_ENET_HAS_SCC=y
+CONFIG_FS_ENET_HAS_FCC=y
+CONFIG_FS_ENET_MDIO_FCC=y
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+CONFIG_GIANFAR=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_JME is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_CPM=y
+CONFIG_SERIAL_CPM_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_OF_PLATFORM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CPM is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_MPC=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Graphics adapter I2C/DDC channel drivers
+#
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_XILINX is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_REGULATOR is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+# CONFIG_RTC_CLASS is not set
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_FSL_DMA=y
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_PERFCOUNTERS is not set
+
+#
+# picoChip Drivers
+#
+CONFIG_PICOHDP_CPLD=m
+CONFIG_PICOIF=m
+CONFIG_PICOIF_PC203=y
+CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL=1
+# CONFIG_PICOIF_DEBUG_TO_CONSOLE is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MSDOS_PARTITION is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_HAVE_LMB=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_IRQSTACKS=y
+# CONFIG_VIRQ_DEBUG is not set
+# CONFIG_PPC_EARLY_DEBUG is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_CRYPTD=m
+# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_KEYSTREAM is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_TALITOS is not set
+CONFIG_PPC_CLOCK=y
+CONFIG_PPC_LIB_RHEAP=y
+# CONFIG_VIRTUALIZATION is not set
diff --git a/arch/powerpc/include/asm/cpld_hdp102.h b/arch/powerpc/include/asm/cpld_hdp102.h
new file mode 100644
index 0000000..b4acc1e
--- /dev/null
+++ b/arch/powerpc/include/asm/cpld_hdp102.h
@@ -0,0 +1,120 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+ * \file cpld_hdp102.h
+ * \brief Header file for HDP102 CPLD access
+ *
+ * Copyright (c)(p) 1997-2004 Airspan Networks Inc
+ * Copyright (c) 2007 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#ifndef __CPLD_HDP102_H__
+#define __CPLD_HDP102_H__
+
+#include <asm/types.h>
+
+/**
+ This driver provides a common interface for other drivers that need 
+ to access a shared register in the CPLD.  The API should be kept 
+ consistent with drivers/asmax/cpld.h as far as possible.
+**/
+
+typedef struct cpld_reg_param {
+    __u16 device;
+    __u16 reg;
+    __u16 data;
+} cpld_reg_param_t;
+
+#define PICO_CPLD_IOC_MAGIC   'C'
+#define PICO_CPLD_IOC_BASE     0
+#define PICO_CPLD_IOCWRITEREG  _IOW(   PICO_CPLD_IOC_MAGIC, PICO_CPLD_IOC_BASE + 0, cpld_reg_param_t)
+#define PICO_CPLD_IOCREADREG   _IOWR(  PICO_CPLD_IOC_MAGIC, PICO_CPLD_IOC_BASE + 1, cpld_reg_param_t)
+#define PICO_CPLD_IOC_MAXNUM (PICO_CPLD_IOC_BASE + 1)
+
+/* Platform stuff */
+#define PICO_CPLD_MAX_NUM_DEV 1              /* One programmable device on the hdp platforms */
+
+/** Register definitions  **/
+/*
+ * Please maintain the comments on the ends of the lines - these are for
+ * code-generattion in the cpld util.
+ */
+#define PICO_CPLD_REG_REV            (0x0)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_TEST           (0x1)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_DEBUG          (0x2)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_LEDRESET       (0x3)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_RFCTRL         (0x4)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_RFSPI          (0x5)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_RFIN           (0x6)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ATMCTRL        (0x7)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_PC102JTAG      (0x8)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_DUMMY1         (0x9)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_DREQCTRL       (0xA)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_HDP_MODE       (0xB)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_DMA_SELECT     (0xC)  /* codegen_cpld_reg */
+
+#define PICO_CPLD_REG_NREGS          (0x10)
+
+/*
+ * Number of DMA channels under our control via 
+ * PICO_CPLD_REG_DREQCTL register
+ */
+#define PICO_CPLD_DMA_NCHANS         (4)
+
+/** PicoChip resets are in register 3, with the LED control and
+ *  watchdog bits.
+ *  Bits 4..0 are LEDS 4..0; resets are write 1 to reset, auto-clearing.
+ */
+
+#define PICO_CPLD_BIT_LEDRESET_PA0RESET      (0x8000)
+#define PICO_CPLD_BIT_LEDRESET_PA1RESET      (0x4000)
+#define PICO_CPLD_BIT_LEDRESET_PA2RESET      (0x2000)
+#define PICO_CPLD_BIT_LEDRESET_PA3RESET      (0x1000)
+#define PICO_CPLD_BIT_LEDRESET_WATCHDOG      (0x0080)
+#define PICO_CPLD_BIT_LEDRESET_LEDMODE       (0x0040)
+#define PICO_CPLD_BIT_LEDRESET_LEDMASK       (0x001F)
+
+#define PICO_CPLD_REG_BLOCKSIZE	(0x10 * sizeof(u16))
+
+#ifdef __KERNEL__
+
+#include <asm/picochip/hdp102.h>
+
+/* Reset Register */
+/* These are dummy functions */
+void cpld_fpga_reset(int fpga);
+void cpld_fpga_reset_assert(int fpga);
+void cpld_fpga_reset_deassert(int fpga);
+
+/* Only reset_assert is used; our reset is auto-clearing */
+void cpld_pico_reset_assert(int pico);
+void cpld_pico_reset_deassert(int pico);
+
+/* Host CTRL Register - not implemented on this target, so dummy functions */
+void cpld_fan_on(int fan);
+void cpld_fan_off(int fan);
+
+/* functions for CPLD register read and write */
+unsigned short cpld_reg_read(unsigned char regno);
+void cpld_reg_write(unsigned char regno, unsigned short data);
+
+/* functions for working with the CPLD DMA state machines */
+void cpld_dma_enable(unsigned char chan);
+void cpld_dma_disable(unsigned char chan);
+void cpld_dma_reset(unsigned char chan);
+
+/* CPLD Version Register - not used at present */
+u8 cpld_version(void);
+u8 cpld_diagnostics(void);
+
+#endif	/* KERNEL */
+#endif  /* __CPLD_HDP102__ */
+
diff --git a/arch/powerpc/include/asm/cpm2.h b/arch/powerpc/include/asm/cpm2.h
index 0f5e8ff..8a1e403 100644
--- a/arch/powerpc/include/asm/cpm2.h
+++ b/arch/powerpc/include/asm/cpm2.h
@@ -1130,7 +1130,6 @@ typedef struct im_idma {
 #define FCC1_MEM_OFFSET FCC_MEM_OFFSET(0)
 #define FCC2_MEM_OFFSET FCC_MEM_OFFSET(1)
 #define FCC3_MEM_OFFSET FCC_MEM_OFFSET(2)
-
 /* Clocks and GRG's */
 
 enum cpm_clk_dir {
diff --git a/arch/powerpc/include/asm/picochip/hdp102.h b/arch/powerpc/include/asm/picochip/hdp102.h
new file mode 100644
index 0000000..f9b6c98
--- /dev/null
+++ b/arch/powerpc/include/asm/picochip/hdp102.h
@@ -0,0 +1,30 @@
+/*
+ * include/asm-ppc/picochip/hdp102.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/* Avoid multiple inclusion */
+#ifndef _PICOCHIP_HDP102_H_
+#define _PICOCHIP_HDP102_H_
+
+#define PICOHDP_CPLD_BASE           (0xE0000000) /* main board CPLD */
+
+#endif /* _PICOCHIP_HDP102_H_ */
+
diff --git a/arch/powerpc/include/asm/socket.h b/arch/powerpc/include/asm/socket.h
index f5a4e16..fa0359f 100644
--- a/arch/powerpc/include/asm/socket.h
+++ b/arch/powerpc/include/asm/socket.h
@@ -61,4 +61,7 @@
 
 #define SO_MARK			36
 
+#define SO_TIMESTAMPING         37
+#define SCM_TIMESTAMPING        SO_TIMESTAMPING
+
 #endif	/* _ASM_POWERPC_SOCKET_H */
diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c
index f36936d..a2f212e 100644
--- a/arch/powerpc/kernel/pci-common.c
+++ b/arch/powerpc/kernel/pci-common.c
@@ -772,8 +772,17 @@ void __devinit pci_process_bridge_OF_ranges(struct pci_controller *hose,
 			 * space starting at 0 so we factor in pci_addr
 			 */
 			hose->pci_io_size = pci_addr + size;
+
+/* picoHDP has a 1->1 mapping of PCI->CPU addresses and we need this to make
+ * it work.
+ */
+#ifdef CONFIG_PICOHDP
+			hose->io_base_phys = pci_addr;
+#else
 			hose->io_base_phys = cpu_addr - pci_addr;
 
+#endif
+
 			/* Build resource */
 			res = &hose->io_resource;
 			res->flags = IORESOURCE_IO;
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index b79dc71..7e45c23 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -115,6 +115,13 @@ config SBC8560
 	help
 	  This option enables support for the Wind River SBC8560 board
 
+config PICOHDP203
+        bool "picoHDP 203"
+        help
+        The picoChip HDP203 board is a Freescale 8560 based target with
+        4 picoChip PC203 devices.  Say Y to support it.
+        For more information see <http://www.picochip.com/>
+
 endif # MPC85xx
 
 config TQM85xx
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index cb3054e..f1ec4c4 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -12,3 +12,4 @@ obj-$(CONFIG_TQM85xx)	  += tqm85xx.o
 obj-$(CONFIG_SBC8560)     += sbc8560.o
 obj-$(CONFIG_SBC8548)     += sbc8548.o
 obj-$(CONFIG_KSI8560)	  += ksi8560.o
+obj-$(CONFIG_PICOHDP203)     += picohdp.o
diff --git a/arch/powerpc/platforms/85xx/picohdp.c b/arch/powerpc/platforms/85xx/picohdp.c
new file mode 100644
index 0000000..3c2ef09
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/picohdp.c
@@ -0,0 +1,359 @@
+/*
+ * picohdp setup and early boot code plus other random bits.
+ *
+ * Maintained by Kumar Gala (see MAINTAINERS for contact information)
+ *
+ * Copyright 2005 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/of_platform.h>
+
+#include <asm/system.h>
+#include <asm/time.h>
+#include <asm/machdep.h>
+#include <asm/pci-bridge.h>
+#include <asm/mpic.h>
+#include <mm/mmu_decl.h>
+#include <asm/udbg.h>
+
+#include <sysdev/fsl_soc.h>
+#include <sysdev/fsl_pci.h>
+
+#ifdef CONFIG_CPM2
+#include <asm/cpm2.h>
+#include <sysdev/cpm2_pic.h>
+#endif
+
+#ifdef CONFIG_PCI
+static int picohdp_exclude_device(struct pci_controller *hose,
+				   u_char bus, u_char devfn)
+{
+	if (bus == 0 && PCI_SLOT(devfn) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	else
+		return PCIBIOS_SUCCESSFUL;
+}
+#endif /* CONFIG_PCI */
+
+#ifdef CONFIG_CPM2
+
+static void cpm2_cascade(unsigned int irq, struct irq_desc *desc)
+{
+	int cascade_irq;
+
+	while ((cascade_irq = cpm2_get_irq()) >= 0)
+		generic_handle_irq(cascade_irq);
+
+	desc->chip->eoi(irq);
+}
+
+#endif /* CONFIG_CPM2 */
+
+static int __init picohdp_guts_init(void)
+{
+        struct device_node *np =
+            of_find_compatible_node(NULL, NULL, "fsl,mpc8560-guts");
+        struct resource r;
+
+        if (NULL == np) {
+                printk(KERN_ERR "GUTS init: failed to find guts node\n");
+                return -EIO;
+        }
+
+        if (of_address_to_resource(np, 0, &r)) {
+                printk(KERN_ERR "Failed to map GUTS register space\n");
+                of_node_put(np);
+                return -EIO;
+        }
+
+        if (NULL == platform_device_register_simple("mpc8560-guts",
+                                                    0, &r, 1)) {
+                printk(KERN_ERR "Failed to register guts device\n");
+                of_node_put(np);
+                return -EIO;
+        }
+
+        of_node_put(np);
+
+        return 0;
+}
+arch_initcall(picohdp_guts_init);
+
+static int __init picohdp_pa_init(void)
+{
+        struct device_node *np;
+        /* 4 resources - procif, dma base, interrupt and ccr. */
+        struct resource res[4];
+        struct platform_device *pdev;
+        int cindex;
+        const unsigned int *prop;
+        int prop_len;
+        int ret;
+        unsigned num_props;
+
+        memset(res, 0, sizeof(res));
+
+        for_each_compatible_node(np, NULL, "picoArray") {
+                num_props = 0;
+
+                prop = of_get_property(np, "cell-index", NULL);
+                if (!prop) {
+                        printk(KERN_ERR "pA: failed to get cell-index\n");
+                        return -EINVAL;
+                }
+                cindex = (int)*prop;
+
+                pdev = platform_device_alloc("picoArray", (int)*prop);
+                if (!pdev) {
+                        printk(KERN_ERR
+                               "pA: failed to create platform device\n");
+                        return -EIO;
+                }
+
+                prop = of_get_property(np, "procif", &prop_len);
+                if (!prop || prop_len != 8) {
+                        printk(KERN_ERR "invalid procif attribute\n");
+                        platform_device_put(pdev);
+                        return -EIO;
+                } else {
+                        ++num_props;
+                        res[0].start = (int)(prop[0]);
+                        res[0].end = (int)prop[1] + res[0].start - 1;
+                        res[0].flags = IORESOURCE_MEM;
+                        res[0].name = "procif";
+                }
+
+                prop = of_get_property(np, "dma_base", &prop_len);
+                if (!prop || prop_len != 8) {
+                        printk(KERN_ERR "invalid dma base attribute\n");
+                        platform_device_put(pdev);
+                        return -EIO;
+                } else {
+                        ++num_props;
+                        res[1].start = (int)prop[0];
+                        res[1].end = (int)prop[1] + res[1].start - 1;
+                        res[1].flags = IORESOURCE_MEM;
+                        res[1].name = "dma_base";
+                }
+
+                if (NO_IRQ == of_irq_to_resource(np, 0, &res[2])) {
+                        printk(KERN_ERR "failed to get IRQ\n");
+                        return -EIO;
+                }
+                res[2].name = "procif_irq";
+                ++num_props;
+
+                prop = of_get_property(np, "ccr_base", &prop_len);
+                if (prop) {
+                        if (prop_len != 8) {
+                                printk(KERN_ERR "invalid ccr base attribute\n");
+                                platform_device_put(pdev);
+                                return -EIO;
+                        } else {
+                                ++num_props;
+                                res[3].start = (int)prop[0];
+                                res[3].end = (int)prop[1] + res[3].start - 1;
+                                res[3].flags = IORESOURCE_MEM;
+                                res[3].name = "ccr_base";
+                        }
+                }
+
+                ret = platform_device_add_resources(pdev, res, num_props);
+                ret = platform_device_add(pdev); }
+
+        return 0;
+}
+arch_initcall(picohdp_pa_init);
+
+static int __init picohdp_dma_init(void)
+{
+        struct device_node *np;
+        struct resource r[2];
+        const unsigned *prop;
+
+        for_each_compatible_node(np, NULL, "fsl,mpc8560-dma-channel") {
+            memset(r, 0, sizeof(r));
+            if (NULL == np) {
+                printk(KERN_ERR "DMA init: failed to find dma channel node\n");
+                return -EIO;
+            }
+
+            if (of_address_to_resource(np, 0, &r[0])) {
+                printk(KERN_ERR "Failed to map dma register space\n");
+                of_node_put(np);
+                return -EIO;
+            }
+
+            if (NO_IRQ == of_irq_to_resource(np, 0, &r[1])) {
+                printk(KERN_ERR "Failed to map dma IRQ\n");
+                of_node_put(np);
+                return -EIO;
+            }
+
+            prop = of_get_property(np, "cell-index", NULL);
+            if (!prop) {
+                printk(KERN_ERR "failed to get dma cell-index\n");
+                of_node_put(np);
+                return -EIO;
+            }
+
+            if (NULL == platform_device_register_simple("dma-chan",
+                        *(int *)prop, r, 2)) {
+                printk(KERN_ERR "Failed to register dma device\n");
+                of_node_put(np);
+                return -EIO;
+            }
+        }
+
+        return 0;
+}
+arch_initcall(picohdp_dma_init);
+
+static void __init picohdp_pic_init(void)
+{
+	struct mpic *mpic;
+	struct resource r;
+	struct device_node *np = NULL;
+#ifdef CONFIG_CPM2
+	int irq;
+#endif
+
+	np = of_find_node_by_type(np, "open-pic");
+	if (!np) {
+		printk(KERN_ERR "Could not find open-pic node\n");
+		return;
+	}
+
+	if (of_address_to_resource(np, 0, &r)) {
+		printk(KERN_ERR "Could not map mpic register space\n");
+		of_node_put(np);
+		return;
+	}
+
+	mpic = mpic_alloc(np, r.start,
+			MPIC_PRIMARY | MPIC_WANTS_RESET | MPIC_BIG_ENDIAN,
+			0, 256, " OpenPIC  ");
+	BUG_ON(mpic == NULL);
+	of_node_put(np);
+
+	mpic_init(mpic);
+
+#ifdef CONFIG_CPM2
+	/* Setup CPM2 PIC */
+	np = of_find_compatible_node(NULL, NULL, "fsl,cpm2-pic");
+	if (np == NULL) {
+		printk(KERN_ERR "PIC init: can not find fsl,cpm2-pic node\n");
+		return;
+	}
+	irq = irq_of_parse_and_map(np, 0);
+
+	cpm2_pic_init(np);
+	of_node_put(np);
+	set_irq_chained_handler(irq, cpm2_cascade);
+
+#endif
+}
+
+/*
+ * Setup the architecture
+ */
+static void __init picohdp_setup_arch(void)
+{
+#ifdef CONFIG_PCI
+	struct device_node *np;
+#endif
+
+	if (ppc_md.progress)
+		ppc_md.progress("picohdp_setup_arch()", 0);
+
+#ifdef CONFIG_CPM2
+	cpm2_reset();
+#endif
+
+#ifdef CONFIG_PCI
+	for_each_compatible_node(np, "pci", "fsl,mpc8540-pci")
+		fsl_add_bridge(np, 1);
+
+	ppc_md.pci_exclude_device = picohdp_exclude_device;
+#endif
+}
+
+static void picohdp_show_cpuinfo(struct seq_file *m)
+{
+	uint pvid, svid, phid1;
+	uint memsize = total_memory;
+
+	pvid = mfspr(SPRN_PVR);
+	svid = mfspr(SPRN_SVR);
+
+	seq_printf(m, "Vendor\t\t: Freescale Semiconductor\n");
+	seq_printf(m, "Machine\t\t: picohdp\n");
+	seq_printf(m, "PVR\t\t: 0x%x\n", pvid);
+	seq_printf(m, "SVR\t\t: 0x%x\n", svid);
+
+	/* Display cpu Pll setting */
+	phid1 = mfspr(SPRN_HID1);
+	seq_printf(m, "PLL setting\t: 0x%x\n", ((phid1 >> 24) & 0x3f));
+
+	/* Display the amount of memory */
+	seq_printf(m, "Memory\t\t: %d MB\n", memsize / (1024 * 1024));
+}
+
+static struct of_device_id __initdata of_bus_ids[] = {
+	{ .name = "soc", },
+	{ .type = "soc", },
+	{ .name = "cpm", },
+	{ .name = "localbus", },
+	{ .compatible = "simple-bus", },
+	{},
+};
+
+static int __init declare_of_platform_devices(void)
+{
+	of_platform_bus_probe(NULL, of_bus_ids, NULL);
+
+	return 0;
+}
+machine_device_initcall(mpc85xx_ads, declare_of_platform_devices);
+
+extern void abort(void);
+
+void picohdp_restart(char *cmd)
+{
+        abort();
+
+	while (1) ;
+}
+
+/*
+ * Called very early, device-tree isn't unflattened
+ */
+static int __init picohdp_probe(void)
+{
+        unsigned long root = of_get_flat_dt_root();
+
+        return of_flat_dt_is_compatible(root, "MPC85xxADS");
+}
+
+define_machine(mpc85xx_ads) {
+	.name			= "MPC85xx ADS",
+	.probe			= picohdp_probe,
+	.setup_arch		= picohdp_setup_arch,
+	.init_IRQ		= picohdp_pic_init,
+	.show_cpuinfo		= picohdp_show_cpuinfo,
+	.get_irq		= mpic_get_irq,
+	.restart		= picohdp_restart,
+	.calibrate_decr		= generic_calibrate_decr,
+	.progress		= udbg_progress,
+};
diff --git a/arch/powerpc/platforms/85xx/picohdp.h b/arch/powerpc/platforms/85xx/picohdp.h
new file mode 100644
index 0000000..2525697
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/picohdp.h
@@ -0,0 +1,64 @@
+/*
+ * arch/ppc/platforms/picohdp.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * picoHDP board definitions
+ *
+ * Copyright 2005 Zetetica Ltd <david.warman@zetetica.co.uk>
+ *
+ * derived from MPC8560 ADS support by Kumar Gala <kumar.gala@freescale.com>
+ * Copyright 2004 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef __MACH_PICOHDP_H
+#define __MACH_PICOHDP_H
+
+#include <syslib/ppc85xx_setup.h>
+#include <linux/init.h>
+#include <linux/seq_file.h>
+#include <asm/ppcboot.h>
+
+#define BOARD_CCSRBAR           ((uint)0x80000000)
+
+extern int picohdp_show_cpuinfo(struct seq_file *m);
+extern void picohdp_init_IRQ(void) __init;
+extern void picohdp_map_io(void) __init;
+
+/* PCI interrupt controller */
+/* We don't have any real PCI slots - there is only 1 PCI device,
+ * the HiFn crypto processor in "slot" 17, on external IRQ8.
+ */
+#define PIRQA           MPC85xx_IRQ_EXT8
+#define PIRQB           0
+#define PIRQC           0
+#define PIRQD           0
+
+#define MPC85XX_PCI1_LOWER_MEM  0x40000000
+#define MPC85XX_PCI1_UPPER_MEM  0x47ffffff
+
+#define MPC85XX_PCI1_LOWER_IO   0x48000000
+#define MPC85XX_PCI1_UPPER_IO   0x4fffffff
+
+#define MPC85XX_PCI1_IO_SIZE    0x01000000
+
+#define MPC85XX_PCI1_IO_BASE    0x40000000
+#define MPC85XX_PCI1_MEM_OFFSET 0x00000000
+
+#define CPM_MAP_ADDR	(CCSRBAR + MPC85xx_CPM_OFFSET)
+
+/* Added in here during the port from 2.6.17 kernel to 2.6.18 kernel */
+#define F1_RXCLK    11
+#define F1_TXCLK    10
+#define F2_RXCLK    15
+#define F2_TXCLK    16
+#define F3_RXCLK    13
+#define F3_TXCLK    14
+
+#endif				/* __MACH_PICOHDP_H */
diff --git a/arch/powerpc/sysdev/cpm_common.c b/arch/powerpc/sysdev/cpm_common.c
index 00d3d17..42cb749 100644
--- a/arch/powerpc/sysdev/cpm_common.c
+++ b/arch/powerpc/sysdev/cpm_common.c
@@ -56,7 +56,7 @@ void __init udbg_init_cpm(void)
 {
 	if (cpm_udbg_txdesc) {
 #ifdef CONFIG_CPM2
-		setbat(1, 0xf0000000, 0xf0000000, 1024*1024, _PAGE_IO);
+		settlbcam(1, 0xf0000000, 0xf0000000, 1024*1024, _PAGE_IO, 0);
 #endif
 		udbg_putc = udbg_putc_cpm;
 	}
diff --git a/crypto/Kconfig b/crypto/Kconfig
index dc20a34..3b575b6 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -735,6 +735,15 @@ config CRYPTO_ANSI_CPRNG
 	  for cryptographic modules.  Uses the Algorithm specified in
 	  ANSI X9.31 A.2.4
 
+config KEYSTREAM
+        tristate "Configfs based keystream generator"
+        select CONFIGFS_FS
+        help
+          This option enables the keystream generator that provides a configfs
+          based API to use block ciphers to generate a keystream that can be
+          read into userspace applications and XOR'd with plaintext/ciphertext
+          to perform encryption/decryption in a stream cipher mode.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
diff --git a/crypto/Makefile b/crypto/Makefile
index cd4a4ed..9cded00 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -77,6 +77,7 @@ obj-$(CONFIG_CRYPTO_RNG2) += rng.o
 obj-$(CONFIG_CRYPTO_RNG2) += krng.o
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
+obj-$(CONFIG_KEYSTREAM) += keystream.o
 
 #
 # generic algorithms and the async_tx api
diff --git a/crypto/async_tx/async_tx.c b/crypto/async_tx/async_tx.c
index dcbf1be..f21147f 100644
--- a/crypto/async_tx/async_tx.c
+++ b/crypto/async_tx/async_tx.c
@@ -28,351 +28,18 @@
 #include <linux/async_tx.h>
 
 #ifdef CONFIG_DMA_ENGINE
-static enum dma_state_client
-dma_channel_add_remove(struct dma_client *client,
-	struct dma_chan *chan, enum dma_state state);
-
-static struct dma_client async_tx_dma = {
-	.event_callback = dma_channel_add_remove,
-	/* .cap_mask == 0 defaults to all channels */
-};
-
-/**
- * dma_cap_mask_all - enable iteration over all operation types
- */
-static dma_cap_mask_t dma_cap_mask_all;
-
-/**
- * chan_ref_percpu - tracks channel allocations per core/opertion
- */
-struct chan_ref_percpu {
-	struct dma_chan_ref *ref;
-};
-
-static int channel_table_initialized;
-static struct chan_ref_percpu *channel_table[DMA_TX_TYPE_END];
-
-/**
- * async_tx_lock - protect modification of async_tx_master_list and serialize
- *	rebalance operations
- */
-static spinlock_t async_tx_lock;
-
-static LIST_HEAD(async_tx_master_list);
-
-/* async_tx_issue_pending_all - start all transactions on all channels */
-void async_tx_issue_pending_all(void)
-{
-	struct dma_chan_ref *ref;
-
-	rcu_read_lock();
-	list_for_each_entry_rcu(ref, &async_tx_master_list, node)
-		ref->chan->device->device_issue_pending(ref->chan);
-	rcu_read_unlock();
-}
-EXPORT_SYMBOL_GPL(async_tx_issue_pending_all);
-
-/* dma_wait_for_async_tx - spin wait for a transcation to complete
- * @tx: transaction to wait on
- */
-enum dma_status
-dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx)
-{
-	enum dma_status status;
-	struct dma_async_tx_descriptor *iter;
-	struct dma_async_tx_descriptor *parent;
-
-	if (!tx)
-		return DMA_SUCCESS;
-
-	/* poll through the dependency chain, return when tx is complete */
-	do {
-		iter = tx;
-
-		/* find the root of the unsubmitted dependency chain */
-		do {
-			parent = iter->parent;
-			if (!parent)
-				break;
-			else
-				iter = parent;
-		} while (parent);
-
-		/* there is a small window for ->parent == NULL and
-		 * ->cookie == -EBUSY
-		 */
-		while (iter->cookie == -EBUSY)
-			cpu_relax();
-
-		status = dma_sync_wait(iter->chan, iter->cookie);
-	} while (status == DMA_IN_PROGRESS || (iter != tx));
-
-	return status;
-}
-EXPORT_SYMBOL_GPL(dma_wait_for_async_tx);
-
-/* async_tx_run_dependencies - helper routine for dma drivers to process
- *	(start) dependent operations on their target channel
- * @tx: transaction with dependencies
- */
-void async_tx_run_dependencies(struct dma_async_tx_descriptor *tx)
-{
-	struct dma_async_tx_descriptor *dep = tx->next;
-	struct dma_async_tx_descriptor *dep_next;
-	struct dma_chan *chan;
-
-	if (!dep)
-		return;
-
-	chan = dep->chan;
-
-	/* keep submitting up until a channel switch is detected
-	 * in that case we will be called again as a result of
-	 * processing the interrupt from async_tx_channel_switch
-	 */
-	for (; dep; dep = dep_next) {
-		spin_lock_bh(&dep->lock);
-		dep->parent = NULL;
-		dep_next = dep->next;
-		if (dep_next && dep_next->chan == chan)
-			dep->next = NULL; /* ->next will be submitted */
-		else
-			dep_next = NULL; /* submit current dep and terminate */
-		spin_unlock_bh(&dep->lock);
-
-		dep->tx_submit(dep);
-	}
-
-	chan->device->device_issue_pending(chan);
-}
-EXPORT_SYMBOL_GPL(async_tx_run_dependencies);
-
-static void
-free_dma_chan_ref(struct rcu_head *rcu)
-{
-	struct dma_chan_ref *ref;
-	ref = container_of(rcu, struct dma_chan_ref, rcu);
-	kfree(ref);
-}
-
-static void
-init_dma_chan_ref(struct dma_chan_ref *ref, struct dma_chan *chan)
-{
-	INIT_LIST_HEAD(&ref->node);
-	INIT_RCU_HEAD(&ref->rcu);
-	ref->chan = chan;
-	atomic_set(&ref->count, 0);
-}
-
-/**
- * get_chan_ref_by_cap - returns the nth channel of the given capability
- * 	defaults to returning the channel with the desired capability and the
- * 	lowest reference count if the index can not be satisfied
- * @cap: capability to match
- * @index: nth channel desired, passing -1 has the effect of forcing the
- *  default return value
- */
-static struct dma_chan_ref *
-get_chan_ref_by_cap(enum dma_transaction_type cap, int index)
-{
-	struct dma_chan_ref *ret_ref = NULL, *min_ref = NULL, *ref;
-
-	rcu_read_lock();
-	list_for_each_entry_rcu(ref, &async_tx_master_list, node)
-		if (dma_has_cap(cap, ref->chan->device->cap_mask)) {
-			if (!min_ref)
-				min_ref = ref;
-			else if (atomic_read(&ref->count) <
-				atomic_read(&min_ref->count))
-				min_ref = ref;
-
-			if (index-- == 0) {
-				ret_ref = ref;
-				break;
-			}
-		}
-	rcu_read_unlock();
-
-	if (!ret_ref)
-		ret_ref = min_ref;
-
-	if (ret_ref)
-		atomic_inc(&ret_ref->count);
-
-	return ret_ref;
-}
-
-/**
- * async_tx_rebalance - redistribute the available channels, optimize
- * for cpu isolation in the SMP case, and opertaion isolation in the
- * uniprocessor case
- */
-static void async_tx_rebalance(void)
-{
-	int cpu, cap, cpu_idx = 0;
-	unsigned long flags;
-
-	if (!channel_table_initialized)
-		return;
-
-	spin_lock_irqsave(&async_tx_lock, flags);
-
-	/* undo the last distribution */
-	for_each_dma_cap_mask(cap, dma_cap_mask_all)
-		for_each_possible_cpu(cpu) {
-			struct dma_chan_ref *ref =
-				per_cpu_ptr(channel_table[cap], cpu)->ref;
-			if (ref) {
-				atomic_set(&ref->count, 0);
-				per_cpu_ptr(channel_table[cap], cpu)->ref =
-									NULL;
-			}
-		}
-
-	for_each_dma_cap_mask(cap, dma_cap_mask_all)
-		for_each_online_cpu(cpu) {
-			struct dma_chan_ref *new;
-			if (NR_CPUS > 1)
-				new = get_chan_ref_by_cap(cap, cpu_idx++);
-			else
-				new = get_chan_ref_by_cap(cap, -1);
-
-			per_cpu_ptr(channel_table[cap], cpu)->ref = new;
-		}
-
-	spin_unlock_irqrestore(&async_tx_lock, flags);
-}
-
-static enum dma_state_client
-dma_channel_add_remove(struct dma_client *client,
-	struct dma_chan *chan, enum dma_state state)
-{
-	unsigned long found, flags;
-	struct dma_chan_ref *master_ref, *ref;
-	enum dma_state_client ack = DMA_DUP; /* default: take no action */
-
-	switch (state) {
-	case DMA_RESOURCE_AVAILABLE:
-		found = 0;
-		rcu_read_lock();
-		list_for_each_entry_rcu(ref, &async_tx_master_list, node)
-			if (ref->chan == chan) {
-				found = 1;
-				break;
-			}
-		rcu_read_unlock();
-
-		pr_debug("async_tx: dma resource available [%s]\n",
-			found ? "old" : "new");
-
-		if (!found)
-			ack = DMA_ACK;
-		else
-			break;
-
-		/* add the channel to the generic management list */
-		master_ref = kmalloc(sizeof(*master_ref), GFP_KERNEL);
-		if (master_ref) {
-			/* keep a reference until async_tx is unloaded */
-			dma_chan_get(chan);
-			init_dma_chan_ref(master_ref, chan);
-			spin_lock_irqsave(&async_tx_lock, flags);
-			list_add_tail_rcu(&master_ref->node,
-				&async_tx_master_list);
-			spin_unlock_irqrestore(&async_tx_lock,
-				flags);
-		} else {
-			printk(KERN_WARNING "async_tx: unable to create"
-				" new master entry in response to"
-				" a DMA_RESOURCE_ADDED event"
-				" (-ENOMEM)\n");
-			return 0;
-		}
-
-		async_tx_rebalance();
-		break;
-	case DMA_RESOURCE_REMOVED:
-		found = 0;
-		spin_lock_irqsave(&async_tx_lock, flags);
-		list_for_each_entry(ref, &async_tx_master_list, node)
-			if (ref->chan == chan) {
-				/* permit backing devices to go away */
-				dma_chan_put(ref->chan);
-				list_del_rcu(&ref->node);
-				call_rcu(&ref->rcu, free_dma_chan_ref);
-				found = 1;
-				break;
-			}
-		spin_unlock_irqrestore(&async_tx_lock, flags);
-
-		pr_debug("async_tx: dma resource removed [%s]\n",
-			found ? "ours" : "not ours");
-
-		if (found)
-			ack = DMA_ACK;
-		else
-			break;
-
-		async_tx_rebalance();
-		break;
-	case DMA_RESOURCE_SUSPEND:
-	case DMA_RESOURCE_RESUME:
-		printk(KERN_WARNING "async_tx: does not support dma channel"
-			" suspend/resume\n");
-		break;
-	default:
-		BUG();
-	}
-
-	return ack;
-}
-
-static int __init
-async_tx_init(void)
+static int __init async_tx_init(void)
 {
-	enum dma_transaction_type cap;
-
-	spin_lock_init(&async_tx_lock);
-	bitmap_fill(dma_cap_mask_all.bits, DMA_TX_TYPE_END);
-
-	/* an interrupt will never be an explicit operation type.
-	 * clearing this bit prevents allocation to a slot in 'channel_table'
-	 */
-	clear_bit(DMA_INTERRUPT, dma_cap_mask_all.bits);
-
-	for_each_dma_cap_mask(cap, dma_cap_mask_all) {
-		channel_table[cap] = alloc_percpu(struct chan_ref_percpu);
-		if (!channel_table[cap])
-			goto err;
-	}
-
-	channel_table_initialized = 1;
-	dma_async_client_register(&async_tx_dma);
-	dma_async_client_chan_request(&async_tx_dma);
+	dmaengine_get();
 
 	printk(KERN_INFO "async_tx: api initialized (async)\n");
 
 	return 0;
-err:
-	printk(KERN_ERR "async_tx: initialization failure\n");
-
-	while (--cap >= 0)
-		free_percpu(channel_table[cap]);
-
-	return 1;
 }
 
 static void __exit async_tx_exit(void)
 {
-	enum dma_transaction_type cap;
-
-	channel_table_initialized = 0;
-
-	for_each_dma_cap_mask(cap, dma_cap_mask_all)
-		if (channel_table[cap])
-			free_percpu(channel_table[cap]);
-
-	dma_async_client_unregister(&async_tx_dma);
+	dmaengine_put();
 }
 
 /**
@@ -387,16 +54,9 @@ __async_tx_find_channel(struct dma_async_tx_descriptor *depend_tx,
 {
 	/* see if we can keep the chain on one channel */
 	if (depend_tx &&
-		dma_has_cap(tx_type, depend_tx->chan->device->cap_mask))
+	    dma_has_cap(tx_type, depend_tx->chan->device->cap_mask))
 		return depend_tx->chan;
-	else if (likely(channel_table_initialized)) {
-		struct dma_chan_ref *ref;
-		int cpu = get_cpu();
-		ref = per_cpu_ptr(channel_table[tx_type], cpu)->ref;
-		put_cpu();
-		return ref ? ref->chan : NULL;
-	} else
-		return NULL;
+	return dma_find_channel(tx_type);
 }
 EXPORT_SYMBOL_GPL(__async_tx_find_channel);
 #else
diff --git a/crypto/keystream.c b/crypto/keystream.c
new file mode 100644
index 0000000..8e9ad2a
--- /dev/null
+++ b/crypto/keystream.c
@@ -0,0 +1,1177 @@
+#include <linux/cdev.h>
+#include <linux/configfs.h>
+#include <linux/crypto.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/gfp.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/scatterlist.h>
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+
+/*! The number of keystream generator device nodes to create. */
+#define MAX_KS_NODES    8
+
+#define MAX_IV_LEN      32
+
+/*
+ * This keystream generator provides a configfs based interface to the kernel
+ * crypto API to use block ciphers to create a stream cipher and export the
+ * keystream into userspace.
+ *
+ * To configure a keystream generator, create a new directory in
+ * /config/keystream. For example:
+ *
+ *  mkdir /config/keystream/ksgen
+ *
+ * The directory will be populated with "alg, channel, iv, key and pool_size"
+ * attributes. To configure the instance:
+ *
+ *  1. Write the algorithm type into "alg" with no trailing newline. e.g.
+ *      echo -n "cbc(aes)" > /config/keystream/ksgen/alg
+ *  2. Write the keystream size (in bits).
+ *      echo -n "80" > /config/keystream/ksgen/ks_sz
+ *  3. Set the number of keystreams to maintain.
+ *      echo -n "16" > /config/keystream/ksgen/pool_size
+ *  4. Write the key.
+ *      echo -n "deadbeefdeadbeefdeadbeefdeadbeef" > \
+ *          /config/keystream/ksgen/key
+ *  5. Read the channel number and open the corresponding device node and
+ *     a series of IVs for each keystream to be generated.
+ *      dd if=iv1.bin of=/dev/keystream0 bs=16 count=1
+ *      dd if=iv2.bin of=/dev/keystream0 bs=16 count=1
+ *  6. Read the keystreams.
+ *      dd if=/dev/keystream0 of=ks1.bin bs=80 count=1
+ *      dd if=/dev/keystream0 of=ks2.bin bs=80 count=2
+ * The number in the "channel" attribute corresponds to the /dev/keystreamX
+ * device node. Reading from this device file will read the keystream into
+ * userspace. Writing an IV will trigger a new keystream to be generated.
+ */
+
+static struct
+{
+    struct cdev     cdev;
+    dev_t           devno;
+    struct class    *sysfs_class;
+} ks_dev;
+
+static int
+ks_open( struct inode *inode,
+         struct file *filp );
+
+static int
+ks_release( struct inode *inode,
+            struct file *filp );
+
+static ssize_t
+ks_read( struct file *filp,
+         char __user *buf,
+         size_t len,
+         loff_t *offset );
+
+static ssize_t
+ks_write( struct file *filp,
+          const char __user *buf,
+          size_t len,
+          loff_t *offset );
+
+static loff_t
+ks_llseek( struct file *filp,
+           loff_t offs,
+           int origin );
+
+static unsigned int
+ks_poll( struct file *filp,
+         struct poll_table_struct *pollt );
+
+static struct file_operations ks_fops = {
+    .owner              = THIS_MODULE,
+    .open               = ks_open,
+    .release            = ks_release,
+    .read               = ks_read,
+    .write              = ks_write,
+    .llseek             = ks_llseek,
+    .poll		= ks_poll,
+};
+
+/* Request structure used to store temporary per-request information. We
+ * create a kmem_cache for these to reduce the impact of the dynamic
+ * allocation. We will need to allocate one of these for every keystream
+ * request that we get and return it once the encryption has finished. We can
+ * use the scatterlist entry to get the ks_req from the async crypto
+ * completion function.
+ */
+struct ks_req
+{
+    struct ablkcipher_request   *areq;
+    u8                          iv[ MAX_IV_LEN ];
+    struct scatterlist          src;
+    struct scatterlist          dst;
+};
+
+/*
+ * The keystream generator structure. This stores the state of an individual
+ * generator and maintains a buffer of keystream. Each generator is configured
+ * by a configfs item and uses the kernel crypto API to maintain the
+ * keystream.
+ *
+ * Once configured, the buffer will be filled with keystream which may be read
+ * through an associated device node.
+ */
+struct ks_generator
+{
+    struct config_item          item;
+    spinlock_t                  lock;
+    unsigned                    minor;
+    enum {
+        KS_UNCONFIGURED,
+        KS_CONFIGURED,
+        KS_ACTIVE,
+        KS_ENCRYPTING,
+    }                           state;
+    /* The number of users. No need for an atomic as we protect this with the
+     * spinlock whenever we need to access it. */
+    unsigned                    use_count;
+
+    /* Cache for crypto requests. */
+    struct kmem_cache           *req_cache;
+
+    /* Wait queue for anything waiting for encryption to finish. */
+    wait_queue_head_t           waitq;
+
+    /* The keystream FIFO. */
+    u8                          *buf;
+    size_t                      buf_sz;
+
+    /* If the user reads a partial keystream, then store the rest here. This
+     * simplifies the reading logic to know how to resume next time. */
+    u8                          *remainder;
+    size_t                      remainder_bytes;
+
+    /*
+     * FIFO status: rptr is where we should commence reading from. wptr is
+     * where the next keystream should be generated.
+     */
+    unsigned long               rptr;
+    unsigned long               wptr;
+    unsigned long               tail;
+    unsigned long               used;
+
+    /* The size of each keystream to generate. */
+    unsigned                    ks_sz;
+    /* The number of padding bytes to make keystreams cache aligned. */
+    unsigned                    padding;
+    /* The maximum number of keystreams to generate. */
+    unsigned                    pool_sz;
+
+    /* Crypto structures. */
+    ssize_t                     key_len;
+    u8                          *key;
+    char                        alg[ CRYPTO_MAX_ALG_NAME ];
+    struct crypto_ablkcipher    *cipher;
+    /* The number of encryption requests in progress. Increment this when we
+     * dispatch a new request and decrement it on completion. Once this
+     * reaches 0 we can set the state back to KS_ACTIVE. */
+    unsigned                    in_flight;
+
+    struct semaphore		sem;
+};
+
+/* The registered keystream generators. The index in the array signifies the
+ * relative minor number for the device node. */
+static struct ks_generator *ks_slots[ MAX_KS_NODES ];
+
+/* Zeroed page used for generating keystreams. */
+static void *zeroed_page;
+
+static void
+remove_ks_generator( struct ks_generator *ks );
+
+/*
+ * Non-locking variant of ks_cipher_complete(). Used when the keystream
+ * generator is already locked. This is useful for synchronous requests.
+ */
+static void
+__ks_cipher_complete( struct crypto_async_request *req,
+                      int err )
+{
+    struct ks_generator *ks = req->data;
+    struct ablkcipher_request *ablk_req = ablkcipher_request_cast( req );
+    struct ks_req *kreq = container_of( ablk_req->src, struct ks_req, src );
+    BUG_ON( !ks );
+
+    if ( !err )
+    {
+        ks->used += ablk_req->nbytes;
+        /* If this is the last request in flight to complete then we can set
+         * the state back to KS_ACTIVE. This state change will allow us to
+         * rekey or reconfigure. */
+        if ( 0 == --ks->in_flight )
+            ks->state = KS_ACTIVE;
+        /* Copy the encryption of the last block for the IV chaining for the
+         * next encryption. */
+        wake_up_interruptible( &ks->waitq );
+    }
+    else
+        printk( KERN_WARNING "encryption on keystream channel %u failed "
+                "with code %d\n", ks->minor, err );
+
+    ablkcipher_request_free( kreq->areq );
+    kreq->areq = NULL;
+    kmem_cache_free( ks->req_cache, kreq );
+}
+
+/*
+ * Handle a crypto request completion. This will be called when the encryption
+ * has been completed and the data in the buffer is the keystream. This is a
+ * locking variant of __ks_cipher_complete suitable for asynchronous
+ * completion functions.
+ */
+static void
+ks_cipher_complete( struct crypto_async_request *req,
+                    int err )
+{
+    struct ks_generator *ks = req->data;
+
+    BUG_ON( !ks );
+    spin_lock_bh( &ks->lock );
+    __ks_cipher_complete( req, err );
+    spin_unlock_bh( &ks->lock );
+}
+
+/*
+ * Open a keystream device node. This uses the minor number of the device node
+ * to find the channel to associate with. If the channel is not yet configured
+ * then reject the request.
+ */
+static int
+ks_open( struct inode *inode,
+         struct file *filp )
+{
+    int minor = iminor( inode );
+    unsigned minor_base = MINOR( ks_dev.devno );
+    unsigned channel = minor - minor_base;
+    struct ks_generator *ks;
+    int ret = 0;
+
+    /* Make sure that the keystream generator has been configured. If it
+     * hasn't then there is no sense in opening the device node. */
+    if ( channel >= MAX_KS_NODES || !ks_slots[ channel ] )
+        return -ENODEV;
+
+    ks = ks_slots[ channel ];
+
+    spin_lock_bh( &ks->lock );
+    filp->private_data = config_item_get( &ks->item );
+
+    if ( KS_UNCONFIGURED == ks->state )
+    {
+        ret = -EBADF;
+        config_item_put( &ks->item );
+        goto out;
+    }
+    
+    ks->state = KS_ACTIVE;
+    ++ks->use_count;
+
+    sema_init( &ks->sem, 1 );
+
+out:
+    spin_unlock_bh( &ks->lock );
+
+    return ret;
+}
+
+static int
+ks_release( struct inode *inode,
+            struct file *filp )
+{
+    struct ks_generator *ks = filp->private_data;
+
+    spin_lock_bh( &ks->lock );
+    config_item_put( &ks->item );
+    /* If we are the last user then put the generator back into the configured
+     * state. Someone else may want to use it again. */
+    if ( 0 == --ks->use_count )
+        ks->state = KS_CONFIGURED;
+    spin_unlock_bh( &ks->lock );
+
+    return 0;
+}
+
+/*
+ * Write to the device node. The write function takes an array of IV's to use
+ * for keystream generation and for each IV triggers a new keystream
+ * generation which can be read back from the device node once the encryption
+ * has completed.
+ *
+ * Unlike the configfs attributes we expect the IV to be passed in as a binary
+ * array. We do this as the keystream will be read as binary for the efficient
+ * XOR operation and the same application will be generating the IVs.
+ */
+static ssize_t
+ks_write( struct file *filp,
+          const char __user *buf,
+          size_t len,
+          loff_t *offp )
+{
+    ssize_t space;
+    size_t clen;
+    int ret = 0;
+    struct ks_generator *ks = filp->private_data;
+    ssize_t written = 0;
+    struct ks_req *req;
+    unsigned ivsize;
+
+    if ( down_interruptible( &ks->sem ) )
+        return -ERESTARTSYS;
+
+    ret = -EBUSY;
+    if ( ks->state == KS_UNCONFIGURED )
+        goto out;
+
+    ivsize = crypto_ablkcipher_ivsize( ks->cipher );
+
+    /* For each IV in the input buffer trigger a new ciphering request. If the
+     * buffer size is not a multiple of the IV size then process as many as we
+     * can. */
+    while ( written < len && ( len - written ) >= ivsize )
+    {
+        /* Allocate a request. If the allocation fails then we return an error
+         * even though some of the requests may have started succesfully.
+         * Unfortunate if this happens but not a lot we can do. */
+        ret = -ENOMEM;
+        req = kmem_cache_alloc( ks->req_cache, GFP_ATOMIC );
+        if ( !req )
+            goto out;
+        req->areq = ablkcipher_request_alloc( ks->cipher, GFP_ATOMIC );
+        if ( !req )
+        {
+            kmem_cache_free( ks->req_cache, req );
+            goto out;
+        }
+
+        /* Get the IV for the request. */
+        ret = -EFAULT;
+        ret = copy_from_user( req->iv, buf + written, ivsize );
+        if ( ret )
+        {
+            ablkcipher_request_free( req->areq );
+            kmem_cache_free( ks->req_cache, req );
+            goto out;
+        }
+
+        spin_lock_bh( &ks->lock );
+        /* Writing is easy. Each IV generates a single keystream and as the
+         * buffer size is a multiple of the keystream size we don't have to
+         * worry about wrapping the fifo. */
+        if ( ks->wptr >= ks->rptr )
+            space = ( ks->buf_sz - ks->wptr ) + ks->rptr;
+        else
+            space = ks->rptr - ks->wptr;
+        /*
+         * We leave a 1 keystream gap between to read pointer and write
+         * pointer so we can differentiate between FIFO full and FIFO empty.
+         * (Note: ks->used isn't updated until the ciphering completes so we'd
+         * need to maintain another status variable to avoid this.
+         */
+        space -= ( ks->ks_sz + ks->padding );
+        if ( space < ks->ks_sz + ks->padding )
+        {
+            spin_unlock_bh( &ks->lock );
+            ablkcipher_request_free( req->areq );
+            kmem_cache_free( ks->req_cache, req );
+            goto out;
+        }
+        clen = ks->ks_sz + ks->padding;
+
+        sg_init_table( &req->src, 1 );
+        sg_init_table( &req->dst, 1 );
+        sg_set_buf( &req->src, zeroed_page, clen );
+        sg_set_buf( &req->dst, ks->buf + ks->wptr, clen );
+        ablkcipher_request_set_callback( req->areq, CRYPTO_TFM_REQ_MAY_BACKLOG,
+                                         ks_cipher_complete, ks );
+        ablkcipher_request_set_crypt( req->areq, &req->src, &req->dst,
+                                      ks->ks_sz, req->iv );
+
+        ret = crypto_ablkcipher_encrypt( req->areq );
+        if ( !ret )
+        {
+            /* We have completed synchronously. Call the completion function.
+             * This will free the request for us. */
+            __ks_cipher_complete( &req->areq->base, 0 );
+        }
+        else if ( -EINPROGRESS == ret )
+        {
+            ks->state = KS_ENCRYPTING;
+            ++ks->in_flight;
+            ret = 0;
+        }
+        else
+        {
+            printk( KERN_WARNING "keystream: encryption failed with %d\n",
+                    ret );
+            spin_unlock_bh( &ks->lock );
+            goto out;
+        }
+
+        ks->wptr = ( ks->wptr + ks->ks_sz + ks->padding );
+        if ( ks->wptr > ks->buf_sz )
+            ks->wptr -= ks->buf_sz;
+
+        written += ivsize;
+        spin_unlock_bh( &ks->lock );
+    }
+
+out:
+    up( &ks->sem );
+    return ret ?: written;
+}
+
+static unsigned int
+ks_poll( struct file *filp,
+         struct poll_table_struct *pollt )
+{
+    unsigned int ret = 0;
+    struct ks_generator *ks = filp->private_data;
+
+    poll_wait( filp, &ks->waitq, pollt );
+
+    if ( ks->used != 0 )
+        ret |= POLLIN;
+    if ( ks->buf_sz != ks->used )
+        ret |= POLLOUT;
+
+    return ret;
+}
+
+/*
+ * Read from the keystream generator. Currently we only support blocking
+ * reads. This will put as much keystream as possible into the user buffer. If
+ * the user doesn't need all of the keystream then they must either read it
+ * all and discard the excess or explicitly seek to the next keystream.
+ *
+ * The user does not have to read a multiple of the keystream length so it is
+ * possible that the read may wrap the fifo and require 2 separate reads.
+ */
+static ssize_t
+ks_read( struct file *filp,
+         char __user *buf,
+         size_t len,
+         loff_t *offset )
+{
+    struct ks_generator *ks = filp->private_data;
+    int ret;
+    unsigned long read;
+    size_t to_read;
+
+    if ( down_interruptible( &ks->sem ) )
+        return -ERESTARTSYS;
+
+    if ( wait_event_interruptible( ks->waitq, 0 != ks->used ) )
+    {
+        up( &ks->sem );
+	return -ERESTARTSYS;
+    }
+
+    /* Try and read any remainder bytes first. */
+    to_read = min( ks->remainder_bytes, len );
+    if ( copy_to_user( buf, ks->remainder, to_read ) )
+    {
+        ret = -EFAULT;
+        goto out;
+    }
+
+    /*
+     * If we didn't read all of the remainder, then don't read new keystreams.
+     */
+    if ( ks->remainder_bytes )
+    {
+        ret = to_read;
+        goto out;
+    }
+
+    read = to_read;
+    to_read = min( ks->used, len - read );
+
+    while ( to_read )
+    {
+        size_t to_copy = min( to_read, ks->ks_sz );
+        if ( copy_to_user( buf + read, ks->buf + ks->rptr, to_copy ) )
+        {
+            ret = -EFAULT;
+            goto out;
+        }
+
+        if ( ks->ks_sz != to_copy )
+        {
+            /*
+             * Partial copy. We need to put the rest into the remainder
+             * buffer.
+             */
+            memmove( ks->remainder, ks->buf + ks->rptr + to_copy,
+                     ks->ks_sz - to_copy );
+            ks->remainder_bytes = ks->ks_sz - to_copy;
+        }
+
+        read += to_copy;
+        ks->rptr = ks->rptr + ks->ks_sz + ks->padding;
+        if ( ks->rptr > ks->buf_sz )
+            ks->rptr -= ks->buf_sz;
+
+        to_read -= to_copy;
+
+        ks->used -= ks->ks_sz;
+    }
+
+    ret = read;
+
+out:
+    up( &ks->sem );
+    return ret;
+}
+
+static loff_t
+ks_llseek( struct file *filp,
+           loff_t offs,
+           int origin )
+{
+    struct ks_generator *ks = filp->private_data;
+    int ret = 0;
+    /* Don't allow offsets bigger than 32 bits. We'll never have 4GB of
+     * keystream so it would be pointless to support this. We also don't allow
+     * seeking backwards as we have discarded the data. */
+    unsigned long offs32 = ( unsigned long )offs;
+    unsigned long skipped = 0;
+    unsigned whole_keystreams;
+    unsigned partial_bytes;
+
+    if ( down_interruptible( &ks->sem ) )
+        return -ERESTARTSYS;
+
+    if ( offs >= ( 1LL << 32 ) || offs < 0 )
+    {
+        up( &ks->sem );
+        return -EOVERFLOW;
+    }
+
+    spin_lock_bh( &ks->lock );
+    offs32 = min( offs32, ks->used );
+    switch ( origin )
+    {
+        case SEEK_CUR:
+            /*
+             * The offset is in keystream bytes. We need to take the remainder
+             * bytes and the padding into account when we seek.
+             */
+            if ( ks->remainder_bytes )
+            {
+                skipped = min( offs32, ( unsigned long )ks->remainder_bytes );
+                ks->remainder_bytes -= skipped;
+                ks->used -= skipped;
+            }
+
+            /* If there is still some remainder left, then we're done. */
+            if ( ks->remainder_bytes )
+                goto out;
+
+            /*
+             * Now skip the rest of the whole keystreams and copy the
+             * remainder if we need to.
+             */
+            whole_keystreams = ( offs32 - skipped ) / ks->ks_sz;
+            partial_bytes = ( offs32 - skipped ) % ks->ks_sz;
+
+            /* Skip past the whole keystreams. */
+            ks->rptr = ks->rptr + ( whole_keystreams *
+                    ( ks->ks_sz + ks->padding ) );
+            if ( ks->rptr > ks->buf_sz )
+                ks->rptr -= ks->buf_sz;
+
+            /* Copy the excess and move to the next keystream. */
+            memcpy( ks->remainder, ks->buf + ks->rptr + partial_bytes,
+                    ks->ks_sz - partial_bytes );
+            ks->remainder_bytes = ks->ks_sz - partial_bytes;
+
+            ks->rptr = ks->rptr + ( ks->ks_sz + ks->padding );
+            if ( ks->rptr > ks->buf_sz )
+                ks->rptr -= ks->buf_sz;
+
+            ks->used -= offs32;
+            break;
+
+        default:
+            ret = -EINVAL;
+            break;
+    }
+
+out:
+    spin_unlock_bh( &ks->lock );
+
+    up( &ks->sem );
+    return ret ?: ( filp->f_pos += offs );
+}
+
+static inline struct ks_generator *
+to_ks_generator( struct config_item *item )
+{
+    return item ? container_of( item, struct ks_generator, item ) : NULL;
+}
+
+CONFIGFS_ATTR_STRUCT( ks_generator );
+
+#define KS_GENERATOR_ATTR( _name, _mode, _show, _store )    \
+    struct ks_generator_attribute ks_attr_##_name =         \
+        __CONFIGFS_ATTR( _name, _mode, _show, _store )
+
+#define KS_GENERATOR_ATTR_RO( _name, _show )    \
+    struct ks_generator_attribute ks_attr_##_name =         \
+        __CONFIGFS_ATTR_RO( _name, _show )
+
+static ssize_t
+ks_generator_alg_show( struct ks_generator *ks,
+                       char *page )
+{
+    return sprintf( page, "%s\n", ks->alg );
+}
+
+/* Store the algorithm. This will trigger the existing setup to be flushed and
+ * to allocate the new transform with a fresh key. */
+static ssize_t
+ks_generator_alg_store( struct ks_generator *ks,
+                        const char *page,
+                        size_t len )
+{
+    int ret;
+
+    spin_lock_bh( &ks->lock );
+
+    /* If the keystream is in use, then don't allow us to be reconfigured. */
+    ret = -EBUSY;
+    if ( KS_ACTIVE == ks->state || KS_ENCRYPTING == ks->state )
+    {
+        spin_unlock_bh( &ks->lock );
+        goto out;
+    }
+
+    if ( ks->cipher )
+    {
+        crypto_free_ablkcipher( ks->cipher );
+        ks->cipher = NULL;
+    }
+
+    if ( ks->key )
+        kfree( ks->key );
+
+    ks->state = KS_UNCONFIGURED;
+
+    spin_unlock_bh( &ks->lock );
+
+    /* Allocate the new transform. */
+    strncpy( ks->alg, page, sizeof( ks->alg ) - 1 );
+    ks->cipher = crypto_alloc_ablkcipher( ks->alg, 0, 0);
+    if ( IS_ERR( ks->cipher ) )
+    {
+        /* Couldn't allocate the cipher. Clear the buffer to make sure that
+         * there is no confusion. */
+        ks->alg[ 0 ] = '\0';
+        ret = PTR_ERR( ks->cipher );
+        ks->cipher = NULL;
+        goto out;
+    }
+
+    /* Reserve space for the key and IV. */
+    ret = -ENOMEM;
+    ks->key = kzalloc( ks->cipher->base.__crt_alg->cra_ablkcipher.max_keysize,
+                       GFP_KERNEL );
+    if ( !ks->key )
+        goto key_fail;
+    ks->key_len = -1;
+
+    ks->buf_sz = crypto_ablkcipher_blocksize( ks->cipher );
+    ks->buf = kzalloc( ks->buf_sz, GFP_KERNEL | GFP_DMA );
+    if ( !ks->buf )
+        goto buf_fail;
+
+    ret = len;
+    goto out;
+
+buf_fail:
+    kfree( ks->key );
+    ks->key = NULL;
+key_fail:
+    crypto_free_ablkcipher( ks->cipher );
+out:
+    return ret;
+}
+KS_GENERATOR_ATTR( alg, 0600, ks_generator_alg_show, ks_generator_alg_store );
+
+static ssize_t
+ks_generator_key_show( struct ks_generator *ks,
+                       char *page )
+{
+    unsigned i = 0;
+    char *pos = page;
+
+    if ( NULL == ks->cipher )
+        return -EINVAL;
+
+    spin_lock_bh( &ks->lock );
+    if ( ks->key_len < 0 )
+    {
+        spin_unlock_bh( &ks->lock );
+        return -EINVAL;
+    }
+
+    for ( ; i < ks->key_len; ++i )
+        pos += sprintf( pos, "%02x", ks->key[ i ] );
+    *pos++ = '\n';
+    *pos++ = '\0';
+
+    spin_unlock_bh( &ks->lock );
+
+    return pos - page;
+}
+
+static ssize_t
+ks_generator_key_store( struct ks_generator *ks,
+                        const char *page,
+                        size_t len )
+{
+    const char *pos = page;
+    unsigned i = 0;
+    unsigned int val;
+    int ret;
+    /* Temporary buffer for key extraction. */
+    char tmpbuf[ 3 ] = { 0, 0, 0 };
+
+    /* Key must be a byte multiple in ASCII hex. */
+    if ( len % 2 )
+        return -EINVAL;
+
+    if ( NULL == ks->cipher )
+        return -EINVAL;
+
+    /* Wait for the encryption to finish. After waking we need to make sure
+     * that another process hasn't started encryption so we need to retest the
+     * state and possible sleep again. */
+    if ( KS_ENCRYPTING == ks->state )
+    {
+again:
+        wait_event_interruptible( ks->waitq,
+                                  !( KS_ENCRYPTING == ks->state ) );
+        spin_lock_bh( &ks->lock );
+        if ( KS_ENCRYPTING == ks->state )
+        {
+            spin_unlock_bh( &ks->lock );
+            goto again;
+        }
+    }
+    else
+        spin_lock_bh( &ks->lock );
+
+    for ( ; i < len / 2; ++i )
+    {
+        tmpbuf[ 0 ] = *pos;
+        tmpbuf[ 1 ] = *( pos + 1 );
+        sscanf( tmpbuf, "%02x", &val );
+        ks->key[ i ] = val;
+        pos += 2;
+    }
+
+    ks->key_len = len / 2;
+    ret = crypto_ablkcipher_setkey( ks->cipher, ks->key, ks->key_len ) ?: len;
+
+    /* Flush the buffer. We just need to set the read and write pointers to
+     * zero so that the FIFO appears empty. */
+    ks->wptr = ks->rptr = ks->remainder_bytes = 0;
+
+    /* If we have set the key then we can now mark this as configured. If the
+     * setkey fails, then don't allow any more keystream generation until we
+     * put a new good key in. */
+    if ( ret == len )
+        ks->state = KS_CONFIGURED;
+    else
+        ks->state = KS_UNCONFIGURED;
+
+    spin_unlock_bh( &ks->lock );
+
+    return ret;
+}
+KS_GENERATOR_ATTR( key, 0600, ks_generator_key_show, ks_generator_key_store );
+
+static ssize_t
+ks_generator_ks_sz_show( struct ks_generator *ks,
+                         char *page )
+{
+    spin_lock_bh( &ks->lock );
+    sprintf( page, "%u\n", ks->ks_sz );
+    spin_unlock_bh( &ks->lock );
+
+    return strlen( page );
+}
+
+static ssize_t
+ks_generator_ks_sz_store( struct ks_generator *ks,
+                          const char *page,
+                          size_t len )
+{
+    int ret;
+
+    /* Wait for the encryption to finish. */
+    if ( KS_ENCRYPTING == ks->state )
+        return -EBUSY;
+
+    /* Can't configure until we know the block cipher size. */
+    if ( !ks->cipher )
+        return -EINVAL;
+
+    ks->ks_sz = simple_strtoul( page, NULL, 0 );
+    ks->padding = roundup_pow_of_two( ks->ks_sz ) - ks->ks_sz;
+    /* The keystream size must be a multiple of the block cipher size. */
+    if ( ks->ks_sz % crypto_ablkcipher_blocksize( ks->cipher ) )
+        return -EINVAL;
+
+    spin_lock_bh( &ks->lock );
+
+    if ( ks->buf )
+    {
+        kfree( ks->buf );
+        ks->buf = NULL;
+        ks->buf_sz = 0;
+    }
+
+    /* Allocate the buffer for storing the keystream. Make sure that the
+     * buffer is a multiple of the cipher block size and that we have at least
+     * one block. */
+    ks->buf_sz = ( ks->ks_sz + ks->padding ) * ks->pool_sz;
+    if ( !ks->buf_sz )
+        ks->buf_sz =
+            ( 2 * ( crypto_ablkcipher_blocksize( ks->cipher ) + ks->padding ) );
+    ks->buf = kmalloc( ks->buf_sz, GFP_ATOMIC | GFP_DMA );
+
+    if ( !ks->buf )
+    {
+        ks->buf_sz = 0;
+        ret = -ENOMEM;
+    }
+    else
+        ret = len;
+
+    ks->remainder = kmalloc( ks->ks_sz, GFP_ATOMIC );
+    if ( !ks->remainder )
+    {
+        kfree( ks->buf );
+        ks->buf = NULL;
+        ks->buf_sz = 0;
+        ret = -ENOMEM;
+    }
+    ks->remainder_bytes = 0;
+
+    spin_unlock_bh( &ks->lock );
+
+    return ret;
+}
+KS_GENERATOR_ATTR( ks_size, 0600, ks_generator_ks_sz_show,
+                   ks_generator_ks_sz_store );
+
+static ssize_t
+ks_generator_pool_sz_show( struct ks_generator *ks,
+                           char *page )
+{
+    spin_lock_bh( &ks->lock );
+    sprintf( page, "%u\n", ks->pool_sz );
+    spin_unlock_bh( &ks->lock );
+
+    return strlen( page );
+}
+
+static ssize_t
+ks_generator_pool_sz_store( struct ks_generator *ks,
+                          const char *page,
+                          size_t len )
+{
+    int ret;
+
+    /* Wait for the encryption to finish. */
+    if ( KS_ENCRYPTING == ks->state )
+        return -EBUSY;
+
+    /* Can't configure until we know the block cipher size. */
+    if ( !ks->cipher )
+        return -EINVAL;
+
+    spin_lock_bh( &ks->lock );
+
+    if ( ks->buf )
+    {
+        kfree( ks->buf );
+        ks->buf = NULL;
+        ks->buf_sz = 0;
+    }
+
+    /* Allocate the buffer for storing the keystream. Make sure that the
+     * buffer is a multiple of the cipher block size and that we have at least
+     * one block. */
+    ks->pool_sz = simple_strtoul( page, NULL, 0 );
+    ks->buf_sz = ( ks->ks_sz + ks->padding ) * ks->pool_sz;
+    if ( !ks->buf_sz )
+        ks->buf_sz =
+            ( 2 * ( crypto_ablkcipher_blocksize( ks->cipher ) + ks->padding ) );
+    ks->buf = kmalloc( ks->buf_sz, GFP_ATOMIC | GFP_DMA );
+
+    if ( !ks->buf )
+    {
+        ks->buf_sz = 0;
+        ret = -ENOMEM;
+    }
+    else
+        ret = len;
+
+    spin_unlock_bh( &ks->lock );
+
+    return ret;
+}
+KS_GENERATOR_ATTR( pool_size, 0600, ks_generator_pool_sz_show,
+                   ks_generator_pool_sz_store );
+
+static ssize_t
+ks_generator_channel_show( struct ks_generator *ks,
+                           char *page )
+{
+    return sprintf( page, "%u\n", ks->minor );
+}
+KS_GENERATOR_ATTR_RO( channel, ks_generator_channel_show );
+
+static struct configfs_attribute *ks_generator_attrs[] = {
+    &ks_attr_alg.attr,
+    &ks_attr_key.attr,
+    &ks_attr_ks_size.attr,
+    &ks_attr_pool_size.attr,
+    &ks_attr_channel.attr,
+    NULL,
+};
+
+CONFIGFS_ATTR_OPS( ks_generator );
+
+static void
+ks_generator_release( struct config_item *item )
+{
+    struct ks_generator *ks = to_ks_generator( item );
+
+    /* Wait for the encryption to finish. If we are releasing then we can't
+     * have any users left so we don't need to lock but we do need to make
+     * sure that any requests in flight have finished. */
+    if ( KS_ENCRYPTING == ks->state )
+        wait_event_interruptible( ks->waitq,
+                                  !( KS_ENCRYPTING == ks->state ) );
+
+    if ( ks->cipher )
+    {
+        crypto_free_ablkcipher( ks->cipher );
+        ks->cipher = NULL;
+    }
+
+    remove_ks_generator( ks );
+
+    if ( ks->key )
+        kfree( ks->key );
+    if ( ks->buf )
+        kfree( ks->buf );
+
+    kmem_cache_destroy( ks->req_cache );
+
+    kfree( ks );
+}
+
+static struct configfs_item_operations ks_generator_item_ops = {
+    .show_attribute     = ks_generator_attr_show,
+    .store_attribute    = ks_generator_attr_store,
+    .release            = ks_generator_release,
+};
+
+static struct config_item_type ks_generator_type = {
+    .ct_item_ops        = &ks_generator_item_ops,
+    .ct_attrs           = ks_generator_attrs,
+    .ct_owner           = THIS_MODULE,
+};
+
+struct ks_generator_group {
+    struct config_group     group;
+};
+
+static inline struct ks_generator_group *
+to_ks_generator_group( struct config_item *item )
+{
+    return item ? container_of( to_config_group( item ),
+                                struct ks_generator_group, group ) : NULL;
+}
+
+static struct config_item *
+ks_generator_make_item( struct config_group *group,
+                        const char *name );
+
+static struct configfs_group_operations ks_generator_group_ops = {
+    .make_item          = ks_generator_make_item,
+};
+
+static int
+add_ks_generator( struct ks_generator *ks )
+{
+    unsigned i;
+    int ret = -EBUSY;
+
+    for ( i = 0; i < MAX_KS_NODES; ++i )
+        if ( !ks_slots[ i ] )
+        {
+            ks_slots[ i ] = ks;
+            ks->minor = i;
+            ret = 0;
+            break;
+        }
+
+    return ret;
+}
+
+static void
+remove_ks_generator( struct ks_generator *ks )
+{
+    ks_slots[ ks->minor ] = NULL;
+}
+
+static struct config_item *
+ks_generator_make_item( struct config_group *group,
+                        const char *name )
+{
+    int ret;
+    struct ks_generator *ks = kzalloc( sizeof( *ks ), GFP_KERNEL );
+    if ( !ks )
+        return ERR_PTR( -ENOMEM );
+    config_item_init_type_name( &ks->item, name, &ks_generator_type );
+
+    spin_lock_init( &ks->lock );
+
+    ks->rptr        = ks->wptr = 0;
+    ks->buf         = NULL;
+    ks->key         = NULL;
+    ks->alg[ 0 ]    = '\0';
+    ks->cipher      = NULL;
+    ks->used        = 0;
+    ks->ks_sz       = 128;
+    ks->pool_sz     = 32;
+
+    ret = -ENOMEM;
+    ks->req_cache   = kmem_cache_create( "ks_generator",
+                                         sizeof( struct ks_req ),
+                                         0, 0, NULL );
+    if ( !ks->req_cache )
+    {
+        kfree( ks );
+        return ERR_PTR( ret );
+    }
+
+    init_waitqueue_head( &ks->waitq );
+
+    ret = add_ks_generator( ks );
+    if ( ret )
+    {
+        kfree( ks );
+        return ERR_PTR( ret );
+    }
+    return &ks->item;
+}
+
+static void
+ks_generator_group_release( struct config_item *item )
+{
+    kfree( to_ks_generator_group( item ) );
+}
+
+static struct configfs_item_operations ks_group_item_ops = {
+    .release            = ks_generator_group_release,
+};
+
+static struct config_item_type ks_group_type = {
+    .ct_item_ops        = &ks_group_item_ops,
+    .ct_group_ops       = &ks_generator_group_ops,
+    .ct_owner           = THIS_MODULE,
+};
+
+static struct configfs_subsystem ks_generator_subsys = {
+    .su_group = {
+        .cg_item = {
+            .ci_namebuf = "keystream",
+            .ci_type    = &ks_group_type,
+        },
+    },
+};
+
+static int
+ks_init( void )
+{
+    int ret;
+    unsigned i;
+
+    ret = -ENOMEM;
+    zeroed_page = ( void * )get_zeroed_page( GFP_KERNEL );
+    if ( !zeroed_page )
+        goto out;
+
+    cdev_init( &ks_dev.cdev, &ks_fops );
+    ks_dev.cdev.owner = THIS_MODULE;
+    ks_dev.cdev.ops = &ks_fops;
+
+    ret = alloc_chrdev_region( &ks_dev.devno, 0, MAX_KS_NODES, "keystream" );
+    if ( ret )
+    {
+        printk( KERN_INFO "failed to allocate dev node range\n" );
+        goto out;
+    }
+
+    ks_dev.sysfs_class = class_create( THIS_MODULE, "keystream" );
+    for ( i = 0; i < MAX_KS_NODES; ++i )
+        device_create( ks_dev.sysfs_class, NULL,
+                       MKDEV( MAJOR( ks_dev.devno ),
+                              MINOR( ks_dev.devno ) + i ), NULL,
+                       "keystream%u", i );
+
+    ret = cdev_add( &ks_dev.cdev, ks_dev.devno, MAX_KS_NODES );
+    if ( ret )
+        printk( KERN_INFO "failed to add cdev\n" );
+
+    config_group_init( &ks_generator_subsys.su_group );
+    mutex_init( &ks_generator_subsys.su_mutex );
+
+    ret = configfs_register_subsystem( &ks_generator_subsys );
+out:
+    return ret;
+}
+
+static void
+ks_exit( void )
+{
+    int i;
+
+    free_page( ( unsigned long )zeroed_page );
+    configfs_unregister_subsystem( &ks_generator_subsys );
+    for ( i = 0; i < MAX_KS_NODES; ++i )
+        device_destroy( ks_dev.sysfs_class,
+                        MKDEV( MAJOR( ks_dev.devno ),
+                               MINOR( ks_dev.devno ) + i ) );
+    class_destroy( ks_dev.sysfs_class );
+    cdev_del( &ks_dev.cdev );
+    unregister_chrdev_region( ks_dev.devno, MAX_KS_NODES );
+}
+
+module_init( ks_init );
+module_exit( ks_exit );
+
+MODULE_LICENSE( "GPL" );
+MODULE_AUTHOR( "Jamie Iles" );
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 2f557f5..ceeda43 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -100,6 +100,10 @@ source "drivers/dma/Kconfig"
 
 source "drivers/dca/Kconfig"
 
+source "drivers/perfcounters/Kconfig"
+
+source "drivers/picochip/Kconfig"
+
 source "drivers/auxdisplay/Kconfig"
 
 source "drivers/uio/Kconfig"
@@ -107,4 +111,5 @@ source "drivers/uio/Kconfig"
 source "drivers/xen/Kconfig"
 
 source "drivers/staging/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index fceb71a..a3f6f57 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -33,6 +33,10 @@ obj-$(CONFIG_FB_INTEL)          += video/intelfb/
 
 obj-y				+= serial/
 obj-$(CONFIG_PARPORT)		+= parport/
+
+# picochip/ needed before misc/ and picochip/ needs dma/
+obj-$(CONFIG_DMA_ENGINE)	+= dma/
+obj-y				+= picochip/
 obj-y				+= base/ block/ misc/ mfd/ net/ media/
 obj-$(CONFIG_NUBUS)		+= nubus/
 obj-$(CONFIG_ATM)		+= atm/
@@ -93,7 +97,6 @@ obj-y				+= firmware/
 obj-$(CONFIG_CRYPTO)		+= crypto/
 obj-$(CONFIG_SUPERH)		+= sh/
 obj-$(CONFIG_GENERIC_TIME)	+= clocksource/
-obj-$(CONFIG_DMA_ENGINE)	+= dma/
 obj-$(CONFIG_DCA)		+= dca/
 obj-$(CONFIG_HID)		+= hid/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
@@ -102,3 +105,4 @@ obj-$(CONFIG_SSB)		+= ssb/
 obj-$(CONFIG_VIRTIO)		+= virtio/
 obj-$(CONFIG_REGULATOR)		+= regulator/
 obj-$(CONFIG_STAGING)		+= staging/
+obj-y				+= perfcounters/
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index e522144..ed26036 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -200,4 +200,17 @@ config CRYPTO_DEV_IXP4XX
 	help
 	  Driver for the IXP4xx NPE crypto engine.
 
+config CRYPTO_DEV_PC302
+        tristate "Driver for PC302 crypto offload engines"
+        depends on ARCH_PC302
+        select CRYPTO_DES
+        select CRYPTO_AES
+        select CRYPTO_BLKCIPHER
+        select CRYPTO_AUTHENC
+        select CRYPTO_SHA1
+        select CRYPTO_CBC
+        select CRYPTO_ECB
+        help
+          Driver for the picoChip PC302 crypto offload engines.
+
 endif # CRYPTO_HW
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 73557b2..50144cf 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -4,3 +4,4 @@ obj-$(CONFIG_CRYPTO_DEV_GEODE) += geode-aes.o
 obj-$(CONFIG_CRYPTO_DEV_HIFN_795X) += hifn_795x.o
 obj-$(CONFIG_CRYPTO_DEV_TALITOS) += talitos.o
 obj-$(CONFIG_CRYPTO_DEV_IXP4XX) += ixp4xx_crypto.o
+obj-$(CONFIG_CRYPTO_DEV_PC302) += pc302crypto.o
diff --git a/drivers/crypto/pc302crypto.c b/drivers/crypto/pc302crypto.c
new file mode 100644
index 0000000..5bd0ccf
--- /dev/null
+++ b/drivers/crypto/pc302crypto.c
@@ -0,0 +1,2944 @@
+#include <linux/crypto.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <crypto/algapi.h>
+#include <crypto/des.h>
+#include <crypto/authenc.h>
+#include <crypto/aead.h>
+#include <crypto/internal/skcipher.h>
+#include <asm/io.h>
+#include <linux/rtnetlink.h> /* For rt attributes (struct rtattr) for encoding
+                              * encryption and authentication keys in authenc
+                              * algorithms. */
+
+#include <mach/pc302/pc302.h>
+#include <mach/pc302/spacc.h>
+
+/* The threshold for the number of packets that should complete in the SPAcc
+ * before the STAT_CNT interrupt is raised. Incresing this value will reduce
+ * the number of interrupts raised to the CPU. */
+#define STAT_IRQ_THRESHOLD   ( 1 )
+
+/* The threshold for the number of entries in the CMD FIFO available before
+ * the CMD0_CNT interrupt is raised. Incresing this value will reduce the
+ * number of interrupts raised to the CPU. */
+#define CMD0_IRQ_THRESHOLD   ( 1 )
+
+/* The timeout period (in jiffies) for a PDU. When the the number of PDUs in
+ * flight is greater than the STAT_IRQ_THRESHOLD or 0 the timer is disabled.
+ * When there are packets in flight but lower than the threshold, we enable
+ * the timer and at expiry, attempt to remove any processed packets from the
+ * queue and if there are still packets left, schedule the timer again. */
+#define PACKET_TIMEOUT      ( 1 )
+
+/*! The priority to register each algorithm with. */
+#define PC302_CRYPTO_ALG_PRIORITY       ( 10000 )
+
+/*! Max length for an AES key. */
+#define PC302_CRYPTO_AES_MAX_KEY_LEN    ( 32 )
+/*! Length of an AES IV in bytes. */
+#define PC302_CRYPTO_AES_IV_LEN         ( 16 )
+/*! Length of the AES salt mask. */
+#define PC302_CRYPTO_AES_SALT_MASK_LEN  ( 16 )
+
+/*! Length of a DES IV. */
+#define PC302_CRYPTO_DES_IV_LEN         ( 8 )
+/*! Length of a DES key. */
+#define PC302_CRYPTO_DES_KEY_LEN        ( 8 )
+
+/*! Length of a kasumi f8 encryption key in bytes. */
+#define PC302_CRYPTO_KASUMI_F8_KEY_LEN  ( 16 )
+/*! Length of a kasumi f8 IV. */
+#define PC302_CRYPTO_KASUMI_F8_IV_LEN   ( 8 )
+/*! Length of the reserved field in the kasumi f8 context. */
+#define PC302_CRYPTO_KASUMI_F8_RSVD_LEN ( 8 )
+
+/*! Cipher key page size in the IPSec crypto engine. */
+#define PC302_CRYPTO_IPSEC_CIPHER_PG_SZ ( 64 )
+/*! Hash key page size in the IPSec crypto engine. */
+#define PC302_CRYPTO_IPSEC_HASH_PG_SZ   ( 64 )
+/*! Maximum number of key contexts in the IPSec engine. */
+#define PC302_CRYPTO_IPSEC_MAX_CTXS     ( 32 )
+/*! The depth of the request FIFO in the IPSec engine. */
+#define PC302_CRYPTO_IPSEC_FIFO_SZ      ( 32 )
+
+/*! Cipher key page size in the SRTP crypto engine. */
+#define PC302_CRYPTO_SRTP_CIPHER_PG_SZ  ( 64 )
+/*! Hash key page size in the SRTP crypto engine. */
+#define PC302_CRYPTO_SRTP_HASH_PG_SZ    ( 32 )
+/*! Maximum number of key contexts in the SRTP engine. */
+#define PC302_CRYPTO_SRTP_MAX_CTXS      ( 128 )
+/*! The depth of the request FIFO in the SRTP engine. */
+#define PC302_CRYPTO_SRTP_FIFO_SZ       ( 128 )
+
+/*! Cipher key page size in the L2 crypto engine. */
+#define PC302_CRYPTO_L2_CIPHER_PG_SZ    ( 64 )
+/*! Hash key page size in the L2 crypto engine. */
+#define PC302_CRYPTO_L2_HASH_PG_SZ      ( 64 )
+/*! Maximum number of key contexts in the L2 crypto engine. */
+#define PC302_CRYPTO_L2_MAX_CTXS        ( 128 )
+/*! The depth of the request FIFO in the SRTP engine. */
+#define PC302_CRYPTO_L2_FIFO_SZ         ( 128 )
+
+/*! The maximum hash key page size of all engines. */
+#define PC302_CRYPTO_MAX_HASH_PG_SZ     ( PC302_CRYPTO_IPSEC_HASH_PG_SZ )
+
+/*! The maximum length of a DDT. If we exceed this then we probably have an
+ *  architectural problem if the fragmentation is this bad. If this isn't true
+ *  and we have some really clever scheme then make this bigger. */
+#define MAX_DDT_LEN                     ( 64 )
+
+/*! Debug enumeration. High integer values are of lower priority. */
+enum debug_levels
+{
+    DBG_ERROR = 0,  /*!< Critical errors. */
+    DBG_WARN,       /*!< Warning messages. */
+    DBG_NOTICE,     /*!< Notices of abnormal conditions. */
+    DBG_TRACE,      /*!< Trace level messages for debug. */
+    DBG_IO,         /*!< All I/O requests. */
+};
+
+/*! The current debug level of the driver. */
+#define DEBUG_LVL   ( DBG_NOTICE )
+
+/*!
+ * Print a debug message to the console. If _lvl is less than or equal to the
+ * current debug level then the message is printed.
+ *
+ * @param _lvl The level of the message.
+ * @param _fmt The message to print.
+ */
+#define PRINTD( _lvl, _fmt, ... ) \
+    ({ \
+        if ( _lvl <= DEBUG_LVL ) \
+            printk( "pc302crypto.c:%u: " _fmt "\n", __LINE__, \
+                    ##__VA_ARGS__ ); \
+    })
+
+struct pc302crypt_generic_ctx;
+
+enum pc302crypt_direction
+{
+    ENCRYPT,
+    DECRYPT,
+};
+
+/*!
+ * \brief DDT format. This must match the hardware DDT format exactly.
+ */
+struct pc302crypt_ddt
+{
+    u32                         p;      /*!< The address of the buffer to
+                                         *   transfer. */
+
+    u32                         len;    /*!< The length of the buffer. */
+};
+
+/* DDT's must be aligned to a 64 byte boundary. */
+#define __ddt_align             __attribute__((aligned(64)))
+
+struct pc302crypt_engine_ctx
+{
+    struct pc302crypt_ddt       __ddt_align src_ddt[MAX_DDT_LEN];
+    struct pc302crypt_ddt       __ddt_align dst_ddt[MAX_DDT_LEN];
+    int                         in_use;
+};
+
+/*!
+ * \brief Asynchronous crypto request structure.
+ *
+ * This structure defines a request that is either queued for processing or
+ * being processed.
+ */
+struct pc302crypt_req
+{
+    /*! The asynchronous crypto request from the crypto API. */
+    struct crypto_async_request *req;
+
+    /*! The result of the operation. Only valid once the ciphering has
+     * completed. */
+    int                         result;
+
+    /*! The position in the request queue. */
+    struct list_head            list;
+
+    /*! The processing direction. */
+    enum pc302crypt_direction   dir;
+
+    /*! The context slot in the engine that is associated with the request. */
+    unsigned                    ctx_id;
+
+    /*! The destination for a generated IV for geniv requests. */
+    u8                          *giv;
+
+    /*! The length of the generated IV. */
+    size_t                      giv_len;
+
+    /*! The sequence number for giv algos. */
+    u64                         seq;
+
+    /*! The physical address of the DMA mapped giv. */
+    dma_addr_t                  giv_pa;
+
+    /*! The length of the source and destination DDTs. Make both the same
+     * length for simplicity. */
+    unsigned                    ddt_len;
+
+    dma_addr_t                  src_addr;
+    dma_addr_t                  dst_addr;
+};
+
+/*!
+ * \brief Crypto queue. Allows queueing of pc302crypto_req requests.
+ *
+ * This is used rather than the crypto API crypto queue as we want to add
+ * pc302crypto_req structures and to be able to force addition even if the
+ * request can't backlog. This is used when a request that can't backlog has
+ * actually completed but we want to defer the completion function.
+ */
+struct pc302crypt_queue
+{
+    struct list_head            list;       /*!< list of requests. */
+
+    struct list_head            *backlog;   /*!< The position in the list
+                                             *   where the backlog starts. */
+
+    unsigned                    qlen;       /*!< The number of entries in the
+                                             *   queue. */
+
+    unsigned                    max_qlen;   /*!< The maximum number of entries
+                                             *   that the queue may hold. */
+};
+
+/*!
+ * \brief Definition of a PC302 crypto engine.
+ */
+struct pc302crypt_engine
+{
+    /*! The engine name. */
+    const char                  *name;
+
+    /*! The device entry. */
+    struct device               *dev;
+
+    /*! Register base address. */
+    void __iomem                *regs;
+
+    /*! Cipher key context base address. */
+    void __iomem                *cipher_ctx_base;
+
+    /*! Hash key base address. */
+    void __iomem                *hash_key_base;
+
+    /*! The DDT buffer. */
+    struct pc302crypt_engine_ctx    *ddt_buf;
+
+    /*! The physical address of the DDT buffer. */
+    dma_addr_t                  ddt_buf_phys;
+
+    /*! Hardware lock for sequencing commands. */
+    spinlock_t                  hw_lock;
+
+    /*! Maximum number of contexts that the engine can hold. */
+    unsigned                    max_ctxs;
+
+    /*! The algorithms that can be registered for the engine. */
+    struct pc302crypt_alg       *algs;
+
+    /* The number of algorithms that may be registered. */
+    unsigned                    num_algs;
+
+    /*! Algorithms registered for this engine. */
+    struct list_head            registered_algs;
+
+    /*! The cipher key context page size in bytes. */
+    size_t                      cipher_pg_sz;
+
+    /*! The hash key context page size in bytes. */
+    size_t                      hash_pg_sz;
+
+    /*! Queue for requests. */
+    struct pc302crypt_queue     pending;
+
+    /*! Queue for completed requests. */
+    struct pc302crypt_queue     completed;
+
+    /*! Tasklet for completing asynchronous requests by callbacks. */
+    struct tasklet_struct       complete;
+
+    /*! The size of the request fifo. */
+    unsigned                    fifo_sz;
+
+    /*! The number of requests 'in flight'. */
+    unsigned                    in_flight;
+
+    /*! The timer for packet timeouts. */
+    struct timer_list           packet_timeout;
+};
+
+/*! Type mask for a crypto algorithm. */
+#define PC302_CRYPTO_TYPE_MASK          ( 0x0F00 )
+/*! Type mask for block algorithms. */
+#define PC302_CRYPTO_BLOCK_MASK         ( 0x000F )
+/*! Type mask for hash algorithms. */
+#define PC302_CRYPTO_HASH_MASK          ( 0x00F0 )
+/*! The algorithm is a block cipher. */
+#define PC302_CRYPTO_BLOCK              ( 0x0100 )
+/*! The algorithm is a hash. */
+#define PC302_CRYPTO_HASH               ( 0x0200 )
+/*! The algorithm is a combined mode (authenc). */
+#define PC302_CRYPTO_COMBINED           ( 0x0300 )
+
+/*! Algorithm type mask. */
+#define PC302_CRYPTO_ALG_MASK           ( 0x00FF )
+/*! AES block cipher. */
+#define PC302_CRYPTO_ALG_AES            ( 0x0001 | PC302_CRYPTO_BLOCK )
+/*! DES block cipher. */
+#define PC302_CRYPTO_ALG_DES            ( 0x0002 | PC302_CRYPTO_BLOCK )
+/*! Triple DES block cipher. */
+#define PC302_CRYPTO_ALG_3DES           ( 0x0003 | PC302_CRYPTO_BLOCK )
+/*! Kasumi F8 block cipher. */
+#define PC302_CRYPTO_ALG_KASUMI         ( 0x0004 | PC302_CRYPTO_BLOCK )
+/*! SHA1 hash. */
+#define PC302_CRYPTO_ALG_SHA1           ( 0x0010 | PC302_CRYPTO_HASH )
+/*! MD5 hash. */
+#define PC302_CRYPTO_ALG_MD5            ( 0x0020 | PC302_CRYPTO_HASH )
+/*! SHA256 hash. */
+#define PC302_CRYPTO_ALG_SHA256         ( 0x0030 | PC302_CRYPTO_HASH )
+
+/*! Block cipher mode of operation mask. */
+#define PC302_CRYPTO_ABLK_MODE_MASK     ( 0xF000 )
+/*! CBC mode. */
+#define PC302_CRYPTO_ABLK_MODE_CBC      ( 0x1000 )
+/*! ECB mode. */
+#define PC302_CRYPTO_ABLK_MODE_ECB      ( 0x2000 )
+/*! F8 mode. */
+#define PC302_CRYPTO_ABLK_MODE_F8       ( 0x3000 )
+
+/*! Combined mode cbc(aes) and hmac(sha1). */
+#define PC302_CRYPTO_ALG_AUTHENC_AES_CBC_HMAC_SHA1 \
+    ( PC302_CRYPTO_COMBINED | \
+      PC302_CRYPTO_ALG_AES | \
+      PC302_CRYPTO_ABLK_MODE_CBC | \
+      PC302_CRYPTO_ALG_SHA1 )
+
+/*! Combined mode cbc(aes) and hmac(sha256). */
+#define PC302_CRYPTO_ALG_AUTHENC_AES_CBC_HMAC_SHA256 \
+    ( PC302_CRYPTO_COMBINED | \
+      PC302_CRYPTO_ALG_AES | \
+      PC302_CRYPTO_ABLK_MODE_CBC | \
+      PC302_CRYPTO_ALG_SHA256 )
+
+/*! Combined mode cbc(aes) and hmac(md5). */
+#define PC302_CRYPTO_ALG_AUTHENC_AES_CBC_HMAC_MD5 \
+    ( PC302_CRYPTO_COMBINED | \
+      PC302_CRYPTO_ALG_AES | \
+      PC302_CRYPTO_ABLK_MODE_CBC | \
+      PC302_CRYPTO_ALG_MD5 )
+
+/*! Combined mode cbc(des3_ede) and hmac(sha1). */
+#define PC302_CRYPTO_ALG_AUTHENC_3DES_CBC_HMAC_SHA1 \
+    ( PC302_CRYPTO_COMBINED | \
+      PC302_CRYPTO_ALG_3DES | \
+      PC302_CRYPTO_ABLK_MODE_CBC | \
+      PC302_CRYPTO_ALG_SHA1 )
+
+/*! Combined mode cbc(aes) and hmac(sha256). */
+#define PC302_CRYPTO_ALG_AUTHENC_3DES_CBC_HMAC_SHA256 \
+    ( PC302_CRYPTO_COMBINED | \
+      PC302_CRYPTO_ALG_3DES | \
+      PC302_CRYPTO_ABLK_MODE_CBC | \
+      PC302_CRYPTO_ALG_SHA256 )
+
+/*! Combined mode cbc(aes) and hmac(md5). */
+#define PC302_CRYPTO_ALG_AUTHENC_3DES_CBC_HMAC_MD5 \
+    ( PC302_CRYPTO_COMBINED | \
+      PC302_CRYPTO_ALG_3DES | \
+      PC302_CRYPTO_ABLK_MODE_CBC | \
+      PC302_CRYPTO_ALG_MD5 )
+
+/*!
+ * \brief PC302 definition of a crypto algorithm.
+ */
+struct pc302crypt_alg
+{
+    /*! The cipher type. */
+    unsigned long               type;
+
+    /*! The algorithm as it is registered with the crypto API. */
+    struct crypto_alg           alg;
+
+    /*! The engine that processes the algorithm. */
+    struct pc302crypt_engine    *engine;
+
+    /*! List head for storing registered algorithms for each engine. */
+    struct list_head            entry;
+};
+
+/*!
+ * \brief Generic context structure for any algorithm type.
+ */
+struct pc302crypt_generic_ctx
+{
+    /*! The engine that the context is associated with. */
+    struct pc302crypt_engine    *engine;
+
+    /*! The type of operation. */
+    int                         flags;
+};
+
+/*!
+ * \brief Block cipher context.
+ */
+struct pc302crypt_ablk_ctx
+{
+    /*! The algorithm independent generic information. */
+    struct pc302crypt_generic_ctx   generic;
+
+    /*! The cipher key. */
+    u8                          key[ PC302_CRYPTO_AES_MAX_KEY_LEN ];
+
+    /*! The length of the key in bytes. */
+    u8                          key_len;
+
+    /*! The fallback cipher. If the operation can't be done in hardware,
+     *  fallback to a software version. */
+    struct crypto_ablkcipher    *sw_cipher;
+};
+
+/*!
+ * \brief AEAD cipher context.
+ */
+struct pc302crypt_aead_ctx
+{
+    /*! The algorithm indenpendent generic information. */
+    struct pc302crypt_generic_ctx   generic;
+
+    /*! The block cipher key. */
+    u8                          cipher_key[ PC302_CRYPTO_AES_MAX_KEY_LEN ];
+
+    /*! The hash key. */
+    u8                          hash_ctx[ PC302_CRYPTO_IPSEC_HASH_PG_SZ ];
+
+    /*! The length of the cipher key in bytes. */
+    u8                          cipher_key_len;
+
+    /*! The length of the hash key in bytes. */
+    u8                          hash_key_len;
+
+    /*! The fallback cipher. */
+    struct crypto_aead          *sw_cipher;
+
+    /*! The length of the hash output. */
+    size_t                      auth_size;
+
+    /*! The salt for givencrypt requests. */
+    u8                          salt[ PC302_CRYPTO_AES_IV_LEN ];
+};
+
+static int
+pc302crypt_ablk_setkey( struct crypto_ablkcipher *cipher,
+                        const u8 *key,
+                        unsigned int len );
+
+static int
+pc302crypt_ablk_encrypt( struct ablkcipher_request *req );
+
+static int
+pc302crypt_ablk_decrypt( struct ablkcipher_request *req );
+
+static int
+pc302crypt_ablk_cra_init( struct crypto_tfm *tfm );
+
+static void
+pc302crypt_ablk_cra_exit( struct crypto_tfm *tfm );
+
+static int
+pc302crypt_aead_setkey( struct crypto_aead *tfm,
+                        const u8 *key,
+                        unsigned int keylen );
+
+static int
+pc302crypt_aead_encrypt( struct aead_request *req );
+
+static int
+pc302crypt_aead_givencrypt( struct aead_givcrypt_request *req );
+
+static int
+pc302crypt_aead_decrypt( struct aead_request *req );
+
+static int
+pc302crypt_aead_cra_init( struct crypto_tfm *tfm );
+
+static void
+pc302crypt_aead_cra_exit( struct crypto_tfm *tfm );
+
+static int
+pc302crypt_aead_setauthsize( struct crypto_aead *tfm,
+                             unsigned int authsize );
+
+static int
+ablk_null_givencrypt( struct skcipher_givcrypt_request *req )
+{
+    return crypto_ablkcipher_encrypt(&req->creq);
+}
+
+static int
+ablk_null_givdecrypt( struct skcipher_givcrypt_request *req )
+{
+    return crypto_ablkcipher_decrypt(&req->creq);
+}
+
+static struct pc302crypt_alg ipsec_engine_algs[] = {
+    {
+        .type           = PC302_CRYPTO_ALG_AES | PC302_CRYPTO_ABLK_MODE_CBC,
+        .alg            = {
+            .cra_name           = "cbc(aes)",
+            .cra_driver_name    = "cbc-aes-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_ABLKCIPHER |
+                                  CRYPTO_ALG_ASYNC |
+                                  CRYPTO_ALG_NEED_FALLBACK,
+            .cra_blocksize      = 16,
+            .cra_ctxsize        = sizeof( struct pc302crypt_ablk_ctx ),
+            .cra_type           = &crypto_ablkcipher_type,
+            .cra_module         = THIS_MODULE,
+            .cra_ablkcipher     = {
+                .setkey         = pc302crypt_ablk_setkey,
+                .encrypt        = pc302crypt_ablk_encrypt,
+                .decrypt        = pc302crypt_ablk_decrypt,
+                .min_keysize    = 16,
+                .max_keysize    = 32,
+                .ivsize         = 16,
+            },
+            .cra_init           = pc302crypt_ablk_cra_init,
+            .cra_exit           = pc302crypt_ablk_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_AES | PC302_CRYPTO_ABLK_MODE_ECB,
+        .alg            = {
+            .cra_name           = "ecb(aes)",
+            .cra_driver_name    = "ecb-aes-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_ABLKCIPHER |
+                                  CRYPTO_ALG_ASYNC |
+                                  CRYPTO_ALG_NEED_FALLBACK,
+            .cra_blocksize      = 16,
+            .cra_ctxsize        = sizeof( struct pc302crypt_ablk_ctx ),
+            .cra_type           = &crypto_ablkcipher_type,
+            .cra_module         = THIS_MODULE,
+            .cra_ablkcipher     = {
+                .setkey         = pc302crypt_ablk_setkey,
+                .encrypt        = pc302crypt_ablk_encrypt,
+                .decrypt        = pc302crypt_ablk_decrypt,
+                .min_keysize    = 16,
+                .max_keysize    = 32,
+            },
+            .cra_init           = pc302crypt_ablk_cra_init,
+            .cra_exit           = pc302crypt_ablk_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_DES | PC302_CRYPTO_ABLK_MODE_CBC,
+        .alg            = {
+            .cra_name           = "cbc(des)",
+            .cra_driver_name    = "cbc-des-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_ABLKCIPHER |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 8,
+            .cra_ctxsize        = sizeof( struct pc302crypt_ablk_ctx ),
+            .cra_type           = &crypto_ablkcipher_type,
+            .cra_module         = THIS_MODULE,
+            .cra_ablkcipher     = {
+                .setkey         = pc302crypt_ablk_setkey,
+                .encrypt        = pc302crypt_ablk_encrypt,
+                .decrypt        = pc302crypt_ablk_decrypt,
+                .min_keysize    = 8,
+                .max_keysize    = 8,
+                .ivsize         = 8,
+            },
+            .cra_init           = pc302crypt_ablk_cra_init,
+            .cra_exit           = pc302crypt_ablk_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_DES | PC302_CRYPTO_ABLK_MODE_ECB,
+        .alg            = {
+            .cra_name           = "ecb(des)",
+            .cra_driver_name    = "ecb-des-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_ABLKCIPHER |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 8,
+            .cra_ctxsize        = sizeof( struct pc302crypt_ablk_ctx ),
+            .cra_type           = &crypto_ablkcipher_type,
+            .cra_module         = THIS_MODULE,
+            .cra_ablkcipher     = {
+                .setkey         = pc302crypt_ablk_setkey,
+                .encrypt        = pc302crypt_ablk_encrypt,
+                .decrypt        = pc302crypt_ablk_decrypt,
+                .min_keysize    = 8,
+                .max_keysize    = 8,
+            },
+            .cra_init           = pc302crypt_ablk_cra_init,
+            .cra_exit           = pc302crypt_ablk_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_3DES | PC302_CRYPTO_ABLK_MODE_CBC,
+        .alg            = {
+            .cra_name           = "cbc(des3_ede)",
+            .cra_driver_name    = "cbc-des3-ede-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_ABLKCIPHER |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 8,
+            .cra_ctxsize        = sizeof( struct pc302crypt_ablk_ctx ),
+            .cra_type           = &crypto_ablkcipher_type,
+            .cra_module         = THIS_MODULE,
+            .cra_ablkcipher     = {
+                .setkey         = pc302crypt_ablk_setkey,
+                .encrypt        = pc302crypt_ablk_encrypt,
+                .decrypt        = pc302crypt_ablk_decrypt,
+                .min_keysize    = 24,
+                .max_keysize    = 24,
+                .ivsize         = 8,
+            },
+            .cra_init           = pc302crypt_ablk_cra_init,
+            .cra_exit           = pc302crypt_ablk_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_DES | PC302_CRYPTO_ABLK_MODE_ECB,
+        .alg            = {
+            .cra_name           = "ecb(des3_ede)",
+            .cra_driver_name    = "ecb-des3-ede-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_ABLKCIPHER |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 8,
+            .cra_ctxsize        = sizeof( struct pc302crypt_ablk_ctx ),
+            .cra_type           = &crypto_ablkcipher_type,
+            .cra_module         = THIS_MODULE,
+            .cra_ablkcipher     = {
+                .setkey         = pc302crypt_ablk_setkey,
+                .encrypt        = pc302crypt_ablk_encrypt,
+                .decrypt        = pc302crypt_ablk_decrypt,
+                .min_keysize    = 24,
+                .max_keysize    = 24,
+            },
+            .cra_init           = pc302crypt_ablk_cra_init,
+            .cra_exit           = pc302crypt_ablk_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_AUTHENC_AES_CBC_HMAC_SHA1,
+        .alg            = {
+            .cra_name           = "authenc(hmac(sha1),cbc(aes))",
+            .cra_driver_name    = "authenc-hmac-sha1-cbc-aes-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_AEAD |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 16,
+            .cra_ctxsize        = sizeof( struct pc302crypt_aead_ctx ),
+            .cra_type           = &crypto_aead_type,
+            .cra_module         = THIS_MODULE,
+            .cra_aead           = {
+                .setkey         = pc302crypt_aead_setkey,
+                .setauthsize    = pc302crypt_aead_setauthsize,
+                .encrypt        = pc302crypt_aead_encrypt,
+                .decrypt        = pc302crypt_aead_decrypt,
+                .givencrypt     = pc302crypt_aead_givencrypt,
+                .ivsize         = 16,
+                .maxauthsize    = 20,
+            },
+            .cra_init           = pc302crypt_aead_cra_init,
+            .cra_exit           = pc302crypt_aead_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_AUTHENC_AES_CBC_HMAC_SHA256,
+        .alg            = {
+            .cra_name           = "authenc(hmac(sha256),cbc(aes))",
+            .cra_driver_name    = "authenc-hmac-sha256-cbc-aes-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_AEAD |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 16,
+            .cra_ctxsize        = sizeof( struct pc302crypt_aead_ctx ),
+            .cra_type           = &crypto_aead_type,
+            .cra_module         = THIS_MODULE,
+            .cra_aead           = {
+                .setkey         = pc302crypt_aead_setkey,
+                .setauthsize    = pc302crypt_aead_setauthsize,
+                .encrypt        = pc302crypt_aead_encrypt,
+                .decrypt        = pc302crypt_aead_decrypt,
+                .givencrypt     = pc302crypt_aead_givencrypt,
+                .ivsize         = 16,
+                .maxauthsize    = 32,
+            },
+            .cra_init           = pc302crypt_aead_cra_init,
+            .cra_exit           = pc302crypt_aead_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_AUTHENC_AES_CBC_HMAC_MD5,
+        .alg            = {
+            .cra_name           = "authenc(hmac(md5),cbc(aes))",
+            .cra_driver_name    = "authenc-hmac-md5-cbc-aes-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_AEAD |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 16,
+            .cra_ctxsize        = sizeof( struct pc302crypt_aead_ctx ),
+            .cra_type           = &crypto_aead_type,
+            .cra_module         = THIS_MODULE,
+            .cra_aead           = {
+                .setkey         = pc302crypt_aead_setkey,
+                .setauthsize    = pc302crypt_aead_setauthsize,
+                .encrypt        = pc302crypt_aead_encrypt,
+                .decrypt        = pc302crypt_aead_decrypt,
+                .givencrypt     = pc302crypt_aead_givencrypt,
+                .ivsize         = 16,
+                .maxauthsize    = 16,
+            },
+            .cra_init           = pc302crypt_aead_cra_init,
+            .cra_exit           = pc302crypt_aead_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_AUTHENC_3DES_CBC_HMAC_SHA1,
+        .alg            = {
+            .cra_name           = "authenc(hmac(sha1),cbc(des3_ede))",
+            .cra_driver_name    = "authenc-hmac-sha1-cbc-3des-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_AEAD |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 8,
+            .cra_ctxsize        = sizeof( struct pc302crypt_aead_ctx ),
+            .cra_type           = &crypto_aead_type,
+            .cra_module         = THIS_MODULE,
+            .cra_aead           = {
+                .setkey         = pc302crypt_aead_setkey,
+                .setauthsize    = pc302crypt_aead_setauthsize,
+                .encrypt        = pc302crypt_aead_encrypt,
+                .decrypt        = pc302crypt_aead_decrypt,
+                .givencrypt     = pc302crypt_aead_givencrypt,
+                .ivsize         = 8,
+                .maxauthsize    = 20,
+            },
+            .cra_init           = pc302crypt_aead_cra_init,
+            .cra_exit           = pc302crypt_aead_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_AUTHENC_3DES_CBC_HMAC_SHA256,
+        .alg            = {
+            .cra_name           = "authenc(hmac(sha256),cbc(des3_ede))",
+            .cra_driver_name    = "authenc-hmac-sha256-cbc-3des-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_AEAD |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 8,
+            .cra_ctxsize        = sizeof( struct pc302crypt_aead_ctx ),
+            .cra_type           = &crypto_aead_type,
+            .cra_module         = THIS_MODULE,
+            .cra_aead           = {
+                .setkey         = pc302crypt_aead_setkey,
+                .setauthsize    = pc302crypt_aead_setauthsize,
+                .encrypt        = pc302crypt_aead_encrypt,
+                .decrypt        = pc302crypt_aead_decrypt,
+                .givencrypt     = pc302crypt_aead_givencrypt,
+                .ivsize         = 8,
+                .maxauthsize    = 32,
+            },
+            .cra_init           = pc302crypt_aead_cra_init,
+            .cra_exit           = pc302crypt_aead_cra_exit,
+        },
+    },
+    {
+        .type           = PC302_CRYPTO_ALG_AUTHENC_3DES_CBC_HMAC_MD5,
+        .alg            = {
+            .cra_name           = "authenc(hmac(md5),cbc(des3_ede))",
+            .cra_driver_name    = "authenc-hmac-md5-cbc-3des-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_AEAD |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 8,
+            .cra_ctxsize        = sizeof( struct pc302crypt_aead_ctx ),
+            .cra_type           = &crypto_aead_type,
+            .cra_module         = THIS_MODULE,
+            .cra_aead           = {
+                .setkey         = pc302crypt_aead_setkey,
+                .setauthsize    = pc302crypt_aead_setauthsize,
+                .encrypt        = pc302crypt_aead_encrypt,
+                .decrypt        = pc302crypt_aead_decrypt,
+                .givencrypt     = pc302crypt_aead_givencrypt,
+                .ivsize         = 8,
+                .maxauthsize    = 16,
+            },
+            .cra_init           = pc302crypt_aead_cra_init,
+            .cra_exit           = pc302crypt_aead_cra_exit,
+        },
+    },
+};
+
+/* Although we never want to use f8(kasumi) as a geniv cipher, we need to make
+ * it one so that the kernel doesn't try to wrap it up in a generic IV
+ * generator. If we let it do this then as it doesn't know about the f8 mode
+ * or Kasumi algorithm it fails. Best to tell it we have our own IV generator
+ * and turn givencrypt/givdecrypt requests into normal encrypt/decrypt
+ * requests. */
+static struct pc302crypt_alg l2_engine_algs[] = {
+    {
+        .type           = PC302_CRYPTO_ALG_KASUMI |
+                          PC302_CRYPTO_ABLK_MODE_F8,
+        .alg            = {
+            .cra_name           = "f8(kasumi)",
+            .cra_driver_name    = "f8-kasumi-pc302",
+            .cra_priority       = PC302_CRYPTO_ALG_PRIORITY,
+            .cra_flags          = CRYPTO_ALG_TYPE_GIVCIPHER |
+                                  CRYPTO_ALG_ASYNC,
+            .cra_blocksize      = 8,
+            .cra_ctxsize        = sizeof( struct pc302crypt_ablk_ctx ),
+            .cra_type           = &crypto_ablkcipher_type,
+            .cra_module         = THIS_MODULE,
+            .cra_ablkcipher     = {
+                .setkey         = pc302crypt_ablk_setkey,
+                .encrypt        = pc302crypt_ablk_encrypt,
+                .decrypt        = pc302crypt_ablk_decrypt,
+                .givencrypt     = ablk_null_givencrypt,
+                .givdecrypt     = ablk_null_givdecrypt,
+                .min_keysize    = 16,
+                .max_keysize    = 16,
+                .ivsize         = 8,
+                .geniv          = "internal",
+            },
+            .cra_init           = pc302crypt_ablk_cra_init,
+            .cra_exit           = pc302crypt_ablk_cra_exit,
+        },
+    },
+};
+
+/*! The IPSec offload engine. */
+static struct pc302crypt_engine ipsec_engine = {
+    .name               = "ipsec_engine",
+    .hw_lock            = SPIN_LOCK_UNLOCKED,
+    .max_ctxs           = PC302_CRYPTO_IPSEC_MAX_CTXS,
+    .cipher_pg_sz       = PC302_CRYPTO_IPSEC_CIPHER_PG_SZ,
+    .hash_pg_sz         = PC302_CRYPTO_IPSEC_HASH_PG_SZ,
+    .fifo_sz            = PC302_CRYPTO_IPSEC_FIFO_SZ,
+    .algs               = ipsec_engine_algs,
+    .num_algs           = ARRAY_SIZE( ipsec_engine_algs ),
+};
+
+/*! The layer 2 offload engine. */
+static struct pc302crypt_engine l2_engine = {
+    .name               = "l2_engine",
+    .hw_lock            = SPIN_LOCK_UNLOCKED,
+    .max_ctxs           = PC302_CRYPTO_L2_MAX_CTXS,
+    .cipher_pg_sz       = PC302_CRYPTO_L2_CIPHER_PG_SZ,
+    .hash_pg_sz         = PC302_CRYPTO_L2_HASH_PG_SZ,
+    .fifo_sz            = PC302_CRYPTO_L2_FIFO_SZ,
+    .algs               = l2_engine_algs,
+    .num_algs           = ARRAY_SIZE( l2_engine_algs ),
+};
+
+/*!
+ * From a generic context, get the block cipher context containing it.
+ *
+ * @param ctx The generic context.
+ * @return Returns a pointer to the block cipher context on success,
+ * NULL on failure.
+ */
+static inline struct pc302crypt_ablk_ctx *
+to_pc302crypt_ablk_ctx( struct pc302crypt_generic_ctx *ctx )
+{
+    return ctx ? container_of( ctx, struct pc302crypt_ablk_ctx, generic ) :
+        NULL;
+}
+
+/*!
+ * From a generic context, get the AEAD cipher context containing it.
+ *
+ * @param ctx The generic context.
+ * @return Returns a pointer to the AEAD cipher context on success,
+ * NULL on failure.
+ */
+static inline struct pc302crypt_aead_ctx *
+to_pc302crypt_aead_ctx( struct pc302crypt_generic_ctx *ctx )
+{
+    return ctx ? container_of( ctx, struct pc302crypt_aead_ctx, generic ) :
+        NULL;
+}
+
+static inline struct pc302crypt_alg *
+to_pc302crypt_alg( struct crypto_alg *alg );
+
+/*!
+ * Write to a register in the crypto offload engine.
+ *
+ * @param engine The engine to write to.
+ * @param offset The offset of the register from the engine base address.
+ * @param value The value to write to the register.
+ */
+static inline void
+pc302crypt_reg_write( struct pc302crypt_engine *engine,
+                      unsigned long offset,
+                      u32 value )
+{
+    void __iomem *addr = engine->regs + offset;
+    PRINTD( DBG_IO, "reg_wr, engine=\"%s\": 0x%04x := 0x%08x", engine->name,
+            ( unsigned )offset, value );
+    iowrite32( value, addr );
+}
+
+/*!
+ * Read from a register in the crypto offload engine.
+ *
+ * @param engine The engine to read from.
+ * @param offset The offset of the register from the engine base address.
+ * @return Returns the value of the register.
+ */
+static inline u32
+pc302crypt_reg_read( struct pc302crypt_engine *engine,
+                     unsigned long offset )
+{
+    void __iomem *addr = engine->regs + offset;
+    u32 val = ioread32( addr );
+    PRINTD( DBG_IO, "reg_rd, engine=\"%s\": 0x%04x == 0x%08x", engine->name,
+            ( unsigned )offset, val );
+    return val;
+}
+
+/*!
+ * Given a cipher context, and a context number, get the base address of the
+ * context page.
+ *
+ * @param ctx The context of the algorithm.
+ * @param indx The index of the page to use inside the engine.
+ * @param cipher_ctx Boolean flag indicating that the context is a cipher and
+ * not a hash.
+ * @return Returns the address of the context page where the key/context may
+ * be written.
+ */
+static inline void __iomem *
+pc302crypt_ctx_page_addr( struct pc302crypt_generic_ctx *ctx,
+                          unsigned indx,
+                          int cipher_ctx )
+{
+    if ( cipher_ctx )
+    {
+        return ctx->engine->cipher_ctx_base +
+               ( indx * ctx->engine->cipher_pg_sz );
+    }
+    else
+    {
+        return ctx->engine->hash_key_base +
+               ( indx * ctx->engine->hash_pg_sz );
+    }
+}
+
+static inline void
+memcpy_toio32( u32 __iomem *dst,
+               const void *src,
+               unsigned count )
+{
+    u32 *src32 = ( u32 * )src;
+    while ( count-- )
+        iowrite32( *src32++, dst++ );
+}
+
+/*!
+ * Write a key and IV pair into the correct context format for the engine.
+ *
+ * @param ctx The context to write into the engine.
+ * @param page_addr The address of the context page to write into.
+ * @param key The key to write.
+ * @param key_len The length of the key in bytes.
+ * @param iv The IV.
+ * @param iv_len The length of the IV in bytes.
+ */
+static void
+pc302crypt_cipher_write_ctx( struct pc302crypt_generic_ctx *ctx,
+                             void __iomem *page_addr,
+                             const u8 *key,
+                             size_t key_len,
+                             const u8 *iv,
+                             size_t iv_len )
+{
+    void __iomem *key_ptr;
+    void __iomem *iv_ptr;
+
+    switch ( ( ctx->flags & PC302_CRYPTO_BLOCK_MASK ) | PC302_CRYPTO_BLOCK )
+    {
+        case PC302_CRYPTO_ALG_AES:
+            key_ptr = page_addr;
+            iv_ptr = page_addr + PC302_CRYPTO_AES_MAX_KEY_LEN;
+            break;
+
+        case PC302_CRYPTO_ALG_3DES:
+        case PC302_CRYPTO_ALG_DES:
+            key_ptr = page_addr + PC302_CRYPTO_DES_IV_LEN;
+            iv_ptr = page_addr;
+            break;
+
+        case PC302_CRYPTO_ALG_KASUMI:
+            key_ptr = page_addr;
+            iv_ptr = page_addr + PC302_CRYPTO_KASUMI_F8_KEY_LEN;
+            break;
+
+        default:
+            BUG();
+    }
+
+    memcpy_toio32( key_ptr, key, key_len / 4 );
+    memcpy_toio32( iv_ptr, iv, iv_len / 4 );
+}
+
+/*! Context load mode. */
+enum context_load_mode
+{
+    CTX_CIPHER,
+    CTX_HASH,
+    CTX_COMBINED,
+};
+
+/*!
+ * Load a context into the engines context memory.
+ *
+ * @param ctx The context to load.
+ * @param iv The IV of the operation.
+ * @param ivlen The length of the IV in bytes.
+ * @param mode The context load type.
+ * @return Returns the index of the context page where the context was loaded.
+ */
+static unsigned
+pc302crypt_load_ctx( struct pc302crypt_generic_ctx *ctx,
+                     u8 *iv,
+                     size_t ivlen,
+                     enum context_load_mode mode )
+{
+    unsigned i;
+    unsigned indx;
+
+    indx = -1;
+    for ( i = 0; i < ctx->engine->max_ctxs; ++i )
+        if ( ( !ctx->engine->ddt_buf[ i ].in_use ) )
+        {
+            indx = i;
+            break;
+        }
+
+    /* We failed to find a context slot. There are the same number of context
+     * pages as there are slots in the FIFO so it should be impossible to get
+     * a context slot. */
+    BUG_ON( -1 == indx );
+
+    ctx->engine->ddt_buf[ i ].in_use = 1;
+
+    if ( CTX_CIPHER == mode )
+    {
+        struct pc302crypt_ablk_ctx *ablk_ctx = to_pc302crypt_ablk_ctx( ctx );
+        pc302crypt_cipher_write_ctx( ctx,
+                                     pc302crypt_ctx_page_addr( ctx, indx, 1 ),
+                                     ablk_ctx->key, ablk_ctx->key_len,
+                                     iv, ivlen );
+        pc302crypt_reg_write( ctx->engine, SPA_KEY_SZ_REG_OFFSET,
+                              ablk_ctx->key_len |
+                              indx << SPA_KEY_SZ_CTX_INDEX_OFFSET |
+                              ( 1 << SPA_KEY_SZ_CIPHER_OFFSET ) );
+    }
+    else if ( CTX_COMBINED == mode )
+    {
+        struct pc302crypt_aead_ctx *aead_ctx = to_pc302crypt_aead_ctx( ctx );
+
+        /* Write the cipher context. */
+        pc302crypt_cipher_write_ctx( ctx,
+                                     pc302crypt_ctx_page_addr( ctx, indx, 1 ),
+                                     aead_ctx->cipher_key,
+                                     aead_ctx->cipher_key_len,
+                                     iv, ivlen );
+        pc302crypt_reg_write( ctx->engine, SPA_KEY_SZ_REG_OFFSET,
+                              aead_ctx->cipher_key_len |
+                              indx << SPA_KEY_SZ_CTX_INDEX_OFFSET |
+                              ( 1 << SPA_KEY_SZ_CIPHER_OFFSET ) );
+
+        /* Write the hash context. */
+        memcpy_toio32( pc302crypt_ctx_page_addr( ctx, indx, 0 ),
+                       &aead_ctx->hash_ctx, aead_ctx->hash_key_len / 4 );
+        pc302crypt_reg_write( ctx->engine, SPA_KEY_SZ_REG_OFFSET,
+                              aead_ctx->hash_key_len |
+                              indx << SPA_KEY_SZ_CTX_INDEX_OFFSET |
+                              ( 0 << SPA_KEY_SZ_CIPHER_OFFSET ) );
+    }
+    else
+    {
+        /* Unsupported context type. */
+        BUG();
+    }
+
+    return indx;
+}
+
+/*!
+ * Unload a context from the crypto engine.
+ *
+ * @param ctx The context to unload.
+ * @param indx The context page address to unload.
+ */
+static void
+pc302crypt_unload_ctx( struct pc302crypt_generic_ctx *ctx,
+                       unsigned indx )
+{
+    ctx->engine->ddt_buf[ indx ].in_use = 0;
+}
+
+/*!
+ * Initialise a PC302 crypto queue for max_qlen entries.
+ *
+ * @param queue The queue to initialise.
+ * @param max_qlen The maximum number of entries that the queue may hold.
+ */
+static void
+pc302crypt_queue_init( struct pc302crypt_queue *queue,
+                       unsigned max_qlen )
+{
+    INIT_LIST_HEAD(&queue->list);
+    queue->backlog = &queue->list;
+    queue->qlen = 0;
+    queue->max_qlen = max_qlen;
+}
+
+/*!
+ * Add a crypto request into the crypto queue.
+ *
+ * @param queue The queue to add the request into.
+ * @param request The request to add to the queue.
+ * @return Returns -EINPROGRESS if the request is added, other negative values
+ * on failure.
+ */
+static int
+pc302crypt_queue_req( struct pc302crypt_queue *queue,
+                      struct pc302crypt_req *request )
+{
+    int err = -EINPROGRESS;
+
+    if ( unlikely( queue->qlen >= queue->max_qlen ) )
+    {
+        err = -EBUSY;
+        if ( !( request->req->flags & CRYPTO_TFM_REQ_MAY_BACKLOG ) )
+            goto out;
+        if ( queue->backlog == &queue->list )
+             queue->backlog = &request->list;
+    }
+
+    queue->qlen++;
+    list_add_tail( &request->list, &queue->list );
+
+out:
+    return err;
+}
+
+/*!
+ * Force a request to be added to the crypto queue. This is useful when we
+ * have completed requests and backlogging does not matter.
+ *
+ * @param queue The queue to add the request to.
+ * @param request The request to add to the queue.
+ * @param Returns -EINPROGRESS.
+ */
+static int
+pc302crypt_queue_req_force( struct pc302crypt_queue *queue,
+                            struct pc302crypt_req *request )
+{
+    if ( queue->qlen >= queue->max_qlen && queue->backlog == &queue->list )
+        queue->backlog = &request->list;
+
+    queue->qlen++;
+    list_add_tail( &request->list, &queue->list );
+
+    return -EINPROGRESS;
+}
+
+/*!
+ * Remove a request from the head of a crypto queue.
+ *
+ * @param queue The queue to remove the request from.
+ * @return Returns the request from the queue head on success, NULL on
+ * failure.
+ */
+static struct pc302crypt_req *
+pc302crypt_dequeue_req( struct pc302crypt_queue *queue )
+{
+    struct list_head *request;
+
+    if ( unlikely( !queue->qlen ) )
+        return NULL;
+
+    queue->qlen--;
+
+    if ( queue->backlog != &queue->list )
+        queue->backlog = queue->backlog->next;
+
+    request = queue->list.next;
+    list_del( request );
+
+    return list_entry( request, struct pc302crypt_req, list );
+}
+
+/*!
+ * Count the number of scatterlist entries in a scatterlist.
+ *
+ * @param sg_list The scatterlist to count.
+ * @param nbytes The number of bytes in the scatterlist.
+ * @return Returns the number of entries in the scatterlist.
+ */
+static int
+sg_count( struct scatterlist *sg_list,
+          int nbytes )
+{
+    struct scatterlist *sg = sg_list;
+    int sg_nents = 0;
+
+    while ( nbytes > 0 )
+    {
+        ++sg_nents;
+        nbytes -= sg->length;
+        sg = sg_next( sg );
+    }
+
+    return sg_nents;
+}
+
+/*!
+ * Take a crypto request and scatterlists for the data and turn them into DDTs
+ * for passing to the crypto engines. This also DMA maps the data so that the
+ * crypto engines can DMA to/from them.
+ *
+ * @param req The request to convert.
+ * @param payload The payload data.
+ * @param nbytes The number of bytes in the payload scatterlist.
+ * @param dir The direction of the transfer.
+ * @return Returns the DDT list on success, NULL on failure.
+ */
+static struct pc302crypt_ddt *
+pc302crypt_sg_to_ddt( struct pc302crypt_req *req,
+                      struct scatterlist *payload,
+                      unsigned nbytes,
+                      enum dma_data_direction dir )
+{
+    unsigned nents = sg_count( payload, nbytes );
+    struct scatterlist *cur;
+    unsigned i = 0;
+    struct pc302crypt_ablk_ctx *ablk_ctx = crypto_tfm_ctx( req->req->tfm );
+    struct pc302crypt_engine *engine = ablk_ctx->generic.engine;
+    struct pc302crypt_ddt *ddt = dir == DMA_TO_DEVICE ?
+        engine->ddt_buf[ req->ctx_id ].src_ddt :
+        engine->ddt_buf[ req->ctx_id ].dst_ddt;
+    unsigned mapped_ents = dma_map_sg( engine->dev, payload, nents, dir );
+    unsigned nddt_entries = mapped_ents;
+
+    /* If we can't make a DDT large enough then fail. */
+    if ( nddt_entries + 1 > MAX_DDT_LEN )
+    {
+        PRINTD( DBG_WARN, "DDT of %u required (>%u)", nddt_entries + 1,
+                MAX_DDT_LEN );
+        return NULL;
+    }
+
+    for_each_sg( payload, cur, mapped_ents, i )
+    {
+        ddt[ i ].p = sg_dma_address( cur );
+        ddt[ i ].len = sg_dma_len( cur );
+    }
+
+    ddt[ nddt_entries ].p = 0;
+    ddt[ nddt_entries ].len = 0;
+
+    return ddt;
+}
+
+static int
+pc302crypt_aead_make_ddts( struct pc302crypt_req *req,
+                           u8 *giv,
+                           u64 seq )
+{
+    int ret = 0;
+    struct aead_request *areq =
+        container_of( req->req, struct aead_request, base );
+    struct pc302crypt_alg *alg = to_pc302crypt_alg( req->req->tfm->__crt_alg );
+    struct pc302crypt_ablk_ctx *aead_ctx = crypto_tfm_ctx( req->req->tfm );
+    struct pc302crypt_engine *engine = aead_ctx->generic.engine;
+    struct pc302crypt_ddt *src_ddt = engine->ddt_buf[ req->ctx_id ].src_ddt;
+    struct pc302crypt_ddt *dst_ddt = engine->ddt_buf[ req->ctx_id ].dst_ddt;
+    unsigned ivsize = alg->alg.cra_aead.ivsize;
+    unsigned nents = sg_count( areq->src, areq->cryptlen );
+    int assoc_ents = dma_map_sg( engine->dev, areq->assoc,
+                                 sg_count( areq->assoc, areq->assoclen ),
+                                 DMA_TO_DEVICE );
+    dma_addr_t iv_addr;
+    struct scatterlist *cur;
+    unsigned src_pos = 0;
+    unsigned dst_pos = 0;
+    unsigned i;
+    int ddt_len;
+    int dst_ents = 0;
+    int src_ents = 0;
+
+    if ( areq->src != areq->dst )
+    {
+        src_ents = dma_map_sg( engine->dev, areq->src, nents,
+                               DMA_TO_DEVICE );
+        dst_ents = dma_map_sg( engine->dev, areq->dst, nents,
+                               DMA_FROM_DEVICE );
+    }
+    else
+    {
+        src_ents = dma_map_sg( engine->dev, areq->src, nents,
+                               DMA_BIDIRECTIONAL );
+    }
+
+    /* Number of DDT entries. +2 because we need to include the IV and the
+     * NULL terminator. */
+    ddt_len = src_ents + dst_ents + assoc_ents + 2;
+
+    if ( giv )
+        iv_addr = dma_map_single( engine->dev, giv, ivsize,
+                                  DMA_BIDIRECTIONAL );
+    else
+        iv_addr = dma_map_single( engine->dev, areq->iv, ivsize,
+                                  DMA_TO_DEVICE );
+    req->giv_pa = iv_addr;
+
+    if ( src_ents < 0 || assoc_ents < 0 )
+    {
+        PRINTD( DBG_WARN, "failed to map payload or associated data" );
+        ret = -EIO;
+        goto out;
+    }
+
+    req->ddt_len = ddt_len;
+
+    for_each_sg( areq->assoc, cur, assoc_ents, i )
+    {
+        src_ddt[ src_pos ].p = sg_dma_address( cur );
+        src_ddt[ src_pos ].len = sg_dma_len( cur );
+        ++src_pos;
+
+        if ( ENCRYPT == req->dir )
+        {
+            dst_ddt[ dst_pos ].p = sg_dma_address( cur );
+            dst_ddt[ dst_pos ].len = sg_dma_len( cur );
+            ++dst_pos;
+        }
+    }
+
+    src_ddt[ src_pos ].p = iv_addr;
+    src_ddt[ src_pos ].len = ivsize;
+    ++src_pos;
+
+    if ( giv || ENCRYPT == req->dir )
+    {
+        dst_ddt[ dst_pos ].p = iv_addr;
+        dst_ddt[ dst_pos ].len = ivsize;
+        ++dst_pos;
+    }
+
+    for_each_sg( areq->src, cur, src_ents, i )
+    {
+        src_ddt[ src_pos ].p = sg_dma_address( cur );
+        src_ddt[ src_pos ].len = sg_dma_len( cur );
+        ++src_pos;
+        if ( areq->src == areq->dst )
+        {
+            dst_ddt[ dst_pos ].p = sg_dma_address( cur );
+            dst_ddt[ dst_pos ].len = sg_dma_len( cur );
+            ++dst_pos;
+        }
+    }
+
+    if ( areq->src != areq->dst )
+        for_each_sg( areq->dst, cur, dst_ents, i )
+        {
+            dst_ddt[ dst_pos ].p = sg_dma_address( cur );
+            dst_ddt[ dst_pos ].len = sg_dma_len( cur );
+            ++dst_pos;
+        }
+
+    src_ddt[ src_pos ].p = 0;
+    src_ddt[ src_pos ].len = 0;
+    dst_ddt[ dst_pos ].p = 0;
+    dst_ddt[ dst_pos ].len = 0;
+
+    ret = 0;
+
+out:
+    return ret;
+}
+
+static void
+pc302crypt_aead_kill_ddts( struct pc302crypt_req *req )
+{
+    struct aead_request *areq =
+        container_of( req->req, struct aead_request, base );
+    struct pc302crypt_alg *alg = to_pc302crypt_alg( req->req->tfm->__crt_alg );
+    struct pc302crypt_ablk_ctx *aead_ctx = crypto_tfm_ctx( req->req->tfm );
+    struct pc302crypt_engine *engine = aead_ctx->generic.engine;
+    unsigned ivsize = alg->alg.cra_aead.ivsize;
+    unsigned nents = sg_count( areq->src, areq->cryptlen );
+    if ( areq->src != areq->dst )
+    {
+        dma_unmap_sg( engine->dev, areq->src, nents, DMA_TO_DEVICE );
+        dma_unmap_sg( engine->dev, areq->dst,
+                      sg_count( areq->dst, areq->cryptlen ), DMA_FROM_DEVICE );
+    }
+    else
+    {
+        dma_unmap_sg( engine->dev, areq->src, nents, DMA_BIDIRECTIONAL );
+    }
+    dma_unmap_sg( engine->dev, areq->assoc,
+                  sg_count( areq->assoc, areq->assoclen ), DMA_TO_DEVICE );
+
+    dma_unmap_single( engine->dev, req->giv_pa, ivsize,
+                      DMA_BIDIRECTIONAL );
+}
+
+/*!
+ * Free a DDT list.
+ *
+ * @param req The request to free the DDT list for.
+ * @param assoc The associated data for the request. If this is a block cipher
+ * then this may be NULL.
+ * @param payload The payload data for the operation.
+ * @param giv The generated IV.
+ * @param ivlen The length of the generated IV.
+ * @param nbytes The number of bytes in the payload scatterlist.
+ * @param dir The direction of the operation.
+ */
+static void
+pc302crypt_free_ddt( struct pc302crypt_req *req,
+                     struct scatterlist *payload,
+                     unsigned nbytes,
+                     enum dma_data_direction dir )
+{
+    unsigned nents = sg_count( payload, nbytes );
+    struct pc302crypt_ablk_ctx *ablk_ctx = crypto_tfm_ctx( req->req->tfm );
+    struct pc302crypt_engine *engine = ablk_ctx->generic.engine;
+    dma_unmap_sg( engine->dev, payload, nents, dir );
+}
+
+/*!
+ * Set key for a DES operation in an AEAD cipher. This also performs weak key
+ * checking if required.
+ *
+ * @param aead The transform to set the key for.
+ * @param key The key to set.
+ * @param len The length of the key in bytes.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302crypt_aead_des_setkey( struct crypto_aead *aead,
+                            const u8 *key,
+                            unsigned int len )
+{
+    struct crypto_tfm *tfm = crypto_aead_tfm( aead );
+    struct pc302crypt_aead_ctx *ctx = crypto_tfm_ctx( tfm );
+    int err = 0;
+    u32 tmp[ DES_EXPKEY_WORDS ];
+
+    err = des_ekey( tmp, key );
+    if ( unlikely( !err ) &&
+            ( crypto_aead_get_flags( aead) ) & CRYPTO_TFM_REQ_WEAK_KEY )
+    {
+        tfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;
+        return -EINVAL;
+    }
+    err = 0;
+
+    memcpy( ctx->cipher_key, key, len );
+    ctx->cipher_key_len = len;
+
+    return err;
+}
+
+/*!
+ * Set the key for the AES block cipher component of the AEAD transform. 
+ *
+ * @param aead The transform to set the key for.
+ * @param key The key to set.
+ * @param len The length of the key in bytes.
+ *
+ * @return Returns zero on success, negative on failure, and 1 if we require a
+ * fallback.
+ */
+static int
+pc302crypt_aead_aes_setkey( struct crypto_aead *aead,
+                            const u8 *key,
+                            unsigned int len )
+{
+    struct crypto_tfm *tfm = crypto_aead_tfm( aead );
+    struct pc302crypt_aead_ctx *ctx = crypto_tfm_ctx( tfm );
+
+    /* IPSec engine only supports 128 and 256 bit AES keys. If we get a
+     * request for any other size (192 bits) then we need to do a software
+     * fallback. */
+    if ( !( 16 == len || 32 == len ) )
+        return 1;
+
+    memcpy( ctx->cipher_key, key, len );
+    ctx->cipher_key_len = len;
+
+    return 0;
+}
+
+/*!
+ * Set the key for an AEAD operation.
+ *
+ * @param tfm The transform to set the key for.
+ * @param key The key to set.
+ * @param keylen The length of the key in bytes.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302crypt_aead_setkey( struct crypto_aead *tfm,
+                        const u8 *key,
+                        unsigned int keylen )
+{
+    struct pc302crypt_aead_ctx *ctx = crypto_aead_ctx( tfm );
+    struct pc302crypt_alg *alg = to_pc302crypt_alg( tfm->base.__crt_alg );
+    struct rtattr *rta = (void *)key;
+    struct crypto_authenc_key_param *param;
+    unsigned int authkeylen;
+    unsigned int enckeylen;
+    int err;
+
+    if ( !RTA_OK( rta, keylen ) )
+        goto badkey;
+
+    if ( rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM )
+        goto badkey;
+
+    if ( RTA_PAYLOAD( rta ) < sizeof( *param ) )
+        goto badkey;
+
+    param = RTA_DATA( rta );
+    enckeylen = be32_to_cpu( param->enckeylen );
+
+    key += RTA_ALIGN( rta->rta_len );
+    keylen -= RTA_ALIGN( rta->rta_len );
+
+    if ( keylen < enckeylen )
+        goto badkey;
+
+    authkeylen = keylen - enckeylen;
+
+    if ( enckeylen > PC302_CRYPTO_AES_MAX_KEY_LEN )
+        goto badkey;
+
+    /* Set the block cipher key. */
+    switch ( ( alg->type & PC302_CRYPTO_BLOCK_MASK ) | PC302_CRYPTO_BLOCK )
+    {
+        case PC302_CRYPTO_ALG_AES:
+            err = pc302crypt_aead_aes_setkey( tfm, key + authkeylen,
+                                              enckeylen );
+            /* We need a fallback so we need to set the fallback algorithm to
+             * use the block and hash key pair. */
+            if ( 1 == err && ctx->sw_cipher )
+            {
+                /* Set the fallback transform to use the same request flags as
+                 * the hardware transform. */
+                ctx->sw_cipher->base.crt_flags &= ~CRYPTO_TFM_REQ_MASK;
+                ctx->sw_cipher->base.crt_flags |=
+                    ( tfm->base.crt_flags & CRYPTO_TFM_REQ_MASK );
+
+                err = crypto_aead_setkey( ctx->sw_cipher, key, keylen );
+            }
+            else if ( 1 == err && !ctx->sw_cipher )
+                err = -EINVAL;
+            break;
+
+        case PC302_CRYPTO_ALG_3DES:
+        case PC302_CRYPTO_ALG_DES:
+            err = pc302crypt_aead_des_setkey( tfm, key + authkeylen,
+                                              enckeylen );
+            break;
+
+        default:
+            BUG();
+            break;
+    }
+
+    if ( err )
+        goto badkey;
+
+    memcpy( ctx->hash_ctx, key, authkeylen );
+    ctx->hash_key_len = authkeylen;
+
+    return 0;
+
+badkey:
+    crypto_aead_set_flags( tfm, CRYPTO_TFM_RES_BAD_KEY_LEN );
+    return -EINVAL;
+}
+
+/*!
+ * Set the authsize field of an AEAD request.
+ *
+ * @param tfm The transform to set the authsize for.
+ * @param authsize The size of the authentication data.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302crypt_aead_setauthsize( struct crypto_aead *tfm,
+                             unsigned int authsize )
+{
+    struct pc302crypt_aead_ctx *ctx = crypto_tfm_ctx( crypto_aead_tfm( tfm ) );
+    ctx->auth_size = authsize;
+    return 0;
+}
+
+/*!
+ * Check if an AEAD request requires a fallback operation. Some requests can't
+ * be completed in hardware because the hardware may not support certain key
+ * sizes. In these cases we need to complete the request in software.
+ *
+ * @param req The request to check.
+ * @return Returns 1 if the request needs a fallback, zero otherwise.
+ */
+static int
+pc302crypt_aead_need_fallback( struct pc302crypt_req *req )
+{
+    struct aead_request *aead_req;
+    struct pc302crypt_aead_ctx *ctx;
+    struct crypto_tfm *tfm = req->req->tfm;
+    struct crypto_alg *alg = req->req->tfm->__crt_alg;
+    struct pc302crypt_alg *pc302_alg = to_pc302crypt_alg( alg );
+
+    ctx = crypto_tfm_ctx( tfm );
+
+    aead_req = container_of( req->req, struct aead_request, base );
+    /* If we have a non-supported key-length, then we need to do a
+     * software fallback. */
+    if ( ( ( pc302_alg->type & PC302_CRYPTO_ALG_MASK ) |
+           PC302_CRYPTO_BLOCK ) == PC302_CRYPTO_ALG_AES &&
+         ( &ipsec_engine == ctx->generic.engine ) &&
+         !( 16 == ctx->cipher_key_len || 32 == ctx->cipher_key_len ) )
+    {
+        return 1;
+    }
+
+    return 0;
+}
+
+/*!
+ * Perform a software fallback of an AEAD request.
+ *
+ * @param req The request to run.
+ * @param alg_type The algorithm type.
+ * @param dir The direction of the request. Must be either ENCRYPT or DECRYPT.
+ * @return Returns the success/failure status of the fallback operation.
+ */
+static int
+pc302crypt_aead_do_fallback( struct aead_request *req,
+                             unsigned alg_type,
+                             enum pc302crypt_direction dir )
+{
+    struct crypto_tfm *old_tfm = crypto_aead_tfm( crypto_aead_reqtfm( req ) );
+    struct pc302crypt_aead_ctx *ctx = crypto_tfm_ctx( old_tfm );
+    int err;
+
+    if ( ctx->sw_cipher )
+    {
+        /* Change the request to use the software fallback transform, and once
+         * the ciphering has completed, put the old transform back into the
+         * request.
+         */
+        aead_request_set_tfm( req, ctx->sw_cipher );
+        err = ( ENCRYPT == dir ) ? crypto_aead_encrypt( req ) :
+            crypto_aead_decrypt( req );
+        aead_request_set_tfm( req, __crypto_aead_cast( old_tfm ) );
+    }
+    else
+        err = -EINVAL;
+
+    return err;
+}
+
+/*!
+ * Submit an AEAD request to the crypto offload engine.
+ *
+ * @param req The request to submit.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302crypt_aead_submit( struct pc302crypt_req *req )
+{
+    struct crypto_tfm *tfm = req->req->tfm;
+    struct pc302crypt_aead_ctx *ctx = crypto_tfm_ctx( tfm );
+    struct aead_request *aead_req =
+        container_of( req->req, struct aead_request, base );
+    struct crypto_alg *alg = req->req->tfm->__crt_alg;
+    struct pc302crypt_alg *pc302_alg = to_pc302crypt_alg( alg );
+    struct pc302crypt_engine *engine = ctx->generic.engine;
+    unsigned proc_len;
+    unsigned assoc_len;
+    u32 ctrl;
+
+    req->result = -EINPROGRESS;
+    req->ctx_id = pc302crypt_load_ctx( &ctx->generic,
+                                       aead_req->iv,
+                                       alg->cra_aead.ivsize,
+                                       CTX_COMBINED );
+
+    pc302crypt_aead_make_ddts( req, req->giv, req->seq );
+
+    req->src_addr = engine->ddt_buf_phys +
+        ( req->ctx_id * sizeof( struct pc302crypt_engine_ctx ) ) +
+        offsetof( struct pc302crypt_engine_ctx, src_ddt );
+    req->dst_addr = engine->ddt_buf_phys +
+        ( req->ctx_id * sizeof( struct pc302crypt_engine_ctx ) ) +
+        offsetof( struct pc302crypt_engine_ctx, dst_ddt );
+
+    /* Set the source and destination DDT pointers. */
+    pc302crypt_reg_write( engine, SPA_SRC_PTR_REG_OFFSET,
+                          ( u32 )req->src_addr );
+    pc302crypt_reg_write( engine, SPA_DST_PTR_REG_OFFSET,
+                          ( u32 )req->dst_addr );
+    pc302crypt_reg_write( engine, SPA_OFFSET_REG_OFFSET, 0 );
+
+    assoc_len = aead_req->assoclen;
+    proc_len = aead_req->cryptlen + assoc_len;
+
+    /* If we aren't generating an IV, then we need to include the IV in the
+     * associated data so that it is included in the hash. */
+    if ( !req->giv )
+    {
+        assoc_len += crypto_aead_ivsize( crypto_aead_reqtfm( aead_req ) );
+        proc_len += crypto_aead_ivsize( crypto_aead_reqtfm( aead_req ) );
+    }
+    else
+        proc_len += req->giv_len;
+
+    /* If we are decrypting, we need to take the length of the ICV out of the
+     * processing length. */
+    if ( req->dir == DECRYPT )
+        proc_len -= ctx->auth_size;
+    
+    /* Set the total processing length. */
+    pc302crypt_reg_write( engine, SPA_PROC_LEN_REG_OFFSET, proc_len );
+    pc302crypt_reg_write( engine, SPA_AAD_LEN_REG_OFFSET, assoc_len );
+    pc302crypt_reg_write( engine, SPA_ICV_LEN_REG_OFFSET, ctx->auth_size );
+    pc302crypt_reg_write( engine, SPA_ICV_OFFSET_REG_OFFSET, 0 );
+    pc302crypt_reg_write( engine, SPA_AUX_INFO_REG_OFFSET, 0 );
+
+    /* Setup the control register. */
+    ctrl = 0;
+
+    switch ( ( pc302_alg->type & PC302_CRYPTO_BLOCK_MASK ) | PC302_CRYPTO_BLOCK )
+    {
+        case PC302_CRYPTO_ALG_DES:
+        case PC302_CRYPTO_ALG_3DES:
+            ctrl |= SPA_CTRL_CIPH_ALG_DES;
+            break;
+        case PC302_CRYPTO_ALG_AES:
+            ctrl |= SPA_CTRL_CIPH_ALG_AES;
+            break;
+        case PC302_CRYPTO_ALG_KASUMI:
+            ctrl |= SPA_CTRL_CIPH_ALG_KASUMI;
+            break;
+        default:
+            BUG();
+    }
+
+    switch ( ( pc302_alg->type & PC302_CRYPTO_HASH_MASK ) | PC302_CRYPTO_HASH )
+    {
+        case PC302_CRYPTO_ALG_SHA1:
+            ctrl |= SPA_CTRL_HASH_ALG_SHA;
+            ctrl |= SPA_CTRL_HASH_MODE_HMAC;
+            break;
+        case PC302_CRYPTO_ALG_SHA256:
+            ctrl |= SPA_CTRL_HASH_ALG_SHA256;
+            ctrl |= SPA_CTRL_HASH_MODE_HMAC;
+            break;
+        case PC302_CRYPTO_ALG_MD5:
+            ctrl |= SPA_CTRL_HASH_ALG_MD5;
+            ctrl |= SPA_CTRL_HASH_MODE_HMAC;
+            break;
+        default:
+            BUG();
+    }
+
+    switch ( pc302_alg->type & PC302_CRYPTO_ABLK_MODE_MASK )
+    {
+        case PC302_CRYPTO_ABLK_MODE_CBC:
+            ctrl |= SPA_CTRL_CIPH_MODE_CBC;
+            break;
+        case PC302_CRYPTO_ABLK_MODE_ECB:
+            ctrl |= SPA_CTRL_CIPH_MODE_ECB;
+            break;
+        case PC302_CRYPTO_ABLK_MODE_F8:
+            ctrl |= SPA_CTRL_CIPH_MODE_F8;
+            break;
+        default:
+            BUG();
+    }
+
+    /* Set the context page. */
+    ctrl |= ( ( req->ctx_id  << SPA_CTRL_CTX_IDX ) |
+              ( 1 << SPA_CTRL_ICV_APPEND ) |
+              ( ( ENCRYPT == req->dir ) ? ( 1 << SPA_CTRL_ENCRYPT_IDX ) : 0 ) |
+              ( ( ENCRYPT == req->dir ) ? ( 1 << SPA_CTRL_AAD_COPY ) : 0 ) );
+    if ( DECRYPT == req->dir )
+        ctrl |= ( 1 << SPA_CTRL_KEY_EXP );
+
+    /* Make sure all writes are finished before we start the operation. */
+    wmb();
+
+    /* If we are not over the IRQ threshold, then schedule a timeout. If we
+     * are over the threshold then we can simply delete the timer as we'll get
+     * an interrupt and reenable the timer when we pass below the threshold. */
+    if ( ++engine->in_flight < STAT_IRQ_THRESHOLD )
+    {
+        PRINTD( DBG_TRACE, "schedule timeout" );
+        mod_timer( &engine->packet_timeout, jiffies + PACKET_TIMEOUT );
+    }
+    else
+    {
+        PRINTD( DBG_TRACE, "over threshold, disable timer" );
+        del_timer( &engine->packet_timeout );
+    }
+
+    pc302crypt_reg_write( engine, SPA_CTRL_REG_OFFSET, ctrl );
+
+    return -EINPROGRESS;
+}
+
+/*!
+ * Setup an AEAD request for processing. This will configure the engine, load
+ * the context and then start the packet processing.
+ *
+ * @param req The request to process.
+ * @param giv Pointer to destination address for a generated IV. If the
+ * request does not need to generate an IV then this should be set to NULL.
+ * @param seq Sequence number for the request. Only valid if giv is not NULL.
+ * @param alg_type The algorithm type.
+ * @param dir The direction of the request. Must be ENCRYPT or DECRYPT.
+ * @return Returns -EINPROGRESS if the packet is queued for processing.
+ */
+static int
+pc302crypt_aead_setup( struct aead_request *req,
+                       u8 *giv,
+                       u64 seq,
+                       unsigned alg_type,
+                       enum pc302crypt_direction dir )
+{
+    struct crypto_alg *alg = req->base.tfm->__crt_alg;
+    struct pc302crypt_engine *engine = to_pc302crypt_alg( alg )->engine;
+    struct pc302crypt_req *dev_req = aead_request_ctx( req );
+    unsigned long flags;
+    int err = -EINPROGRESS;
+    unsigned ivsize = crypto_aead_ivsize( crypto_aead_reqtfm( req ) );
+
+    if ( !dev_req )
+        return -ENOMEM;
+
+    dev_req->giv = giv;
+    dev_req->giv_len = ivsize;
+    dev_req->seq = seq;
+
+    dev_req->req = &req->base;
+    dev_req->dir = dir;
+
+    dev_req->result = -EBUSY;
+
+    if ( unlikely( pc302crypt_aead_need_fallback( dev_req ) ) )
+    {
+        err = pc302crypt_aead_do_fallback( req, alg_type, dir );
+        pc302crypt_aead_kill_ddts( dev_req );
+        goto out;
+    }
+
+    spin_lock_irqsave( &engine->hw_lock, flags );
+    err = pc302crypt_queue_req( &engine->pending, dev_req );
+
+    /* If we were unable to put the request in because the transform can't
+     * backlog, then return early. */
+    if ( -EBUSY == err && !( req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG ) )
+    {
+        spin_unlock_irqrestore( &engine->hw_lock, flags );
+        goto out;
+    }
+    else if ( -EINPROGRESS == err )
+    {
+        err = pc302crypt_aead_submit( dev_req );
+    }
+    else
+    {
+        /* We have added the request to the queue so it is pending and
+         * effectively in progress. */
+        err = -EINPROGRESS;
+    }
+
+    spin_unlock_irqrestore( &engine->hw_lock, flags );
+
+out:
+    return err;
+}
+
+/*!
+ * Perform an encrypt request for an AEAD cipher.
+ *
+ * @param req The request to encrypt.
+ * @return Returns the success/failure status of the operation.
+ */
+static int
+pc302crypt_aead_encrypt( struct aead_request *req )
+{
+    struct crypto_aead *aead = crypto_aead_reqtfm( req );
+    struct crypto_tfm *tfm = crypto_aead_tfm( aead );
+    struct pc302crypt_alg *alg = to_pc302crypt_alg( tfm->__crt_alg );
+
+    return pc302crypt_aead_setup( req, NULL, 0, alg->type, ENCRYPT );
+}
+
+/*!
+ * Perform a givencrypt request for an AEAD cipher.
+ *
+ * @param req The request to encrypt.
+ * @return Returns the success/failure status of the operation.
+ */
+static int
+pc302crypt_aead_givencrypt( struct aead_givcrypt_request *req )
+{
+    struct crypto_aead *tfm = aead_givcrypt_reqtfm( req );
+    struct pc302crypt_aead_ctx *ctx = crypto_aead_ctx( tfm );
+    size_t ivsize = crypto_aead_ivsize( tfm );
+    struct pc302crypt_alg *alg = to_pc302crypt_alg( tfm->base.__crt_alg );
+    unsigned len;
+    __be64 seq;
+
+    memcpy( req->areq.iv, ctx->salt, ivsize );
+    len = ivsize;
+    if ( ivsize > sizeof( u64 ) )
+    {
+        memset( req->giv, 0, ivsize - sizeof( u64 ) );
+        len = sizeof( u64 );
+    }
+    seq = cpu_to_be64( req->seq );
+    memcpy( req->giv + ivsize - len, &seq, len );
+
+    return pc302crypt_aead_setup( &req->areq, req->giv, ivsize, alg->type,
+                                  ENCRYPT );
+}
+
+/*!
+ * Perform a decrypt request for an AEAD cipher.
+ *
+ * @param req The request to decrypt.
+ * @return Returns the success/failure status of the operation.
+ */
+static int
+pc302crypt_aead_decrypt( struct aead_request *req )
+{
+    struct crypto_aead *aead = crypto_aead_reqtfm( req );
+    struct crypto_tfm *tfm = crypto_aead_tfm( aead );
+    struct pc302crypt_alg *alg = to_pc302crypt_alg( tfm->__crt_alg );
+
+    return pc302crypt_aead_setup( req, NULL, 0, alg->type, DECRYPT );
+}
+
+/*!
+ * Initialise a new AEAD context. This is responsible for allocating the
+ * fallback cipher and initialising the context.
+ *
+ * @param tfm The transform to create the context for.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302crypt_aead_cra_init( struct crypto_tfm *tfm )
+{
+    struct pc302crypt_aead_ctx *ctx = crypto_tfm_ctx( tfm );
+    struct crypto_alg *alg = tfm->__crt_alg;
+    struct pc302crypt_alg *pc302_alg = to_pc302crypt_alg( alg );
+    struct pc302crypt_engine *engine = pc302_alg->engine;
+
+    ctx->generic.flags = pc302_alg->type;
+    ctx->generic.engine = engine;
+    ctx->sw_cipher =
+        crypto_alloc_aead( alg->cra_name, 0,
+                           CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK );
+    if ( IS_ERR( ctx->sw_cipher ) )
+    {
+        PRINTD( DBG_WARN, "failed to allocate fallback for %s",
+                alg->cra_name );
+        ctx->sw_cipher = NULL;
+    }
+
+    get_random_bytes( ctx->salt, sizeof( ctx->salt ) );
+
+    tfm->crt_aead.reqsize = sizeof( struct pc302crypt_req );
+
+    return 0;
+}
+
+/*!
+ * Destructor for an AEAD context. This is called when the transform is freed
+ * and must free the fallback cipher.
+ *
+ * @param tfm The transform being freed.
+ */
+static void
+pc302crypt_aead_cra_exit( struct crypto_tfm *tfm )
+{
+    struct pc302crypt_aead_ctx *ctx = crypto_tfm_ctx(tfm);
+
+    if ( ctx->sw_cipher )
+        crypto_free_aead( ctx->sw_cipher );
+    ctx->sw_cipher = NULL;
+}
+
+/*!
+ * Set the DES key for a block cipher transform. This also performs weak key
+ * checking if the transform has requested it.
+ *
+ * @param cipher The transform to set the key of.
+ * @param key The key to set.
+ * @param len The length of the key in bytes.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302crypt_des_setkey( struct crypto_ablkcipher *cipher,
+                       const u8 *key,
+                       unsigned int len )
+{
+    struct crypto_tfm *tfm = crypto_ablkcipher_tfm( cipher );
+    struct pc302crypt_ablk_ctx *ctx = crypto_tfm_ctx( tfm );
+    int err = 0;
+    u32 tmp[ DES_EXPKEY_WORDS ];
+
+    err = des_ekey( tmp, key );
+    if ( unlikely( !err ) &&
+            ( crypto_ablkcipher_get_flags( cipher ) &
+              CRYPTO_TFM_REQ_WEAK_KEY ) )
+    {
+        tfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;
+        return -EINVAL;
+    }
+    err = 0;
+
+    memcpy( ctx->key, key, len );
+    ctx->key_len = len;
+
+    return err;
+}
+
+/*!
+ * Set the key for an AES block cipher. Some key lengths are not supported in
+ * hardware so this must also check whether a fallback is needed.
+ *
+ * @param cipher The transform to set the key for.
+ * @param key The key to set.
+ * @param len The length of the key in bytes.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302crypt_aes_setkey( struct crypto_ablkcipher *cipher,
+                       const u8 *key,
+                       unsigned int len )
+{
+    struct crypto_tfm *tfm = crypto_ablkcipher_tfm( cipher );
+    struct pc302crypt_ablk_ctx *ctx = crypto_tfm_ctx( tfm );
+    int err = 0;
+
+    /* IPSec engine only supports 128 and 256 bit AES keys. If we get a
+     * request for any other size (192 bits) then we need to do a software
+     * fallback. */
+    if ( !( 16 == len || 32 == len ) && ctx->sw_cipher )
+    {
+        /* Set the fallback transform to use the same request flags as the
+         * hardware transform. */
+        ctx->sw_cipher->base.crt_flags &= ~CRYPTO_TFM_REQ_MASK;
+        ctx->sw_cipher->base.crt_flags |=
+            ( cipher->base.crt_flags & CRYPTO_TFM_REQ_MASK );
+
+        err = crypto_ablkcipher_setkey( ctx->sw_cipher, key, len );
+        if ( err )
+            goto sw_setkey_failed;
+    }
+    else if ( !( 16 == len || 32 == len ) && !ctx->sw_cipher )
+        err = -EINVAL;
+
+    memcpy( ctx->key, key, len );
+    ctx->key_len = len;
+
+sw_setkey_failed:
+    return err;
+}
+
+/*!
+ * Set the key for a Kasumi F8 block cipher.
+ *
+ * @param cipher The transform to set the key for.
+ * @param key The key to set.
+ * @param len The length of the key in bytes.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302crypt_kasumi_f8_setkey( struct crypto_ablkcipher *cipher,
+                             const u8 *key,
+                             unsigned int len )
+{
+    struct crypto_tfm *tfm = crypto_ablkcipher_tfm( cipher );
+    struct pc302crypt_ablk_ctx *ctx = crypto_tfm_ctx( tfm );
+
+    memcpy( ctx->key, key, len );
+    ctx->key_len = len;
+
+    return 0;
+}
+
+/*!
+ * Set the key for a block cipher transform.
+ *
+ * @param cipher The transform to set the key for.
+ * @param key The key to set.
+ * @param len The length of the key in bytes.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302crypt_ablk_setkey( struct crypto_ablkcipher *cipher,
+                        const u8 *key,
+                        unsigned int len )
+{
+    struct crypto_tfm *tfm = crypto_ablkcipher_tfm( cipher );
+    struct pc302crypt_ablk_ctx *ctx = crypto_tfm_ctx( tfm );
+    struct pc302crypt_alg *alg = to_pc302crypt_alg( tfm->__crt_alg );
+    int err = 0;
+
+    if ( len > PC302_CRYPTO_AES_MAX_KEY_LEN )
+    {
+        crypto_ablkcipher_set_flags( cipher, CRYPTO_TFM_RES_BAD_KEY_LEN );
+        err = -EINVAL;
+        goto bad_key_len;
+    }
+
+    switch ( ( alg->type & PC302_CRYPTO_BLOCK_MASK ) | PC302_CRYPTO_BLOCK )
+    {
+        case PC302_CRYPTO_ALG_AES:
+            err = pc302crypt_aes_setkey( cipher, key, len );
+            break;
+
+        case PC302_CRYPTO_ALG_3DES:
+        case PC302_CRYPTO_ALG_DES:
+            err = pc302crypt_des_setkey( cipher, key, len );
+            break;
+
+        case PC302_CRYPTO_ALG_KASUMI:
+            err = pc302crypt_kasumi_f8_setkey( cipher, key, len );
+            break;
+
+        default:
+            BUG();
+            break;
+    }
+
+    if ( err )
+        goto out;
+
+    if ( ctx->sw_cipher )
+    {
+        /* Set the fallback transform to use the same request flags as the
+         * hardware transform. */
+        ctx->sw_cipher->base.crt_flags &= ~CRYPTO_TFM_REQ_MASK;
+        ctx->sw_cipher->base.crt_flags |=
+            ( cipher->base.crt_flags & CRYPTO_TFM_REQ_MASK );
+
+        err = crypto_ablkcipher_setkey( ctx->sw_cipher, key, len );
+        if ( err )
+            goto sw_setkey_failed;
+    }
+
+    return err;
+
+bad_key_len:
+    PRINTD( DBG_WARN, "bad key length (%u)", len );
+    return err;
+
+sw_setkey_failed:
+    PRINTD( DBG_WARN, "failed to set key for fallback cipher (%d)", err );
+    tfm->crt_flags &= ~CRYPTO_TFM_RES_MASK;
+    tfm->crt_flags |= ( ctx->sw_cipher->base.crt_flags & CRYPTO_TFM_RES_MASK );
+out:
+    return err;
+}
+
+static int
+pc302crypt_ablk_need_fallback( struct pc302crypt_req *req )
+{
+    struct ablkcipher_request *ablk_req;
+    struct pc302crypt_ablk_ctx *ctx;
+    struct crypto_tfm *tfm = req->req->tfm;
+    struct crypto_alg *alg = req->req->tfm->__crt_alg;
+    struct pc302crypt_alg *pc302_alg = to_pc302crypt_alg( alg );
+
+    ctx = crypto_tfm_ctx( tfm );
+
+    ablk_req = ablkcipher_request_cast( req->req );
+    /* If we have a non-supported key-length, then we need to do a software
+     * fallback. */
+    if ( ( ( pc302_alg->type & PC302_CRYPTO_ALG_MASK ) |
+                PC302_CRYPTO_BLOCK ) == PC302_CRYPTO_ALG_AES &&
+            ( &ipsec_engine == ctx->generic.engine ) &&
+            !( 16 == ctx->key_len || 32 == ctx->key_len ) )
+    {
+        return 1;
+    }
+
+    return 0;
+}
+
+static int
+pc302crypt_ablk_submit( struct pc302crypt_req *req )
+{
+    struct crypto_tfm *tfm = req->req->tfm;
+    struct pc302crypt_ablk_ctx *ctx = crypto_tfm_ctx( tfm );
+    struct ablkcipher_request *ablk_req = ablkcipher_request_cast( req->req );
+    struct crypto_alg *alg = req->req->tfm->__crt_alg;
+    struct pc302crypt_alg *pc302_alg = to_pc302crypt_alg( alg );
+    struct pc302crypt_engine *engine = ctx->generic.engine;
+    u32 ctrl;
+
+    req->result = -EINPROGRESS;
+    req->ctx_id = pc302crypt_load_ctx( &ctx->generic, ablk_req->info,
+                                       alg->cra_ablkcipher.ivsize,
+                                       CTX_CIPHER );
+
+    if ( !pc302crypt_sg_to_ddt( req, ablk_req->src, ablk_req->nbytes,
+                               DMA_TO_DEVICE ) )
+        return -ENOMEM;
+    if ( !pc302crypt_sg_to_ddt( req, ablk_req->dst, ablk_req->nbytes,
+                                DMA_FROM_DEVICE ) )
+        return -ENOMEM;
+
+    req->src_addr = engine->ddt_buf_phys +
+        ( req->ctx_id * sizeof( struct pc302crypt_engine_ctx ) ) +
+        offsetof( struct pc302crypt_engine_ctx, src_ddt );
+    req->dst_addr = engine->ddt_buf_phys +
+        ( req->ctx_id * sizeof( struct pc302crypt_engine_ctx ) ) +
+        offsetof( struct pc302crypt_engine_ctx, dst_ddt );
+
+    /* Set the source and destination DDT pointers. */
+    pc302crypt_reg_write( engine, SPA_SRC_PTR_REG_OFFSET,
+                          ( u32 )req->src_addr );
+    pc302crypt_reg_write( engine, SPA_DST_PTR_REG_OFFSET,
+                          ( u32 )req->dst_addr );
+    pc302crypt_reg_write( engine, SPA_OFFSET_REG_OFFSET, 0 );
+
+    /* Set the total processing length. */
+    pc302crypt_reg_write( engine, SPA_PROC_LEN_REG_OFFSET,
+                          ablk_req->nbytes );
+    pc302crypt_reg_write( engine, SPA_ICV_OFFSET_REG_OFFSET, 0 );
+    pc302crypt_reg_write( engine, SPA_AUX_INFO_REG_OFFSET, 0 );
+    pc302crypt_reg_write( engine, SPA_AAD_LEN_REG_OFFSET, 0 );
+
+    /* Setup the control register. */
+    ctrl = 0;
+
+    switch ( ( pc302_alg->type & PC302_CRYPTO_BLOCK_MASK ) | PC302_CRYPTO_BLOCK )
+    {
+        case PC302_CRYPTO_ALG_DES:
+        case PC302_CRYPTO_ALG_3DES:
+            ctrl |= SPA_CTRL_CIPH_ALG_DES;
+            break;
+        case PC302_CRYPTO_ALG_AES:
+            ctrl |= SPA_CTRL_CIPH_ALG_AES;
+            break;
+        case PC302_CRYPTO_ALG_KASUMI:
+            ctrl |= SPA_CTRL_CIPH_ALG_KASUMI;
+            break;
+        default:
+            BUG();
+    }
+
+    switch ( pc302_alg->type & PC302_CRYPTO_ABLK_MODE_MASK )
+    {
+        case PC302_CRYPTO_ABLK_MODE_CBC:
+            ctrl |= SPA_CTRL_CIPH_MODE_CBC;
+            break;
+        case PC302_CRYPTO_ABLK_MODE_ECB:
+            ctrl |= SPA_CTRL_CIPH_MODE_ECB;
+            break;
+        case PC302_CRYPTO_ABLK_MODE_F8:
+            ctrl |= SPA_CTRL_CIPH_MODE_F8;
+            break;
+        default:
+            BUG();
+    }
+
+    /* Set the context page. */
+    ctrl |= ( req->ctx_id ) << SPA_CTRL_CTX_IDX;
+    ctrl |= ( ENCRYPT == req->dir ) ? ( 1 << SPA_CTRL_ENCRYPT_IDX ) : 0;
+    if ( DECRYPT == req->dir )
+        ctrl |= ( 1 << SPA_CTRL_KEY_EXP );
+
+    /* Make sure all writes are finished before we start the operation. */
+    wmb();
+
+    /* If we are not over the IRQ threshold, then schedule a timeout. If we
+     * are over the threshold then we can simply delete the timer as we'll get
+     * an interrupt and reenable the timer when we pass below the threshold. */
+    if ( ++engine->in_flight < STAT_IRQ_THRESHOLD )
+    {
+        PRINTD( DBG_TRACE, "schedule timeout" );
+        mod_timer( &engine->packet_timeout, jiffies + PACKET_TIMEOUT );
+    }
+    else
+    {
+        PRINTD( DBG_TRACE, "over threshold, disable timer" );
+        del_timer( &engine->packet_timeout );
+    }
+
+    pc302crypt_reg_write( engine, SPA_CTRL_REG_OFFSET, ctrl );
+
+    return -EINPROGRESS;
+}
+
+static int
+pc302crypt_ablk_do_fallback( struct ablkcipher_request *req,
+                             unsigned alg_type,
+                             enum pc302crypt_direction dir )
+{
+    struct crypto_tfm *old_tfm =
+        crypto_ablkcipher_tfm( crypto_ablkcipher_reqtfm( req ) );
+    struct pc302crypt_ablk_ctx *ctx = crypto_tfm_ctx( old_tfm );
+    int err;
+
+    /* Change the request to use the software fallback transform, and once the
+     * ciphering has completed, put the old transform back into the request.
+     */
+    if ( ctx->sw_cipher )
+    {
+        ablkcipher_request_set_tfm( req, ctx->sw_cipher );
+        err = ( ENCRYPT == dir ) ? crypto_ablkcipher_encrypt( req ) :
+            crypto_ablkcipher_decrypt( req );
+        ablkcipher_request_set_tfm( req, __crypto_ablkcipher_cast( old_tfm ) );
+    }
+    else
+        err = -EINVAL;
+
+    return err;
+}
+
+static int
+pc302crypt_ablk_setup( struct ablkcipher_request *req,
+                       unsigned alg_type,
+                       enum pc302crypt_direction dir )
+{
+    struct crypto_alg *alg = req->base.tfm->__crt_alg;
+    struct pc302crypt_engine *engine = to_pc302crypt_alg( alg )->engine;
+    struct pc302crypt_req *dev_req = ablkcipher_request_ctx( req );
+    unsigned long flags;
+    int err = -EINPROGRESS;
+
+    if ( !dev_req )
+        return -ENOMEM;
+
+    dev_req->req = &req->base;
+    dev_req->result = -EBUSY;
+    dev_req->dir = dir;
+
+    if ( pc302crypt_ablk_need_fallback( dev_req ) )
+    {
+        err = pc302crypt_ablk_do_fallback( req, alg_type, dir );
+        pc302crypt_free_ddt( dev_req, req->src,
+                             req->nbytes, DMA_TO_DEVICE );
+        pc302crypt_free_ddt( dev_req, req->dst,
+                             req->nbytes, DMA_FROM_DEVICE );
+        goto out;
+    }
+
+    spin_lock_irqsave( &engine->hw_lock, flags );
+    err = pc302crypt_queue_req( &engine->pending, dev_req );
+
+    /* If we were unable to put the request in because the transform can't
+     * backlog, then return early. */
+    if ( -EBUSY == err && !( req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG ) )
+    {
+        spin_unlock_irqrestore( &engine->hw_lock, flags );
+        goto out;
+    }
+    else if ( -EINPROGRESS == err )
+    {
+        err = pc302crypt_ablk_submit( dev_req );
+    }
+    else
+    {
+        /* We have added the request to the queue so it is pending and
+         * effectively in progress. */
+        err = -EINPROGRESS;
+    }
+
+    spin_unlock_irqrestore( &engine->hw_lock, flags );
+out:
+    return err;
+}
+
+static int
+pc302crypt_ablk_cra_init( struct crypto_tfm *tfm )
+{
+    struct pc302crypt_ablk_ctx *ctx = crypto_tfm_ctx( tfm );
+    struct crypto_alg *alg = tfm->__crt_alg;
+    struct pc302crypt_alg *pc302_alg = to_pc302crypt_alg( alg );
+    struct pc302crypt_engine *engine = pc302_alg->engine;
+
+    ctx->generic.flags = pc302_alg->type;
+    ctx->generic.engine = engine;
+    if ( alg->cra_flags & CRYPTO_ALG_NEED_FALLBACK )
+    {
+        ctx->sw_cipher =
+            crypto_alloc_ablkcipher( alg->cra_name, 0,
+                                     CRYPTO_ALG_ASYNC |
+                                     CRYPTO_ALG_NEED_FALLBACK );
+        if ( IS_ERR( ctx->sw_cipher ) )
+        {
+            PRINTD( DBG_WARN, "failed to allocate fallback for %s",
+                    alg->cra_name );
+            ctx->sw_cipher = NULL;
+        }
+    }
+
+    tfm->crt_ablkcipher.reqsize = sizeof( struct pc302crypt_req );
+
+    return 0;
+}
+
+static void
+pc302crypt_ablk_cra_exit( struct crypto_tfm *tfm )
+{
+    struct pc302crypt_ablk_ctx *ctx = crypto_tfm_ctx(tfm);
+
+    if ( ctx->sw_cipher )
+        crypto_free_ablkcipher( ctx->sw_cipher );
+    ctx->sw_cipher = NULL;
+}
+
+/*
+ * Given a struct crypto_alg, find the pc302crypt_alg entry.
+ *
+ * \param alg The algorithm search for.
+ * \return Returns the pc302 representation on success, NULL on failure.
+ */
+static inline struct pc302crypt_alg *
+to_pc302crypt_alg( struct crypto_alg *alg )
+{
+    return alg ? container_of( alg, struct pc302crypt_alg, alg ) : NULL;
+}
+
+static int
+pc302crypt_ablk_encrypt( struct ablkcipher_request *req )
+{
+    struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm( req );
+    struct crypto_tfm *tfm = crypto_ablkcipher_tfm( cipher );
+    struct pc302crypt_alg *alg = to_pc302crypt_alg( tfm->__crt_alg );
+
+    return pc302crypt_ablk_setup( req, alg->type, ENCRYPT );
+}
+
+static int
+pc302crypt_ablk_decrypt( struct ablkcipher_request *req )
+{
+    struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm( req );
+    struct crypto_tfm *tfm = crypto_ablkcipher_tfm( cipher );
+    struct pc302crypt_alg *alg = to_pc302crypt_alg( tfm->__crt_alg );
+
+    return pc302crypt_ablk_setup( req, alg->type, DECRYPT );
+}
+
+static int
+pc302crypt_fifo_stat_empty( struct pc302crypt_engine *engine )
+{
+    u32 fifo_stat = pc302crypt_reg_read( engine, SPA_FIFO_STAT_REG_OFFSET );
+
+    return !!( fifo_stat & SPA_FIFO_STAT_EMPTY );
+}
+
+static int
+pc302crypt_fifo_cmd_full( struct pc302crypt_engine *engine )
+{
+    u32 fifo_stat = pc302crypt_reg_read( engine, SPA_FIFO_STAT_REG_OFFSET );
+
+    return !!( fifo_stat & SPA_FIFO_CMD_FULL );
+}
+
+static void
+pc302crypt_process_done( struct pc302crypt_engine *engine )
+{
+    struct pc302crypt_req *req;
+    struct pc302crypt_ablk_ctx *ablk_ctx;
+    struct pc302crypt_aead_ctx *aead_ctx;
+    struct pc302crypt_generic_ctx *generic_ctx = NULL;
+    int err;
+    unsigned long flags;
+
+    spin_lock_irqsave( &engine->hw_lock, flags );
+
+    while ( !pc302crypt_fifo_stat_empty( engine ) )
+    {
+        req = pc302crypt_dequeue_req( &engine->pending );
+        BUG_ON( !req );
+
+        err = pc302crypt_queue_req_force( &engine->completed, req );
+
+        /* POP the status register. */
+        pc302crypt_reg_write( engine, SPA_STAT_POP_REG_OFFSET, ~0 );
+        wmb();
+
+        /* Read the status of the operation. */
+        req->result = ( pc302crypt_reg_read( engine, SPA_STATUS_REG_OFFSET ) &
+            SPA_STATUS_RES_CODE_MASK ) >> SPA_STATUS_RES_CODE_OFFSET;
+
+        /* Convert the SPAcc error status into the standard POSIX error
+         * codes. */
+        switch ( req->result )
+        {
+            case SPA_STATUS_OK:
+                req->result = 0;
+                break;
+
+            case SPA_STATUS_ICV_FAIL:
+                req->result = -EBADMSG;
+                break;
+
+            case SPA_STATUS_MEMORY_ERROR:
+                PRINTD( DBG_WARN, "memory error triggered" );
+                req->result = -EFAULT;
+                break;
+
+            case SPA_STATUS_BLOCK_ERROR:
+                PRINTD( DBG_WARN, "block error triggered" );
+                req->result = -EIO;
+                break;
+
+            default:
+                BUG();
+        }
+
+        switch ( crypto_tfm_alg_type( req->req->tfm ) )
+        {
+            case CRYPTO_ALG_TYPE_BLKCIPHER:
+            case CRYPTO_ALG_TYPE_ABLKCIPHER:
+            case CRYPTO_ALG_TYPE_GIVCIPHER:
+                ablk_ctx = crypto_tfm_ctx( req->req->tfm );
+                generic_ctx = &ablk_ctx->generic;
+                break;
+
+            case CRYPTO_ALG_TYPE_AEAD:
+                aead_ctx = crypto_tfm_ctx( req->req->tfm );
+                generic_ctx = &aead_ctx->generic;
+                break;
+
+            default:
+                WARN( 1, "invalid transform type completed (%d)\n",
+                      crypto_tfm_alg_type( req->req->tfm ) );
+                break;
+        }
+
+        if ( likely( generic_ctx ) )
+            pc302crypt_unload_ctx( generic_ctx, req->ctx_id );
+    }
+
+    spin_unlock_irqrestore( &engine->hw_lock, flags );
+
+    tasklet_schedule( &engine->complete );
+}
+
+static irqreturn_t
+pc302crypt_spacc_irq( int irq,
+                      void *dev )
+{
+    struct pc302crypt_engine *engine = ( struct pc302crypt_engine * )dev;
+    u32 irq_stat = pc302crypt_reg_read( engine, SPA_IRQ_STAT_REG_OFFSET );
+
+    /* Clear the interrupts. */
+    pc302crypt_reg_write( engine, SPA_IRQ_STAT_REG_OFFSET, irq_stat );
+
+    /* Process the completed packets. */
+    pc302crypt_process_done( engine );
+
+    return IRQ_HANDLED;
+}
+
+static void
+pc302crypt_packet_timeout( unsigned long data )
+{
+    struct pc302crypt_engine *engine = ( struct pc302crypt_engine * )data;
+
+    PRINTD( DBG_TRACE, "packet timeout, %u in flight", engine->in_flight );
+    pc302crypt_process_done( engine );
+}
+
+static int
+pc302crypt_req_submit( struct pc302crypt_req *req )
+{
+    struct crypto_alg *alg = req->req->tfm->__crt_alg;
+
+    if ( CRYPTO_ALG_TYPE_AEAD & alg->cra_flags )
+        return pc302crypt_aead_submit( req );
+    else if ( CRYPTO_ALG_TYPE_ABLKCIPHER & alg->cra_flags ||
+              CRYPTO_ALG_TYPE_GIVCIPHER & alg->cra_flags )
+        return pc302crypt_ablk_submit( req );
+
+    BUG();
+}
+
+static void
+pc302crypt_spacc_complete( unsigned long data )
+{
+    struct pc302crypt_engine *engine = ( struct pc302crypt_engine * )data;
+    struct pc302crypt_req *req;
+    struct ablkcipher_request *ablk_req;
+    struct aead_request *aead_req;
+    struct pc302crypt_alg *alg;
+    struct list_head *l;
+    unsigned long flags;
+
+    for (;;)
+    {
+        spin_lock_irqsave( &engine->hw_lock, flags );
+        req = pc302crypt_dequeue_req( &engine->completed );
+        spin_unlock_irqrestore( &engine->hw_lock, flags );
+
+        if ( !req )
+            break;
+
+        alg = to_pc302crypt_alg( req->req->tfm->__crt_alg );
+        switch ( alg->type & PC302_CRYPTO_TYPE_MASK )
+        {
+            case PC302_CRYPTO_BLOCK:
+                ablk_req =
+                    container_of( req->req, struct ablkcipher_request, base );
+
+                pc302crypt_free_ddt( req, ablk_req->src,
+                                     ablk_req->nbytes, DMA_TO_DEVICE );
+                pc302crypt_free_ddt( req, ablk_req->dst,
+                                     ablk_req->nbytes, DMA_FROM_DEVICE );
+                break;
+
+            case PC302_CRYPTO_COMBINED:
+                aead_req =
+                    container_of( req->req, struct aead_request, base );
+
+                pc302crypt_aead_kill_ddts( req );
+                break;
+
+            default:
+                BUG();
+        }
+
+        if ( req->req->complete )
+            req->req->complete( req->req, req->result );
+
+        --engine->in_flight;
+
+        /* If we have no remaining packets then we can stop the timer. */
+        if ( !engine->in_flight )
+        {
+            PRINTD( DBG_TRACE, "no packets remaining. del timer" );
+            del_timer( &engine->packet_timeout );
+        }
+    }
+
+    /*
+     * Need to iterate over the pending queue starting from the HEAD and skip
+     * over the requests that have the result field set to -EINPROGRESS and
+     * then submit num_completed requests to the hardware.
+     */
+    spin_lock_irqsave( &engine->hw_lock, flags );
+    list_for_each( l, &engine->pending.list )
+    {
+        if ( pc302crypt_fifo_cmd_full( engine ) )
+            break;
+
+        req = container_of( l, struct pc302crypt_req, list );
+
+        if ( -EINPROGRESS == req->result )
+            continue;
+        else if ( -EBUSY == req->result )
+            req->result = pc302crypt_req_submit( req );
+    }
+
+    /* If we have less packets in flight than the threshold, kick the
+     * timer. */
+    if ( engine->in_flight && engine->in_flight < STAT_IRQ_THRESHOLD )
+    {
+        PRINTD( DBG_TRACE, "below threshold, kick timer" );
+        mod_timer( &engine->packet_timeout, jiffies + PACKET_TIMEOUT );
+    }
+
+    spin_unlock_irqrestore( &engine->hw_lock, flags );
+}
+
+static void
+pc302crypt_release_and_unmap( struct resource *resource,
+                              void __iomem *iomem )
+{
+    unsigned long size = resource->end - resource->start + 1;
+    iounmap( iomem );
+    release_mem_region( resource->start, size );
+}
+
+static void __iomem *
+pc302crypt_request_and_map( struct resource *resource,
+                            const char *name )
+{
+    unsigned long size = resource->end - resource->start + 1;
+    void __iomem *ret;
+
+    struct resource *req = request_mem_region( resource->start, size, name );
+
+    if ( !req )
+        goto req_fail;
+
+    ret = ioremap( req->start, size );
+    if ( !ret )
+    {
+        printk( KERN_INFO "pc302crypt: ioremap failed\n" );
+        goto remap_failed;
+    }
+
+    return ret;
+
+remap_failed:
+    release_resource( req );
+
+req_fail:
+
+    return NULL;
+}
+
+static int
+spacc_probe( struct platform_device *pdev )
+{
+    int err;
+    int ret = -EINVAL;
+    unsigned i;
+    struct pc302crypt_alg *alg;
+    struct pc302crypt_alg *next;
+    struct resource *mem_resource =
+        platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+    struct resource *irq =
+        platform_get_resource( pdev, IORESOURCE_IRQ, 0 );
+    struct pc302crypt_engine *engine;
+
+    if ( !strcmp( "ipsec_engine", pdev->name ) )
+        engine = &ipsec_engine;
+    else if ( !strcmp( "l2_engine", pdev->name ) )
+        engine = &l2_engine;
+    else
+    {
+        printk( KERN_INFO "invalid SPAcc engine (%s)\n", pdev->name );
+        return -EINVAL;
+    }
+
+    if ( !mem_resource )
+    {
+        printk( KERN_INFO
+                "pc302crypt: no memory resource for engine\n" );
+        goto out;
+    }
+
+    engine->dev = &pdev->dev;
+
+    engine->regs =
+        pc302crypt_request_and_map( mem_resource, engine->name );
+    if ( !engine->regs )
+    {
+        printk( KERN_INFO "pc302crypt: memory map failed\n" );
+        goto map_fail;
+    }
+    engine->cipher_ctx_base =
+        engine->regs + SPA_CIPH_KEY_BASE_REG_OFFSET;
+    engine->hash_key_base =
+        engine->regs + SPA_HASH_KEY_BASE_REG_OFFSET;
+
+    ret = request_irq( irq->start, pc302crypt_spacc_irq, 0, engine->name,
+                       engine );
+    if ( ret )
+    {
+        PRINTD( DBG_ERROR, "failed to request IRQ\n" );
+        goto irq_fail;
+    }
+
+    /* Register all of the algorithms that we support with the crypto
+     * subsystem. */
+    INIT_LIST_HEAD( &engine->registered_algs );
+    for ( i = 0; i < engine->num_algs; ++i )
+    {
+        engine->algs[ i ].engine = engine;
+        err = crypto_register_alg( &engine->algs[ i ].alg );
+        if ( !err )
+        {
+            list_add_tail( &engine->algs[ i ].entry,
+                           &engine->registered_algs );
+            /* If we add at least one algorithm then we consider this as a
+             * success. */
+            ret = 0;
+        }
+        PRINTD( ( !err ? DBG_TRACE : DBG_WARN ), "%s alg \"%s\"",
+                ( !err ) ? "registered" : "failed to register",
+                engine->algs[ i ].alg.cra_name );
+    }
+
+    if ( !ret )
+    {
+        pc302crypt_queue_init( &engine->pending, engine->fifo_sz );
+        pc302crypt_queue_init( &engine->completed, 1 );
+        tasklet_init( &engine->complete, pc302crypt_spacc_complete,
+                      ( unsigned long )engine );
+    }
+
+    /* Configure the interrupts. We only use the STAT_CNT interrupt as we only
+     * submit a new packet for processing when we complete another in the
+     * queue. This minimizes time spent in the interrupt handler. */
+    pc302crypt_reg_write( engine, SPA_IRQ_CTRL_REG_OFFSET,
+                          STAT_IRQ_THRESHOLD << SPA_IRQ_CTRL_STAT_CNT_OFFSET );
+    pc302crypt_reg_write( engine, SPA_IRQ_EN_REG_OFFSET,
+                          SPA_IRQ_EN_STAT_EN | SPA_IRQ_EN_GLBL_EN );
+
+    setup_timer( &engine->packet_timeout, pc302crypt_packet_timeout,
+                 ( unsigned long )engine );
+
+    engine->ddt_buf = dma_alloc_coherent( engine->dev, engine->max_ctxs *
+            sizeof( struct pc302crypt_engine_ctx ), &engine->ddt_buf_phys,
+            GFP_KERNEL );
+    if ( !engine->ddt_buf )
+    {
+        ret = -ENOMEM;
+        goto ddt_failed;
+    }
+
+    return ret;
+
+ddt_failed:
+    del_timer( &engine->packet_timeout );
+
+    list_for_each_entry_safe( alg, next, &engine->registered_algs,
+                              entry )
+    {
+        list_del( &alg->entry );
+        crypto_unregister_alg( &alg->alg );
+    }
+
+map_fail:
+irq_fail:
+out:
+
+    return ret;
+}
+
+static int
+spacc_remove( struct platform_device *pdev )
+{
+    struct pc302crypt_alg *alg;
+    struct pc302crypt_alg *next;
+    struct resource *mem_resource =
+        platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+    struct resource *irq =
+        platform_get_resource( pdev, IORESOURCE_IRQ, 0 );
+    struct pc302crypt_engine *engine = NULL;
+
+    if ( !strcmp( "ipsec_engine", pdev->name ) )
+        engine = &ipsec_engine;
+    else if ( !strcmp( "l2_engine", pdev->name ) )
+        engine = &l2_engine;
+
+    BUG_ON( !engine );
+    BUG_ON( !mem_resource );
+
+    del_timer( &engine->packet_timeout );
+
+    pc302crypt_release_and_unmap( mem_resource, engine->regs );
+    free_irq( irq->start, engine );
+
+    dma_free_coherent( engine->dev, engine->max_ctxs *
+            sizeof( struct pc302crypt_engine_ctx ), engine->ddt_buf,
+            engine->ddt_buf_phys );
+
+    list_for_each_entry_safe( alg, next, &engine->registered_algs,
+                              entry )
+    {
+        list_del( &alg->entry );
+        crypto_unregister_alg( &alg->alg );
+    }
+
+    return 0;
+}
+
+static struct platform_driver ipsec_driver = {
+    .probe  = spacc_probe,
+    .remove = spacc_remove,
+    .driver = {
+        .name = "ipsec_engine",
+    },
+};
+
+static struct platform_driver l2_driver = {
+    .probe  = spacc_probe,
+    .remove = spacc_remove,
+    .driver = {
+        .name = "l2_engine",
+    },
+};
+
+static int
+pc302crypt_init( void )
+{
+    int ret = platform_driver_register( &ipsec_driver );
+    if ( ret )
+    {
+        PRINTD( DBG_ERROR, "failed to register platform driver" );
+        goto out;
+    }
+
+    ret = platform_driver_register( &l2_driver );
+    if ( ret )
+    {
+        PRINTD( DBG_ERROR, "failed to register platform driver" );
+        goto l2_failed;
+    }
+
+    goto out;
+
+l2_failed:
+    platform_driver_unregister( &ipsec_driver );
+
+out:
+    return ret;
+}
+
+static void
+pc302crypt_exit( void )
+{
+    platform_driver_unregister( &ipsec_driver );
+    platform_driver_unregister( &l2_driver );
+}
+
+module_init( pc302crypt_init );
+module_exit( pc302crypt_exit );
+
+MODULE_LICENSE( "GPL" );
+MODULE_AUTHOR( "Jamie Iles" );
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 904e575..56fc487 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -33,7 +33,6 @@ config INTEL_IOATDMA
 config INTEL_IOP_ADMA
 	tristate "Intel IOP ADMA support"
 	depends on ARCH_IOP32X || ARCH_IOP33X || ARCH_IOP13XX
-	select ASYNC_CORE
 	select DMA_ENGINE
 	help
 	  Enable support for the Intel(R) IOP Series RAID engines.
@@ -47,6 +46,23 @@ config DW_DMAC
 	  Support the Synopsys DesignWare AHB DMA controller.  This
 	  can be integrated in chips such as the Atmel AT32ap7000.
 
+config PC302_DMA
+    tristate "PC302 DMA support"
+    depends on ARCH_PC302
+    select DMA_ENGINE
+    ---help---
+      This driver provides support for the Synopsys DesignWare AHB DMA controllers
+      present on the PC302. 
+
+config PC302_DMA_DEBUG_LEVEL
+        int "PC302 driver debugging verbosity (0 = quiet, 9 = noisy)"
+        default "0"
+        depends on PC302_DMA
+        help
+          This controls the amount of debugging messages produced by the
+          PC30x DMA driver. A value of zero builds a driver that has as default
+          no debug code.
+
 config FSL_DMA
 	tristate "Freescale Elo and Elo Plus DMA support"
 	depends on FSL_SOC
@@ -59,7 +75,6 @@ config FSL_DMA
 config MV_XOR
 	bool "Marvell XOR engine support"
 	depends on PLAT_ORION
-	select ASYNC_CORE
 	select DMA_ENGINE
 	---help---
 	  Enable support for the Marvell XOR engine.
@@ -88,4 +103,12 @@ config DMATEST
 	  Simple DMA test client. Say N unless you're debugging a
 	  DMA Device driver.
 
+config PC302_DMA_TEST
+    tristate "PC30x DMA test driver"
+    depends on PC302_DMA && DMATEST
+    ---help---
+      This driver provides a number of basic tests for the DMA controllers
+      present on the PC302. The tests are run on module load and can be 
+      targetted to run on DMAC 0 or 1.
+
 endif
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 14f5952..f2009a1 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -1,3 +1,5 @@
+# BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+#
 obj-$(CONFIG_DMA_ENGINE) += dmaengine.o
 obj-$(CONFIG_NET_DMA) += iovlock.o
 obj-$(CONFIG_DMATEST) += dmatest.o
@@ -7,3 +9,12 @@ obj-$(CONFIG_INTEL_IOP_ADMA) += iop-adma.o
 obj-$(CONFIG_FSL_DMA) += fsldma.o
 obj-$(CONFIG_MV_XOR) += mv_xor.o
 obj-$(CONFIG_DW_DMAC) += dw_dmac.o
+
+# PC302 DMA driver
+obj-$(CONFIG_PC302_DMA) += dmac.o
+dmac-y :=  pc302_dmac.o
+
+# PC302 DMA driver tester
+obj-$(CONFIG_PC302_DMA_TEST) += dmacdebug.o
+dmacdebug-y := pc302_dmac_test.o
+
diff --git a/drivers/dma/dmaengine.c b/drivers/dma/dmaengine.c
index 6579965..aeb9485 100644
--- a/drivers/dma/dmaengine.c
+++ b/drivers/dma/dmaengine.c
@@ -31,32 +31,18 @@
  *
  * LOCKING:
  *
- * The subsystem keeps two global lists, dma_device_list and dma_client_list.
- * Both of these are protected by a mutex, dma_list_mutex.
+ * The subsystem keeps a global list of dma_device structs it is protected by a
+ * mutex, dma_list_mutex.
+ *
+ * A subsystem can get access to a channel by calling dmaengine_get() followed
+ * by dma_find_channel(), or if it has need for an exclusive channel it can call
+ * dma_request_channel().  Once a channel is allocated a reference is taken
+ * against its corresponding driver to disable removal.
  *
  * Each device has a channels list, which runs unlocked but is never modified
  * once the device is registered, it's just setup by the driver.
  *
- * Each client is responsible for keeping track of the channels it uses.  See
- * the definition of dma_event_callback in dmaengine.h.
- *
- * Each device has a kref, which is initialized to 1 when the device is
- * registered. A kref_get is done for each device registered.  When the
- * device is released, the corresponding kref_put is done in the release
- * method. Every time one of the device's channels is allocated to a client,
- * a kref_get occurs.  When the channel is freed, the corresponding kref_put
- * happens. The device's release function does a completion, so
- * unregister_device does a remove event, device_unregister, a kref_put
- * for the first reference, then waits on the completion for all other
- * references to finish.
- *
- * Each channel has an open-coded implementation of Rusty Russell's "bigref,"
- * with a kref and a per_cpu local_t.  A dma_chan_get is called when a client
- * signals that it wants to use a channel, and dma_chan_put is called when
- * a channel is removed or a client using it is unregistered.  A client can
- * take extra references per outstanding transaction, as is the case with
- * the NET DMA client.  The release function does a kref_put on the device.
- *	-ChrisL, DanW
+ * See Documentation/dmaengine.txt for more details
  */
 
 #include <linux/init.h>
@@ -70,54 +56,83 @@
 #include <linux/rcupdate.h>
 #include <linux/mutex.h>
 #include <linux/jiffies.h>
+#include <linux/rculist.h>
 
 static DEFINE_MUTEX(dma_list_mutex);
 static LIST_HEAD(dma_device_list);
-static LIST_HEAD(dma_client_list);
+static long dmaengine_ref_count;
 
 /* --- sysfs implementation --- */
 
+/**
+ * dev_to_dma_chan - convert a device pointer to the its sysfs container object
+ * @dev - device node
+ *
+ * Must be called under dma_list_mutex
+ */
+static struct dma_chan *dev_to_dma_chan(struct device *dev)
+{
+	struct dma_chan_dev *chan_dev;
+
+	chan_dev = container_of(dev, typeof(*chan_dev), device);
+	return chan_dev->chan;
+}
+
 static ssize_t show_memcpy_count(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct dma_chan *chan = to_dma_chan(dev);
+	struct dma_chan *chan;
 	unsigned long count = 0;
 	int i;
+	int err;
 
-	for_each_possible_cpu(i)
-		count += per_cpu_ptr(chan->local, i)->memcpy_count;
+	mutex_lock(&dma_list_mutex);
+	chan = dev_to_dma_chan(dev);
+	if (chan) {
+		for_each_possible_cpu(i)
+			count += per_cpu_ptr(chan->local, i)->memcpy_count;
+		err = sprintf(buf, "%lu\n", count);
+	} else
+		err = -ENODEV;
+	mutex_unlock(&dma_list_mutex);
 
-	return sprintf(buf, "%lu\n", count);
+	return err;
 }
 
 static ssize_t show_bytes_transferred(struct device *dev, struct device_attribute *attr,
 				      char *buf)
 {
-	struct dma_chan *chan = to_dma_chan(dev);
+	struct dma_chan *chan;
 	unsigned long count = 0;
 	int i;
+	int err;
 
-	for_each_possible_cpu(i)
-		count += per_cpu_ptr(chan->local, i)->bytes_transferred;
+	mutex_lock(&dma_list_mutex);
+	chan = dev_to_dma_chan(dev);
+	if (chan) {
+		for_each_possible_cpu(i)
+			count += per_cpu_ptr(chan->local, i)->bytes_transferred;
+		err = sprintf(buf, "%lu\n", count);
+	} else
+		err = -ENODEV;
+	mutex_unlock(&dma_list_mutex);
 
-	return sprintf(buf, "%lu\n", count);
+	return err;
 }
 
 static ssize_t show_in_use(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct dma_chan *chan = to_dma_chan(dev);
-	int in_use = 0;
-
-	if (unlikely(chan->slow_ref) &&
-		atomic_read(&chan->refcount.refcount) > 1)
-		in_use = 1;
-	else {
-		if (local_read(&(per_cpu_ptr(chan->local,
-			get_cpu())->refcount)) > 0)
-			in_use = 1;
-		put_cpu();
-	}
+	struct dma_chan *chan;
+	int err;
 
-	return sprintf(buf, "%d\n", in_use);
+	mutex_lock(&dma_list_mutex);
+	chan = dev_to_dma_chan(dev);
+	if (chan)
+		err = sprintf(buf, "%d\n", chan->client_count);
+	else
+		err = -ENODEV;
+	mutex_unlock(&dma_list_mutex);
+
+	return err;
 }
 
 static struct device_attribute dma_attrs[] = {
@@ -127,76 +142,104 @@ static struct device_attribute dma_attrs[] = {
 	__ATTR_NULL
 };
 
-static void dma_async_device_cleanup(struct kref *kref);
-
-static void dma_dev_release(struct device *dev)
+static void chan_dev_release(struct device *dev)
 {
-	struct dma_chan *chan = to_dma_chan(dev);
-	kref_put(&chan->device->refcount, dma_async_device_cleanup);
+	struct dma_chan_dev *chan_dev;
+
+	chan_dev = container_of(dev, typeof(*chan_dev), device);
+	kfree(chan_dev);
 }
 
 static struct class dma_devclass = {
 	.name		= "dma",
 	.dev_attrs	= dma_attrs,
-	.dev_release	= dma_dev_release,
+	.dev_release	= chan_dev_release,
 };
 
 /* --- client and device registration --- */
 
-#define dma_chan_satisfies_mask(chan, mask) \
-	__dma_chan_satisfies_mask((chan), &(mask))
+#define dma_device_satisfies_mask(device, mask) \
+	__dma_device_satisfies_mask((device), &(mask))
 static int
-__dma_chan_satisfies_mask(struct dma_chan *chan, dma_cap_mask_t *want)
+__dma_device_satisfies_mask(struct dma_device *device, dma_cap_mask_t *want)
 {
 	dma_cap_mask_t has;
 
-	bitmap_and(has.bits, want->bits, chan->device->cap_mask.bits,
+	bitmap_and(has.bits, want->bits, device->cap_mask.bits,
 		DMA_TX_TYPE_END);
 	return bitmap_equal(want->bits, has.bits, DMA_TX_TYPE_END);
 }
 
+static struct module *dma_chan_to_owner(struct dma_chan *chan)
+{
+	return chan->device->dev->driver->owner;
+}
+
 /**
- * dma_client_chan_alloc - try to allocate channels to a client
- * @client: &dma_client
+ * balance_ref_count - catch up the channel reference count
+ * @chan - channel to balance ->client_count versus dmaengine_ref_count
  *
- * Called with dma_list_mutex held.
+ * balance_ref_count must be called under dma_list_mutex
  */
-static void dma_client_chan_alloc(struct dma_client *client)
+static void balance_ref_count(struct dma_chan *chan)
 {
-	struct dma_device *device;
-	struct dma_chan *chan;
-	int desc;	/* allocated descriptor count */
-	enum dma_state_client ack;
+	struct module *owner = dma_chan_to_owner(chan);
 
-	/* Find a channel */
-	list_for_each_entry(device, &dma_device_list, global_node) {
-		/* Does the client require a specific DMA controller? */
-		if (client->slave && client->slave->dma_dev
-				&& client->slave->dma_dev != device->dev)
-			continue;
+	while (chan->client_count < dmaengine_ref_count) {
+		__module_get(owner);
+		chan->client_count++;
+	}
+}
 
-		list_for_each_entry(chan, &device->channels, device_node) {
-			if (!dma_chan_satisfies_mask(chan, client->cap_mask))
-				continue;
+/**
+ * dma_chan_get - try to grab a dma channel's parent driver module
+ * @chan - channel to grab
+ *
+ * Must be called under dma_list_mutex
+ */
+static int dma_chan_get(struct dma_chan *chan)
+{
+	int err = -ENODEV;
+	struct module *owner = dma_chan_to_owner(chan);
+
+	if (chan->client_count) {
+		__module_get(owner);
+		err = 0;
+	} else if (try_module_get(owner))
+		err = 0;
+
+	if (err == 0)
+		chan->client_count++;
+
+	/* allocate upon first client reference */
+	if (chan->client_count == 1 && err == 0) {
+		int desc_cnt = chan->device->device_alloc_chan_resources(chan);
+
+		if (desc_cnt < 0) {
+			err = desc_cnt;
+			chan->client_count = 0;
+			module_put(owner);
+		} else if (!dma_has_cap(DMA_PRIVATE, chan->device->cap_mask))
+			balance_ref_count(chan);
+	}
 
-			desc = chan->device->device_alloc_chan_resources(
-					chan, client);
-			if (desc >= 0) {
-				ack = client->event_callback(client,
-						chan,
-						DMA_RESOURCE_AVAILABLE);
+	return err;
+}
 
-				/* we are done once this client rejects
-				 * an available resource
-				 */
-				if (ack == DMA_ACK) {
-					dma_chan_get(chan);
-					chan->client_count++;
-				} else if (ack == DMA_NAK)
-					return;
-			}
-		}
-	}
+/**
+ * dma_chan_put - drop a reference to a dma channel's parent driver module
+ * @chan - channel to release
+ *
+ * Must be called under dma_list_mutex
+ */
+static void dma_chan_put(struct dma_chan *chan)
+{
+	if (!chan->client_count)
+		return; /* this channel failed alloc_chan_resources */
+	chan->client_count--;
+	module_put(dma_chan_to_owner(chan));
+	if (chan->client_count == 0)
+		chan->device->device_free_chan_resources(chan);
 }
 
 enum dma_status dma_sync_wait(struct dma_chan *chan, dma_cookie_t cookie)
@@ -218,138 +261,342 @@ enum dma_status dma_sync_wait(struct dma_chan *chan, dma_cookie_t cookie)
 EXPORT_SYMBOL(dma_sync_wait);
 
 /**
- * dma_chan_cleanup - release a DMA channel's resources
- * @kref: kernel reference structure that contains the DMA channel device
+ * dma_cap_mask_all - enable iteration over all operation types
+ */
+static dma_cap_mask_t dma_cap_mask_all;
+
+/**
+ * dma_chan_tbl_ent - tracks channel allocations per core/operation
+ * @chan - associated channel for this entry
+ */
+struct dma_chan_tbl_ent {
+	struct dma_chan *chan;
+};
+
+/**
+ * channel_table - percpu lookup table for memory-to-memory offload providers
  */
-void dma_chan_cleanup(struct kref *kref)
+static struct dma_chan_tbl_ent *channel_table[DMA_TX_TYPE_END];
+
+static int __init dma_channel_table_init(void)
 {
-	struct dma_chan *chan = container_of(kref, struct dma_chan, refcount);
-	chan->device->device_free_chan_resources(chan);
-	kref_put(&chan->device->refcount, dma_async_device_cleanup);
+	enum dma_transaction_type cap;
+	int err = 0;
+
+	bitmap_fill(dma_cap_mask_all.bits, DMA_TX_TYPE_END);
+
+	/* 'interrupt', 'private', and 'slave' are channel capabilities,
+	 * but are not associated with an operation so they do not need
+	 * an entry in the channel_table
+	 */
+	clear_bit(DMA_INTERRUPT, dma_cap_mask_all.bits);
+	clear_bit(DMA_PRIVATE, dma_cap_mask_all.bits);
+	clear_bit(DMA_SLAVE, dma_cap_mask_all.bits);
+
+	for_each_dma_cap_mask(cap, dma_cap_mask_all) {
+		channel_table[cap] = alloc_percpu(struct dma_chan_tbl_ent);
+		if (!channel_table[cap]) {
+			err = -ENOMEM;
+			break;
+		}
+	}
+
+	if (err) {
+		pr_err("dmaengine: initialization failure\n");
+		for_each_dma_cap_mask(cap, dma_cap_mask_all)
+			if (channel_table[cap])
+				free_percpu(channel_table[cap]);
+	}
+
+	return err;
 }
-EXPORT_SYMBOL(dma_chan_cleanup);
+subsys_initcall(dma_channel_table_init);
 
-static void dma_chan_free_rcu(struct rcu_head *rcu)
+/**
+ * dma_find_channel - find a channel to carry out the operation
+ * @tx_type: transaction type
+ */
+struct dma_chan *dma_find_channel(enum dma_transaction_type tx_type)
 {
-	struct dma_chan *chan = container_of(rcu, struct dma_chan, rcu);
-	int bias = 0x7FFFFFFF;
-	int i;
-	for_each_possible_cpu(i)
-		bias -= local_read(&per_cpu_ptr(chan->local, i)->refcount);
-	atomic_sub(bias, &chan->refcount.refcount);
-	kref_put(&chan->refcount, dma_chan_cleanup);
+	struct dma_chan *chan;
+	int cpu;
+
+	WARN_ONCE(dmaengine_ref_count == 0,
+		  "client called %s without a reference", __func__);
+
+	cpu = get_cpu();
+	chan = per_cpu_ptr(channel_table[tx_type], cpu)->chan;
+	put_cpu();
+
+	return chan;
 }
+EXPORT_SYMBOL(dma_find_channel);
 
-static void dma_chan_release(struct dma_chan *chan)
+/**
+ * dma_issue_pending_all - flush all pending operations across all channels
+ */
+void dma_issue_pending_all(void)
 {
-	atomic_add(0x7FFFFFFF, &chan->refcount.refcount);
-	chan->slow_ref = 1;
-	call_rcu(&chan->rcu, dma_chan_free_rcu);
+	struct dma_device *device;
+	struct dma_chan *chan;
+
+	WARN_ONCE(dmaengine_ref_count == 0,
+		  "client called %s without a reference", __func__);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(device, &dma_device_list, global_node) {
+		if (dma_has_cap(DMA_PRIVATE, device->cap_mask))
+			continue;
+		list_for_each_entry(chan, &device->channels, device_node)
+			if (chan->client_count)
+				device->device_issue_pending(chan);
+	}
+	rcu_read_unlock();
 }
+EXPORT_SYMBOL(dma_issue_pending_all);
 
 /**
- * dma_chans_notify_available - broadcast available channels to the clients
+ * nth_chan - returns the nth channel of the given capability
+ * @cap: capability to match
+ * @n: nth channel desired
+ *
+ * Defaults to returning the channel with the desired capability and the
+ * lowest reference count when 'n' cannot be satisfied.  Must be called
+ * under dma_list_mutex.
  */
-static void dma_clients_notify_available(void)
+static struct dma_chan *nth_chan(enum dma_transaction_type cap, int n)
 {
-	struct dma_client *client;
+	struct dma_device *device;
+	struct dma_chan *chan;
+	struct dma_chan *ret = NULL;
+	struct dma_chan *min = NULL;
 
-	mutex_lock(&dma_list_mutex);
+	list_for_each_entry(device, &dma_device_list, global_node) {
+		if (!dma_has_cap(cap, device->cap_mask) ||
+		    dma_has_cap(DMA_PRIVATE, device->cap_mask))
+			continue;
+		list_for_each_entry(chan, &device->channels, device_node) {
+			if (!chan->client_count)
+				continue;
+			if (!min)
+				min = chan;
+			else if (chan->table_count < min->table_count)
+				min = chan;
+
+			if (n-- == 0) {
+				ret = chan;
+				break; /* done */
+			}
+		}
+		if (ret)
+			break; /* done */
+	}
 
-	list_for_each_entry(client, &dma_client_list, global_node)
-		dma_client_chan_alloc(client);
+	if (!ret)
+		ret = min;
 
-	mutex_unlock(&dma_list_mutex);
+	if (ret)
+		ret->table_count++;
+
+	return ret;
 }
 
 /**
- * dma_chans_notify_available - tell the clients that a channel is going away
- * @chan: channel on its way out
+ * dma_channel_rebalance - redistribute the available channels
+ *
+ * Optimize for cpu isolation (each cpu gets a dedicated channel for an
+ * operation type) in the SMP case,  and operation isolation (avoid
+ * multi-tasking channels) in the non-SMP case.  Must be called under
+ * dma_list_mutex.
  */
-static void dma_clients_notify_removed(struct dma_chan *chan)
+static void dma_channel_rebalance(void)
 {
-	struct dma_client *client;
-	enum dma_state_client ack;
+	struct dma_chan *chan;
+	struct dma_device *device;
+	int cpu;
+	int cap;
+	int n;
 
-	mutex_lock(&dma_list_mutex);
+	/* undo the last distribution */
+	for_each_dma_cap_mask(cap, dma_cap_mask_all)
+		for_each_possible_cpu(cpu)
+			per_cpu_ptr(channel_table[cap], cpu)->chan = NULL;
+
+	list_for_each_entry(device, &dma_device_list, global_node) {
+		if (dma_has_cap(DMA_PRIVATE, device->cap_mask))
+			continue;
+		list_for_each_entry(chan, &device->channels, device_node)
+			chan->table_count = 0;
+	}
+
+	/* don't populate the channel_table if no clients are available */
+	if (!dmaengine_ref_count)
+		return;
 
-	list_for_each_entry(client, &dma_client_list, global_node) {
-		ack = client->event_callback(client, chan,
-				DMA_RESOURCE_REMOVED);
+	/* redistribute available channels */
+	n = 0;
+	for_each_dma_cap_mask(cap, dma_cap_mask_all)
+		for_each_online_cpu(cpu) {
+			if (num_possible_cpus() > 1)
+				chan = nth_chan(cap, n++);
+			else
+				chan = nth_chan(cap, -1);
 
-		/* client was holding resources for this channel so
-		 * free it
-		 */
-		if (ack == DMA_ACK) {
-			dma_chan_put(chan);
-			chan->client_count--;
+			per_cpu_ptr(channel_table[cap], cpu)->chan = chan;
 		}
+}
+
+static struct dma_chan *private_candidate(dma_cap_mask_t *mask, struct dma_device *dev,
+					  dma_filter_fn fn, void *fn_param)
+{
+	struct dma_chan *chan;
+
+	if (!__dma_device_satisfies_mask(dev, mask)) {
+		pr_debug("%s: wrong capabilities\n", __func__);
+		return NULL;
 	}
+	/* devices with multiple channels need special handling as we need to
+	 * ensure that all channels are either private or public.
+	 */
+	if (dev->chancnt > 1 && !dma_has_cap(DMA_PRIVATE, dev->cap_mask))
+		list_for_each_entry(chan, &dev->channels, device_node) {
+			/* some channels are already publicly allocated */
+			if (chan->client_count)
+				return NULL;
+		}
 
-	mutex_unlock(&dma_list_mutex);
+	list_for_each_entry(chan, &dev->channels, device_node) {
+		if (chan->client_count) {
+			pr_debug("%s: %s busy\n",
+				 __func__, dma_chan_name(chan));
+			continue;
+		}
+		if (fn && !fn(chan, fn_param)) {
+			pr_debug("%s: %s filter said false\n",
+				 __func__, dma_chan_name(chan));
+			continue;
+		}
+		return chan;
+	}
+
+	return NULL;
 }
 
 /**
- * dma_async_client_register - register a &dma_client
- * @client: ptr to a client structure with valid 'event_callback' and 'cap_mask'
+ * dma_request_channel - try to allocate an exclusive channel
+ * @mask: capabilities that the channel must satisfy
+ * @fn: optional callback to disposition available channels
+ * @fn_param: opaque parameter to pass to dma_filter_fn
  */
-void dma_async_client_register(struct dma_client *client)
+struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, dma_filter_fn fn, void *fn_param)
 {
-	/* validate client data */
-	BUG_ON(dma_has_cap(DMA_SLAVE, client->cap_mask) &&
-		!client->slave);
+	struct dma_device *device, *_d;
+	struct dma_chan *chan = NULL;
+	int err;
+
+	/* Find a channel */
+	mutex_lock(&dma_list_mutex);
+	list_for_each_entry_safe(device, _d, &dma_device_list, global_node) {
+		chan = private_candidate(mask, device, fn, fn_param);
+		if (chan) {
+			/* Found a suitable channel, try to grab, prep, and
+			 * return it.  We first set DMA_PRIVATE to disable
+			 * balance_ref_count as this channel will not be
+			 * published in the general-purpose allocator
+			 */
+			dma_cap_set(DMA_PRIVATE, device->cap_mask);
+			err = dma_chan_get(chan);
+
+			if (err == -ENODEV) {
+				pr_debug("%s: %s module removed\n", __func__,
+					 dma_chan_name(chan));
+				list_del_rcu(&device->global_node);
+			} else if (err)
+				pr_err("dmaengine: failed to get %s: (%d)\n",
+				       dma_chan_name(chan), err);
+			else
+				break;
+			chan = NULL;
+		}
+	}
+	mutex_unlock(&dma_list_mutex);
+
+	pr_debug("%s: %s (%s)\n", __func__, chan ? "success" : "fail",
+		 chan ? dma_chan_name(chan) : NULL);
+
+	return chan;
+}
+EXPORT_SYMBOL_GPL(__dma_request_channel);
 
+void dma_release_channel(struct dma_chan *chan)
+{
 	mutex_lock(&dma_list_mutex);
-	list_add_tail(&client->global_node, &dma_client_list);
+	WARN_ONCE(chan->client_count != 1,
+		  "chan reference count %d != 1\n", chan->client_count);
+	dma_chan_put(chan);
 	mutex_unlock(&dma_list_mutex);
 }
-EXPORT_SYMBOL(dma_async_client_register);
+EXPORT_SYMBOL_GPL(dma_release_channel);
 
 /**
- * dma_async_client_unregister - unregister a client and free the &dma_client
- * @client: &dma_client to free
- *
- * Force frees any allocated DMA channels, frees the &dma_client memory
+ * dmaengine_get - register interest in dma_channels
  */
-void dma_async_client_unregister(struct dma_client *client)
+void dmaengine_get(void)
 {
-	struct dma_device *device;
+	struct dma_device *device, *_d;
 	struct dma_chan *chan;
-	enum dma_state_client ack;
-
-	if (!client)
-		return;
+	int err;
 
 	mutex_lock(&dma_list_mutex);
-	/* free all channels the client is holding */
-	list_for_each_entry(device, &dma_device_list, global_node)
-		list_for_each_entry(chan, &device->channels, device_node) {
-			ack = client->event_callback(client, chan,
-				DMA_RESOURCE_REMOVED);
+	dmaengine_ref_count++;
 
-			if (ack == DMA_ACK) {
-				dma_chan_put(chan);
-				chan->client_count--;
-			}
+	/* try to grab channels */
+	list_for_each_entry_safe(device, _d, &dma_device_list, global_node) {
+		if (dma_has_cap(DMA_PRIVATE, device->cap_mask))
+			continue;
+		list_for_each_entry(chan, &device->channels, device_node) {
+			err = dma_chan_get(chan);
+			if (err == -ENODEV) {
+				/* module removed before we could use it */
+				list_del_rcu(&device->global_node);
+				break;
+			} else if (err)
+				pr_err("dmaengine: failed to get %s: (%d)\n",
+				       dma_chan_name(chan), err);
 		}
+	}
 
-	list_del(&client->global_node);
+	/* if this is the first reference and there were channels
+	 * waiting we need to rebalance to get those channels
+	 * incorporated into the channel table
+	 */
+	if (dmaengine_ref_count == 1)
+		dma_channel_rebalance();
 	mutex_unlock(&dma_list_mutex);
 }
-EXPORT_SYMBOL(dma_async_client_unregister);
+EXPORT_SYMBOL(dmaengine_get);
 
 /**
- * dma_async_client_chan_request - send all available channels to the
- * client that satisfy the capability mask
- * @client - requester
+ * dmaengine_put - let dma drivers be removed when ref_count == 0
  */
-void dma_async_client_chan_request(struct dma_client *client)
+void dmaengine_put(void)
 {
+	struct dma_device *device;
+	struct dma_chan *chan;
+
 	mutex_lock(&dma_list_mutex);
-	dma_client_chan_alloc(client);
+	dmaengine_ref_count--;
+	BUG_ON(dmaengine_ref_count < 0);
+	/* drop channel references */
+	list_for_each_entry(device, &dma_device_list, global_node) {
+		if (dma_has_cap(DMA_PRIVATE, device->cap_mask))
+			continue;
+		list_for_each_entry(chan, &device->channels, device_node)
+			dma_chan_put(chan);
+	}
 	mutex_unlock(&dma_list_mutex);
 }
-EXPORT_SYMBOL(dma_async_client_chan_request);
+EXPORT_SYMBOL(dmaengine_put);
 
 /**
  * dma_async_device_register - registers DMA devices found
@@ -386,9 +633,6 @@ int dma_async_device_register(struct dma_device *device)
 	BUG_ON(!device->device_issue_pending);
 	BUG_ON(!device->dev);
 
-	init_completion(&device->done);
-	kref_init(&device->refcount);
-
 	mutex_lock(&dma_list_mutex);
 	device->dev_id = id++;
 	mutex_unlock(&dma_list_mutex);
@@ -398,45 +642,60 @@ int dma_async_device_register(struct dma_device *device)
 		chan->local = alloc_percpu(typeof(*chan->local));
 		if (chan->local == NULL)
 			continue;
+		chan->dev = kzalloc(sizeof(*chan->dev), GFP_KERNEL);
+		if (chan->dev == NULL) {
+			free_percpu(chan->local);
+			continue;
+		}
 
 		chan->chan_id = chancnt++;
-		chan->dev.class = &dma_devclass;
-		chan->dev.parent = device->dev;
-		dev_set_name(&chan->dev, "dma%dchan%d",
+		chan->dev->device.class = &dma_devclass;
+		chan->dev->device.parent = device->dev;
+		chan->dev->chan = chan;
+		dev_set_name(&chan->dev->device, "dma%dchan%d",
 			     device->dev_id, chan->chan_id);
 
-		rc = device_register(&chan->dev);
+		rc = device_register(&chan->dev->device);
 		if (rc) {
-			chancnt--;
 			free_percpu(chan->local);
 			chan->local = NULL;
 			goto err_out;
 		}
-
-		/* One for the channel, one of the class device */
-		kref_get(&device->refcount);
-		kref_get(&device->refcount);
-		kref_init(&chan->refcount);
 		chan->client_count = 0;
-		chan->slow_ref = 0;
-		INIT_RCU_HEAD(&chan->rcu);
 	}
+	device->chancnt = chancnt;
 
 	mutex_lock(&dma_list_mutex);
-	list_add_tail(&device->global_node, &dma_device_list);
+	/* take references on public channels */
+	if (dmaengine_ref_count && !dma_has_cap(DMA_PRIVATE, device->cap_mask))
+		list_for_each_entry(chan, &device->channels, device_node) {
+			/* if clients are already waiting for channels we need
+			 * to take references on their behalf
+			 */
+			if (dma_chan_get(chan) == -ENODEV) {
+				/* note we can only get here for the first
+				 * channel as the remaining channels are
+				 * guaranteed to get a reference
+				 */
+				rc = -ENODEV;
+				mutex_unlock(&dma_list_mutex);
+				goto err_out;
+			}
+		}
+	list_add_tail_rcu(&device->global_node, &dma_device_list);
+	dma_channel_rebalance();
 	mutex_unlock(&dma_list_mutex);
 
-	dma_clients_notify_available();
-
 	return 0;
 
 err_out:
 	list_for_each_entry(chan, &device->channels, device_node) {
 		if (chan->local == NULL)
 			continue;
-		kref_put(&device->refcount, dma_async_device_cleanup);
-		device_unregister(&chan->dev);
-		chancnt--;
+		mutex_lock(&dma_list_mutex);
+		chan->dev->chan = NULL;
+		mutex_unlock(&dma_list_mutex);
+		device_unregister(&chan->dev->device);
 		free_percpu(chan->local);
 	}
 	return rc;
@@ -444,37 +703,30 @@ err_out:
 EXPORT_SYMBOL(dma_async_device_register);
 
 /**
- * dma_async_device_cleanup - function called when all references are released
- * @kref: kernel reference object
- */
-static void dma_async_device_cleanup(struct kref *kref)
-{
-	struct dma_device *device;
-
-	device = container_of(kref, struct dma_device, refcount);
-	complete(&device->done);
-}
-
-/**
- * dma_async_device_unregister - unregisters DMA devices
+ * dma_async_device_unregister - unregister a DMA device
  * @device: &dma_device
+ *
+ * This routine is called by dma driver exit routines, dmaengine holds module
+ * references to prevent it being called while channels are in use.
  */
 void dma_async_device_unregister(struct dma_device *device)
 {
 	struct dma_chan *chan;
 
 	mutex_lock(&dma_list_mutex);
-	list_del(&device->global_node);
+	list_del_rcu(&device->global_node);
+	dma_channel_rebalance();
 	mutex_unlock(&dma_list_mutex);
 
 	list_for_each_entry(chan, &device->channels, device_node) {
-		dma_clients_notify_removed(chan);
-		device_unregister(&chan->dev);
-		dma_chan_release(chan);
+		WARN_ONCE(chan->client_count,
+			  "%s called while %d clients hold a reference\n",
+			  __func__, chan->client_count);
+		mutex_lock(&dma_list_mutex);
+		chan->dev->chan = NULL;
+		mutex_unlock(&dma_list_mutex);
+		device_unregister(&chan->dev->device);
 	}
-
-	kref_put(&device->refcount, dma_async_device_cleanup);
-	wait_for_completion(&device->done);
 }
 EXPORT_SYMBOL(dma_async_device_unregister);
 
@@ -626,6 +878,90 @@ void dma_async_tx_descriptor_init(struct dma_async_tx_descriptor *tx,
 }
 EXPORT_SYMBOL(dma_async_tx_descriptor_init);
 
+/* dma_wait_for_async_tx - spin wait for a transaction to complete
+ * @tx: in-flight transaction to wait on
+ *
+ * This routine assumes that tx was obtained from a call to async_memcpy,
+ * async_xor, async_memset, etc which ensures that tx is "in-flight" (prepped
+ * and submitted).  Walking the parent chain is only meant to cover for DMA
+ * drivers that do not implement the DMA_INTERRUPT capability and may race with
+ * the driver's descriptor cleanup routine.
+ */
+enum dma_status
+dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx)
+{
+	enum dma_status status;
+	struct dma_async_tx_descriptor *iter;
+	struct dma_async_tx_descriptor *parent;
+
+	if (!tx)
+		return DMA_SUCCESS;
+
+	WARN_ONCE(tx->parent, "%s: speculatively walking dependency chain for"
+		  " %s\n", __func__, dma_chan_name(tx->chan));
+
+	/* poll through the dependency chain, return when tx is complete */
+	do {
+		iter = tx;
+
+		/* find the root of the unsubmitted dependency chain */
+		do {
+			parent = iter->parent;
+			if (!parent)
+				break;
+			else
+				iter = parent;
+		} while (parent);
+
+		/* there is a small window for ->parent == NULL and
+		 * ->cookie == -EBUSY
+		 */
+		while (iter->cookie == -EBUSY)
+			cpu_relax();
+
+		status = dma_sync_wait(iter->chan, iter->cookie);
+	} while (status == DMA_IN_PROGRESS || (iter != tx));
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(dma_wait_for_async_tx);
+
+/* dma_run_dependencies - helper routine for dma drivers to process
+ *	(start) dependent operations on their target channel
+ * @tx: transaction with dependencies
+ */
+void dma_run_dependencies(struct dma_async_tx_descriptor *tx)
+{
+	struct dma_async_tx_descriptor *dep = tx->next;
+	struct dma_async_tx_descriptor *dep_next;
+	struct dma_chan *chan;
+
+	if (!dep)
+		return;
+
+	chan = dep->chan;
+
+	/* keep submitting up until a channel switch is detected
+	 * in that case we will be called again as a result of
+	 * processing the interrupt from async_tx_channel_switch
+	 */
+	for (; dep; dep = dep_next) {
+		spin_lock_bh(&dep->lock);
+		dep->parent = NULL;
+		dep_next = dep->next;
+		if (dep_next && dep_next->chan == chan)
+			dep->next = NULL; /* ->next will be submitted */
+		else
+			dep_next = NULL; /* submit current dep and terminate */
+		spin_unlock_bh(&dep->lock);
+
+		dep->tx_submit(dep);
+	}
+
+	chan->device->device_issue_pending(chan);
+}
+EXPORT_SYMBOL_GPL(dma_run_dependencies);
+
 static int __init dma_bus_init(void)
 {
 	mutex_init(&dma_list_mutex);
@@ -633,3 +969,4 @@ static int __init dma_bus_init(void)
 }
 subsys_initcall(dma_bus_init);
 
+
diff --git a/drivers/dma/dmatest.c b/drivers/dma/dmatest.c
index ed9636b..7da6223 100644
--- a/drivers/dma/dmatest.c
+++ b/drivers/dma/dmatest.c
@@ -35,7 +35,7 @@ MODULE_PARM_DESC(threads_per_chan,
 
 static unsigned int max_channels;
 module_param(max_channels, uint, S_IRUGO);
-MODULE_PARM_DESC(nr_channels,
+MODULE_PARM_DESC(max_channels,
 		"Maximum number of channels to use (default: all)");
 
 /*
@@ -71,7 +71,7 @@ struct dmatest_chan {
 
 /*
  * These are protected by dma_list_mutex since they're only used by
- * the DMA client event callback
+ * the DMA filter function callback
  */
 static LIST_HEAD(dmatest_channels);
 static unsigned int nr_channels;
@@ -80,7 +80,7 @@ static bool dmatest_match_channel(struct dma_chan *chan)
 {
 	if (test_channel[0] == '\0')
 		return true;
-	return strcmp(dev_name(&chan->dev), test_channel) == 0;
+	return strcmp(dma_chan_name(chan), test_channel) == 0;
 }
 
 static bool dmatest_match_device(struct dma_device *device)
@@ -215,7 +215,6 @@ static int dmatest_func(void *data)
 
 	smp_rmb();
 	chan = thread->chan;
-	dma_chan_get(chan);
 
 	while (!kthread_should_stop()) {
 		total_tests++;
@@ -293,7 +292,6 @@ static int dmatest_func(void *data)
 	}
 
 	ret = 0;
-	dma_chan_put(chan);
 	kfree(thread->dstbuf);
 err_dstbuf:
 	kfree(thread->srcbuf);
@@ -319,21 +317,16 @@ static void dmatest_cleanup_channel(struct dmatest_chan *dtc)
 	kfree(dtc);
 }
 
-static enum dma_state_client dmatest_add_channel(struct dma_chan *chan)
+static int dmatest_add_channel(struct dma_chan *chan)
 {
 	struct dmatest_chan	*dtc;
 	struct dmatest_thread	*thread;
 	unsigned int		i;
 
-	/* Have we already been told about this channel? */
-	list_for_each_entry(dtc, &dmatest_channels, node)
-		if (dtc->chan == chan)
-			return DMA_DUP;
-
 	dtc = kmalloc(sizeof(struct dmatest_chan), GFP_KERNEL);
 	if (!dtc) {
-		pr_warning("dmatest: No memory for %s\n", dev_name(&chan->dev));
-		return DMA_NAK;
+		pr_warning("dmatest: No memory for %s\n", dma_chan_name(chan));
+		return -ENOMEM;
 	}
 
 	dtc->chan = chan;
@@ -343,16 +336,16 @@ static enum dma_state_client dmatest_add_channel(struct dma_chan *chan)
 		thread = kzalloc(sizeof(struct dmatest_thread), GFP_KERNEL);
 		if (!thread) {
 			pr_warning("dmatest: No memory for %s-test%u\n",
-				   dev_name(&chan->dev), i);
+				   dma_chan_name(chan), i);
 			break;
 		}
 		thread->chan = dtc->chan;
 		smp_wmb();
 		thread->task = kthread_run(dmatest_func, thread, "%s-test%u",
-				dev_name(&chan->dev), i);
+				dma_chan_name(chan), i);
 		if (IS_ERR(thread->task)) {
 			pr_warning("dmatest: Failed to run thread %s-test%u\n",
-					dev_name(&chan->dev), i);
+					dma_chan_name(chan), i);
 			kfree(thread);
 			break;
 		}
@@ -362,86 +355,63 @@ static enum dma_state_client dmatest_add_channel(struct dma_chan *chan)
 		list_add_tail(&thread->node, &dtc->threads);
 	}
 
-	pr_info("dmatest: Started %u threads using %s\n", i, dev_name(&chan->dev));
+	pr_info("dmatest: Started %u threads using %s\n", i, dma_chan_name(chan));
 
 	list_add_tail(&dtc->node, &dmatest_channels);
 	nr_channels++;
 
-	return DMA_ACK;
-}
-
-static enum dma_state_client dmatest_remove_channel(struct dma_chan *chan)
-{
-	struct dmatest_chan	*dtc, *_dtc;
-
-	list_for_each_entry_safe(dtc, _dtc, &dmatest_channels, node) {
-		if (dtc->chan == chan) {
-			list_del(&dtc->node);
-			dmatest_cleanup_channel(dtc);
-			pr_debug("dmatest: lost channel %s\n",
-					dev_name(&chan->dev));
-			return DMA_ACK;
-		}
-	}
-
-	return DMA_DUP;
+	return 0;
 }
 
-/*
- * Start testing threads as new channels are assigned to us, and kill
- * them when the channels go away.
- *
- * When we unregister the client, all channels are removed so this
- * will also take care of cleaning things up when the module is
- * unloaded.
- */
-static enum dma_state_client
-dmatest_event(struct dma_client *client, struct dma_chan *chan,
-		enum dma_state state)
+static bool filter(struct dma_chan *chan, void *param)
 {
-	enum dma_state_client	ack = DMA_NAK;
-
-	switch (state) {
-	case DMA_RESOURCE_AVAILABLE:
-		if (!dmatest_match_channel(chan)
-				|| !dmatest_match_device(chan->device))
-			ack = DMA_DUP;
-		else if (max_channels && nr_channels >= max_channels)
-			ack = DMA_NAK;
-		else
-			ack = dmatest_add_channel(chan);
-		break;
-
-	case DMA_RESOURCE_REMOVED:
-		ack = dmatest_remove_channel(chan);
-		break;
-
-	default:
-		pr_info("dmatest: Unhandled event %u (%s)\n",
-				state, dev_name(&chan->dev));
-		break;
-	}
-
-	return ack;
+	if (!dmatest_match_channel(chan) || !dmatest_match_device(chan->device))
+		return false;
+	else
+		return true;
 }
 
-static struct dma_client dmatest_client = {
-	.event_callback	= dmatest_event,
-};
-
 static int __init dmatest_init(void)
 {
-	dma_cap_set(DMA_MEMCPY, dmatest_client.cap_mask);
-	dma_async_client_register(&dmatest_client);
-	dma_async_client_chan_request(&dmatest_client);
+	dma_cap_mask_t mask;
+	struct dma_chan *chan;
+	int err = 0;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_MEMCPY, mask);
+	dma_cap_set(DMA_PRIVATE, mask);
+	for (;;) {
+		chan = dma_request_channel(mask, filter, NULL);
+		if (chan) {
+			err = dmatest_add_channel(chan);
+			if (err == 0)
+				continue;
+			else {
+				dma_release_channel(chan);
+				break; /* add_channel failed, punt */
+			}
+		} else
+			break; /* no more channels available */
+		if (max_channels && nr_channels >= max_channels)
+			break; /* we have all we need */
+	}
 
-	return 0;
+	return err;
 }
-module_init(dmatest_init);
+/* when compiled-in wait for drivers to load first */
+late_initcall(dmatest_init);
 
 static void __exit dmatest_exit(void)
 {
-	dma_async_client_unregister(&dmatest_client);
+	struct dmatest_chan *dtc, *_dtc;
+
+	list_for_each_entry_safe(dtc, _dtc, &dmatest_channels, node) {
+		list_del(&dtc->node);
+		dmatest_cleanup_channel(dtc);
+		pr_debug("dmatest: dropped channel %s\n",
+			 dma_chan_name(dtc->chan));
+		dma_release_channel(dtc->chan);
+	}
 }
 module_exit(dmatest_exit);
 
diff --git a/drivers/dma/dw_dmac.c b/drivers/dma/dw_dmac.c
index 0778d99..ac980fd 100644
--- a/drivers/dma/dw_dmac.c
+++ b/drivers/dma/dw_dmac.c
@@ -70,6 +70,15 @@
  * the controller, though.
  */
 
+static struct device *chan2dev(struct dma_chan *chan)
+{
+	return &chan->dev->device;
+}
+static struct device *chan2parent(struct dma_chan *chan)
+{
+	return chan->dev->device.parent;
+}
+
 static struct dw_desc *dwc_first_active(struct dw_dma_chan *dwc)
 {
 	return list_entry(dwc->active_list.next, struct dw_desc, desc_node);
@@ -93,12 +102,12 @@ static struct dw_desc *dwc_desc_get(struct dw_dma_chan *dwc)
 			ret = desc;
 			break;
 		}
-		dev_dbg(&dwc->chan.dev, "desc %p not ACKed\n", desc);
+		dev_dbg(chan2dev(&dwc->chan), "desc %p not ACKed\n", desc);
 		i++;
 	}
 	spin_unlock_bh(&dwc->lock);
 
-	dev_vdbg(&dwc->chan.dev, "scanned %u descriptors on freelist\n", i);
+	dev_vdbg(chan2dev(&dwc->chan), "scanned %u descriptors on freelist\n", i);
 
 	return ret;
 }
@@ -108,10 +117,10 @@ static void dwc_sync_desc_for_cpu(struct dw_dma_chan *dwc, struct dw_desc *desc)
 	struct dw_desc	*child;
 
 	list_for_each_entry(child, &desc->txd.tx_list, desc_node)
-		dma_sync_single_for_cpu(dwc->chan.dev.parent,
+		dma_sync_single_for_cpu(chan2parent(&dwc->chan),
 				child->txd.phys, sizeof(child->lli),
 				DMA_TO_DEVICE);
-	dma_sync_single_for_cpu(dwc->chan.dev.parent,
+	dma_sync_single_for_cpu(chan2parent(&dwc->chan),
 			desc->txd.phys, sizeof(desc->lli),
 			DMA_TO_DEVICE);
 }
@@ -129,11 +138,11 @@ static void dwc_desc_put(struct dw_dma_chan *dwc, struct dw_desc *desc)
 
 		spin_lock_bh(&dwc->lock);
 		list_for_each_entry(child, &desc->txd.tx_list, desc_node)
-			dev_vdbg(&dwc->chan.dev,
+			dev_vdbg(chan2dev(&dwc->chan),
 					"moving child desc %p to freelist\n",
 					child);
 		list_splice_init(&desc->txd.tx_list, &dwc->free_list);
-		dev_vdbg(&dwc->chan.dev, "moving desc %p to freelist\n", desc);
+		dev_vdbg(chan2dev(&dwc->chan), "moving desc %p to freelist\n", desc);
 		list_add(&desc->desc_node, &dwc->free_list);
 		spin_unlock_bh(&dwc->lock);
 	}
@@ -163,9 +172,9 @@ static void dwc_dostart(struct dw_dma_chan *dwc, struct dw_desc *first)
 
 	/* ASSERT:  channel is idle */
 	if (dma_readl(dw, CH_EN) & dwc->mask) {
-		dev_err(&dwc->chan.dev,
+		dev_err(chan2dev(&dwc->chan),
 			"BUG: Attempted to start non-idle channel\n");
-		dev_err(&dwc->chan.dev,
+		dev_err(chan2dev(&dwc->chan),
 			"  SAR: 0x%x DAR: 0x%x LLP: 0x%x CTL: 0x%x:%08x\n",
 			channel_readl(dwc, SAR),
 			channel_readl(dwc, DAR),
@@ -193,7 +202,7 @@ dwc_descriptor_complete(struct dw_dma_chan *dwc, struct dw_desc *desc)
 	void				*param;
 	struct dma_async_tx_descriptor	*txd = &desc->txd;
 
-	dev_vdbg(&dwc->chan.dev, "descriptor %u complete\n", txd->cookie);
+	dev_vdbg(chan2dev(&dwc->chan), "descriptor %u complete\n", txd->cookie);
 
 	dwc->completed = txd->cookie;
 	callback = txd->callback;
@@ -208,11 +217,11 @@ dwc_descriptor_complete(struct dw_dma_chan *dwc, struct dw_desc *desc)
 	 * mapped before they were submitted...
 	 */
 	if (!(txd->flags & DMA_COMPL_SKIP_DEST_UNMAP))
-		dma_unmap_page(dwc->chan.dev.parent, desc->lli.dar, desc->len,
-				DMA_FROM_DEVICE);
+		dma_unmap_page(chan2parent(&dwc->chan), desc->lli.dar,
+			       desc->len, DMA_FROM_DEVICE);
 	if (!(txd->flags & DMA_COMPL_SKIP_SRC_UNMAP))
-		dma_unmap_page(dwc->chan.dev.parent, desc->lli.sar, desc->len,
-				DMA_TO_DEVICE);
+		dma_unmap_page(chan2parent(&dwc->chan), desc->lli.sar,
+			       desc->len, DMA_TO_DEVICE);
 
 	/*
 	 * The API requires that no submissions are done from a
@@ -228,7 +237,7 @@ static void dwc_complete_all(struct dw_dma *dw, struct dw_dma_chan *dwc)
 	LIST_HEAD(list);
 
 	if (dma_readl(dw, CH_EN) & dwc->mask) {
-		dev_err(&dwc->chan.dev,
+		dev_err(chan2dev(&dwc->chan),
 			"BUG: XFER bit set, but channel not idle!\n");
 
 		/* Try to continue after resetting the channel... */
@@ -273,7 +282,7 @@ static void dwc_scan_descriptors(struct dw_dma *dw, struct dw_dma_chan *dwc)
 		return;
 	}
 
-	dev_vdbg(&dwc->chan.dev, "scan_descriptors: llp=0x%x\n", llp);
+	dev_vdbg(chan2dev(&dwc->chan), "scan_descriptors: llp=0x%x\n", llp);
 
 	list_for_each_entry_safe(desc, _desc, &dwc->active_list, desc_node) {
 		if (desc->lli.llp == llp)
@@ -292,7 +301,7 @@ static void dwc_scan_descriptors(struct dw_dma *dw, struct dw_dma_chan *dwc)
 		dwc_descriptor_complete(dwc, desc);
 	}
 
-	dev_err(&dwc->chan.dev,
+	dev_err(chan2dev(&dwc->chan),
 		"BUG: All descriptors done, but channel not idle!\n");
 
 	/* Try to continue after resetting the channel... */
@@ -308,7 +317,7 @@ static void dwc_scan_descriptors(struct dw_dma *dw, struct dw_dma_chan *dwc)
 
 static void dwc_dump_lli(struct dw_dma_chan *dwc, struct dw_lli *lli)
 {
-	dev_printk(KERN_CRIT, &dwc->chan.dev,
+	dev_printk(KERN_CRIT, chan2dev(&dwc->chan),
 			"  desc: s0x%x d0x%x l0x%x c0x%x:%x\n",
 			lli->sar, lli->dar, lli->llp,
 			lli->ctlhi, lli->ctllo);
@@ -342,9 +351,9 @@ static void dwc_handle_error(struct dw_dma *dw, struct dw_dma_chan *dwc)
 	 * controller flagged an error instead of scribbling over
 	 * random memory locations.
 	 */
-	dev_printk(KERN_CRIT, &dwc->chan.dev,
+	dev_printk(KERN_CRIT, chan2dev(&dwc->chan),
 			"Bad descriptor submitted for DMA!\n");
-	dev_printk(KERN_CRIT, &dwc->chan.dev,
+	dev_printk(KERN_CRIT, chan2dev(&dwc->chan),
 			"  cookie: %d\n", bad_desc->txd.cookie);
 	dwc_dump_lli(dwc, &bad_desc->lli);
 	list_for_each_entry(child, &bad_desc->txd.tx_list, desc_node)
@@ -442,12 +451,12 @@ static dma_cookie_t dwc_tx_submit(struct dma_async_tx_descriptor *tx)
 	 * for DMA. But this is hard to do in a race-free manner.
 	 */
 	if (list_empty(&dwc->active_list)) {
-		dev_vdbg(&tx->chan->dev, "tx_submit: started %u\n",
+		dev_vdbg(chan2dev(tx->chan), "tx_submit: started %u\n",
 				desc->txd.cookie);
 		dwc_dostart(dwc, desc);
 		list_add_tail(&desc->desc_node, &dwc->active_list);
 	} else {
-		dev_vdbg(&tx->chan->dev, "tx_submit: queued %u\n",
+		dev_vdbg(chan2dev(tx->chan), "tx_submit: queued %u\n",
 				desc->txd.cookie);
 
 		list_add_tail(&desc->desc_node, &dwc->queue);
@@ -472,11 +481,11 @@ dwc_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
 	unsigned int		dst_width;
 	u32			ctllo;
 
-	dev_vdbg(&chan->dev, "prep_dma_memcpy d0x%x s0x%x l0x%zx f0x%lx\n",
+	dev_vdbg(chan2dev(chan), "prep_dma_memcpy d0x%x s0x%x l0x%zx f0x%lx\n",
 			dest, src, len, flags);
 
 	if (unlikely(!len)) {
-		dev_dbg(&chan->dev, "prep_dma_memcpy: length is zero!\n");
+		dev_dbg(chan2dev(chan), "prep_dma_memcpy: length is zero!\n");
 		return NULL;
 	}
 
@@ -516,7 +525,7 @@ dwc_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
 			first = desc;
 		} else {
 			prev->lli.llp = desc->txd.phys;
-			dma_sync_single_for_device(chan->dev.parent,
+			dma_sync_single_for_device(chan2parent(chan),
 					prev->txd.phys, sizeof(prev->lli),
 					DMA_TO_DEVICE);
 			list_add_tail(&desc->desc_node,
@@ -531,7 +540,7 @@ dwc_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
 		prev->lli.ctllo |= DWC_CTLL_INT_EN;
 
 	prev->lli.llp = 0;
-	dma_sync_single_for_device(chan->dev.parent,
+	dma_sync_single_for_device(chan2parent(chan),
 			prev->txd.phys, sizeof(prev->lli),
 			DMA_TO_DEVICE);
 
@@ -562,7 +571,7 @@ dwc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 	struct scatterlist	*sg;
 	size_t			total_len = 0;
 
-	dev_vdbg(&chan->dev, "prep_dma_slave\n");
+	dev_vdbg(chan2dev(chan), "prep_dma_slave\n");
 
 	if (unlikely(!dws || !sg_len))
 		return NULL;
@@ -570,7 +579,7 @@ dwc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 	reg_width = dws->slave.reg_width;
 	prev = first = NULL;
 
-	sg_len = dma_map_sg(chan->dev.parent, sgl, sg_len, direction);
+	sg_len = dma_map_sg(chan2parent(chan), sgl, sg_len, direction);
 
 	switch (direction) {
 	case DMA_TO_DEVICE:
@@ -587,7 +596,7 @@ dwc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 
 			desc = dwc_desc_get(dwc);
 			if (!desc) {
-				dev_err(&chan->dev,
+				dev_err(chan2dev(chan),
 					"not enough descriptors available\n");
 				goto err_desc_get;
 			}
@@ -607,7 +616,7 @@ dwc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 				first = desc;
 			} else {
 				prev->lli.llp = desc->txd.phys;
-				dma_sync_single_for_device(chan->dev.parent,
+				dma_sync_single_for_device(chan2parent(chan),
 						prev->txd.phys,
 						sizeof(prev->lli),
 						DMA_TO_DEVICE);
@@ -633,7 +642,7 @@ dwc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 
 			desc = dwc_desc_get(dwc);
 			if (!desc) {
-				dev_err(&chan->dev,
+				dev_err(chan2dev(chan),
 					"not enough descriptors available\n");
 				goto err_desc_get;
 			}
@@ -653,7 +662,7 @@ dwc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 				first = desc;
 			} else {
 				prev->lli.llp = desc->txd.phys;
-				dma_sync_single_for_device(chan->dev.parent,
+				dma_sync_single_for_device(chan2parent(chan),
 						prev->txd.phys,
 						sizeof(prev->lli),
 						DMA_TO_DEVICE);
@@ -673,7 +682,7 @@ dwc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,
 		prev->lli.ctllo |= DWC_CTLL_INT_EN;
 
 	prev->lli.llp = 0;
-	dma_sync_single_for_device(chan->dev.parent,
+	dma_sync_single_for_device(chan2parent(chan),
 			prev->txd.phys, sizeof(prev->lli),
 			DMA_TO_DEVICE);
 
@@ -758,8 +767,7 @@ static void dwc_issue_pending(struct dma_chan *chan)
 	spin_unlock_bh(&dwc->lock);
 }
 
-static int dwc_alloc_chan_resources(struct dma_chan *chan,
-		struct dma_client *client)
+static int dwc_alloc_chan_resources(struct dma_chan *chan)
 {
 	struct dw_dma_chan	*dwc = to_dw_dma_chan(chan);
 	struct dw_dma		*dw = to_dw_dma(chan->device);
@@ -770,17 +778,17 @@ static int dwc_alloc_chan_resources(struct dma_chan *chan,
 	u32			cfghi;
 	u32			cfglo;
 
-	dev_vdbg(&chan->dev, "alloc_chan_resources\n");
+	dev_vdbg(chan2dev(chan), "alloc_chan_resources\n");
 
 	/* Channels doing slave DMA can only handle one client. */
-	if (dwc->dws || client->slave) {
+	if (dwc->dws || (client && client->slave)) {
 		if (chan->client_count)
 			return -EBUSY;
 	}
 
 	/* ASSERT:  channel is idle */
 	if (dma_readl(dw, CH_EN) & dwc->mask) {
-		dev_dbg(&chan->dev, "DMA channel not idle?\n");
+		dev_dbg(chan2dev(chan), "DMA channel not idle?\n");
 		return -EIO;
 	}
 
@@ -822,7 +830,7 @@ static int dwc_alloc_chan_resources(struct dma_chan *chan,
 
 		desc = kzalloc(sizeof(struct dw_desc), GFP_KERNEL);
 		if (!desc) {
-			dev_info(&chan->dev,
+			dev_info(chan2dev(chan),
 				"only allocated %d descriptors\n", i);
 			spin_lock_bh(&dwc->lock);
 			break;
@@ -832,7 +840,7 @@ static int dwc_alloc_chan_resources(struct dma_chan *chan,
 		desc->txd.tx_submit = dwc_tx_submit;
 		desc->txd.flags = DMA_CTRL_ACK;
 		INIT_LIST_HEAD(&desc->txd.tx_list);
-		desc->txd.phys = dma_map_single(chan->dev.parent, &desc->lli,
+		desc->txd.phys = dma_map_single(chan2parent(chan), &desc->lli,
 				sizeof(desc->lli), DMA_TO_DEVICE);
 		dwc_desc_put(dwc, desc);
 
@@ -847,7 +855,7 @@ static int dwc_alloc_chan_resources(struct dma_chan *chan,
 
 	spin_unlock_bh(&dwc->lock);
 
-	dev_dbg(&chan->dev,
+	dev_dbg(chan2dev(chan),
 		"alloc_chan_resources allocated %d descriptors\n", i);
 
 	return i;
@@ -860,7 +868,7 @@ static void dwc_free_chan_resources(struct dma_chan *chan)
 	struct dw_desc		*desc, *_desc;
 	LIST_HEAD(list);
 
-	dev_dbg(&chan->dev, "free_chan_resources (descs allocated=%u)\n",
+	dev_dbg(chan2dev(chan), "free_chan_resources (descs allocated=%u)\n",
 			dwc->descs_allocated);
 
 	/* ASSERT:  channel is idle */
@@ -881,13 +889,13 @@ static void dwc_free_chan_resources(struct dma_chan *chan)
 	spin_unlock_bh(&dwc->lock);
 
 	list_for_each_entry_safe(desc, _desc, &list, desc_node) {
-		dev_vdbg(&chan->dev, "  freeing descriptor %p\n", desc);
-		dma_unmap_single(chan->dev.parent, desc->txd.phys,
+		dev_vdbg(chan2dev(chan), "  freeing descriptor %p\n", desc);
+		dma_unmap_single(chan2parent(chan), desc->txd.phys,
 				sizeof(desc->lli), DMA_TO_DEVICE);
 		kfree(desc);
 	}
 
-	dev_vdbg(&chan->dev, "free_chan_resources done\n");
+	dev_vdbg(chan2dev(chan), "free_chan_resources done\n");
 }
 
 /*----------------------------------------------------------------------*/
diff --git a/drivers/dma/fsldma.c b/drivers/dma/fsldma.c
index 0b95dcc..846b579 100644
--- a/drivers/dma/fsldma.c
+++ b/drivers/dma/fsldma.c
@@ -366,8 +366,7 @@ static struct fsl_desc_sw *fsl_dma_alloc_descriptor(
  *
  * Return - The number of descriptors allocated.
  */
-static int fsl_dma_alloc_chan_resources(struct dma_chan *chan,
-					struct dma_client *client)
+static int fsl_dma_alloc_chan_resources(struct dma_chan *chan)
 {
 	struct fsl_dma_chan *fsl_chan = to_fsl_chan(chan);
 
@@ -823,7 +822,7 @@ static int __devinit fsl_dma_chan_probe(struct fsl_dma_device *fdev,
 	 */
 	WARN_ON(fdev->feature != new_fsl_chan->feature);
 
-	new_fsl_chan->dev = &new_fsl_chan->common.dev;
+	new_fsl_chan->dev = fdev->dev;
 	new_fsl_chan->reg_base = ioremap(new_fsl_chan->reg.start,
 			new_fsl_chan->reg.end - new_fsl_chan->reg.start + 1);
 
@@ -927,6 +926,7 @@ static int __devinit of_fsl_dma_probe(struct of_device *dev,
 						- fdev->reg.start + 1);
 
 	dma_cap_set(DMA_MEMCPY, fdev->common.cap_mask);
+	dma_cap_set(DMA_PRIVATE, fdev->common.cap_mask);
 	dma_cap_set(DMA_INTERRUPT, fdev->common.cap_mask);
 	fdev->common.device_alloc_chan_resources = fsl_dma_alloc_chan_resources;
 	fdev->common.device_free_chan_resources = fsl_dma_free_chan_resources;
diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 4f21a51..fc317fe 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -153,26 +153,26 @@ struct fsl_dma_chan {
 #define tx_to_fsl_desc(tx) container_of(tx, struct fsl_desc_sw, async_tx)
 
 #ifndef __powerpc64__
-static u64 in_be64(const u64 __iomem *addr)
+static inline u64 in_be64(const u64 __iomem *addr)
 {
 	return ((u64)in_be32((u32 __iomem *)addr) << 32) |
 		(in_be32((u32 __iomem *)addr + 1));
 }
 
-static void out_be64(u64 __iomem *addr, u64 val)
+static inline void out_be64(u64 __iomem *addr, u64 val)
 {
 	out_be32((u32 __iomem *)addr, val >> 32);
 	out_be32((u32 __iomem *)addr + 1, (u32)val);
 }
 
 /* There is no asm instructions for 64 bits reverse loads and stores */
-static u64 in_le64(const u64 __iomem *addr)
+static inline u64 in_le64(const u64 __iomem *addr)
 {
 	return ((u64)in_le32((u32 __iomem *)addr + 1) << 32) |
 		(in_le32((u32 __iomem *)addr));
 }
 
-static void out_le64(u64 __iomem *addr, u64 val)
+static inline void out_le64(u64 __iomem *addr, u64 val)
 {
 	out_le32((u32 __iomem *)addr + 1, val >> 32);
 	out_le32((u32 __iomem *)addr, (u32)val);
diff --git a/drivers/dma/ioat_dma.c b/drivers/dma/ioat_dma.c
index 6607fdd..e42e1ae 100644
--- a/drivers/dma/ioat_dma.c
+++ b/drivers/dma/ioat_dma.c
@@ -734,8 +734,7 @@ static void ioat2_dma_massage_chan_desc(struct ioat_dma_chan *ioat_chan)
  * ioat_dma_alloc_chan_resources - returns the number of allocated descriptors
  * @chan: the channel to be filled out
  */
-static int ioat_dma_alloc_chan_resources(struct dma_chan *chan,
-					 struct dma_client *client)
+static int ioat_dma_alloc_chan_resources(struct dma_chan *chan)
 {
 	struct ioat_dma_chan *ioat_chan = to_ioat_chan(chan);
 	struct ioat_desc_sw *desc;
@@ -1381,7 +1380,7 @@ static int ioat_dma_self_test(struct ioatdma_device *device)
 	dma_chan = container_of(device->common.channels.next,
 				struct dma_chan,
 				device_node);
-	if (device->common.device_alloc_chan_resources(dma_chan, NULL) < 1) {
+	if (device->common.device_alloc_chan_resources(dma_chan) < 1) {
 		dev_err(&device->pdev->dev,
 			"selftest cannot allocate chan resource\n");
 		err = -ENODEV;
diff --git a/drivers/dma/iop-adma.c b/drivers/dma/iop-adma.c
index 6be3172..df0e37d 100644
--- a/drivers/dma/iop-adma.c
+++ b/drivers/dma/iop-adma.c
@@ -24,7 +24,6 @@
 
 #include <linux/init.h>
 #include <linux/module.h>
-#include <linux/async_tx.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/spinlock.h>
@@ -116,7 +115,7 @@ iop_adma_run_tx_complete_actions(struct iop_adma_desc_slot *desc,
 	}
 
 	/* run dependent operations */
-	async_tx_run_dependencies(&desc->async_tx);
+	dma_run_dependencies(&desc->async_tx);
 
 	return cookie;
 }
@@ -471,8 +470,7 @@ static void iop_chan_start_null_xor(struct iop_adma_chan *iop_chan);
  * greater than 2x the number slots needed to satisfy a device->max_xor
  * request.
  * */
-static int iop_adma_alloc_chan_resources(struct dma_chan *chan,
-					 struct dma_client *client)
+static int iop_adma_alloc_chan_resources(struct dma_chan *chan)
 {
 	char *hw_desc;
 	int idx;
@@ -866,7 +864,7 @@ static int __devinit iop_adma_memcpy_self_test(struct iop_adma_device *device)
 	dma_chan = container_of(device->common.channels.next,
 				struct dma_chan,
 				device_node);
-	if (iop_adma_alloc_chan_resources(dma_chan, NULL) < 1) {
+	if (iop_adma_alloc_chan_resources(dma_chan) < 1) {
 		err = -ENODEV;
 		goto out;
 	}
@@ -964,7 +962,7 @@ iop_adma_xor_zero_sum_self_test(struct iop_adma_device *device)
 	dma_chan = container_of(device->common.channels.next,
 				struct dma_chan,
 				device_node);
-	if (iop_adma_alloc_chan_resources(dma_chan, NULL) < 1) {
+	if (iop_adma_alloc_chan_resources(dma_chan) < 1) {
 		err = -ENODEV;
 		goto out;
 	}
@@ -1255,7 +1253,6 @@ static int __devinit iop_adma_probe(struct platform_device *pdev)
 	spin_lock_init(&iop_chan->lock);
 	INIT_LIST_HEAD(&iop_chan->chain);
 	INIT_LIST_HEAD(&iop_chan->all_slots);
-	INIT_RCU_HEAD(&iop_chan->common.rcu);
 	iop_chan->common.device = dma_dev;
 	list_add_tail(&iop_chan->common.device_node, &dma_dev->channels);
 
diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c
index bcda174..d35cbd1 100644
--- a/drivers/dma/mv_xor.c
+++ b/drivers/dma/mv_xor.c
@@ -18,7 +18,6 @@
 
 #include <linux/init.h>
 #include <linux/module.h>
-#include <linux/async_tx.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/spinlock.h>
@@ -340,7 +339,7 @@ mv_xor_run_tx_complete_actions(struct mv_xor_desc_slot *desc,
 	}
 
 	/* run dependent operations */
-	async_tx_run_dependencies(&desc->async_tx);
+	dma_run_dependencies(&desc->async_tx);
 
 	return cookie;
 }
@@ -607,8 +606,7 @@ submit_done:
 }
 
 /* returns the number of allocated descriptors */
-static int mv_xor_alloc_chan_resources(struct dma_chan *chan,
-				       struct dma_client *client)
+static int mv_xor_alloc_chan_resources(struct dma_chan *chan)
 {
 	char *hw_desc;
 	int idx;
@@ -958,7 +956,7 @@ static int __devinit mv_xor_memcpy_self_test(struct mv_xor_device *device)
 	dma_chan = container_of(device->common.channels.next,
 				struct dma_chan,
 				device_node);
-	if (mv_xor_alloc_chan_resources(dma_chan, NULL) < 1) {
+	if (mv_xor_alloc_chan_resources(dma_chan) < 1) {
 		err = -ENODEV;
 		goto out;
 	}
@@ -1053,7 +1051,7 @@ mv_xor_xor_self_test(struct mv_xor_device *device)
 	dma_chan = container_of(device->common.channels.next,
 				struct dma_chan,
 				device_node);
-	if (mv_xor_alloc_chan_resources(dma_chan, NULL) < 1) {
+	if (mv_xor_alloc_chan_resources(dma_chan) < 1) {
 		err = -ENODEV;
 		goto out;
 	}
@@ -1221,7 +1219,6 @@ static int __devinit mv_xor_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&mv_chan->chain);
 	INIT_LIST_HEAD(&mv_chan->completed_slots);
 	INIT_LIST_HEAD(&mv_chan->all_slots);
-	INIT_RCU_HEAD(&mv_chan->common.rcu);
 	mv_chan->common.device = dma_dev;
 
 	list_add_tail(&mv_chan->common.device_node, &dma_dev->channels);
diff --git a/drivers/dma/pc302_dma.h b/drivers/dma/pc302_dma.h
new file mode 100644
index 0000000..40b2ffa
--- /dev/null
+++ b/drivers/dma/pc302_dma.h
@@ -0,0 +1,234 @@
+/*******************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ ******************************************************************************/
+/*!
+ * \file pc302_dma.h
+ * \brief PC302 DMA Register Definitions and register manipulation macros
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All inquiries to support@picochip.com
+ */
+
+#ifndef __PC302_DMA_H__
+#define __PC302_DMA_H__
+
+/* Channel register offsets from DMA base */
+#define PC302_DMA_N_SRC_ADDR_REG_OFFSET(__N)     (0x000 + (0x058 * (__N)))
+#define PC302_DMA_N_DST_ADDR_REG_OFFSET(__N)     (0x008 + (0x058 * (__N)))
+#define PC302_DMA_N_LLP_REG_OFFSET(__N)          (0x010 + (0x058 * (__N)))
+#define PC302_DMA_N_CTRL_REG_OFFSET(__N)         (0x018 + (0x058 * (__N)))
+#define PC302_DMA_N_BLOCK_SIZE_REG_OFFSET(__N)   (0x01c + (0x058 * (__N)))
+#define PC302_DMA_N_SRC_STATUS_REG_OFFSET(__N)   (0x020 + (0x058 * (__N)))
+#define PC302_DMA_N_DST_STATUS_REG_OFFSET(__N)   (0x028 + (0x058 * (__N)))
+#define PC302_DMA_N_SRC_STATUS_ADDR_REG_OFF(__N) (0x030 + (0x058 * (__N)))
+#define PC302_DMA_N_DST_STATUS_ADDR_REG_OFF(__N) (0x038 + (0x058 * (__N)))
+#define PC302_DMA_N_LOW_CONFIG_REG_OFFSET(__N)   (0x040 + (0x058 * (__N)))
+#define PC302_DMA_N_HIGH_CONFIG_REG_OFFSET(__N)  (0x044 + (0x058 * (__N)))
+#define PC302_DMA_N_SRC_GATHER_REG_OFFSET(__N)   (0x048 + (0x058 * (__N)))
+#define PC302_DMA_N_DST_SCATTER_REG_OFFSET(__N)  (0x050 + (0x058 * (__N)))
+
+/* Control register (CTL.x) 32 LSBs */
+#define PC302_DMA_INT_EN                (1 << 0)
+#define PC302_DMA_DST_TR_WIDTH_SHIFT    (1)
+#define PC302_DMA_DST_TR_WIDTH_MASK     (0x7 << PC302_DMA_DST_TR_WIDTH_SHIFT)
+#define PC302_DMA_SRC_TR_WIDTH_SHIFT    (4)
+#define PC302_DMA_SRC_TR_WIDTH_MASK     (0x7 << PC302_DMA_SRC_TR_WIDTH_SHIFT)
+#define PC302_DMA_DINC_SHIFT            (7)
+#define PC302_DMA_DINC_MASK             (0x3 << PC302_DMA_DINC_SHIFT)
+#define PC302_DMA_SINC_SHIFT            (9)
+#define PC302_DMA_SINC_MASK             (0x3 << PC302_DMA_SINC_SHIFT)
+#define PC302_DMA_DST_MSIZE_SHIFT       (11)
+#define PC302_DMA_DST_MSIZE_MASK        (0x7 << PC302_DMA_DST_MSIZE_SHIFT)
+#define PC302_DMA_SRC_MSIZE_SHIFT       (14)
+#define PC302_DMA_SRC_MSIZE_MASK        (0x7 << PC302_DMA_SRC_MSIZE_SHIFT)
+#define PC302_DMA_SRC_GATHER_EN         (1 << 17)
+#define PC302_DMA_DST_SCATTER_EN        (1 << 18)
+/* Bit 19 is undefined */
+#define PC302_DMA_TT_FC_SHIFT           (20)
+#define PC302_DMA_TT_FC_MASK            (0x7 << PC302_DMA_TT_FC_SHIFT)
+#define PC302_DMA_DMS_SHIFT             (23)
+#define PC302_DMA_DMS_MASK              (0x3 << PC302_DMA_DMS_SHIFT)
+#define PC302_DMA_SMS_SHIFT             (25)
+#define PC302_DMA_SMS_MASK              (0x3 << PC302_DMA_SMS_SHIFT)
+#define PC302_DMA_LLP_DST_EN            (1 << 27)
+#define PC302_DMA_LLP_SRC_EN            (1 << 28)
+/* Bit 31 is undefined */
+
+/* Block size register (CTL.x) 32 MSBs */
+#define PC302_DMA_BLOCK_TS_SHIFT        (0)
+/* Max channel block size = 4095. Number of bits = log2(blk_size+1)= 12 */
+#define PC302_DMA_BLOCK_TS_MASK         (0xFFF << PC302_DMA_BLOCK_TS_SHIFT)
+#define PC302_DMA_DONE                  (1 << 12)
+
+/* Configuration register (CFG.x) LSBs */
+/* bits 4:0 are reserved */
+#define PC302_DMA_CH_PRIOR_SHIFT        (5)
+#define PC302_DMA_CH_PRIOR_MASK         (0xF << PC302_DMA_CH_PRIOR_SHIFT)
+#define PC302_DMA_CH_SUSP               (1 << 8)
+#define PC302_DMA_FIFO_EMPTY            (1 << 9)
+#define PC302_DMA_HS_SEL_DST            (1 << 10)
+#define PC302_DMA_HS_SEL_SRC            (1 << 11)
+#define PC302_DMA_CHAN_LOCK_LEVEL_SHIFT (1 << 12)
+#define PC302_DMA_CHAN_LOCK_LEVEL_MASK  (0x3 << PC302_DMA_CHAN_LOCK_LEVEL_MASK)
+#define PC302_DMA_BUS_LOCK_LEVEL_SHIFT  (1 << 14)
+#define PC302_DMA_BUS_LOCK_LEVEL_MASK   (0x3 << PC302_DMA_BUS_LOCK_LEVEL_SHIFT)
+#define PC302_DMA_DST_HS_POL            (1 << 18)
+#define PC302_DMA_SRC_HS_POL            (1 << 19)
+#define PC302_DMA_MAX_ABRST_SHIFT       (20)
+#define PC302_DMA_MAX_ABRST_MASK        (0x3FF << PC302_DMA_MAX_ABRST_SHIFT)
+#define PC302_DMA_RELOAD_SRC            (1 << 30)
+#define PC302_DMA_RELOAD_DST            (1 << 31)
+
+/* Configuration register (CFG.x) MSBs */
+#define PC302_DMA_FC_MODE               (1 << 0)
+#define PC302_DMA_FIFO_MODE             (1 << 1)
+#define PC302_DMA_PROTCTL_SHIFT         (2)
+#define PC302_DMA_PROTCTL_MASK          (0x7 << PC302_DMA_PROTCTL_SHIFT)
+#define PC302_DMA_DST_UPD_EN            (1 << 5)
+#define PC302_DMA_SRC_UPD_EN            (1 << 6)
+#define PC302_DMA_SRC_PER_SHIFT         (7)
+#define PC302_DMA_SRC_PER_MASK          (0xF << PC302_DMA_SRC_PER_SHIFT)
+#define PC302_DMA_DST_PER_SHIFT         (11)
+#define PC302_DMA_DST_PER_MASK          (0xF << PC302_DMA_DST_PER_SHIFT)
+/* bits 15:31 unused */
+
+/* Scatter and gather (SGR.x) registers LSBs */
+#define PC302_DMA_SG_INTERVAL_SHIFT     (0) /* 20 bit register */
+#define PC302_DMA_SG_INTERVAL_MASK      (0xFFFFF << PC302_DMA_SG_INTERVAL_SHIFT)
+#define PC302_DMA_SG_COUNT_SHIFT        (20)/* 12 bit register */
+#define PC302_DMA_SG_COUNT_MASK         (0xFFF << PC302_DMA_SG_COUNT_SHIFT)
+
+/* Interrupt registers.
+ * There are 5 types of interrupt which have their own register families:
+ *      Transfer complete,
+ *      Block complete,
+ *      Source transfer complete,
+ *      Destination transfer complete, and
+ *      Error 
+ *
+ * An update is made by writing/reading a bit in the appropriate register:
+ *      Raw Interrupt Status registers for reading the status of each bit
+ *      Processed Interrupt Status registers
+ *      Interrupt Mask registers
+ *      Interrupt Clear registers
+ *
+ * The following tables gives the address of each register:
+ *  -----------------------------------------------------------------------
+ * | Operation          |                Interrupt Type                    |
+ * |                    | Transfer |  Block  | SRC T/F | DST T/F |  Error  |
+ * |                    |----------|---------|---------|---------|---------|
+ * |Raw Status (R)      |  0x2c0   |  0x2c8  |  0x2d0  |  0x2d8  |  0x2e0  |
+ * |Processed Status (R)|  0x2e8   |  0x2f0  |  0x2f8  |  0x300  |  0x308  |
+ * |Mask (R/W)          |  0x310   |  0x318  |  0x320  |  0x328  |  0x330  |
+ * |Clear (W)           |  0x338   |  0x340  |  0x348  |  0x350  |  0x358  |
+ *  -----------------------------------------------------------------------
+ *
+ * The following 5 macros can be used to access all 20 registers. O is one
+ * of the operation macros defined below.
+ */ 
+#define PC302_DMA_TXFER_COMPLETE_REG_OFFSET(__O)     (0x2c0 + (__O))
+#define PC302_DMA_BLOCK_COMPLETE_REG_OFFSET(__O)     (0x2c8 + (__O))
+#define PC302_DMA_SRC_TRX_COMPLETE_REG_OFFSET(__O)   (0x2d0 + (__O))
+#define PC302_DMA_DST_TRX_COMPLETE_REG_OFFSET(__O)   (0x2d8 + (__O))
+#define PC302_DMA_ERROR_REG_OFFSET(__O)              (0x2e0 + (__O))
+
+/* Interrupt operation macros */
+#define PC302_DMA_INTERRUPT_RAW                      (0x028 * 0)
+#define PC302_DMA_INTERRUPT_STATUS                   (0x028 * 1)
+#define PC302_DMA_INTERRUPT_MASK                     (0x028 * 2)
+#define PC302_DMA_INTERRUPT_CLEAR                    (0x028 * 3)
+
+/* Interrupt mask channel macros
+ * Bits 0:PC302_DMA_CHANNELS-1  = enable / disable
+ * Bits PC302_DMA_CHANNELS:7    = reserved
+ * Bits 8:7+PC302_DMA_CHANNELS  = Corresponding write enable bit
+ * Bits 8+PC302_DMA_CHANNELS:63 = unused
+ */
+#define PC302_DMA_IRQ_ENABLE_CHANNEL(__N)            (0x0101 << (__N))
+#define PC302_DMA_IRQ_DISABLE_CHANNEL(__N)           (0x0100 << (__N))
+
+/* Interrupt clear macro */
+#define PC302_DMA_IRQ_CHANNEL(__N)                   (0x1 << (__N))
+
+/* Interrupt status register */
+#define PC302_DMA_IRQ_STATUS_REG_OFFSET              (0x360)
+
+/* Interrupt status bits */
+#define PC302_DMA_STATUS_TFR                         (1 << 0)
+#define PC302_DMA_STATUS_BLOCK                       (1 << 1)
+#define PC302_DMA_STATUS_SRCT                        (1 << 2)
+#define PC302_DMA_STATUS_DSTT                        (1 << 3)
+#define PC302_DMA_STATUS_ERR                         (1 << 4)
+#define PC302_DMA_STATUS_IRQ_TYPES                   (5)
+/* Bits 5 to 63 are unused */
+
+/*
+ * Software handshaking registers.
+ * Three types of S/W handshaking is permitted, controlled by either the
+ * source or destination; burst (software), single, or last. This results in
+ * 6 registers:
+ *     Source Software Transaction Request           (0x368)
+ *     Destination Software Transaction Request      (0x370)
+ *     Single Source Transaction Request             (0x378)
+ *     Single Destination Transacion Request         (0x380) 
+ *     Last Source Transaction Request               (0x388)
+ *     Last Destination Transaction Request          (0x390)
+ *
+ * The following macros allows the transfer controller to be addressed.
+ * S is the software control type specified by the macros listed below.
+ */
+#define PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(__S)    (0x368 + (__S))
+#define PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(__S)    (0x370 + (__S))
+
+/* Software flow control macros */
+#define PC302_DMA_BURST_TRANSFER                     (0x010 * 0)
+#define PC302_DMA_SINGLE_TRANSFER                    (0x010 * 1)
+#define PC302_DMA_LAST_TRANSFER                      (0x010 * 2)
+
+/*
+ * Software flow Transaction request channel bits 
+ * Bits 0:PC302_DMA_CHANNELS-1  = enable
+ * Bits PC302_DMA_CHANNELS:7    = reserved
+ * Bits 8:7+PC302_DMA_CHANNELS  = Corresponding write enable bit
+ * Bits 8+PC302_DMA_CHANNELS:63 = unused
+ */
+#define PC302_DMA_REQ_CHANNEL(__N)                   (0x0101 << (__N))
+
+/* Miscellaneous registers */
+#define PC302_DMA_CONFIGURATION_REG_OFFSET           (0x398)
+#define PC302_DMA_CHANNEL_ENABLE_REG_OFFSET          (0x3a0)
+#define PC302_DMA_ID_REG_OFFSET                      (0x3a8)
+#define PC302_DMA_TEST_REG_OFFSET                    (0x3b0)
+
+/* DMA configuration (DmaCfgReg) register bits */
+#define PC302_DMA_ENABLE                             (0x01)
+/* bits 1:63 are unused */
+
+/* Channel (ChEnReg) enable/disable bits
+ * Bits 0:PC302_DMA_CHANNELS-1  = enable/disable
+ * Bits PC302_DMA_CHANNELS:7    = reserved
+ * Bits 8:7+PC302_DMA_CHANNELS  = Corresponding write enable bit
+ * Bits 8+PC302_DMA_CHANNELS:63 = unused
+ */
+#define PC302_DMA_ENABLE_CHANNEL(__N)                (0x0101 << (__N))
+#define PC302_DMA_DISABLE_CHANNEL(__N)               (0x0100 << (__N))
+#define PC302_DMA_CHANNEL(__N)                       (0x01 << (__N))
+
+/* Channels per controller */
+#define PC302_DMA_CHANNELS                           (8)
+
+/* Hardware handshaking interfaces per controller */
+#define PC302_DMA_HANDSHAKING_IFS                    (8)
+
+/* Four DMA masters per controller */
+#define PC302_DMA_MASTERS                            (4)
+
+/* Two DMAs in the system */
+#define PC302_NUM_OF_DMAS                            (2)
+
+#endif /* __PC302_DMA_H__ */
diff --git a/drivers/dma/pc302_dmac.c b/drivers/dma/pc302_dmac.c
new file mode 100644
index 0000000..d26ec92
--- /dev/null
+++ b/drivers/dma/pc302_dmac.c
@@ -0,0 +1,4016 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+ * \file pc302_dmac.c
+ * \brief This module provides the interface to the low level DMA functionality.
+ *
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All inquiries to support@picochip.com
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/autoconf.h>
+
+#include <mach/io.h>
+#include <mach/hardware.h>
+
+#include <mach/pc302_dmac.h>
+#include "pc302_dma.h"
+
+/*****************************************************************************
+ * Magic numbers
+ *****************************************************************************/
+
+/*!
+ * A name for this module
+ */
+#define TITLE "PC302 DMA Controller Driver"
+
+/*!
+ *  The name of the driver used in the system
+ */
+#define CARDNAME "pc302-dmac"
+
+/*!
+ * Defininition of sucess and fail
+ */
+#define SUCCESS               (0)
+#define FAIL                  (1)
+
+/*****************************************************************************
+ * Macros
+ *****************************************************************************/
+
+/*!
+ * The following macro must be set if paths not yet verified on hardware are
+ * to be enabled
+ */
+#undef PC302_DMA_ENABLE_UNTESTED_PATHS
+
+/*!
+ * The following macro should be defined and set to the appropriate level
+ * if debugging is required by default
+ */
+#define PC302_DMA_DEBUG_LEVEL (0)
+
+/*!
+ * Define the size of the tasklet FIFO
+ */
+#define PC302_DMA_FIFO_SIZE   (32)
+
+/*!
+ * Debugging macro - print warning messages
+ */
+#define PRINTD(dma, level, format, ...)  \
+    do {\
+        if (dma->lvl >= level)\
+        {\
+            printk("%s : " format, __FUNCTION__, ##__VA_ARGS__);\
+        }\
+    } while(0)
+
+/*!
+ * Print error message.
+ */
+#define PRINTE(format, ...) \
+    do {\
+        printk("%s %s %d:" format, __FILE__, __FUNCTION__, __LINE__, \
+                 ##__VA_ARGS__);\
+        WARN_ON(1); \
+    } while(0)
+
+/*!
+ * Print error message.
+ */
+#define PRINTE_RATELIMIT(format, ...) \
+    do {\
+        if (printk_ratelimit()) \
+        { \
+            printk("%s %s %d:" format, __FILE__, __FUNCTION__, __LINE__, \
+                 ##__VA_ARGS__);\
+            WARN_ON(1); \
+        } \
+    } while (0)
+
+/*!
+ * Macro that can be used to determine if the DMA handle and engine are enabled.
+ */
+#define DMA_ENGINE_ENABLED(__dma) \
+    ((__dma != NULL) && \
+        ((pc302_dma_ioread32(__dma, PC302_DMA_CONFIGURATION_REG_OFFSET) & \
+            PC302_DMA_ENABLE)))
+
+/*!
+ * Macro that can be used to check that a transfer handle is not NULL. 
+ */
+#define TRANSFER_HANDLE_ENABLED(__dma_xfr) (__dma_xfr != NULL)
+
+/*!
+ * Macro that can be used to check that a transfer list handle is not NULL.
+ */
+#define TRANSFER_LIST_HANDLE_ENABLED(__list) (__list != NULL)
+
+/*!
+ * Time-out for waiting for the FIFO to empty when stopping a DMA
+ * (in jiffies).
+ * Note: Make this small as it is used in a busy-waiting loop.
+ */
+#define ABORT_TIMEOUT       (HZ / 100)      /* Board timeout */
+
+/*!
+ * Calculate the number of bytes per transaction for a given endpoint.
+ */
+#define TR_BYTES(__E)       (1 << __E->tr_width)
+
+/*!
+ * BURST_BYTES macro calculates the number of bytes per burst transfer, 
+ * given an endpoint.  msize_lookup converts from the pc302_dma_msize_t
+ * enum to transfer width multiplier
+ */
+#define BURST_BYTES(__E) \
+               (TR_BYTES(__E) * pc302_dma_msize_lookup[__E->msize])
+
+/*!
+ * Check that the number of bytes left is not divisible by the transfer width
+ */
+#define BURST_NOT_DIVISIBLE_BY_TRANSFER_WIDTH(__E, __COUNT) \
+    ((((__COUNT)/TR_BYTES(__E)) * TR_BYTES(__E)) != __COUNT)
+
+/*!
+ * Read the specified hex digit and place the value in the 4 LSBs
+ */
+#define READ_HEX_DIGIT(__value, __digit) ((__value >> (4 * __digit)) & 0xF)
+
+/*!
+ * Print channel registers
+ */
+#define PRINT_CH_REG(__name, __offset) \
+    ( { \
+        reg = pc302_dma_ioread32(dma, __offset); \
+        printk("    %16s: ch0(%u) ch1(%u) ch2(%u) ch3(%u)\n", __name, \
+            reg&PC302_DMA_CHANNEL(0)?1:0, reg&PC302_DMA_CHANNEL(1)?1:0, \
+            reg&PC302_DMA_CHANNEL(2)?1:0, reg&PC302_DMA_CHANNEL(3)?1:0); \
+    } )
+
+/*!
+ * Print register
+ */
+#define PRINT_REG(__name, __offset) \
+    ( { \
+        reg = pc302_dma_ioread32(dma, __offset);  \
+        printk("    %16s: 0x%08x\n", __name, reg); \
+    } )
+
+/*!
+ * Print bit
+ */
+#define PRINT_BIT(__name, __mask) \
+    ( printk("                %16s: %u\n", __name, reg & __mask ?1:0) )
+
+/*!
+ * Print field
+ */
+#define PRINT_FIELD(__name, __mask, __shift) \
+    (printk("                %16s: 0x%08x\n", __name, \
+        (reg & __mask) >> __shift))
+
+/*!
+ * Print a register from a link list descriptor
+ */
+#define PRINT_LLP_REG(__name, __field) \
+    ( { \
+        printk("                %16s: 0x%08x\n", __name, ioread32(__field)); \
+    } )
+
+/*!
+ * Report an error through a U32
+ */
+#define ERROR_INDICATED         ((u32)(0xFFFFFFFF))
+
+/*****************************************************************************
+ * Private data structure & types
+ *****************************************************************************/
+/*!
+ * Definition of the transfer type
+ * This applies to the CTLx.TT_FC bits and is used to define the transfer type
+ * and flow controller
+ */
+typedef enum
+{
+    /** Memory to memory transfer, DMA is the flow controller */
+    PC302_DMA_MEM_TO_MEM_DMAC_CTRL = 0x0, 
+
+    /** Memory to peripheral transfer, DMA is the flow controller */
+    PC302_DMA_MEM_TO_PER_DMAC_CTRL = 0x1, 
+
+    /** Peripheral to memory transfer, DMA is the flow controller */
+    PC302_DMA_PER_TO_MEM_DMAC_CTRL = 0x2, 
+
+    /** Peripheral to peripheral transfer, DMA is the flow controller */
+    PC302_DMA_PER_TO_PER_DMAC_CTRL = 0x3, 
+
+    /** Peripheral to memory transfer, Source is the flow controller */
+    PC302_DMA_PER_TO_MEM_SRC_CTRL = 0x4, 
+
+    /** Peripheral to peripheral transfer, Source is the flow controller */
+    PC302_DMA_PER_TO_PER_SRC_CTRL = 0x5, 
+
+    /** Memory to peripheral transfer, Destination is the flow controller */
+    PC302_DMA_MEM_TO_PER_DST_CTRL = 0x6, 
+
+    /** Peripheral to peripheral transfer, Destination is the flow
+        controller */
+    PC302_DMA_PER_TO_PER_DST_CTRL = 0x7, 
+
+    /** Placeholder - used to determine the number of transfer types
+        available */
+    PC302_DMA_TRANSFER_TYPES
+}
+pc302_dma_tt_fc_t;
+#define PC302_DMA_TRANSFER_TYPES_RANGE_FAIL (PC302_DMA_TRANSFER_TYPES)
+
+/*!
+ * Transaction type for end points
+ */
+typedef enum
+{
+    /** Undefined transaction type */
+    TRT_NONE = 0x0, 
+
+    /** Burst transaction*/
+    TRT_BURST = 0x1, 
+
+    /** Single bus width transaction */
+    TRT_SINGLE = 0x2, 
+
+    /** Last transaction in the block */
+    TRT_LAST = 0x4
+}
+transaction_type_t;
+
+/*!
+ * Transfer status
+ */
+typedef enum
+{
+    /** Transfer stopped */
+    STOPPED, 
+
+    /** Transfer running */
+    RUNNING, 
+
+    /** Transfer stopping */
+    STOPPING
+} transfer_state_t;
+
+/*!
+ * This structure holds the hardware descriptor at the start (the LLP [Link
+ * List Pointer] will point to this), and additional information required
+ * to manage the DMA.
+ */
+typedef struct
+{
+    struct /* Hardware descriptor                                             */
+    {
+        u32 source_addr;             /*!< LLI.SARx                            */
+        u32 dest_addr;               /*!< LLI.DARx                            */
+        u32 link;                    /*!< LLI.LLPx                            */
+        u32 control;                 /*!< LLI.CTLx[31:0]                      */
+        u32 block_ts;                /*!< LLI.CTLx[63:32]                     */
+        u32 sstat;                   /*!< LLI.SSTATx                          */
+        u32 dstat;                   /*!< LLI.DSTATx                          */
+    }
+    hw;
+    struct/* Software descriptor                                              */
+    {
+        pc302_dma_endpoint_t src;    /*!< The source endpoint                 */
+        pc302_dma_endpoint_t dst;    /*!< The destination endpoint            */
+        size_t count;                /*!< Bytes to transfer                   */
+    }
+    sw;
+} __attribute__ ((__aligned__(4))) descriptor_t;
+
+/*!
+ * Internal state associated with a DMA transfer. Each client will construct
+ * one of these structures using the API functions prior to data transfer
+ */
+struct pc302_dma_xfr_tag
+{
+    void *cookie;                       /*!< Client context                   */
+    pc302_dma_list_t list;              /*!< Multi-block list or NULL if direct
+                                           xfr                                */
+    pc302_dma_t dma;                    /*!< Link to the engine context       */
+    unsigned channel;                   /*!< The channel number used for this
+                                           transfer                           */
+    transfer_state_t state;             /*!< The current state of the transfer*/
+    pc302_dma_endpoint_t src;           /*!< The source endpoint              */
+    pc302_dma_endpoint_t dst;           /*!< The destination endpoint         */
+    pc302_dma_handshake_t src_handshake;/*!< Params for src                   */
+    pc302_dma_handshake_t dst_handshake;/*!< Params for dst                   */
+    unsigned src_hw_handshaking_on;     /*!< Is src hardware handshaking on?  */
+    unsigned dst_hw_handshaking_on;     /*!< Is dst hardware handshaking on?  */
+    pc302_dma_sg_t gather;              /*!< Source gather parameters         */
+    pc302_dma_sg_t scatter;             /*!< Destination scatter parameters   */
+    size_t count;                       /*!< Bytes to transfer                */
+    u32 flags;                          /*!< The transfer flags               */
+    u32 config_low;                     /*!< Mirror of low CFGx register      */
+    u32 config_high;                    /*!< Mirror of high CFGx register     */
+};
+
+/*!
+ * Structure for storing the DMA internal state. One of these exists for each
+ * DMA engine in the system and is shared by all clients.  Consequently client
+ * processes need to be very careful in what they do with this structure and
+ * only use the API functions to alter parameters for the channels they are
+ * using. The only exception will be the turning off, on, up, or down of
+ * debugging information via the lvl parameter (and pc302_dma_set_debug_level()
+ * function)
+ */
+struct pc302_dma_tag
+{
+    void __iomem *membase;           /*!< Virtual base address of the DMA     */
+    int id;                          /*!< DMA ID                              */
+    struct
+    {
+        int ( *handler )( void *cookie, int errno );
+                                     /*!< Handler function ptr for channel    */
+        struct pc302_dma_xfr_tag
+                           transfer; /*!< Channel Transfer parameters         */
+    }
+    channel[PC302_DMA_CHANNELS];
+    spinlock_t spinlock;             /*!< Thread synchronisation              */
+    struct device *device;           /*!< Pointer to the physical device      */
+    unsigned lvl;                    /*!< The Debug level. Set globally at
+                                        compile time, or defined dynamically  */
+    unsigned last_int_channel;       /*!< The last interrupt channel found    */
+    u32 handshaking_inuse;           /*!< Bit field indicating which H/W
+                                         interfaces are in use                */
+    u32 allocatedChannels;           /*!< Bit field indicating which channels
+                                         are  allocated                       */
+    u32 allocatedInterrupts;         /*!< Bit field indicating which channels
+                                        are allocated to receive interrupts   */
+    struct tasklet_struct tasklet;   /*!< Tasklet for the servicing interrupts*/
+    struct
+    {
+        pc302_dma_xfr_t dma_xfr;
+        int irq_type;
+        unsigned int_channel;
+    }
+    fifo[PC302_DMA_FIFO_SIZE];       /*!< FIFO for queuing deferred interrupt
+                                        handling                             */
+    unsigned readPtr;                /*!< FIFO read pointer                  */
+    unsigned writePtr;               /*!< FIFO write pointer                 */
+};
+
+/*!
+ * Internal state associated with a DMA multi-block list
+ */
+struct pc302_dma_list_tag
+{
+    descriptor_t *descriptor_list;   /*!< Pointer the HW/SW list              */
+    dma_addr_t dma_descriptor_list;  /*!< DMA address of the list             */
+    unsigned length;                 /*!< Total list items                    */
+    unsigned items;                  /*!< Current used items                  */
+    descriptor_t *last_desc;         /*!< Pointer to the last in the list     */
+    pc302_dma_t dma;                 /*!< Link to the engine context          */
+    pc302_dma_xfr_t dma_xfr;         /*!< Transfer associated with the list   */
+    unsigned is_multi_block_src;     /*!< 1 if the source is a multi-block list.
+                                        0 if the transfer is multi-block with
+                                        auto-reload or continuous set         */
+    unsigned is_multi_block_dst;     /*!< 1 if the destination is a multi-block
+                                        list type. 0 if the transfer is multi-
+                                        block with auto-reload or continuous  */
+    descriptor_t *current_block;     /*!< When running holds the block currently
+                                        transferring                          */
+    struct device *device;           /*!< Pointer to the device               */
+};
+
+/*****************************************************************************
+ * Global variables & module parameters
+ *****************************************************************************/
+
+/*!
+ * Burst size look up table.
+ * This table contains a list of supported burst sizes for the DMA. The DMA
+ * FIFOs are 32 bytes which defines the maximum size.
+ */
+static u32 pc302_dma_msize_lookup[PC302_DMA_MS_AUTO] =
+{
+    1,    /*!< 1 word transfer width (Corresponding to PC302_DMA_MS_1_TRW)    */
+    4,    /*!< 4 word transfer width (Corresponding to PC302_DMA_MS_4_TRW)    */
+    8,    /*!< 8 word transfer width (Corresponding to PC302_DMA_MS_8_TRW)    */
+    16,   /*!< 16 word transfer width (Corresponding to PC302_DMA_MS_16_TRW)  */
+    32     /*!< 32 word (maximum) transfer width (Corresponding to
+              PC302_DMA_MS_32_TRW)                                            */
+};
+
+/*!
+ * Bus width loop up table
+ * This table is used to determine the maximum possible burst width for each
+ * master on each DMA. Master 4 on DMAC2 only supports a bus widths of up to
+ * 32 bits.The table takes the form:
+ *            Max Bus width[DMAC number][Master number]
+ */
+static pc302_tr_width_t
+    pc302_dma_buswidth_lookup[PC302_NUM_OF_DMAS][PC302_DMA_MASTERS] =
+    {
+         {
+             PC302_DMA_TR_WIDTH64, /*!< DMA 1 master 1 - max width = 64 bits  */
+             PC302_DMA_TR_WIDTH64, /*!< DMA 1 master 2 - max width = 64 bits  */
+             PC302_DMA_TR_WIDTH64, /*!< DMA 1 master 3 - max width = 64 bits  */
+             PC302_DMA_TR_WIDTH64, /*!< DMA 1 master 4 - max width = 64 bits  */
+         }, 
+         {
+             PC302_DMA_TR_WIDTH64, /*!< DMA 2 master 1 - max width = 64 bits  */
+             PC302_DMA_TR_WIDTH64, /*!< DMA 2 master 2 - max width = 64 bits  */
+             PC302_DMA_TR_WIDTH64, /*!< DMA 2 master 3 - max width = 64 bits  */
+             PC302_DMA_TR_WIDTH32  /*!< DMA 2 master 4 - max width = 32 bits  */
+         }
+     };
+
+/*!
+ * Hardware interface lookup table
+ * This table is used to determine which hardware interfaces may be used with
+ * each master on each DMA. This table does not provide complete checking. It
+ * is impossible to determine if the end point address is consistent with the
+ * hardware selected interface selected. What can be checked is that the
+ * hardware interface exists and can be used with the master chosen. The table
+ * takes the form:
+ *    Masters supported[DMAC][H/W interface number]
+ *          where Masters supported is logic OR of the following bit fields:
+ *                 0001 -> PC302_DMA_MASTER1 supported
+ *                 0010 -> PC302_DMA_MASTER2 supported
+ *                 0100 -> PC302_DMA_MASTER3 supported
+ *                 1000 -> PC302_DMA_MASTER4 supported
+ */
+static u32 pc302_dma_hw_if_support_lookup
+    [PC302_NUM_OF_DMAS][PC302_DMA_HANDSHAKING_IFS] =
+        {
+            {
+                0xF,   /*!< DMA 1 Interface 0 -> All masters supported        */
+                0xF,   /*!< DMA 1 Interface 1 -> All masters supported        */
+                0xF,   /*!< DMA 1 Interface 2 -> All masters supported        */
+                0xF,   /*!< DMA 1 Interface 3 -> All masters supported        */
+                0xF,   /*!< DMA 1 Interface 4 -> All masters supported        */
+                0xF,   /*!< DMA 1 Interface 5 -> All masters supported        */
+                0xF,   /*!< DMA 1 Interface 6 -> All masters supported        */
+                0xF     /*!< DMA 1 Interface 7 -> All masters supported       */
+            }, 
+            {
+                0x0,   /*!< DMA 2 Interface 0 -> Not connected                */
+                0x0,   /*!< DMA 2 Interface 1 -> Not connected                */
+                0x0,   /*!< DMA 2 Interface 2 -> Not connected                */
+                0x0,   /*!< DMA 2 Interface 3 -> Not connected                */
+                0x0,   /*!< DMA 2 Interface 4 -> Not connected                */
+                0x8,   /*!< DMA 2 Interface 5 -> Only Master 4 supported      */
+                0x8,   /*!< DMA 2 Interface 6 -> Only Master 4 supported      */
+                0x8     /*!< DMA 2 Interface 7 -> Only Master 4 supported     */
+            }
+        };
+
+/*!
+ * Transfer Type / Flow Controller encoding table.
+ * The index number corresponds to the transfer type as specified in the
+ * pc302_dma_tt_fc_t enumeration. Using this table the transfer type can be
+ * determined from the source and destination end point parameters.
+ * Note: Some of these paths have not been tested on hardware and cannot be
+ * used unless the PC302_DMA_ENABLE_UNTESTED_PATHS macro is set.
+ */
+struct pc302_dma_tt_fc_lookup_tag
+{
+    struct {
+        unsigned char src_periph;   /*!< Source is peripheral not memory      */
+        unsigned char src_fc;       /*!< Source is a flow controller          */
+        unsigned char dst_periph;   /*!< Destination is peripheral not memory */
+        unsigned char dst_fc;       /*!< Destination is a flow controller     */
+    }
+    path;
+    unsigned tested;                /*!< Whether this path has been tested    */
+}
+static pc302_dma_tt_fc_lookup[PC302_DMA_TRANSFER_TYPES] =
+{
+    {{0, 0, 0, 0}, 1},    /*!< Memory to Memory,        DMA Flow Controller   */
+    {{0, 0, 1, 0}, 1},    /*!< Memory to Peripheral,    DMA Flow Controller   */
+    {{1, 0, 0, 0}, 1},    /*!< Peripheral to Memory,    DMA Flow Controller   */
+    {{1, 0, 1, 0}, 0},    /*!< Peripheral to Peripheral, DMA Flow Controller  */
+    {{1, 1, 0, 0}, 0},    /*!< Peripheral to Memory,    SRC Flow Controller   */
+    {{1, 1, 1, 0}, 0},    /*!< Peripheral to Peripheral, SRC Flow Controller  */
+    {{0, 0, 1, 1}, 0},    /*!< Memory to Peripheral,    DST Flow Controller   */
+    {{1, 0, 1, 1}, 0}     /*!< Peripheral to Peripheral, DST Flow Controller  */
+};
+
+/*!
+ * Keep a copy of platform handles for internal use 
+ */
+struct
+{
+    struct platform_device *dev;
+    pc302_dma_t dma;
+}
+static dmac[PC302_NUM_OF_DMAS];
+ 
+/*****************************************************************************
+ * Private function prototypes
+ *****************************************************************************/
+
+/*!
+ * \brief Initialise the DMA engine and enable it
+ *
+ * Post-conditions:
+ *   1. DMA engine enabled
+ *   2. All channels disabled.
+ *
+ * \param dma The DMA handle
+ */
+static void
+pc302_dma_hw_initialise(pc302_dma_t dma);
+
+/*!
+ * \brief Disable the DMA hardware
+ *
+ * Post-conditions:
+ *   1. DMA engines disabled.
+ *
+ * \param dma The DMA handle
+ *
+ * Notes:
+ *   The DMA channel will not be disabled immediately. The DMA will continue
+ *   any transfers in progress and then stop
+ *
+ */
+static void
+pc302_dma_hw_shutdown(pc302_dma_t dma);
+
+/*!
+ * \brief Allocate a transfer
+ *
+ * Pre-conditions:
+ *   1. The engine is initialised.
+ *
+ * Post-conditions:
+ *   1. One of the DMA channels is marked as in use
+ *   2. The associated transfer is initialised.
+ *
+ * \param dma The DMA handle
+ * \param handler The callback function pointer
+ *
+ * \return The allocated transfer handle, NULL on error
+*/
+__must_check static pc302_dma_xfr_t
+pc302_dma_alloc_xfr(pc302_dma_t dma, 
+                    int ( *handler )( void *cookie,
+                                      int errno ) );
+
+/*!
+ * \brief Release a transfer and its DMA channel so that it becomes available to
+ * be allocated.
+ *
+ * Pre-conditions:
+ *   1. The transfer is allocated by pc302_dma_alloc_xfr.
+ *
+ * Post-conditions:
+ *   1. The transfer is available for allocation. Any hardware interfaces
+ *      that were used by the transfer are made available.
+ *
+ * \param dma_xfr The transfer handle
+ */
+static void
+pc302_dma_free_xfr(pc302_dma_xfr_t dma_xfr);
+
+/*!
+ * \brief Allocate the list for multi-block transfers
+ *
+ * Post-conditions:
+ *   1. Heap memory allocated
+ *   2. The allocated list is initialised
+ *
+ * \param dma The DMA handle
+ * \param count The maximum number of elements for the list
+ *
+ * \return Pointer to the newly allocated list, NULL on error
+*/
+__must_check static pc302_dma_list_t
+pc302_dma_alloc_list(pc302_dma_t dma, 
+                     size_t count);
+
+/*!
+ * \brief Calculate the Transfer Type and Flow control field values.
+ *
+ * Given the periph_not_mem and flow controller flags for the source and
+ * destination endpoints, work out the TT_FC field value.
+ *
+ * Pre-conditions:
+ *   1. Memory endpoints must not be flow controllers.
+ *   2. Source and destination endpoints cannot be both flow controllers.
+ *
+ * Notes:
+ *   1. If both src_fc and dst_fc are unset, it is assumed that DMA flow
+ *      control is required
+ *
+ * \param dma The DMA handle
+ * \param src_periph 1 for source is a peripheral, 
+ *                   0 for source is a memory
+ * \param src_fc     1 for source is the flow controller
+ * \param dst_periph 1 for destination is a peripheral, 
+ *                   0 for memory is a peripheral
+ * \param dst_fc     1 for destination is the flow controller
+ *
+ * \return           Any element from pc302_dma_tt_fc_t, or 0 on no match
+ */
+__must_check static pc302_dma_tt_fc_t
+pc302_dma_lookup_tt_fc(pc302_dma_t dma, 
+                       unsigned src_periph, 
+                       unsigned src_fc, 
+                       unsigned dst_periph, 
+                       unsigned dst_fc);
+
+/*!
+ * \brief Build the contents of the control register (CTL[0:32]) given a source
+ * and destination endpoint.
+ *
+ * Pre-conditions:
+ *   1. The source and destination endpoints are valid.
+ *
+ * Notes:
+ *   1. The DMA_LLP_SRC_EN and DMA_LLP_DST_EN bits are set by the
+ *      pc302_dma_build_llp_control_register function so that we do not set
+ *      these bits when used for the last element of a multi-block list.
+ *
+ * \param dma DMA handle
+ * \param src Source endpoint parameters
+ * \param dst Destination endpoint parameters
+ *
+ * \return SUCCESS or -EINVAL for Invalid parameter
+ */
+__must_check static u32
+pc302_dma_build_control_register(pc302_dma_t dma, 
+                                 pc302_dma_endpoint_t *src, 
+                                 pc302_dma_endpoint_t *dst);
+
+/*!
+ * \brief Build the contents of the control register source / dest block
+ * chaining bits for the link list.
+ *
+ * Pre-conditions:
+ *   1. A valid list must be provided
+ *
+ * \param dma DMA handle
+ * \param list Pointer to a valid transfer list
+ *
+ * \return The 32-bit value to be programmed into the control register
+ */
+__must_check static u32
+pc302_dma_build_llp_control_register(pc302_dma_t dma, 
+                                     pc302_dma_list_t list);
+
+/*!
+ * \brief Build the contents of the control register (CTL[0:32]) from a source
+ * and destination endpoint
+ *
+ * Pre-conditions:
+ *   1. The transfer is not running.
+ *   2. The transfer is valid.
+ *
+ * Post-conditions:
+ *   1. DMA registers are written.
+ *
+ * Notes:
+ *   1. For linked list transfers, the list is allocated and setup in the
+ *      transfer.
+ * \param dma_xfr   - The transfer handle
+ *
+ * \return SUCCESS, or -EINVAL on error
+*/
+__must_check static int
+pc302_dma_update_xfr_registers(pc302_dma_xfr_t dma_xfr);
+
+/*!
+ * \brief Get/update the current state of a DMA transfer
+ *
+ * Pre-conditions:
+ *   1. The transfer is allocated and initialised.
+ *
+ * Post-conditions:
+ *   1. The transfer state is updated if the hardware indicates that it is
+ *      not running
+ *
+ * Notes:
+ *   1. Transfers are started in software and can stop in hardware. This
+ *      function gets the combined state.
+ *
+ * \param dma_xfr   - The transfer handle
+ *
+ * \return            The transfer state
+ */
+__must_check static transfer_state_t
+pc302_dma_get_xfr_state(pc302_dma_xfr_t dma_xfr);
+
+/*!
+ * \brief Configure one or more interrupt registers in one operation
+ *
+ * Pre-conditions:
+ *   1. The engine is initialised.
+ *
+ * Post-conditions:
+ *   1. Several interrupt registers are updated
+ *
+ * \param dma The engine context
+ * \param irq_types A bit-field of the interrupt types to be configured.
+ *                  Any combination of dma_irq_type_t:
+ *                      PC302_DMA_INT_BLOCK, 
+ *                      PC302_DMA_INT_DST_TRANSACTION, 
+ *                      PC302_DMA_INT_ERROR, 
+ *                      PC302_DMA_INT_SRC_TRANSACTION, 
+ *                      PC302_DMA_INT_TRANSFER, 
+ *                      PC302_DMA_INT_ALL
+ * \param operation_type Operation to perform. Any of:
+ *                         PC302_DMA_INTERRUPT_RAW (read status register), 
+ *                         PC302_DMA_INTERRUPT_STATUS (read masked interrupts), 
+ *                         PC302_DMA_INTERRUPT_MASK (set/clear mask bits), or
+ *                         PC302_DMA_INTERRUPT_CLEAR (clear interrupt)
+ * \param value The value to write to the interrupt registers. Any of:
+ *                  PC302_DMA_IRQ_ENABLE_CHANNEL(channel number) for updating
+ *                  mask registers, 
+ *                  PC302_DMA_IRQ_DISABLE_CHANNEL(channel number) for updating
+ *                  mask registers, or
+ *                  PC302_DMA_IRQ_CHANNEL(channel number) for clearing
+ *                  interrupts
+ */
+static void
+pc302_dma_write_int_registers(pc302_dma_t dma, 
+                              dma_irq_type_t irq_types, 
+                              unsigned operation_type, 
+                              u32 value);
+
+/*!
+ * \brief Return the transfer request signals for software handshaking that need
+ * to be asserted for the next transaction
+ *
+ * Pre-conditions:
+ *   1. The transfer is running.
+ *   2. The bytes_left is divisible by the transfer width.
+ *   3. The endpoint uses software handshaking.
+ *
+ * \param dma_xfr The transfer handle
+ * \param endpoint The endpoint for which the transfer request is to be made
+ * \param bytes_left The number of bytes of the block left to transfer (after
+ *                   this transfer)
+ *
+ * \return Bit field. Any of (transaction_type_t):
+ *           TRT_BURST, 
+ *           TRT_LAST, 
+ *           TRT_SINGLE, or
+ *           TRT_NONE
+ */
+__must_check static transaction_type_t
+pc302_dma_determine_transfer_type(pc302_dma_xfr_t dma_xfr, 
+                                  pc302_dma_endpoint_t *endpoint, 
+                                  unsigned *bytes_left);
+
+/*!
+ * \brief Checks that a transfer request (software handshaking) is not in
+ * progress.
+ *
+ * Pre-conditions:
+ *   1. The transfer is running.
+ *   2. The endpoint uses software handshaking.
+ *
+ * \param dma_xfr The transfer handle
+ * \param src_dst The source or destination of the transfer.
+ *
+ * \return FAIL if transfer request is in progress, or SUCCESS if no 
+ *         request is in progress
+ */
+__must_check static unsigned
+pc302_dma_get_transaction_state(pc302_dma_xfr_t dma_xfr, 
+                                pc302_dma_endpoint_type_t src_dst);
+
+/*!
+ * \brief Set the DMA transfer request registers to trigger a request.
+ *
+ * Pre-conditions:
+ *   1 The transfer is running.
+ *   2 The endpoint uses software handshaking.
+ *
+ * Post-conditions:
+ *   1 DMA transfer request registers updated.
+ *
+ * \param dma_xfr The transfer handle
+ * \param src_dst Selects the source or destination endpoint.
+ * \param type Transfer type to request. Any of (transaction_type_t):
+ *                TRT_NONE, 
+ *                TRT_BURST, 
+ *                TRT_SINGLE, 
+ *                TRT_LAST
+ */
+static void
+pc302_dma_transfer_request(pc302_dma_xfr_t dma_xfr, 
+                           pc302_dma_endpoint_type_t src_dst, 
+                           transaction_type_t type);
+
+/*!
+ * \brief This function deals with the 'auto' setting for the transaction
+ * size.
+ *
+ * This function chooses the best transaction size and updates the endpoint
+ * parameters.
+ *
+ * Pre-conditions:
+ *   1. The count parameter is divisible by the transfer width.
+ *   2. The block size needs to be known and set by calling code.
+ *
+ * Post-conditions:
+ *   1 The endpoint is updated with the chosen burst size.
+ *
+ * Notes:
+ *   1. The transaction size that results in the fewest transactions (burst and
+ *      single) to complete the block is chosen.
+ *
+ * \param dma The DMA handle
+ * \param endpoint The endpoint parameters
+ * \param count The size of the block in bytes
+ */
+static void
+pc302_dma_set_auto_burst_length(pc302_dma_t dma, 
+                                pc302_dma_endpoint_t *endpoint, 
+                                size_t count);
+
+/*!
+ * \brief Do some parameter checks on endpoint parameters.
+ *
+ * \param dma The DMA handle
+ * \param src The source endpoint parameters
+ * \param dst The destination endpoint parameters
+ * \param count The block size
+ *
+ * \return SUCCESS, or FAIL - Checking failed
+ */
+__must_check static unsigned
+pc302_dma_params_valid(pc302_dma_t dma, 
+                       pc302_dma_endpoint_t *src, 
+                       pc302_dma_endpoint_t *dst, 
+                       size_t count);
+
+/*!
+ * \brief Set the handshaking parameter in the transfer endpoint
+ *
+ * Pre-conditions:
+ *   1. The transfer in not running.
+ *
+ * Post-conditions:
+ *   1. The transfer is updated. Hardware is not updated
+ *
+ * \param dma_xfr The transfer handle
+ * \param src_handshake The source handshaking parameters
+ * \param dst_handshake The destination handshaking parameters
+ */
+static void
+pc302_dma_setup_handshaking(pc302_dma_xfr_t dma_xfr, 
+                            pc302_dma_handshake_t *src_handshake, 
+                            pc302_dma_handshake_t *dst_handshake);
+
+/*!
+ * \brief Check the handshaking parameters. Check if any handshaking interface
+ * is used on more than one endpoint.
+ *
+ * Pre-conditions:
+ *   1. Engine is initialised.
+ *   2. The handshaking interfaces in use are maintained in the engine context.
+ *
+ * \param dma The engine context
+ * \param src The source endpoint information
+ * \param dst The destination endpoint information
+ * \param src_handshake The handshaking parameters for the source or NULL if
+ *                        not using hardware handshaking parameters
+ * \param dst_handshake The handshaking parameters for the destination or NULL
+ *                        if not using hardware handshaking parameters
+ *
+ * \return            0 - Success, 1 - Checking failed
+ */
+__must_check static unsigned
+pc302_dma_handshaking_params_valid(pc302_dma_t dma, 
+                                   pc302_dma_endpoint_t *src, 
+                                   pc302_dma_endpoint_t *dst, 
+                                   pc302_dma_handshake_t *src_handshake, 
+                                   pc302_dma_handshake_t *dst_handshake);
+
+/*!
+ * \brief Allows a client process to register to receive an interrupt for the
+ * DMAC and DMA channel specified.
+ *
+ * The function will keep a count of which channels are currently registered for
+ * interrupts. On the first channel registered, the DMA requests IRQ for the
+ * generic ISR function pc302_dma_isr(). Thus an interrupt can only be generated
+ * for the DMA when there is at least at one client process registered to
+ * receive an interrupt
+ *
+ * Notes:
+ *   1. This function performs no parameter checking. It assumes that the
+ *      calling function has the right to enable interrupts on the channel and
+ *      DMA specified.
+ *   2. As this function only requests an IRQ when a client process requires it,
+ *      it means that at system start up if IRQs are examined the DMAs will
+ *      appear to have no IRQs registered.
+ *
+ * \param dma The DMA handle.
+ * \param bitField The DMA channel(s) for the IRQ to be registered against
+ *
+ * \return SUCCESS, or EINVAL for Invalid parameter
+ */
+__must_check static int
+pc302_dma_request_irq(pc302_dma_t dma, 
+                      u32 bitField);
+
+/*!
+ * \brief Function that allows a client to process to de-register itself from
+ * receiving an interrupt for the DMA and channel specified.
+ *
+ * \param dma The DMA handle
+ * \param bitField The DMA channel(s) to exclude from IRQ
+ *
+ * \return SUCCESS, EINVAL for Invalid parameter
+ */
+__must_check static int
+pc302_dma_free_irq(pc302_dma_t dma, 
+                   u32 bitField);
+
+/*!
+ * \brief Generic ISR function called when a DMA transfer is complete.
+ *
+ * Hands over control to client callback function specified with the transfer
+ * functions pc302_dma_setup_direct_xfr() or pc302_dma_setup_list_xfr()
+ *
+ * \param irq Interrupt number
+ * \param dev Ptr to the client/device structure
+ *
+ * \return IRQ_HANDLED for Interrupt handled, IRQ_NONE for interrupt not handled
+ */
+__must_check static irqreturn_t
+pc302_dma_isr(int irq, 
+              void *dev);
+
+/*!
+ * \brief Generic DPR for processing interrupts run under a tasklet
+ *
+ * \param unused Unused parameter
+ */
+static void
+pc302_dma_do_tasklet(unsigned long dmaP);
+
+/*!
+ * \brief Print the bits of the low dword of the control register
+ *
+ * \param reg The value of the low part of the control register
+ */
+static void
+pc302_dma_print_ctl_low(pc302_dma_t dma, 
+                        u32 reg);
+
+/*!
+ * \brief Print the bits of the high dword of the control register
+ *
+ * \param reg The value of the low part of the control register
+ */
+static void
+pc302_dma_print_ctl_high(pc302_dma_t dma, 
+                         u32 reg);
+
+/*!
+ * \brief Read the register specified
+ *
+ * \param dma The dma handle
+ * \param offset_addr The offset address of the register to read
+ *
+ * \return The value of the register read
+ */
+__must_check static u32
+pc302_dma_ioread32(pc302_dma_t dma, 
+                   unsigned long offset_addr);
+
+/*!
+ *  \brief Write to the address specified
+ *
+ * \param dma The dma handle
+ * \param v Value to write
+ * \param offset_addr The address to write
+ */
+static void
+pc302_dma_iowrite32(pc302_dma_t dma, 
+                    u32 v, 
+                    unsigned long offset_addr);
+
+/*!
+ * \brief Platform probe function
+ *
+ * \param pdev Platform device
+ */
+__must_check static int
+pc302_dma_drv_probe(struct platform_device *pdev);
+
+/*!
+ * \brief Platform remove function
+ *
+ * \param pdev Platform device
+ */
+__must_check static int
+pc302_dma_drv_remove(struct platform_device *pdev);
+
+/*****************************************************************************
+ * Private function declarations
+ *****************************************************************************/
+
+/*****************************************************************************
+   Generic ISR function called when a DMA transfer is complete.
+******************************************************************************/
+static irqreturn_t
+pc302_dma_isr(int irq, 
+              void *dev)
+{
+    pc302_dma_t dma = dev;
+    pc302_dma_xfr_t dma_xfr=NULL;
+    dma_irq_type_t irq_type = 0;
+
+    unsigned int_channel = 0;
+    u32 hw_int_status_block = 0;
+    u32 hw_int_status_dst_trx_complete = 0;
+    u32 hw_int_status_error = 0;
+    u32 hw_int_status_src_trx_complete = 0;
+    u32 hw_int_status_transfer_complete = 0;
+    unsigned loop_count = 0;
+    unsigned tmp = 0;
+
+    int ret=IRQ_NONE;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return IRQ_NONE;
+    }
+
+    /* Read all of the interrupt status registers to see which ones are set */
+    hw_int_status_block = pc302_dma_ioread32(dma, 
+        PC302_DMA_BLOCK_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+
+    hw_int_status_dst_trx_complete = pc302_dma_ioread32(dma, 
+        PC302_DMA_DST_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+
+    hw_int_status_error = pc302_dma_ioread32(dma, 
+        PC302_DMA_ERROR_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+
+    hw_int_status_src_trx_complete = pc302_dma_ioread32(dma, 
+        PC302_DMA_SRC_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+
+    hw_int_status_transfer_complete = pc302_dma_ioread32(dma, 
+        PC302_DMA_TXFER_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+
+    /* Now find a channel number. Do a round robin search to find any
+       interrupt to avoid starving any channels */
+    int_channel = dma->last_int_channel+1;
+    int_channel %= PC302_DMA_CHANNELS;
+    for(loop_count=0;loop_count<PC302_DMA_CHANNELS;loop_count++)
+    {
+        irq_type = 0;
+
+        /* The order of this set of statements determines the order in which
+           interrupt types are processed */
+        if (hw_int_status_transfer_complete & (1 << int_channel))
+        {
+            irq_type |= PC302_DMA_INT_TRANSFER;
+        }
+        if (hw_int_status_block & (1 << int_channel))
+        {
+            irq_type |= PC302_DMA_INT_BLOCK;
+        }
+        if (hw_int_status_dst_trx_complete & (1 << int_channel))
+        {
+            irq_type |= PC302_DMA_INT_DST_TRANSACTION;
+        }
+        if (hw_int_status_src_trx_complete & (1 << int_channel))
+        {
+            irq_type |= PC302_DMA_INT_SRC_TRANSACTION;
+        }
+        if (hw_int_status_error & (1 << int_channel))
+        {
+            irq_type |= PC302_DMA_INT_ERROR;
+        }
+
+        /* Break if the channel status is set and the channel is enabled.  */
+        if (irq_type > 0)
+        {
+            /* Channel found, set the transfer handle to be returned */
+            dma_xfr = &dma->channel[int_channel].transfer;
+            if (dma_xfr != NULL)
+            {
+                /* Reset the interrupt we are servicing */
+                pc302_dma_clear_int(dma_xfr, irq_type);
+
+                /* Record the channel so that we do not service it next time
+                   without looking for others first.  */
+                dma->last_int_channel = int_channel;
+
+                if (dma->channel[int_channel].handler == NULL)
+                {
+                    PRINTE_RATELIMIT("chan %d: IRQ=%d DMA Handler function ptr "
+                            "is NULL\n", dma_xfr->channel, irq);
+                }
+                else
+                {
+                    /* call the handler function */
+                    tmp = dma->writePtr +1;
+                    tmp %= PC302_DMA_FIFO_SIZE;
+                    if (tmp == dma->readPtr)
+                    {
+                        PRINTE("Cannot schedule interrupt processing for "
+                            "chan %d, IRQ %d because queue is full\n",
+                            dma_xfr->channel, irq);
+                    }
+                    else
+                    { 
+                        PRINTD(dma, PC302_DMA_LVL_DEBUG, 
+                            "Queuing handle 0x%p dma_xfr=%p int type=%d\n", 
+                            dma->channel[int_channel].handler,
+                            dma_xfr, irq_type);
+
+                        dma->fifo[dma->writePtr].int_channel = int_channel;
+                        dma->fifo[dma->writePtr].dma_xfr = dma_xfr;
+                        dma->fifo[dma->writePtr].irq_type = irq_type;
+                        tasklet_schedule(&dma->tasklet);
+
+                        dma->writePtr = tmp;
+                    }
+                }
+
+                ret = IRQ_HANDLED;
+            }
+        }
+
+        /* Move on to the next channel */
+        int_channel++;
+        int_channel %= PC302_DMA_CHANNELS;
+    }
+
+    if (ret == IRQ_NONE)
+    {
+        PRINTE_RATELIMIT("no xfr found\n");
+    }
+
+    return ret;
+}
+
+/*****************************************************************************
+   Generic DPR for servicing interrupts under a tasklet
+******************************************************************************/
+static void
+pc302_dma_do_tasklet(unsigned long dmaP)
+{
+    pc302_dma_t dma = (pc302_dma_t)dmaP;
+
+    while(dma->readPtr != dma->writePtr)
+    {
+        PRINTD(dma, PC302_DMA_LVL_DEBUG, 
+              "calling handle 0x%p dma_xfr=%p irq_type=%d\n", 
+                   dma->channel[dma->fifo[dma->readPtr].int_channel].handler,
+                   dma->fifo[dma->readPtr].dma_xfr,
+                   dma->fifo[dma->readPtr].irq_type );
+        dma->channel[dma->fifo[dma->readPtr].int_channel].handler(
+                    dma->fifo[dma->readPtr].dma_xfr->cookie,
+                    dma->fifo[dma->readPtr].irq_type );
+   
+        dma->readPtr++;
+        dma->readPtr %= PC302_DMA_FIFO_SIZE;  
+    }
+}
+
+/*****************************************************************************
+   Read the register specified
+******************************************************************************/
+static u32
+pc302_dma_ioread32(pc302_dma_t dma, 
+                   unsigned long offset_addr)
+{
+    void __iomem *p = dma->membase + offset_addr;
+
+    u32 v = ioread32(p);
+
+    PRINTD(dma, PC302_DMA_LVL_TRACE_IO, "ioread32(0x%08lx) = 0x%08x\n", 
+        offset_addr, v);
+
+    return v;
+}
+
+/*****************************************************************************
+   Write to the address specified
+******************************************************************************/
+static void
+pc302_dma_iowrite32(pc302_dma_t dma, 
+                    u32 v, 
+                    unsigned long offset_addr)
+{
+    void __iomem *p = dma->membase + offset_addr;
+
+    PRINTD(dma, PC302_DMA_LVL_TRACE_IO, "iowrite32(0x%08lx) = 0x%08x\n", 
+        offset_addr, v);
+
+    iowrite32(v, p);
+}
+
+/*****************************************************************************
+   Initialise the DMA engine and enable it.
+******************************************************************************/
+static void
+pc302_dma_hw_initialise(pc302_dma_t dma)
+{
+    unsigned ch = 0;
+
+    if (dma == NULL)
+    {
+        PRINTE("NULL DMA handle\n");
+        return;
+    }
+
+    PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+
+    /* Disable the hardware before we initialise it */
+    pc302_dma_hw_shutdown(dma);
+
+    /* Switch all channels off and enable the DMA engine */
+    for (ch = 0; ch < PC302_DMA_CHANNELS; ch++)
+    {
+        pc302_dma_iowrite32(dma, PC302_DMA_DISABLE_CHANNEL(ch), 
+            PC302_DMA_CHANNEL_ENABLE_REG_OFFSET);
+    }
+
+    /* Enable the engine */
+    pc302_dma_iowrite32(dma, PC302_DMA_ENABLE, 
+        PC302_DMA_CONFIGURATION_REG_OFFSET);
+}
+
+/*****************************************************************************
+   Disable the DMA hardware.
+   The DMA channel will not be disabled immediately. The DMA will continue
+   any transfers in progress and then stop.
+******************************************************************************/
+static void
+pc302_dma_hw_shutdown(pc302_dma_t dma)
+{
+    if (dma == NULL)
+    {
+        PRINTE("NULL DMA handle\n");
+        return;
+    }
+
+    PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+
+    /* Disable the DMA */
+    pc302_dma_iowrite32(dma, ~PC302_DMA_ENABLE, 
+        PC302_DMA_CONFIGURATION_REG_OFFSET);
+}
+
+/*****************************************************************************
+   Allocate a transfer
+*****************************************************************************/
+static pc302_dma_xfr_t
+pc302_dma_alloc_xfr(pc302_dma_t dma, 
+                    int ( *handler )( void *cookie,
+                                      int errno ))
+{
+    pc302_dma_xfr_t dma_xfr=NULL;
+    unsigned ch=0;
+
+    /* Check that the engine is initialised */
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return NULL;
+    }
+
+
+    /* Find a free channel */
+    for (ch = 0; ch < PC302_DMA_CHANNELS; ch++)
+    {
+        if ((dma->allocatedChannels & (1 << ch)) == 0)
+        {
+            break;
+        }
+    }
+
+    if (ch == PC302_DMA_CHANNELS)
+    {
+        PRINTD(dma, PC302_DMA_LVL_WARNING, "All channels in use\n");
+        return NULL;
+    }
+
+    /* Pointer to the new transfer */
+    dma_xfr = &dma->channel[ch].transfer;
+
+    /* Reset the structure */
+    memset(dma_xfr, 0, sizeof(struct pc302_dma_xfr_tag));
+
+    /* Set the link to the engine context */
+    dma_xfr->dma = dma;
+
+    /* Set the channel number and allocated flag */
+    dma->allocatedChannels |= (1 << ch);
+    dma->channel[ch].handler = handler;
+    dma_xfr->channel = ch;
+
+    PRINTD(dma, PC302_DMA_LVL_DEBUG, "xfr=%p\n", dma_xfr);
+    return dma_xfr;
+}
+
+/*****************************************************************************
+   Release a transfer and its DMA channel so that it becomes
+   available to be allocated.
+*****************************************************************************/
+static void
+pc302_dma_free_xfr(pc302_dma_xfr_t dma_xfr)
+{
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return;
+    }
+
+    /* Reset the allocated flag */
+    dma_xfr->dma->allocatedChannels &= ~((unsigned)(1 << dma_xfr->channel));
+    dma_xfr->dma->channel[dma_xfr->channel].handler = NULL;
+
+    /* Release any handshaking interfaces used in the transfer */
+    if (dma_xfr->src_hw_handshaking_on)
+    {
+        dma_xfr->dma->handshaking_inuse &=
+             ~((unsigned)(1 << dma_xfr->src_handshake.hwInterface));
+    }
+
+    if (dma_xfr->dst_hw_handshaking_on)
+    {
+        dma_xfr->dma->handshaking_inuse &=
+             ~((unsigned)(1 << dma_xfr->dst_handshake.hwInterface));
+    }
+}
+
+/*****************************************************************************
+   Allocate the list for multi-block transfers
+*****************************************************************************/
+static pc302_dma_list_t
+pc302_dma_alloc_list(pc302_dma_t dma, 
+                     size_t count)
+{
+    pc302_dma_list_t list=NULL;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return NULL;
+    }
+
+    /* Allocate the object */
+    list = kzalloc(sizeof(struct pc302_dma_list_tag), GFP_KERNEL);
+    if (list == NULL)
+    {
+        /* No memory, return null */
+        PRINTE("Out of memory to allocate list\n");
+        return NULL;
+    }
+
+    /* Hold the device in the list for freeing */
+    list->device = dma->device;
+
+    /* Allocate the list. This must be on a 32-bit word boundary for the
+       hardware, and must be cache less, coherent buffer */
+    list->descriptor_list = dma_alloc_coherent(list->device, 
+            (sizeof(descriptor_t) * count), 
+            &list->dma_descriptor_list, GFP_KERNEL);
+    if (list->descriptor_list == NULL)
+    {
+        /* No memory, free the object and return null */
+        PRINTE("Out of memory to allocate list\n");
+        kfree(list);
+        return NULL;
+    }
+
+    /* Reset the list */
+    memset(list->descriptor_list, 0, (sizeof(descriptor_t) * count));
+
+    PRINTD(dma, PC302_DMA_LVL_DEBUG, "list=0x%p\n", list);
+    return list;
+}
+
+/*****************************************************************************
+   Given the periph_not_mem and flow controller flags for the source and
+   destination endpoints, work out the TT_FC (Transfer Type / Flow Control)
+   field value.
+*****************************************************************************/
+static pc302_dma_tt_fc_t
+pc302_dma_lookup_tt_fc(pc302_dma_t dma, 
+                       unsigned src_periph, 
+                       unsigned src_fc, 
+                       unsigned dst_periph, 
+                       unsigned dst_fc)
+{
+    pc302_dma_tt_fc_t tt_fc=0;
+    struct pc302_dma_tt_fc_lookup_tag match =
+                                 {{src_periph, src_fc, dst_periph, dst_fc}};
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return PC302_DMA_TRANSFER_TYPES_RANGE_FAIL;
+    }
+
+    for (tt_fc = 0; tt_fc < PC302_DMA_TRANSFER_TYPES; tt_fc++)
+    {
+        if (memcmp(&pc302_dma_tt_fc_lookup[tt_fc].path, &match.path, 
+            (sizeof(unsigned char)*4)) == 0)
+        {
+#ifndef PC302_DMA_ENABLE_UNTESTED_PATHS
+            if (pc302_dma_tt_fc_lookup[tt_fc].tested == 0)
+            {
+                PRINTE("An untested on\nhardware path has "
+                    "been selected. Recompile with "
+                    "PC302_DMA_ENABLE_UNTESTED_PATHS defined\n"
+                    "SRC_PER=%d SRC_FC=%d DST_PER=%d DST_FC=%d\n", 
+                     src_periph, src_fc, dst_periph, dst_fc);
+                return PC302_DMA_TRANSFER_TYPES_RANGE_FAIL;
+            }
+#endif
+
+            PRINTD(dma, PC302_DMA_LVL_DEBUG, "tt_fc=%d\n", tt_fc);
+            return tt_fc;
+        }
+    }
+
+    PRINTD(dma, PC302_DMA_LVL_WARNING, " Invalid parameters SRC_PER=%d "
+        "SRC_FC=%d DST_PER=%d DST_FC=%d. Assuming mem_to_mem t/f using "
+        "DMA FC\n", src_periph, src_fc, dst_periph, dst_fc);
+
+    return PC302_DMA_TRANSFER_TYPES_RANGE_FAIL;
+}
+
+/*****************************************************************************
+   Given a source and destination endpoint, build the contents of
+   the control register (CTL[0:32]).
+*****************************************************************************/
+static u32
+pc302_dma_build_control_register(pc302_dma_t dma, 
+                                 pc302_dma_endpoint_t *src, 
+                                 pc302_dma_endpoint_t *dst)
+{
+    u32 tt_fc=0;                      /* New TT_FC reg */
+    u32 control = 0;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return ERROR_INDICATED;
+    }
+
+    if ((src == NULL) || (dst == NULL))
+    {
+        PRINTE("NULL SRC and / or DST ptrs are null (0x%p, 0x%p)\n", 
+            src, dst);
+        return ERROR_INDICATED;
+    }
+
+    /* Enable the channel global interrupt */
+    control |= PC302_DMA_INT_EN;
+
+    /* Set the Source/Destination Transfer Width */
+    control |= (((u32)src->tr_width << PC302_DMA_SRC_TR_WIDTH_SHIFT)
+            & PC302_DMA_SRC_TR_WIDTH_MASK);
+    control |= (((u32)dst->tr_width << PC302_DMA_DST_TR_WIDTH_SHIFT)
+            & PC302_DMA_DST_TR_WIDTH_MASK);
+
+    /* Set the Source/Destination address incrementing */
+    control |=
+        (((u32)src->addr_inc << PC302_DMA_SINC_SHIFT) & PC302_DMA_SINC_MASK);
+    control |=
+        (((u32)dst->addr_inc << PC302_DMA_DINC_SHIFT) & PC302_DMA_DINC_MASK);
+
+    /* Set the Source/Destination transaction length */
+    control |= ((src->msize << PC302_DMA_SRC_MSIZE_SHIFT)
+            & PC302_DMA_SRC_MSIZE_MASK);
+    control |= ((dst->msize << PC302_DMA_DST_MSIZE_SHIFT)
+            & PC302_DMA_DST_MSIZE_MASK);
+
+    /* Scatter gather enable */
+    if (src->enable_sg)
+    {
+        control |= PC302_DMA_SRC_GATHER_EN;
+    }
+    if (dst->enable_sg)
+    {
+        control |= PC302_DMA_DST_SCATTER_EN;
+    }
+
+    /* Set the transfer type and flow control */
+    tt_fc = pc302_dma_lookup_tt_fc(
+                dma, 
+                src->periph_not_mem, 
+                src->flow_controller, 
+                dst->periph_not_mem, 
+                dst->flow_controller);
+    if (tt_fc == PC302_DMA_TRANSFER_TYPES_RANGE_FAIL)
+    {
+        /* No match found - return error status */
+        return ERROR_INDICATED;
+    }
+
+    control |= ((tt_fc << PC302_DMA_TT_FC_SHIFT) & PC302_DMA_TT_FC_MASK);
+
+    /* Set the Source/Destination master select */
+    control |= (((u32)src->master << PC302_DMA_SMS_SHIFT) & PC302_DMA_SMS_MASK);
+    control |= (((u32)dst->master << PC302_DMA_DMS_SHIFT) & PC302_DMA_DMS_MASK);
+
+    PRINTD(dma, PC302_DMA_LVL_DEBUG, "Exit, control=0x%08x\n", control);
+
+    return control;
+}
+
+/*****************************************************************************
+   Given a linked list, build the contents of the control register
+   source / dest block chaining bits.
+*****************************************************************************/
+static u32
+pc302_dma_build_llp_control_register(pc302_dma_t dma, 
+                                     pc302_dma_list_t list)
+{
+    u32 control = 0;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return ERROR_INDICATED;
+    }
+
+    /* Set the source/destination block chaining enable */
+    if (list != NULL)
+    { /* Multi-block and no auto-reload */
+        if (list->is_multi_block_src)
+        {
+            control |= PC302_DMA_LLP_SRC_EN;
+        }
+        if (list->is_multi_block_dst)
+        {
+            control |= PC302_DMA_LLP_DST_EN;
+        }
+    }
+    else
+    {
+        PRINTE("NULL block list ptr\n");
+        control = ERROR_INDICATED;
+    }
+
+    PRINTD(dma, PC302_DMA_LVL_DEBUG, "Exit, control=0x%08x\n", control);
+
+    return control;
+}
+
+/*****************************************************************************
+   Given a source and destination endpoint, build the contents of
+   the control register (CTL[0:32]).
+*****************************************************************************/
+static int
+pc302_dma_update_xfr_registers(pc302_dma_xfr_t dma_xfr)
+{
+    pc302_dma_endpoint_t *src=NULL;
+    pc302_dma_endpoint_t *dst=NULL;
+    u32 block_ts=0;                   /* New BLOCK_TS reg */
+    u32 sg=0;                         /* New scatter/gather reg */
+    u32 control=0;                    /* New control reg */
+    descriptor_t *desc=NULL;
+    int ret = SUCCESS;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return -EINVAL;
+    }
+
+    /* Check / update the transfer status */
+    if (pc302_dma_get_xfr_state(dma_xfr) == RUNNING)
+    {
+        PRINTE("Transfer is running\n");
+        return -EINVAL;
+    }
+
+    /* If we are using a list, the src and dst endpoint information is
+       held in the list. The first element in the list sets the registers.
+       If we are not using a list, the src and dst
+       endpoint information is held in the transfer itself.  */
+
+    /* Write the linked list pointer. This will be NULL if we have not
+     * setup for linked multi-block.  */
+    if (dma_xfr->list == NULL)
+    {
+        src = &dma_xfr->src; /* src and dst endpoint info must be in the */
+        dst = &dma_xfr->dst; /* transfer */
+
+        pc302_dma_iowrite32(dma_xfr->dma, 0, 
+            PC302_DMA_N_LLP_REG_OFFSET(dma_xfr->channel));
+    }
+    else
+    {
+        desc = dma_xfr->list->descriptor_list;
+
+        src = &desc->sw.src; /* src and dst endpoint info must be in the */
+        dst = &desc->sw.dst; /* first element of the list */
+
+        /* Set the LLP register to the start of the block list */
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_DEBUG, "Head LLP reg = 0x%p\n", 
+            (void *)dma_xfr->list->dma_descriptor_list);
+        pc302_dma_iowrite32(dma_xfr->dma, dma_xfr->list->dma_descriptor_list, 
+                PC302_DMA_N_LLP_REG_OFFSET(dma_xfr->channel));
+    }
+
+    /* Write the Source/Destination address registers */
+    PRINTD(dma_xfr->dma, PC302_DMA_LVL_DEBUG, 
+        "src addr = 0x%08x, dst addr = 0x08%x\n", src->dma_addr, dst->dma_addr);
+    pc302_dma_iowrite32(dma_xfr->dma, src->dma_addr, 
+        PC302_DMA_N_SRC_ADDR_REG_OFFSET(dma_xfr->channel));
+    pc302_dma_iowrite32(dma_xfr->dma, dst->dma_addr, 
+        PC302_DMA_N_DST_ADDR_REG_OFFSET(dma_xfr->channel));
+
+    /* Write the control register
+       Debug prints provided by pc302_dma_build_llp_control_register &
+                               pc302_dma_build_llp_control_register     */
+    control = pc302_dma_build_control_register(dma_xfr->dma, src, dst);
+    if (control == ERROR_INDICATED)
+    {
+        return -EINVAL; /* Error message printed in function */
+    }
+
+    if (dma_xfr->list)
+    {
+        control |=
+            pc302_dma_build_llp_control_register(dma_xfr->dma, dma_xfr->list);
+        if (control == ERROR_INDICATED)
+        {
+            return -EINVAL; /* Error message printed in function */
+        }
+    }
+
+    pc302_dma_iowrite32(dma_xfr->dma, control, 
+        PC302_DMA_N_CTRL_REG_OFFSET(dma_xfr->channel));
+
+    /* Write the block transfer size (top dword of control register) */
+    block_ts = dma_xfr->count / TR_BYTES(src);
+    PRINTD(dma_xfr->dma, PC302_DMA_LVL_DEBUG, "block_ts = 0x%08x\n", block_ts);
+    pc302_dma_iowrite32(dma_xfr->dma, block_ts, 
+        PC302_DMA_N_BLOCK_SIZE_REG_OFFSET(dma_xfr->channel));
+
+    /* Build the low configuration register */
+    dma_xfr->config_low = 0;
+
+    /* Set the channel priority */
+    dma_xfr->config_low |= ((READ_HEX_DIGIT((u32)dma_xfr->flags, 0) <<
+        PC302_DMA_CH_PRIOR_SHIFT) & PC302_DMA_CH_PRIOR_MASK);
+
+    /* Set software handshaking for source and destination */
+    if (dma_xfr->src_hw_handshaking_on)
+    {
+        /* Is hardware handshaking, set polarity */
+        if (dma_xfr->src_handshake.active_low)
+        {
+            dma_xfr->config_low |= PC302_DMA_SRC_HS_POL;
+        }
+    }
+    else
+    {
+        /* Set software handshaking */
+        dma_xfr->config_low |= PC302_DMA_HS_SEL_SRC;
+    }
+
+    if (dma_xfr->dst_hw_handshaking_on)
+    {
+        /* Is hardware handshaking, set polarity */
+        if (dma_xfr->dst_handshake.active_low)
+        {
+            dma_xfr->config_low |= PC302_DMA_DST_HS_POL;
+        }
+    }
+    else
+    {
+        /* Set software handshaking */
+        dma_xfr->config_low |= PC302_DMA_HS_SEL_DST;
+    }
+
+    /* Set the source and destination auto-reload */
+    if (src->auto_reload)
+    {
+        dma_xfr->config_low |= PC302_DMA_RELOAD_SRC;
+    }
+    if (dst->auto_reload)
+    {
+        dma_xfr->config_low |= PC302_DMA_RELOAD_DST;
+    }
+
+    /* Write the low configuration register */
+    PRINTD(dma_xfr->dma, PC302_DMA_LVL_DEBUG, "CTRLx (Low) = 0x%08x\n", 
+        dma_xfr->config_low);
+    pc302_dma_iowrite32(dma_xfr->dma, dma_xfr->config_low, 
+        PC302_DMA_N_LOW_CONFIG_REG_OFFSET(dma_xfr->channel));
+
+    /* Build the high configuration register */
+    dma_xfr->config_high = 0;
+
+    /* Set the flow control mode */
+    if (dma_xfr->flags & PC302_DMA_DST_WAIT)
+    {
+        dma_xfr->config_high |= PC302_DMA_FC_MODE;
+    }
+
+    /* Set the FIFO mode */
+    if (dma_xfr->flags & PC302_DMA_FIFO_WAIT)
+    {
+        dma_xfr->config_high |= PC302_DMA_FIFO_MODE;
+    }
+
+    /* Set the protection control */
+    dma_xfr->config_high |= ((READ_HEX_DIGIT((u32)dma_xfr->flags, 1)
+          << PC302_DMA_PROTCTL_SHIFT) & PC302_DMA_PROTCTL_MASK);
+
+    /* Set the src/dst handshaking peripheral */
+    if (dma_xfr->src_hw_handshaking_on)
+    {
+        dma_xfr->config_high |=
+            (((u32)dma_xfr->src_handshake.hwInterface <<
+            PC302_DMA_SRC_PER_SHIFT) & PC302_DMA_SRC_PER_MASK);
+    }
+    if (dma_xfr->dst_hw_handshaking_on)
+    {
+        dma_xfr->config_high |=
+            (((u32)dma_xfr->dst_handshake.hwInterface <<
+            PC302_DMA_DST_PER_SHIFT) & PC302_DMA_DST_PER_MASK);
+    }
+
+    /* Write the high configuration register */
+    PRINTD(dma_xfr->dma, PC302_DMA_LVL_DEBUG, "CTRLx (High) = 0x%08x\n", 
+        dma_xfr->config_high);
+    pc302_dma_iowrite32(dma_xfr->dma, dma_xfr->config_high, 
+        PC302_DMA_N_HIGH_CONFIG_REG_OFFSET(dma_xfr->channel));
+
+    /* Set the Scatter/Gather registers */
+    sg = 0;
+    sg |= ((dma_xfr->gather.count / TR_BYTES(src)
+                << PC302_DMA_SG_COUNT_SHIFT) & PC302_DMA_SG_COUNT_MASK);
+    sg |= ((dma_xfr->gather.interval / TR_BYTES(src)
+                << PC302_DMA_SG_INTERVAL_SHIFT) & PC302_DMA_SG_INTERVAL_MASK);
+    pc302_dma_iowrite32(dma_xfr->dma, sg, 
+        PC302_DMA_N_SRC_GATHER_REG_OFFSET(dma_xfr->channel));
+
+    sg = 0;
+    sg |= ((dma_xfr->scatter.count / TR_BYTES(dst)
+                << PC302_DMA_SG_COUNT_SHIFT) & PC302_DMA_SG_COUNT_MASK);
+    sg |= ((dma_xfr->scatter.interval / TR_BYTES(dst)
+                << PC302_DMA_SG_INTERVAL_SHIFT) & PC302_DMA_SG_INTERVAL_MASK);
+    PRINTD(dma_xfr->dma, PC302_DMA_LVL_DEBUG, "S/G = 0x%08x\n", sg);
+    pc302_dma_iowrite32(dma_xfr->dma, sg, 
+        PC302_DMA_N_DST_SCATTER_REG_OFFSET(dma_xfr->channel));
+
+   return ret;
+}
+
+/*****************************************************************************
+   Get/update the current state of a DMA transfer
+*****************************************************************************/
+static transfer_state_t
+pc302_dma_get_xfr_state(pc302_dma_xfr_t dma_xfr)
+{
+    u32 hw_state=0;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return STOPPED;
+    }
+
+    /* Read the channel enables */
+    hw_state = pc302_dma_ioread32(dma_xfr->dma, 
+        PC302_DMA_CHANNEL_ENABLE_REG_OFFSET);
+
+    /* If the channel is not enabled, it has stopped - update the state*/
+    if ((hw_state & PC302_DMA_CHANNEL(dma_xfr->channel)) == 0)
+    {
+        dma_xfr->state = STOPPED;
+    }
+
+    PRINTD(dma_xfr->dma, PC302_DMA_LVL_DEBUG, "state = %d\n", dma_xfr->state);
+
+    return dma_xfr->state;
+}
+
+/*****************************************************************************
+   Write many interrupt registers at once.
+*****************************************************************************/
+static void
+pc302_dma_write_int_registers(pc302_dma_t dma, 
+                              dma_irq_type_t irq_types, 
+                              unsigned operation_type, 
+                              u32 value)
+{
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter (dma=0x%p, int types="
+            "0x%08x operation type=0x%08x value=0x%08x)\n", 
+            (void *)dma, irq_types, operation_type, value);
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return;
+    }
+
+    if (irq_types & PC302_DMA_INT_BLOCK)
+    {
+        pc302_dma_iowrite32(dma, value, 
+            PC302_DMA_BLOCK_COMPLETE_REG_OFFSET(operation_type));
+    }
+
+    if (irq_types & PC302_DMA_INT_DST_TRANSACTION)
+    {
+        pc302_dma_iowrite32(dma, value, 
+            PC302_DMA_DST_TRX_COMPLETE_REG_OFFSET(operation_type));
+    }
+
+    if (irq_types & PC302_DMA_INT_ERROR)
+    {
+        pc302_dma_iowrite32(dma, value, 
+            PC302_DMA_ERROR_REG_OFFSET(operation_type));
+    }
+
+    if (irq_types & PC302_DMA_INT_SRC_TRANSACTION)
+    {
+        pc302_dma_iowrite32(dma, value, 
+            PC302_DMA_SRC_TRX_COMPLETE_REG_OFFSET(operation_type));
+    }
+
+    if (irq_types & PC302_DMA_INT_TRANSFER)
+    {
+        pc302_dma_iowrite32(dma, value, 
+            PC302_DMA_TXFER_COMPLETE_REG_OFFSET(operation_type));
+    }
+}
+
+/*****************************************************************************
+   Return the transfer request signals for software handshaking
+   that need to be asserted for the next transaction
+*****************************************************************************/
+static transaction_type_t
+pc302_dma_determine_transfer_type(pc302_dma_xfr_t dma_xfr, 
+                                  pc302_dma_endpoint_t *endpoint, 
+                                  unsigned *bytes_left)
+{
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_TRACE, "Enter: (xfr=0x%p "
+            "endpoint=0x%p, bytes left = %d)\n", 
+            (void *)dma_xfr, (void *)endpoint, *bytes_left);
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return TRT_NONE;
+    }
+
+    if (dma_xfr->state != RUNNING)
+    {
+        PRINTE("Transfer not running\n");
+        return TRT_NONE;
+    }
+
+    if (endpoint == NULL)
+    {
+        PRINTE("NULL endpoint handle\n");
+        return TRT_NONE;
+    }
+
+    /* Check that the endpoint is a flow controller. (Need also to check that
+       the endpoint is not using H/W flow control but the information is not
+       available in this function) */
+    if (!endpoint->flow_controller)
+    {
+        PRINTE("End point is not a flow controller\n");
+        return TRT_NONE;
+    }
+
+    /* Check that the number of bytes left is divisible by the transfer width */
+    if (BURST_NOT_DIVISIBLE_BY_TRANSFER_WIDTH(endpoint, *bytes_left))
+    {
+        PRINTE("Bytes left (%d) is not divisible by the transfer width (%d)\n", 
+            *bytes_left, TR_BYTES(endpoint));
+        return TRT_NONE;
+    }
+
+    /* Select the most desirable transaction type - starting with 
+       burst transfers */
+    if (*bytes_left > BURST_BYTES(endpoint))
+    {
+        *bytes_left -= BURST_BYTES(endpoint);
+        return TRT_BURST; /* Burst in the middle of a transfer */
+    }
+
+    if (*bytes_left == BURST_BYTES(endpoint))
+    {
+        *bytes_left -= BURST_BYTES(endpoint);
+        return TRT_BURST | TRT_LAST; /* Burst at the end of a transfer */
+    }
+
+    /* Single transactions up to the last */
+    if (*bytes_left > TR_BYTES(endpoint))
+    {
+        *bytes_left -= TR_BYTES(endpoint);
+        /* For a single transfer, set the single and burst bits */
+        return TRT_SINGLE | TRT_BURST;
+    }
+
+    if (*bytes_left == TR_BYTES(endpoint))
+    {
+        *bytes_left -= TR_BYTES(endpoint);
+        /* For a single transfer, set the single and burst bits */
+        return TRT_SINGLE | TRT_BURST | TRT_LAST;
+    }
+
+    /* No more left to transfer */
+    return TRT_NONE;
+}
+
+/*****************************************************************************
+   Checks that a transfer request (software handshaking) is not in progress.
+*****************************************************************************/
+static unsigned
+pc302_dma_get_transaction_state(pc302_dma_xfr_t dma_xfr, 
+                                pc302_dma_endpoint_type_t src_dst)
+{
+    u32 status=0;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return FAIL;
+    }
+
+    if (dma_xfr->state != RUNNING)
+    {
+        PRINTE("Transfer not running\n");
+        return FAIL;
+    }
+
+    /* Need to check that the endpoint is using S/W flow control but this
+       information is not available in this function */
+
+    /* Get the burst or single status bits, burst for flow controllers */
+    if (src_dst == PC302_DMA_SRC)
+    {
+        if (dma_xfr->src.flow_controller == 0)
+        {
+            status = pc302_dma_ioread32(dma_xfr->dma, 
+                PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(
+                    PC302_DMA_SINGLE_TRANSFER));
+        }
+        else
+        {
+            status = pc302_dma_ioread32(dma_xfr->dma, 
+                PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(PC302_DMA_BURST_TRANSFER));
+        }
+    }
+    else
+    {
+        if (dma_xfr->dst.flow_controller == 0)
+        {
+            status = pc302_dma_ioread32(dma_xfr->dma, 
+                PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(
+                    PC302_DMA_SINGLE_TRANSFER));
+        }
+        else
+        {
+            status = pc302_dma_ioread32(dma_xfr->dma, 
+                PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(PC302_DMA_BURST_TRANSFER));
+        }
+    }
+
+    /* Return fail if the burst bit is set for the channel */
+    if (status & PC302_DMA_CHANNEL(dma_xfr->channel))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_DEBUG, 
+          "S/W handshaking in progress\n");
+        return FAIL;
+    }
+    else
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_DEBUG, 
+          "S/W handshaking not in progress\n");
+        return SUCCESS;
+    }
+}
+
+/*****************************************************************************
+   Set the DMA transfer request registers to trigger a request.
+*****************************************************************************/
+static void
+pc302_dma_transfer_request(pc302_dma_xfr_t dma_xfr, 
+                           pc302_dma_endpoint_type_t src_dst, 
+                           transaction_type_t type)
+{
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return;
+    }
+
+    if (dma_xfr->state != RUNNING)
+    {
+        PRINTE("Transfer not running\n");
+        return;
+    }
+
+    if ((type & TRT_LAST) != 0)
+    {
+        if (src_dst == PC302_DMA_SRC)
+        {
+            pc302_dma_iowrite32(dma_xfr->dma, 
+                PC302_DMA_REQ_CHANNEL(dma_xfr->channel), 
+                PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(PC302_DMA_LAST_TRANSFER));
+        }
+        else
+        {
+            pc302_dma_iowrite32(dma_xfr->dma, 
+                PC302_DMA_REQ_CHANNEL(dma_xfr->channel), 
+                PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(PC302_DMA_LAST_TRANSFER));
+        }
+    }
+
+    if (type & TRT_SINGLE)
+    {
+        if (src_dst == PC302_DMA_SRC)
+        {
+            pc302_dma_iowrite32(dma_xfr->dma, 
+                PC302_DMA_REQ_CHANNEL(dma_xfr->channel), 
+                PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(
+                    PC302_DMA_SINGLE_TRANSFER));
+        }
+        else
+        {
+            pc302_dma_iowrite32(dma_xfr->dma, 
+                PC302_DMA_REQ_CHANNEL(dma_xfr->channel), 
+                PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(
+                    PC302_DMA_SINGLE_TRANSFER));
+        }
+    }
+
+    if (type & TRT_BURST)
+    {
+        if (src_dst == PC302_DMA_SRC)
+        {
+            pc302_dma_iowrite32(dma_xfr->dma, 
+                PC302_DMA_REQ_CHANNEL(dma_xfr->channel), 
+                PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(PC302_DMA_BURST_TRANSFER));
+        }
+        else
+        {
+            pc302_dma_iowrite32(dma_xfr->dma, 
+                PC302_DMA_REQ_CHANNEL(dma_xfr->channel), 
+                PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(PC302_DMA_BURST_TRANSFER));
+        }
+    }
+}
+
+/*****************************************************************************
+   This function deals with the 'auto' setting for the transaction size. It
+   chooses the best transaction size and updates the endpoint parameters.
+*****************************************************************************/
+static
+void pc302_dma_set_auto_burst_length(pc302_dma_t dma, 
+                                     pc302_dma_endpoint_t *endpoint, 
+                                     size_t count)
+{
+    unsigned cost=0;
+    unsigned cheapest_cost = 10000;    /* A big number! */
+    pc302_msize_t cheapest = 0;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return;
+    }
+
+    if (endpoint == NULL)
+    {
+        PRINTE("NULL endpoint handle\n");
+        return;
+    }
+
+    /* Check that we has an auto type burst size */
+    if (endpoint->msize != PC302_DMA_MS_AUTO)
+    {
+        /* Client has selected the burst size - this function not required */
+        return;
+    }
+
+    /* Check that the number of bytes left is divisible by the transfer width */
+    if (BURST_NOT_DIVISIBLE_BY_TRANSFER_WIDTH(endpoint, count))
+    {
+        PRINTE("Burst size (%d) is not divisible by the transfer width (%d)\n", 
+            count, TR_BYTES(endpoint));
+        return;
+    }
+
+    /* Try each burst size in turn and make costing. Cheapest wins. */
+    for (endpoint->msize = 0; endpoint->msize < PC302_DMA_MS_AUTO;
+          endpoint->msize++)
+    {
+        /* If the count is smaller than the transaction size, skip
+         * the rest as only bigger ones follow */
+        if (BURST_BYTES(endpoint) > count)
+        {
+            break;
+        }
+
+        /* The cost is the number of burst transactions plus the
+         * number of single transactions needed to complete the
+         * block.
+         */
+        cost = count / BURST_BYTES(endpoint);
+        cost += (count % BURST_BYTES(endpoint)) / TR_BYTES(endpoint);
+
+        /* If this is cheaper, remember it */
+        if (cost <= cheapest_cost)
+        {
+            cheapest_cost = cost;
+            cheapest = endpoint->msize;
+        }
+    }
+
+    /* Set the cheapest in the endpoint */
+    PRINTD(dma, PC302_DMA_LVL_DEBUG, "msize set to %d\n", endpoint->msize);
+    endpoint->msize = cheapest;
+}
+
+/*****************************************************************************
+   Do some parameter checks on endpoint parameters.
+*****************************************************************************/
+static unsigned
+pc302_dma_params_valid(pc302_dma_t dma, 
+                       pc302_dma_endpoint_t *src, 
+                       pc302_dma_endpoint_t *dst, 
+                       size_t count)
+{
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return FAIL;
+    }
+
+    /* Check that the source input parameters are in range */
+    if (src != NULL)
+    {
+        /* Master is in range */
+        if (src->master >= PC302_DMA_MASTERS)
+        {
+            PRINTE("Master out of range\n");
+            return FAIL;
+        }
+
+        /* Bus width supported by master */
+        if (src->tr_width >
+            pc302_dma_buswidth_lookup[dma->id][src->master])
+        {
+            PRINTE("Master does not support specified bus width. Master=%d "
+                 "Bus width=%d\n", src->master, src->tr_width);
+            return FAIL;
+        }
+
+        /* Burst size is in range */
+        if (src->msize > PC302_DMA_MS_AUTO)
+        {
+            PRINTE("Burst size is out of range. msize=%d\n", src->msize);
+            return FAIL ;
+        }
+
+        /* Check that the source transfer width is suitable for the number of
+           bytes to be transferred */
+        if ((count % TR_BYTES(src)) != 0)
+        {
+            PRINTE("Block size (%d) not divisible by transfer width\n",
+              count);
+            return FAIL;
+        }
+
+        /* Check that we are not setting memory as a flow controller */
+        if (src->periph_not_mem == 0 && src->flow_controller)
+        {
+            PRINTE("Memory endpoint cannot be flow controller\n");
+            return FAIL;
+        }
+    }
+
+    if (dst != NULL)
+    {
+        /* Master is in range */
+        if (dst->master >= PC302_DMA_MASTERS)
+        {
+            PRINTE("Master out of range\n");
+            return FAIL;
+        }
+
+        /* Bus width supported by master */
+        if (dst->tr_width >
+            pc302_dma_buswidth_lookup[dma->id][dst->master])
+        {
+            PRINTE("Master does not support specified bus width. Master=%d "
+                 "Bus width=%d\n", dst->master, dst->tr_width);
+            return FAIL;
+        }
+
+        /* Burst size is in range */
+        if (dst->msize > PC302_DMA_MS_AUTO)
+        {
+            PRINTE("Burst size is out of range. msize=%d\n", dst->msize);
+            return FAIL ;
+        }
+
+        if (dst->periph_not_mem == 0 && dst->flow_controller)
+        {
+            PRINTE("Memory endpoint cannot be flow controller\n");
+            return FAIL;
+        }
+    }
+
+    /* Check that both the source and destination are not flow controllers */
+    if (src != NULL && dst != NULL)
+    {
+        if (src->flow_controller && dst->flow_controller)
+        {
+            PRINTE("Only one endpoint can be flow controller\n");
+            return FAIL;
+        }
+    }
+
+    return SUCCESS;
+}
+
+/*****************************************************************************
+   Set the handshaking parameter in the transfer endpoint
+*****************************************************************************/
+static void
+pc302_dma_setup_handshaking(pc302_dma_xfr_t dma_xfr, 
+                            pc302_dma_handshake_t *src_handshake, 
+                            pc302_dma_handshake_t *dst_handshake)
+{
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL transfer handle\n");
+        return;
+    }
+
+    if (dma_xfr->state == RUNNING)
+    {
+        PRINTE("Attempting to configure a running transfer\n");
+        return;
+    }
+
+    /* Copy the parameters */
+    if (src_handshake != NULL)
+    {
+        dma_xfr->src_handshake = *src_handshake;
+        dma_xfr->src_hw_handshaking_on = 1;
+
+        /* Mark the interface as in use */
+        dma_xfr->dma->handshaking_inuse |= (1 << src_handshake->hwInterface);
+    }
+
+    if (dst_handshake != NULL)
+    {
+        dma_xfr->dst_handshake = *dst_handshake;
+        dma_xfr->dst_hw_handshaking_on = 1;
+
+        /* Mark the interface as in use */
+        dma_xfr->dma->handshaking_inuse |= (1 << dst_handshake->hwInterface);
+    }
+}
+
+/*****************************************************************************
+   Check the handshaking parameters. Check if any handshaking interface is
+   used on more than one endpoint.
+*****************************************************************************/
+static unsigned
+pc302_dma_handshaking_params_valid(pc302_dma_t dma, 
+                            pc302_dma_endpoint_t *src, 
+                            pc302_dma_endpoint_t *dst, 
+                            pc302_dma_handshake_t *src_handshake, 
+                            pc302_dma_handshake_t *dst_handshake)
+{
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return FAIL;
+    }
+
+    if (src_handshake != NULL)
+    {
+        /* Test for the situation where the H/W interface is specified
+           is already in use */
+        if ((dma->handshaking_inuse & (1 <<src_handshake->hwInterface)) != 0)
+        {
+            PRINTE("Source handshaking interface in use\n");
+            return FAIL;
+        }
+
+        /* Test for the situation where the H/W interface is not supported
+           by the master specified */
+        if (!(pc302_dma_hw_if_support_lookup[dma->id][
+            src_handshake->hwInterface] & (1 << src->master)))
+        {
+            PRINTE("Source handshaking interface (%d) is not supported "
+               "by master selected (%d)\n", src_handshake->hwInterface, 
+               src->master);
+            return FAIL;
+        }
+    }
+
+    if (dst_handshake != NULL)
+    {
+        if ((dma->handshaking_inuse & (1 << dst_handshake->hwInterface)) != 0)
+        {
+            PRINTE("Destination handshaking interface in use\n");
+            return FAIL;
+        }
+
+        if (!(pc302_dma_hw_if_support_lookup[dma->id][
+            dst_handshake->hwInterface] & (1 << dst->master)))
+        {
+            PRINTE("Destination handshaking interface (%d) is not "
+               "supported by master selected (%d)\n", 
+               dst_handshake->hwInterface, dst->master);
+            return FAIL;
+        }
+
+    }
+
+    if (src_handshake != NULL && dst_handshake != NULL)
+    {
+        if (src_handshake->hwInterface == dst_handshake->hwInterface)
+        {
+            PRINTE("Same Source and Destination handshaking interface\n");
+            return FAIL;
+        }
+    }
+
+    return SUCCESS;
+}
+
+/*****************************************************************************
+   Print the bits of the low dword of the control register
+*****************************************************************************/
+static void
+pc302_dma_print_ctl_low(pc302_dma_t dma, u32 reg)
+{
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return;
+    }
+
+    PRINT_BIT("INT_EN", PC302_DMA_INT_EN);
+    PRINT_FIELD("DST_TR_WIDTH", PC302_DMA_DST_TR_WIDTH_MASK, 
+       PC302_DMA_DST_TR_WIDTH_SHIFT);
+    PRINT_FIELD("SRC_TR_WIDTH", PC302_DMA_SRC_TR_WIDTH_MASK, 
+        PC302_DMA_SRC_TR_WIDTH_SHIFT);
+    PRINT_FIELD("DINC", PC302_DMA_DINC_MASK, PC302_DMA_DINC_SHIFT);
+    PRINT_FIELD("SINC", PC302_DMA_SINC_MASK, PC302_DMA_SINC_SHIFT);
+    PRINT_FIELD("DST_MSIZE", PC302_DMA_DST_MSIZE_MASK, 
+        PC302_DMA_DST_MSIZE_SHIFT);
+    PRINT_FIELD("SRC_MSIZE", PC302_DMA_SRC_MSIZE_MASK, 
+        PC302_DMA_SRC_MSIZE_SHIFT);
+    PRINT_BIT("SRC_GATHER_EN", PC302_DMA_SRC_GATHER_EN);
+    PRINT_BIT("DST_SCATTER_EN", PC302_DMA_DST_SCATTER_EN);
+    PRINT_FIELD("TT_FC", PC302_DMA_TT_FC_MASK, PC302_DMA_TT_FC_SHIFT);
+    PRINT_FIELD("DMS", PC302_DMA_DMS_MASK, PC302_DMA_DMS_SHIFT);
+    PRINT_FIELD("SMS", PC302_DMA_SMS_MASK, PC302_DMA_SMS_SHIFT);
+    PRINT_BIT("LLP_DST_EN", PC302_DMA_LLP_DST_EN);
+    PRINT_BIT("LLP_SRC_EN", PC302_DMA_LLP_SRC_EN);
+}
+
+/*****************************************************************************
+   Print the bits of the high dword of the control register
+*****************************************************************************/
+static void
+pc302_dma_print_ctl_high(pc302_dma_t dma, u32 reg)
+{
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return;
+    }
+
+    PRINT_FIELD("BLOCK_TS", PC302_DMA_BLOCK_TS_MASK, PC302_DMA_BLOCK_TS_SHIFT);
+    PRINT_BIT("DONE", PC302_DMA_DONE);
+}
+
+/*****************************************************************************
+ * Public function declarations
+ *****************************************************************************/
+
+/*****************************************************************************
+   Set up a DMA transfer between src and dst
+*****************************************************************************/
+pc302_dma_xfr_t
+pc302_dma_setup_direct_xfr(pc302_dma_t dma, 
+                           pc302_dma_endpoint_t *src, 
+                           pc302_dma_endpoint_t *dst, 
+                           pc302_dma_handshake_t *src_handshake, 
+                           pc302_dma_handshake_t *dst_handshake, 
+                           size_t count, 
+                           u32 flags, 
+                           int ( *handler )( void *cookie,
+                                             int errno ),
+                           void *cookie)
+{
+    struct pc302_dma_xfr_tag *dma_xfr = NULL;
+    unsigned long spinlock_flags = 0;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return NULL;
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&dma->spinlock, spinlock_flags);
+
+    /* Check we have source and destination */
+    if (src == NULL || (dst == NULL))
+    {
+        PRINTE("src or dst NULL\n");
+        goto EXIT;
+    }
+
+    /* Do various parameter checks and exit if they fail */
+    if (pc302_dma_params_valid(dma, src, dst, count))
+    {
+        goto EXIT;
+    }
+
+    /* Check the handshaking parameters */
+    if (pc302_dma_handshaking_params_valid(
+            dma, src, dst, src_handshake, dst_handshake))
+    {
+        goto EXIT;
+    }
+
+    /* Allocate a transfer object including DMA channel */
+    dma_xfr = pc302_dma_alloc_xfr(dma, handler);
+    if (dma_xfr == NULL)
+    {
+        /* Out of resources */
+        goto EXIT;
+    }
+
+    /* Set the transfer state */
+    dma_xfr->state = STOPPED;
+
+    /* Setup transfer structure */
+    dma_xfr->src = *src;
+    dma_xfr->dst = *dst;
+    dma_xfr->count = count;
+    dma_xfr->flags = flags;
+    dma_xfr->list = NULL;
+    dma_xfr->cookie = cookie;
+
+    /* Deal with auto burst length */
+    pc302_dma_set_auto_burst_length(dma, &dma_xfr->src, count);
+    pc302_dma_set_auto_burst_length(dma, &dma_xfr->dst, count);
+
+    /* Setup the handshaking */
+    pc302_dma_setup_handshaking(dma_xfr, src_handshake, dst_handshake);
+
+    /* Disable all interrupts for the channel */
+    pc302_dma_write_int_registers(dma, PC302_DMA_INT_ALL, 
+            PC302_DMA_INTERRUPT_MASK, 
+            PC302_DMA_IRQ_DISABLE_CHANNEL(dma_xfr->channel));
+
+EXIT:
+    spin_unlock_irqrestore(&dma->spinlock, spinlock_flags);
+    return dma_xfr;
+}
+
+/*****************************************************************************
+   Start a DMA transfer on a channel previously set up with the
+   pc302_dma_setup_direct_xfr() or pc302_dma_setup_list_xfr() functions.
+*****************************************************************************/
+int
+pc302_dma_start(pc302_dma_xfr_t dma_xfr)
+{
+    int ret = SUCCESS;
+    unsigned long spinlock_flags = 0;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return -EINVAL;
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+
+    /* Check and set the transfer state */
+    if (pc302_dma_get_xfr_state(dma_xfr) != STOPPED)
+    {
+        /* Already running error */
+        PRINTE("Transfer running\n");
+        ret = -EINVAL;
+        goto EXIT;
+    }
+
+    /* Reset the current block if using multi-block list */
+    if (dma_xfr->list != NULL)
+    {
+        dma_xfr->list->current_block = dma_xfr->list->descriptor_list;
+    }
+
+    /* Write the DMA hardware */
+    ret = pc302_dma_update_xfr_registers(dma_xfr);
+    if (ret != SUCCESS)
+    {
+        goto EXIT;
+    }
+
+    /* Start the DMA channel */
+    pc302_dma_iowrite32(dma_xfr->dma,
+        PC302_DMA_ENABLE_CHANNEL(dma_xfr->channel), 
+        PC302_DMA_CHANNEL_ENABLE_REG_OFFSET);
+    dma_xfr->state = RUNNING;
+
+EXIT:
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+    return ret;
+}
+
+/*****************************************************************************
+   Abort a DMA transfer
+*****************************************************************************/
+int
+pc302_dma_abort(pc302_dma_xfr_t dma_xfr)
+{
+    int ret = SUCCESS;
+    u32 status=0;
+    unsigned long timeout_jiffies=0;
+    unsigned long spinlock_flags = 0;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return -EINVAL;
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+
+    /* Check and set the transfer state */
+    if (pc302_dma_get_xfr_state(dma_xfr) != RUNNING)
+    {
+        /* Already stopped. It is not unusual for this to happen */
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_NOTICE, 
+            "Aborting a stopped transfer\n");
+
+        /* Disable the channel */
+        pc302_dma_iowrite32(dma_xfr->dma, 
+            PC302_DMA_DISABLE_CHANNEL(dma_xfr->channel), 
+            PC302_DMA_CHANNEL_ENABLE_REG_OFFSET);
+
+        goto EXIT; /* Return 0 as function has succeeded */
+    }
+    dma_xfr->state = STOPPING;
+
+    /* Set the suspend bit, wait for the FIFO to clear before
+     * disabling the channel
+     */
+    dma_xfr->config_low |= PC302_DMA_CH_SUSP;
+    pc302_dma_iowrite32(dma_xfr->dma, dma_xfr->config_low, 
+            PC302_DMA_N_LOW_CONFIG_REG_OFFSET(dma_xfr->channel));
+
+    /* Release the API spinlock while waiting as interrupts may
+     * need to be serviced to empty the FIFO and these will try
+     * to grab the lock.
+     * This is safe as we are not updating state while polling.
+     */
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+
+    /* Poll the FIFO_EMPTY bit */
+    timeout_jiffies = jiffies + ABORT_TIMEOUT;
+    while (1)
+    {
+        /* Check for time out */
+        if (time_after(jiffies, timeout_jiffies))
+        {
+            PRINTE("Timed out waiting for FIFO to empty\n");
+            ret = -EIO;
+            break;
+        }
+
+        /* Check for the empty FIFO empty */
+        status = pc302_dma_ioread32(dma_xfr->dma, 
+            PC302_DMA_N_LOW_CONFIG_REG_OFFSET(dma_xfr->channel));
+        if (status & PC302_DMA_FIFO_EMPTY)
+        {
+            break;
+        }
+        cpu_relax();
+    }
+
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+
+    /* Disable the channel */
+    pc302_dma_iowrite32(dma_xfr->dma, 
+        PC302_DMA_DISABLE_CHANNEL(dma_xfr->channel), 
+        PC302_DMA_CHANNEL_ENABLE_REG_OFFSET);
+
+    /* Now stopped, set state */
+    dma_xfr->state = STOPPED;
+
+EXIT:
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+    return ret;
+}
+
+/*****************************************************************************
+   Purpose: Stop a DMA transfer and release resources
+*****************************************************************************/
+int
+pc302_dma_release(pc302_dma_xfr_t dma_xfr)
+{
+    unsigned long spinlock_flags = 0;
+    int ret = SUCCESS;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return -EINVAL;
+    }
+
+    /* Make sure the transfer has is stopped */
+    ret = pc302_dma_abort(dma_xfr);
+    if (ret)
+    {
+       return ret; 
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+
+    /* Reset any interrupts that have been left pending */
+    pc302_dma_write_int_registers(dma_xfr->dma, PC302_DMA_INT_ALL, 
+         PC302_DMA_INTERRUPT_CLEAR, PC302_DMA_IRQ_CHANNEL(dma_xfr->channel));
+
+    /* Disconnect from multi-block list */
+    if (dma_xfr->list != NULL)
+    {
+        dma_xfr->list->dma_xfr = NULL;
+    }
+
+    /* Free the resources */
+    pc302_dma_free_xfr(dma_xfr);
+
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+    return ret;
+}
+
+/*****************************************************************************
+   Creates a DMA buffer list that can be assigned to a multi-block transfer.
+*****************************************************************************/
+pc302_dma_list_t
+pc302_dma_list_create(pc302_dma_t dma, 
+                      size_t count)
+{
+    pc302_dma_list_t list=NULL;
+    unsigned long spinlock_flags = 0;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return NULL;
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&dma->spinlock, spinlock_flags);
+
+    /* Allocate the list */
+    list = pc302_dma_alloc_list(dma, count);
+    if (list == NULL)
+    {
+        PRINTE("Not enough resources\n");
+        goto EXIT;
+    }
+
+    /* Setup the structure */
+    list->dma = dma;
+    list->dma_xfr = NULL;
+    list->items = 0;
+    list->last_desc = NULL;
+    list->length = count;
+    list->is_multi_block_src = 1;
+    list->is_multi_block_dst = 1;
+
+EXIT:
+    spin_unlock_irqrestore(&dma->spinlock, spinlock_flags);
+    return list;
+}
+
+/*****************************************************************************
+   Add an entry to the end of a DMA multi-block list
+*****************************************************************************/
+int
+pc302_dma_list_add(pc302_dma_list_t list, 
+                   pc302_dma_endpoint_t *src, 
+                   pc302_dma_endpoint_t *dst, 
+                   pc302_dma_handshake_t *src_handshake, 
+                   pc302_dma_handshake_t *dst_handshake, 
+                   size_t count)
+{
+    int ret = SUCCESS;
+    descriptor_t *new_desc=NULL;
+    dma_addr_t dma_new_desc=0;
+    unsigned long spinlock_flags = 0;
+
+    if (TRANSFER_LIST_HANDLE_ENABLED(list))
+    {
+        PRINTD(list->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer list handle\n");
+        return -EINVAL;
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&list->dma->spinlock, spinlock_flags);
+
+    /* Do various parameter checks and exit if they fail */
+    if (pc302_dma_params_valid(list->dma, src, dst, count))
+    {
+        ret = -EINVAL; /* PRINTEs provided in the function */
+        goto EXIT;
+    }
+
+    /* Check the block and handshaking parameters before adding the block
+       to the list */
+    if (pc302_dma_handshaking_params_valid(list->dma, src, dst, src_handshake, 
+            dst_handshake))
+    {
+        ret = -EINVAL;
+        goto EXIT; /* PRINTEs provided in the function */
+    }
+
+
+    /* Check we have room */
+    if (list->length == list->items)
+    {
+        PRINTE("List full\n");
+        ret = -ENOMEM;
+        goto EXIT;
+    }
+
+    /* Check for transfers running the list */
+    if (list->dma_xfr != NULL)
+    {
+        if (pc302_dma_get_xfr_state(list->dma_xfr) != STOPPED)
+        {
+            /* Cannot modify a list that is active */
+            PRINTE("Transfer running\n");
+            ret = -EBUSY;
+            goto EXIT;
+        }
+    }
+
+    /* If this is the first item, we must have both src and dst parameters */
+    if (list->items == 0)
+    {
+        if ((src == NULL) || (dst == NULL))
+        {
+            PRINTE("First list element must have both source and "
+                "destination endpoints\n");
+            ret = -EINVAL;
+            goto EXIT;
+        }
+    }
+    /* If this is the second element and src or dst are NULL, 
+     * we are not using a list for the endpoint
+     */
+    else if (list->items)
+    {
+        if ((src == NULL) && (dst == NULL))
+        {
+            /* Either src or dst must be set */
+            PRINTE("List element must have either source or destination "
+                "endpoints\n");
+            ret = -EINVAL;
+            goto EXIT;
+        }
+
+        /* If the source is not set, we are not using a list for it */
+        if (src == NULL)
+        {
+            list->is_multi_block_src = 0;
+        }
+
+        /* If the destination is not set, we are not using a list for it */
+        if (dst == NULL)
+        {
+            list->is_multi_block_dst = 0;
+        }
+    }
+    else
+    { /* Not the first or second item */
+        /* Check that, once we have chosen a non list type multi-block transfer
+         * (auto-reload or continuous), we must stick to it.
+         */
+        if (list->is_multi_block_src)
+        {
+            if (src == NULL)
+            {
+                PRINTE("NULL SRC descriptor in multi block list\n");
+                ret = -EINVAL;
+                goto EXIT;
+            }
+        }
+        else
+        {
+            if (src != NULL)
+            {
+                PRINTE("Non NULL SRC descriptor in multi block list\n");
+                ret = -EINVAL;
+                goto EXIT;
+            }
+        }
+
+        if (list->is_multi_block_dst)
+        {
+            if (dst == NULL)
+            {
+                PRINTE("NULL DST descriptor in multi block list\n");
+                ret = -EINVAL;
+                goto EXIT;
+            }
+        }
+        else
+        {
+            if (dst != NULL)
+            {
+                PRINTE("Non NULL DST descriptor in multi block list\n");
+                ret = -EINVAL;
+                goto EXIT;
+            }
+        }
+    }
+
+    /* Get a pointer to the new descriptor */
+    new_desc = &(list->descriptor_list[list->items]);
+
+    /* Get the physical address (DMA address) of the new descriptor */
+    dma_new_desc = list->dma_descriptor_list +
+        (sizeof(descriptor_t) * list->items);
+
+    /* Allocate the new descriptor */
+    list->items++;
+
+    /* Record the first source/destination for the non-list type
+     * transfers in the software list.
+     */
+    if (src != NULL)
+    {
+        new_desc->sw.src = *src;
+        /* Deal with auto burst length */
+        pc302_dma_set_auto_burst_length(list->dma, &new_desc->sw.src, count);
+    }
+
+    if (dst != NULL)
+    {
+        new_desc->sw.dst = *dst;
+        /* Deal with auto burst length */
+        pc302_dma_set_auto_burst_length(list->dma, &new_desc->sw.dst, count);
+    }
+    new_desc->sw.count = count;
+
+    /* Set the link of the new last element to point to the first.
+     * This ensures that the hardware is ready to be restarted at the
+     * beginning of the list when it completes
+     */
+    new_desc->hw.link = list->dma_descriptor_list;
+
+    /* Link the previous item to this one and enable the block chaining
+     * for it.
+     */
+    if (list->last_desc != NULL)
+    {
+        list->last_desc->hw.link = dma_new_desc;
+        list->last_desc->hw.control |=
+                pc302_dma_build_llp_control_register(list->dma, list);
+        if (list->last_desc->hw.control == ERROR_INDICATED)
+        {
+            ret = -EINVAL; /* PRINTEs provided in function */
+            goto EXIT;
+        }
+    }
+
+    /* Where either the source or destination is not list type, and is null
+     * at this point, use the endpoint descriptor at the head of the list
+     */
+    if (src == NULL)
+    {
+        src = &list->descriptor_list->sw.src;
+    }
+    if (dst == NULL)
+    {
+        dst = &list->descriptor_list->sw.dst;
+    }
+
+    /* Setup the new hardware block descriptor */
+    new_desc->hw.source_addr = src->dma_addr;
+    new_desc->hw.dest_addr = dst->dma_addr;
+    new_desc->hw.control = pc302_dma_build_control_register(list->dma, src,
+        dst);
+    if (new_desc->hw.control == ERROR_INDICATED)
+    {
+        ret = -EINVAL; /* PRINTEs provided in function */
+        goto EXIT;
+    }
+    new_desc->hw.block_ts = count / TR_BYTES(src);
+
+    /* The new last descriptor is now the one we just created */
+    list->last_desc = new_desc;
+
+EXIT:
+    spin_unlock_irqrestore(&list->dma->spinlock, spinlock_flags);
+    return ret;
+}
+
+/*****************************************************************************
+   This function resets a list to the state that it was in just after
+   it was created when calling pc302_dma_list_create
+*****************************************************************************/
+int
+pc302_dma_list_clear(pc302_dma_list_t list)
+{
+    int ret = SUCCESS;
+    unsigned long spinlock_flags = 0;
+
+    if (TRANSFER_LIST_HANDLE_ENABLED(list))
+    { 
+        PRINTD(list->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else 
+    { 
+        PRINTE("NULL  transfer list handle\n"); 
+        return -EINVAL; 
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&list->dma->spinlock, spinlock_flags);
+
+    /* Check for transfers running the list */
+    if (list->dma_xfr != NULL)
+    {
+        if (pc302_dma_get_xfr_state(list->dma_xfr) != STOPPED)
+        {
+            /* Cannot modify a list that is active */
+            PRINTE("Transfer running\n");
+            ret = -EBUSY;
+            goto EXIT;
+        }
+    }
+
+    /* Reset the list */
+    list->items = 0;
+    list->last_desc = NULL;
+    list->is_multi_block_src = 1;
+    list->is_multi_block_dst = 1;
+
+EXIT:
+    spin_unlock_irqrestore(&list->dma->spinlock, spinlock_flags);
+    return ret;
+}
+
+/*****************************************************************************
+   This function frees the resources allocated by a list
+*****************************************************************************/
+int
+pc302_dma_list_destroy(pc302_dma_list_t list)
+{
+    int ret = SUCCESS;
+    struct pc302_dma_list_tag local_list;
+    unsigned long spinlock_flags = 0;
+
+    if (TRANSFER_LIST_HANDLE_ENABLED(list))
+    { 
+        PRINTD(list->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else 
+    { 
+        PRINTE("NULL  transfer list handle\n"); 
+        return -EINVAL; 
+    }
+
+    /* Initialise local_list */
+    memset(&local_list, 0, sizeof(struct pc302_dma_list_tag));
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&list->dma->spinlock, spinlock_flags);
+
+    /* Take a copy of the list before we free it so that we can free
+     * the DMA coherent area outside of the spinlock. This is done
+     * because dma_free_coherent must not be called with interrupts
+     * disabled.
+     */
+    local_list = *list;
+
+    /* Make sure there are no references to the list from transfers.
+     * A transfers using the list needs to be destroyed before the
+     * list can be destroyed.
+     */
+    if (list->dma_xfr != NULL)
+    {
+        /* Cannot destroy a list that is referenced */
+        PRINTE("List in use\n");
+        ret = -EBUSY;
+        goto EXIT;
+    }
+
+    /* Free the object */
+    kfree(list);
+
+EXIT:
+    spin_unlock_irqrestore(&local_list.dma->spinlock, spinlock_flags);
+
+    /* Free the descriptor list if we are not here because of an error */
+    if (ret == SUCCESS)
+    {
+        dma_free_coherent(local_list.device, 
+            (sizeof(descriptor_t) * local_list.length), 
+            local_list.descriptor_list, local_list.dma_descriptor_list);
+    }
+
+    return ret;
+}
+
+/*****************************************************************************
+   Set up a multi-block DMA transfer
+*****************************************************************************/
+pc302_dma_xfr_t
+pc302_dma_setup_list_xfr(pc302_dma_list_t list, 
+                         pc302_dma_handshake_t *src_handshake, 
+                         pc302_dma_handshake_t *dst_handshake, 
+                         u32 flags, 
+                         int ( *handler )( void *cookie,
+                                           int errno),
+                         void *cookie)
+{
+    struct pc302_dma_xfr_tag *dma_xfr = NULL;
+    unsigned long spinlock_flags = 0;
+
+    if (TRANSFER_LIST_HANDLE_ENABLED(list))
+    { 
+        PRINTD(list->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else 
+    { 
+        PRINTE("NULL  transfer list handle\n"); 
+        return NULL; 
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+
+    /* Check that the list is not in use with another transfer */
+    if (list->dma_xfr != NULL)
+    {
+        PRINTE("List in use\n");
+        goto EXIT;
+    }
+
+    /* Allocate a transfer object including DMA channel */
+    dma_xfr = pc302_dma_alloc_xfr(list->dma, handler);
+    if (dma_xfr == NULL)
+    {
+        PRINTE("Out of resources\n");
+        goto EXIT;
+    }
+
+    /* Set the transfer state */
+    dma_xfr->state = STOPPED;
+
+    /* Setup transfer structure */
+    dma_xfr->flags = flags;
+    dma_xfr->list = list;
+    dma_xfr->cookie = cookie;
+
+    /* Pointer from list to the new transfer */
+    list->dma_xfr = dma_xfr;
+
+    /* Setup the handshaking */
+    pc302_dma_setup_handshaking(dma_xfr, src_handshake, dst_handshake);
+
+    /* Disable all interrupts for the channel */
+    pc302_dma_write_int_registers(list->dma, PC302_DMA_INT_ALL, 
+            PC302_DMA_INTERRUPT_MASK, 
+            PC302_DMA_IRQ_DISABLE_CHANNEL(dma_xfr->channel));
+
+EXIT:
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+    return dma_xfr;
+}
+
+/*****************************************************************************
+   Enable interrupt generation of a number of types of interrupt on a
+   DMA transfer.
+*****************************************************************************/
+int pc302_dma_enable_int(pc302_dma_xfr_t dma_xfr, 
+                          unsigned irq_types)
+{
+    unsigned long spinlock_flags = 0;
+    int ret = SUCCESS;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return -EINVAL;
+    }
+
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+    pc302_dma_write_int_registers(dma_xfr->dma, irq_types, 
+         PC302_DMA_INTERRUPT_MASK, 
+         PC302_DMA_IRQ_ENABLE_CHANNEL(dma_xfr->channel));
+    ret = pc302_dma_request_irq(dma_xfr->dma, (1<<dma_xfr->channel));
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+    return ret;
+}
+
+/*****************************************************************************
+   Disable interrupt generation of a number of types of interrupt on a
+   DMA transfer
+*****************************************************************************/
+int
+pc302_dma_disable_int(pc302_dma_xfr_t dma_xfr, 
+                      unsigned irq_types)
+{
+    unsigned long spinlock_flags = 0;
+    int ret = SUCCESS;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return -EINVAL;
+    }
+
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+    pc302_dma_write_int_registers(dma_xfr->dma, irq_types, 
+        PC302_DMA_INTERRUPT_MASK, 
+        PC302_DMA_IRQ_DISABLE_CHANNEL(dma_xfr->channel));
+    ret = pc302_dma_free_irq(dma_xfr->dma, (1<<dma_xfr->channel));
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+    return ret;
+}
+
+/*****************************************************************************
+   Clears a number of interrupt status bits, ready for new interrupt
+   generation.
+*****************************************************************************/
+void
+pc302_dma_clear_int(pc302_dma_xfr_t dma_xfr, 
+                    unsigned irq_types)
+{
+    unsigned long spinlock_flags = 0;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return;
+    }
+
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+    pc302_dma_write_int_registers(dma_xfr->dma, irq_types, 
+            PC302_DMA_INTERRUPT_CLEAR, PC302_DMA_IRQ_CHANNEL(dma_xfr->channel));
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+}
+
+/*****************************************************************************
+   Get the raw status of a DMA transfer. The value returned is a logical OR
+   of one or more dma_irq_type_t types
+*****************************************************************************/
+unsigned
+pc302_dma_get_raw_status(pc302_dma_xfr_t dma_xfr, 
+                         unsigned irq_types)
+{
+    dma_irq_type_t ret = 0; /* No interrupts selected */
+    u32 hw_int_status = 0;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return 0; /* No status bits set */
+    }
+
+    if (irq_types & PC302_DMA_INT_BLOCK)
+    {
+        hw_int_status = pc302_dma_ioread32(dma_xfr->dma, 
+            PC302_DMA_BLOCK_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+        if (hw_int_status & PC302_DMA_IRQ_CHANNEL(dma_xfr->channel))
+        {
+            ret |= PC302_DMA_INT_BLOCK;
+        }
+    }
+
+    if (irq_types & PC302_DMA_INT_DST_TRANSACTION)
+    {
+        hw_int_status = pc302_dma_ioread32(dma_xfr->dma, 
+            PC302_DMA_DST_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+        if (hw_int_status & PC302_DMA_IRQ_CHANNEL(dma_xfr->channel))
+        {
+            ret |= PC302_DMA_INT_DST_TRANSACTION;
+        }
+    }
+
+    if (irq_types & PC302_DMA_INT_ERROR)
+    {
+        hw_int_status = pc302_dma_ioread32(dma_xfr->dma, 
+            PC302_DMA_ERROR_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+        if (hw_int_status & PC302_DMA_IRQ_CHANNEL(dma_xfr->channel))
+        {
+            ret |= PC302_DMA_INT_ERROR;
+        }
+    }
+
+    if (irq_types & PC302_DMA_INT_SRC_TRANSACTION)
+    {
+        hw_int_status = pc302_dma_ioread32(dma_xfr->dma, 
+            PC302_DMA_SRC_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+        if (hw_int_status & PC302_DMA_IRQ_CHANNEL(dma_xfr->channel))
+        {
+            ret |= PC302_DMA_INT_SRC_TRANSACTION;
+        }
+    }
+
+    if (irq_types & PC302_DMA_INT_TRANSFER)
+    {
+        hw_int_status = pc302_dma_ioread32(dma_xfr->dma, 
+            PC302_DMA_TXFER_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+        if (hw_int_status & PC302_DMA_IRQ_CHANNEL(dma_xfr->channel))
+        {
+            ret |= PC302_DMA_INT_TRANSFER;
+        }
+    }
+
+    return ret;
+}
+
+/*****************************************************************************
+   This function is used to setup the scatter or gather parameters of
+   a DMA transfer.
+*****************************************************************************/
+int
+pc302_dma_setup_sg(pc302_dma_xfr_t dma_xfr, 
+                   pc302_dma_sg_t *sg, 
+                   pc302_dma_endpoint_type_t src_dst)
+{
+    int ret = SUCCESS;
+    unsigned long spinlock_flags = 0;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return -EINVAL;
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+
+    /* Check the transfer state */
+    if (pc302_dma_get_xfr_state(dma_xfr) != STOPPED)
+    {
+        /* Already running error */
+        PRINTE("Transfer running\n");
+        ret = -EINVAL;
+        goto EXIT;
+    }
+
+    /* Copy the parameters */
+    if (src_dst == PC302_DMA_SRC)
+    {
+        dma_xfr->gather = *sg;
+    }
+    else
+    {
+        dma_xfr->scatter = *sg;
+    }
+
+EXIT:
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+    return ret;
+}
+
+/*****************************************************************************
+   This function is used to request a new transaction on the source or
+   destination of a transfer.
+*****************************************************************************/
+int
+pc302_dma_request_transaction(pc302_dma_xfr_t dma_xfr, 
+                              pc302_dma_endpoint_type_t src_dst, 
+                              unsigned *bytes_left)
+{
+    pc302_dma_endpoint_t *endpoint = NULL;
+    descriptor_t *curr_desc = NULL;
+    int ret = SUCCESS;
+    transaction_type_t xfr_type = TRT_NONE;
+    unsigned long spinlock_flags = 0;
+
+    if (TRANSFER_HANDLE_ENABLED(dma_xfr))
+    {
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL  transfer handle\n");
+        return -EINVAL;
+    }
+
+    /* Simply lock the API against multiple threads */
+    spin_lock_irqsave(&dma_xfr->dma->spinlock, spinlock_flags);
+
+    /* Check the transfer state */
+    if (pc302_dma_get_xfr_state(dma_xfr) != RUNNING)
+    {
+        /* Not running error */
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO,"Transfer not running\n");
+        ret = -EINVAL;
+        goto EXIT;
+    }
+
+    /* Check that a transfer is not already in progress */
+    if (pc302_dma_get_transaction_state(dma_xfr, src_dst))
+    {
+        /* Transaction in progress error */
+        PRINTD(dma_xfr->dma, PC302_DMA_LVL_INFO, 
+               "Transaction currently in progress\n");
+        ret = -EBUSY;
+        goto EXIT;
+    }
+
+    /* If this is not a flow controlling endpoint, always do a
+     * burst transfer. The hardware will enter the single transaction
+     * region automatically and inter-operate our request appropriately
+     */
+    if ((src_dst == PC302_DMA_SRC && dma_xfr->src.flow_controller == 0)
+     || (src_dst == PC302_DMA_DST && dma_xfr->dst.flow_controller == 0))
+    {
+
+        pc302_dma_transfer_request(dma_xfr, src_dst, 
+            TRT_SINGLE | TRT_BURST);
+    }
+    else
+    {  /* Endpoint is a flow controller */
+
+        /* Handle non-list differently from list transfers */
+        if (dma_xfr->list == NULL)
+        {
+            /* Get the correct endpoint */
+            if (src_dst == PC302_DMA_SRC)
+            {
+                endpoint = &dma_xfr->src;
+            }
+            else
+            {
+                endpoint = &dma_xfr->dst;
+            }
+        }
+        else
+        { /* Multi-block list type */
+            /* Find the current running block */
+            curr_desc = dma_xfr->list->current_block;
+
+            /* Get the correct endpoint */
+            if (src_dst == PC302_DMA_SRC)
+            {
+                /* If auto-reload type, use the first element */
+                if (dma_xfr->list->is_multi_block_src == 0)
+                {
+                    curr_desc = &dma_xfr->list->descriptor_list[0];
+                }
+                endpoint = &curr_desc->sw.src;
+            }
+            else
+            {  /* Dst endpoint */
+                /* If auto-reload type, use the first element */
+                if (dma_xfr->list->is_multi_block_dst == 0)
+                {
+                    curr_desc = &dma_xfr->list->descriptor_list[0];
+                }
+                endpoint = &curr_desc->sw.dst;
+            }
+        } /* multi-block list type transfer */
+
+        /* Work out the transfer type based in the endpoint in use */
+        xfr_type = pc302_dma_determine_transfer_type(dma_xfr, 
+            endpoint, bytes_left);
+
+        /* do nothing and exit if we have nothing more to transfer */
+        if (xfr_type != TRT_NONE)
+        {
+            /* Request the transfer */
+            pc302_dma_transfer_request(dma_xfr, src_dst, xfr_type);
+        }
+    }   /* endpoint is a flow controller */
+
+EXIT:
+    spin_unlock_irqrestore(&dma_xfr->dma->spinlock, spinlock_flags);
+    return ret;
+}
+
+/*****************************************************************************
+   Get the device handle of one of the PC302 DMA controllers.
+*****************************************************************************/
+pc302_dma_t
+pc302_dma_get_dma_handle(unsigned dmaNumber)
+{
+    if (dmaNumber < 2)
+    {
+        return dmac[dmaNumber].dma;
+    }
+    else
+    {
+        PRINTE("Returning NULL as DMA handle\n");
+        return NULL;
+    }
+}
+
+/*****************************************************************************
+   Print out all DMA configuration registers for all channels, including the
+   information held in multi-block lists.
+*****************************************************************************/
+void
+pc302_dma_dump_regs(pc302_dma_t dma)
+{
+    unsigned i=0;
+    u32 reg=0;
+    u32 llp=0;
+    u32 head_llp=0;
+    void __iomem *virt_addr = NULL;
+    int block=0;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return;
+    }
+
+    /* Spinlocks not required as no DMA register or handle parameters are
+       being updsted */
+
+    for (i =0;i< PC302_DMA_CHANNELS;i++)
+    {
+        printk("CHANNEL %u:\n", i);
+
+        PRINT_REG("SAR", PC302_DMA_N_SRC_ADDR_REG_OFFSET(i));
+        PRINT_REG("DAR", PC302_DMA_N_DST_ADDR_REG_OFFSET(i));
+        PRINT_REG("LLP", PC302_DMA_N_LLP_REG_OFFSET(i));
+        head_llp = reg;
+
+        PRINT_REG("CTLlow", PC302_DMA_N_CTRL_REG_OFFSET(i));
+        pc302_dma_print_ctl_low(dma, reg);
+        PRINT_REG("CTLhigh", PC302_DMA_N_BLOCK_SIZE_REG_OFFSET(i));
+        pc302_dma_print_ctl_high(dma, reg);
+
+        PRINT_REG("CFGlow", PC302_DMA_N_LOW_CONFIG_REG_OFFSET(i));
+        PRINT_FIELD("CH_PRIOR", PC302_DMA_CH_PRIOR_MASK, 
+            PC302_DMA_CH_PRIOR_SHIFT);
+        PRINT_BIT("CH_SUSP", PC302_DMA_CH_SUSP);
+        PRINT_BIT("FIFO_EMPTY", PC302_DMA_FIFO_EMPTY);
+        PRINT_BIT("HS_SEL_DST", PC302_DMA_HS_SEL_DST);
+        PRINT_BIT("HS_SEL_SRC", PC302_DMA_HS_SEL_SRC);
+        PRINT_BIT("DST_HS_POL", PC302_DMA_DST_HS_POL);
+        PRINT_BIT("SRC_HS_POL", PC302_DMA_SRC_HS_POL);
+        PRINT_FIELD("MAX_ABRST", PC302_DMA_MAX_ABRST_MASK, 
+            PC302_DMA_MAX_ABRST_SHIFT);
+        PRINT_BIT("RELOAD_SRC", PC302_DMA_RELOAD_SRC);
+        PRINT_BIT("RELOAD_DST", PC302_DMA_RELOAD_DST);
+
+        PRINT_REG("CFGhigh", PC302_DMA_N_HIGH_CONFIG_REG_OFFSET(i));
+        PRINT_BIT("FCMODE", PC302_DMA_FC_MODE);
+        PRINT_BIT("FIFO_MODE", PC302_DMA_FIFO_MODE);
+        PRINT_FIELD("PROTCTL", PC302_DMA_PROTCTL_MASK, PC302_DMA_PROTCTL_SHIFT);
+        PRINT_FIELD("SRC_PER", PC302_DMA_SRC_PER_MASK, PC302_DMA_SRC_PER_SHIFT);
+        PRINT_FIELD("DEST_PER", PC302_DMA_DST_PER_MASK, 
+            PC302_DMA_DST_PER_SHIFT);
+
+        PRINT_REG("SGR", PC302_DMA_N_SRC_GATHER_REG_OFFSET(i));
+        PRINT_FIELD("SGI", PC302_DMA_SG_INTERVAL_MASK, 
+            PC302_DMA_SG_INTERVAL_SHIFT);
+        PRINT_FIELD("SGC", PC302_DMA_SG_COUNT_MASK, PC302_DMA_SG_COUNT_SHIFT);
+
+        PRINT_REG("DSR", PC302_DMA_N_DST_SCATTER_REG_OFFSET(i));
+        PRINT_FIELD("DSI", PC302_DMA_SG_INTERVAL_MASK, 
+            PC302_DMA_SG_INTERVAL_SHIFT);
+        PRINT_FIELD("DSC", PC302_DMA_SG_COUNT_MASK, PC302_DMA_SG_COUNT_SHIFT);
+
+        if (head_llp != 0)
+        {
+            /* Link list pointer is not NULL indicating that this channel
+               has a list of descriptors */
+            printk("\n    MULTI BLOCK LIST:\n");
+            llp = head_llp;
+            do
+            {
+                /* Convert to a virtual address */
+                virt_addr = ioremap(llp, 
+                    (unsigned long)sizeof(descriptor_t));
+                printk("        BLOCK %d phy addr=0x%p, virt_addr=0x%p\n", 
+                    block, (void *)llp, virt_addr);
+                block++;
+
+                PRINT_LLP_REG("LLP.SAR", virt_addr); /* source_addr */
+                PRINT_LLP_REG("LLP.DAR", virt_addr+4); /* dest_addr */
+                PRINT_LLP_REG("LLP.LLP", virt_addr+8); /* link */
+                PRINT_LLP_REG("LLP.CTLlow", virt_addr+12); /*control */
+                pc302_dma_print_ctl_low(dma, reg);
+                PRINT_LLP_REG("LLP.CTLhigh", virt_addr+16); /*block_ts */
+                pc302_dma_print_ctl_high(dma, reg);
+
+                llp = (u32)(((descriptor_t *)virt_addr)->hw.link);
+                iounmap(virt_addr);
+                printk("\n");
+            }
+            while ((llp != 0) && (llp != head_llp));
+        }
+    }
+
+    printk("\n    INTERRUPTS:\n");
+
+    PRINT_CH_REG("RawTfr", 
+        PC302_DMA_TXFER_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+    PRINT_CH_REG("RawBlock", 
+        PC302_DMA_BLOCK_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+    PRINT_CH_REG("RawSrcTran", 
+        PC302_DMA_SRC_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+    PRINT_CH_REG("RawDstTran", 
+        PC302_DMA_DST_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+    PRINT_CH_REG("RawErr", 
+        PC302_DMA_ERROR_REG_OFFSET(PC302_DMA_INTERRUPT_RAW));
+
+    PRINT_CH_REG("StatusTfr", 
+        PC302_DMA_TXFER_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+    PRINT_CH_REG("StatusBlock", 
+        PC302_DMA_BLOCK_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+    PRINT_CH_REG("StatusSrcTran", 
+        PC302_DMA_SRC_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+    PRINT_CH_REG("StatusDstTran", 
+        PC302_DMA_DST_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+    PRINT_CH_REG("StatusErr", 
+        PC302_DMA_ERROR_REG_OFFSET(PC302_DMA_INTERRUPT_STATUS));
+
+    PRINT_CH_REG("MaskTfr", 
+        PC302_DMA_TXFER_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_MASK));
+    PRINT_CH_REG("MaskBlock", 
+        PC302_DMA_BLOCK_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_MASK));
+    PRINT_CH_REG("MaskSrcTran", 
+        PC302_DMA_SRC_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_MASK));
+    PRINT_CH_REG("MaskDstTran", 
+        PC302_DMA_DST_TRX_COMPLETE_REG_OFFSET(PC302_DMA_INTERRUPT_MASK));
+    PRINT_CH_REG("MaskErr", 
+        PC302_DMA_ERROR_REG_OFFSET(PC302_DMA_INTERRUPT_MASK));
+
+    PRINT_REG("StatusInt", PC302_DMA_IRQ_STATUS_REG_OFFSET);
+    PRINT_BIT("TFR", PC302_DMA_STATUS_TFR);
+    PRINT_BIT("BLOCK", PC302_DMA_STATUS_BLOCK);
+    PRINT_BIT("SRCT", PC302_DMA_STATUS_SRCT);
+    PRINT_BIT("DSTT", PC302_DMA_STATUS_DSTT);
+    PRINT_BIT("ERR", PC302_DMA_STATUS_ERR);
+
+    printk("\n    HANDSHAKING:\n");
+    PRINT_CH_REG("ReqSrcReg", 
+        PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(PC302_DMA_BURST_TRANSFER));
+    PRINT_CH_REG("ReqDstReg", 
+        PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(PC302_DMA_BURST_TRANSFER));
+    PRINT_CH_REG("SglReqSrcReg", 
+        PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(PC302_DMA_SINGLE_TRANSFER));
+    PRINT_CH_REG("SglReqDstReg", 
+        PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(PC302_DMA_SINGLE_TRANSFER));
+    PRINT_CH_REG("LstSrcReg", 
+        PC302_DMA_SRC_TRX_REQUEST_REG_OFFSET(PC302_DMA_LAST_TRANSFER));
+    PRINT_CH_REG("LstDstReg", 
+        PC302_DMA_DST_TRX_REQUEST_REG_OFFSET(PC302_DMA_LAST_TRANSFER));
+
+    printk("\n    MISC:\n");
+    PRINT_REG("DmaCfgRe", PC302_DMA_CONFIGURATION_REG_OFFSET);
+    PRINT_CH_REG("ChEnReg", PC302_DMA_CHANNEL_ENABLE_REG_OFFSET);
+    PRINT_REG("DmaIdReg", PC302_DMA_ID_REG_OFFSET);
+    PRINT_REG("DmaTestReg", PC302_DMA_TEST_REG_OFFSET);
+    printk("\n");
+}
+
+/*****************************************************************************
+   Set a debug level for the DMA handle
+*****************************************************************************/
+void
+pc302_dma_set_debug_level(pc302_dma_t dma, 
+                          pc302_dma_lvl_t lvl)
+{
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_INFO, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return;
+    }
+
+    dma->lvl = lvl;
+}
+
+/*****************************************************************************
+ * Platform data structures
+ *****************************************************************************/
+
+/*!
+ * Definition of platform driver functions
+ */
+static struct platform_driver dmac_driver =
+{
+    .probe      = pc302_dma_drv_probe, 
+    .remove     = pc302_dma_drv_remove, 
+    .driver     =
+    {
+        .name   = CARDNAME, 
+    }
+};
+
+/*****************************************************************************
+   Platform driver probe function
+*****************************************************************************/
+static int
+pc302_dma_drv_probe(struct platform_device *pdev)
+{
+    int id  = ((struct platform_device *)pdev)->id;
+    struct resource *pdata = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    struct resource *r=NULL;
+    struct pc302_dma_tag *dma=NULL;
+    int ret = SUCCESS;
+
+    dma = kzalloc(sizeof(struct pc302_dma_tag), GFP_KERNEL);
+    if (dma == NULL)
+    {
+        /* No memory */
+        PRINTE("Out of memory for device %s\n", pdata->name);
+        return -ENOMEM;
+    }
+
+    if (pdata == NULL)
+    {
+        PRINTE("%s: could not allocate device.\n", pdata->name);
+        kfree(dma);
+        return -EINVAL;
+    }
+
+    r = request_mem_region(pdata->start, (pdata->end-pdata->start),
+        pdata->name);
+    if (r != NULL)
+    {
+        dma->membase = ioremap(pdata->start, (pdata->end-pdata->start));
+        if (dma->membase == NULL)
+        {
+            release_resource(r);
+            kfree(dma);
+            ret = -EIO;
+        }
+    }
+    else
+    {
+        kfree(dma);
+        ret = -EBUSY;
+    }
+    
+    dmac[id].dev = pdev;
+    dmac[id].dma = dma;
+
+    if (ret != SUCCESS)
+    {
+         PRINTE("Mapping %s error, hw=%x, virt=%p, size=%d, err=%d\n", 
+            pdata->name, pdata->start, dma->membase, (pdata->end-pdata->start), 
+            ret);
+         return ret;
+    }
+
+    /* Set the default debug level */
+    dma->lvl = PC302_DMA_DEBUG_LEVEL;
+    dma->id = id;
+
+    /* Get a pointer to the underlying device for dma_alloc_coherent calls */
+    dma->device = &pdev->dev;
+    dma->last_int_channel = 0;
+
+    /* Allocate a spinlock for each engine */
+    spin_lock_init(&dma->spinlock);
+
+    /* Initialise engine hardware */
+    pc302_dma_hw_initialise(dma);
+
+    platform_set_drvdata(pdev, dma);
+
+    tasklet_init(&dma->tasklet,pc302_dma_do_tasklet,(unsigned long)dma);
+
+    return SUCCESS;
+}
+
+/*****************************************************************************
+   Platform driver remove function
+*****************************************************************************/
+static int
+pc302_dma_drv_remove(struct platform_device *pdev)
+{
+    struct pc302_dma_tag *dma = platform_get_drvdata(pdev);
+    struct resource *pdata = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    int ret = SUCCESS;
+
+    if (dma != NULL)
+    {
+        pc302_dma_hw_shutdown(dma);
+
+        ret = pc302_dma_free_irq(dma, 0xFF); /* Free all channels at once */
+
+        iounmap(dma->membase);
+        release_mem_region(pdata->start, (pdata->end-pdata->start));
+
+        tasklet_kill(&dma->tasklet);
+
+        kfree(dma);
+    }
+
+    platform_set_drvdata(pdev, NULL);
+
+    return ret;
+}
+
+/*****************************************************************************
+   Allows a client process to register to receive an interrupt for
+   the DMAC and DMA channel specified.
+*****************************************************************************/
+static int
+pc302_dma_request_irq(pc302_dma_t dma, 
+                      u32 bitField)
+{
+    int ret = SUCCESS;
+    struct resource *r=NULL;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+    }
+    else
+    {
+        PRINTE("NULL DMA handle / DMA engine not enabled\n");
+        return -EINVAL;
+    }
+
+    if (dma->allocatedInterrupts == 0)
+    {
+        /* IRQ has not been requested for this DMA handle. Need to determine
+           which DMA (0 or 1) this handle is controlling */
+        r = platform_get_resource(dmac[dma->id].dev, IORESOURCE_IRQ, 0);
+        if (r == NULL)
+        {
+            PRINTE("cannot get DMA resource for DMAC%d\n",dma->id);
+        }
+        else
+        {
+            ret = request_irq(r->start, &pc302_dma_isr, IRQF_DISABLED, 
+                    r->name, dma);
+            if (ret)
+            {
+                PRINTE("cannot assign IRQ for DMAC%d. Ret code = %d\n",
+                    dma->id, ret);
+            }
+        }
+    }
+
+    dma->allocatedInterrupts |= bitField;
+    return ret;
+}
+
+/*****************************************************************************
+   Function that allows a client to process to deregister itself from
+   receiving an interrupt for the DMA and channel specified.
+*****************************************************************************/
+static int
+pc302_dma_free_irq(pc302_dma_t dma, 
+                   u32 bitField)
+{
+    struct resource *r=NULL;
+
+    if (DMA_ENGINE_ENABLED(dma))
+    {
+        PRINTD(dma, PC302_DMA_LVL_TRACE, "Enter\n");
+
+        if (dma->allocatedInterrupts)
+        {
+            dma->allocatedInterrupts &= ~((unsigned)(bitField));
+            if (dma->allocatedInterrupts == 0)
+            {
+                r = platform_get_resource(dmac[dma->id].dev, IORESOURCE_IRQ, 0);
+                if (r == NULL)
+                {
+                    PRINTE("cannot free DMA resource for DMAC%d\n",dma->id);
+                }
+                else
+                {
+                    free_irq(r->start, dma);
+                }
+            }
+        }
+    }
+
+    return SUCCESS;
+}
+
+/*****************************************************************************
+   Driver init function
+*****************************************************************************/
+static int __init dmac_init_module(void)
+{
+    int ret = SUCCESS;
+
+    ret = platform_driver_register(&dmac_driver);
+    if (ret != 0)
+    {
+        printk(KERN_INFO "%s " CONFIG_LOCALVERSION " " __DATE__ " "  __TIME__
+            " failed to load\n", TITLE);
+        return ret;
+    }
+
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " " __DATE__ " "  __TIME__
+        " loaded\n", TITLE);
+
+    return ret;
+}
+
+/*****************************************************************************
+   Driver cleanup function
+*****************************************************************************/
+static void __exit dmac_cleanup_module(void)
+{
+    platform_driver_unregister(&dmac_driver);
+
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " " __DATE__ " "  __TIME__
+        " unloaded\n", TITLE);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("picoChip PC302 DMA Driver");
+MODULE_AUTHOR("Andrew Watkins");
+
+/* Module exports functions */
+module_init(dmac_init_module);
+module_exit(dmac_cleanup_module);
+
+EXPORT_SYMBOL(pc302_dma_setup_direct_xfr);
+EXPORT_SYMBOL(pc302_dma_start);
+EXPORT_SYMBOL(pc302_dma_abort);
+EXPORT_SYMBOL(pc302_dma_release);
+EXPORT_SYMBOL(pc302_dma_list_create);
+EXPORT_SYMBOL(pc302_dma_list_add);
+EXPORT_SYMBOL(pc302_dma_list_clear);
+EXPORT_SYMBOL(pc302_dma_list_destroy);
+EXPORT_SYMBOL(pc302_dma_setup_list_xfr);
+EXPORT_SYMBOL(pc302_dma_enable_int);
+EXPORT_SYMBOL(pc302_dma_disable_int);
+EXPORT_SYMBOL(pc302_dma_clear_int);
+EXPORT_SYMBOL(pc302_dma_get_raw_status);
+EXPORT_SYMBOL(pc302_dma_setup_sg);
+EXPORT_SYMBOL(pc302_dma_request_transaction);
+EXPORT_SYMBOL(pc302_dma_get_dma_handle);
+EXPORT_SYMBOL(pc302_dma_dump_regs);
+EXPORT_SYMBOL(pc302_dma_set_debug_level);
+
diff --git a/drivers/dma/pc302_dmac_test.c b/drivers/dma/pc302_dmac_test.c
new file mode 100644
index 0000000..2665ade
--- /dev/null
+++ b/drivers/dma/pc302_dmac_test.c
@@ -0,0 +1,3473 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+ * \file pc302_dmac_test.c
+ *
+ * \brief This module tests the PC302 DMAs, DMA controller, and API.
+ *
+ * The PC302 DMAC has a lot of functionality some of which cannot be tested
+ * or easily tested on the PC302. Specifically it supports both hardware and 
+ * software flow control where the flow controller can be the DMA itself, or
+ * the source or destination peripheral. Additionally the DMAC supports single
+ * and  burst transfers using a single descriptor loaded into its internal
+ * registers, or a list of descriptors in external memory. The DMA can also
+ * handle variable bus widths up to 64 bits from several master ports, and
+ * permits scatter gather transfers. Finally there are two DMA instances in the
+ * PC302 which do not connect to exactly the same interfaces.
+ *
+ * This test module attempts to test some of the functionality listed above,
+ * as well as the kernel API. The following is a summary of the functionality
+ * that is tested:
+ * - Direct (i.e. a single descriptor) transfers.
+ * - Multiple descriptor (i.e. from a list) transfers.
+ * - Transfers to and from peripherals under software handshaking. The
+ *   peripheral is simulated using a memory location, and software handshaking
+ *   means that the transfer of data to the end point is conducted under the
+ *   control of the client software (using pc302_dma_request_transaction).
+ * - Transfers to and from peripherals under software handshaking and 
+ *   peripheral flow control. These tests simulate the situation where the
+ *   size of the data coming from the peripheral source or going to the
+ *   peripheral destination is not known, and pc302_dma_request_transaction
+ *   has to be called one or more times.
+ *
+ * In summary this module tests:
+ * - Memory to memory transfers
+ * - Memory to peripheral and peripheral to peripheral transfers.
+ * - Descriptor reuse testing
+ * - Interrupt testing
+ * - 64 bit bus widths, single and burst transfers
+ * - There is no hardware interface testing as all the hardware interfaces
+ *   connect directly to the picoArray where special embedded picoArray code
+ *   would be required as an interface.
+ */
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All inquiries to support@picochip.com
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/autoconf.h>
+#include <linux/delay.h>
+
+#include <mach/io.h>
+#include <mach/hardware.h>
+#include <mach/pc302_dmac.h>
+
+/*****************************************************************************
+ * Magic numbers
+ *****************************************************************************/
+
+/*!
+ * A name for this module
+ */
+#define TITLE "pc302 DMA Controller Driver Test Module"
+
+/*!
+ * Return status for the tests
+ */
+#define SUCCESS           (0)
+#define FAIL              (1)
+
+/*!
+ * Specify the delay (in jiffies) to use in the schedule_timeout()
+ * function. 
+ */
+#define SMALL_DELAY       (50)
+
+/*!
+ * Specify a character to put into constant payloads
+ */
+#define TEST_VALUE       (0xbe)
+ 
+/*!
+ * Module default load parameter (which DMAC to test)
+ */
+static int dmac_to_test=0;
+module_param(dmac_to_test, int, 0);
+
+/*!
+ * Module parameter description (which DMAC to test)
+ */
+MODULE_PARM_DESC(dmac_to_test, "Specify which DMAC to test (Default is 0)");
+
+/*!
+ * Module default load parameter (max block size to test)
+ */
+static int max_block_size=2048;
+module_param(max_block_size, int, 1);
+
+/*!
+ * Module parameter description (max block size to test)
+ */
+MODULE_PARM_DESC(max_block_size, 
+    "Specify the maximum block size (Default is 2048)");
+
+/*!
+ * Module default load parameter (tests to run)
+ */
+static unsigned int tests_to_run=0xFFFFFFFF;
+module_param(tests_to_run, int, 0);
+
+/*!
+ * Module parameter description (tests to run)
+ */
+MODULE_PARM_DESC(tests_to_run, 
+    "Specify the tests to run - 1 bit for each test (Default is 0xFFFFFFFF)");
+
+/*****************************************************************************
+ * Macros
+ *****************************************************************************/
+
+/*!
+ * Macro which prints out the cause of the error
+ */
+#define FAIL_TEST(_why) \
+    ( { \
+        test_state |= FAIL; \
+        printk("TEST FAILURE: %s\n",_why); \
+    } )
+
+/*!
+ * Reset test result
+ */
+#define RESET_TEST_RES()  (test_state = SUCCESS)
+
+/*!
+ * Set test result (failed)
+ */
+#define TEST_FAILED       (test_state == FAIL)
+
+/*!
+ * Number of descriptors to chain in multi block tests
+ */
+#define LIST_SIZE         (10)
+
+/*!
+ * Number of descriptors to to reuse in multi block tests
+ */
+#define REUSE_LIST_SIZE   (5)
+
+/*!
+ * Number of tests
+ */
+#define NUM_TESTS         (21)
+
+/*****************************************************************************
+ * Private data structure & types
+ *****************************************************************************/
+
+/*!
+ * Function prototype for all tests
+ */
+typedef void (*tf)(void);
+
+/*!
+ * Structure for holding client data. Used in tests involving interrupts
+ */
+typedef struct
+{
+    unsigned irq_state;          /*<! Total interrupts                     */
+    unsigned tlxwi2_trf_ints;    /*<! Completed Transfer interrupts        */
+    unsigned tlxwi2_block_ints;  /*<! Completed Block interrupts           */
+    unsigned tlxwi2_srctrx_ints; /*<! Source Transfer completed interrupts */
+    unsigned tlxwi2_dsttrx_ints; /*<! Destination transfer completed 
+                                      interrupts                           */
+    unsigned tlxwi2_err_ints;    /*<! Error interrupts                     */
+    unsigned blocks_left;        /*<! Number of blocks left to transfer    */
+    pc302_dma_xfr_t xfr;         /*<! The DMA transfer handle              */
+}
+client_data_interrupt_test_t;
+
+/*****************************************************************************
+ * Private function prototypes
+ *****************************************************************************/
+
+/*!
+ * \brief Return the DMAC handle
+ *
+ * \param num DMA number
+ *
+ * \return DMA context handle, 0 for error
+ */
+static pc302_dma_t
+get_dmac(int num);
+
+/*!
+ * \brief Fill the specified area of memory with random data
+ *
+ * \param vaddr Starting address
+ * \param size Size of memory
+ *
+ * \return none
+ */
+static void
+rand_fill(void *vaddr, 
+          unsigned size);
+
+/*!
+ * \brief Perform a checksum on the area of memory specified
+ *
+ * \param vaddr Starting address
+ * \param size Size of memory
+ *
+ * \return 0 Success, -1 Fail
+ */
+static unsigned
+checksum(void *vaddr, 
+         unsigned size);
+
+/*!
+ * \brief Allocate an area of non cached memory
+ *
+ * \param vaddr Virtual address of memory allocated
+ * \param size  Size of memory to allocate
+ * \param do_checksum Flag
+ *                    Set to 1 if the memory is to be filled with random
+ *                    data with a checksum added to the final 4 bytes.
+ *
+ * \return Physical address for memory allocated, 0 on error
+ */
+static dma_addr_t
+get_dma_buffer(void **vaddr, 
+               unsigned size, 
+               unsigned do_checksum);
+
+/*!
+ * \brief Perform a small delay
+ */
+static void
+shortDelay(void);
+
+/******************************************************************************
+* Interrupt handler function definitions
+******************************************************************************/
+/*!
+ * \brief Interrupt handler for the Direct transfer test using interrupts
+ *
+ * \param cookie Pointer to data associated with this interrupt
+ * \param errno The type of interrupt that triggered the event
+ */
+static int
+test_direct_xfr_with_interrupts_irq(void *cookie, 
+                                    int errno);
+
+/*!
+ * \brief Interrupt handler for the List transfer test using interrupts
+ *
+ * \param cookie Pointer to data associated with this interrupt
+ * \param errno The type of interrupt that triggered the event
+*/
+static int
+test_list_xfr_with_interrupts_irq(void *cookie, 
+                                  int errno);
+
+/*!
+ * \brief Interrupt handler for the List to list transfer test with interrupts
+ * and block control
+ *
+ * \param cookie Pointer to data associated with this interrupt
+ * \param errno The type of interrupt that triggered the event
+ */
+static int
+test_list_xfr_with_interrupts2_irq(void *cookie, 
+                                   int errno);
+
+/*!
+ * \brief Interrupt handler for the simple direct transfer test using source
+ * and destinmation software handshaking controlled by interrupts
+ *
+ * \param cookie Pointer to data associated with this interrupt
+ * \param errno The type of interrupt that triggered the event
+ */
+static int
+test_src_dst_sw_handshaking_int_irq(void *cookie, 
+                                    int errno);
+
+/******************************************************************************
+* DMAC tests definitions
+******************************************************************************/
+
+/*!
+ * \brief Direct memory to memory transfer test with no interrupts
+ *
+ * \par Test 1 (tests_to_run: 0x00000001)
+ * This test will perform a direct memory to memory transfer without using
+ * interrupts as follows:
+ * - Sets the debug level to maximum (0xFFFF)
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize of 1
+ * - Transfers a total of 4*MAX_BLOCK_SIZE bytes
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_direct_xfr(void);
+
+/*!
+ * \brief Direct memory to memory transfer of an entire list without interrupts
+ *
+ * \par Test 2 (tests_to_run: 0x00000002)
+ * This test will perform a list memory to memory transfer using a list
+ * and no interrupts. It does the following:
+ * - Sets up a list of LIST_SIZE blocks of size max_block_size
+ * - Fills all blocks with pseudo random data
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize of 1
+ * - Performs a checksum on the each block of data transferred
+ */
+static void
+test_list_list_xfr(void);
+
+/*!
+ * \brief Direct memory to memory transfer test using interrupts
+ *
+ * \par Test 3 (tests_to_run: 0x00000004)
+ * This test will perform a direct memory to memory transfer using interrupts.
+ * It does the following:
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize of 1
+ * - Installs an interrupt handler to process interrupts
+ * - Enables Block completion, Transfer completion, and Error detection
+ *   interrupts
+ * - Counts the interrupts received.
+ * - Transfers a total of 4*MAX_BLOCK_SIZE bytes
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_direct_xfr_with_interrupts(void);
+
+/*!
+ * \brief List memory to list memory transfer test using interrupts
+ * 
+ * \par Test 4 (tests_to_run: 0x00000008)
+ * This test will perform a direct memory to memory transfer using a list
+ * and interrupts. It does the following:
+ * - Sets up a list of LIST_SIZE blocks of size max_block_size
+ * - Fills all blocks with pseudo random data
+ * - Installs an interrupt handler to process interrupts
+ * - Enables Block completion, Transfer completion, and Error detection
+ *   interrupts
+ * - Counts the interrupts received.
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize of 1
+ * - Performs a checksum on the each block of data transferred
+ */
+static void
+test_list_xfr_with_interrupts(void);
+
+/*!
+ * \brief List memory to list memory transfer test with interrupts and block
+ * control.
+ *
+ * \par Test 5 (tests_to_run: 0x00000010)
+ * This test will perform a list memory to memory transfer using a list,
+ * interrupts and block control. It does the following:
+ * - Sets up a list of LIST_SIZE blocks of size max_block_size
+ * - Fills all blocks with pseudo random data
+ * - Installs a interrupt handler to process interrupts
+ * - Enables Block completion, Transfer completion, and Error detection
+ *   interrupts
+ * - Counts the interrupts received, and confirms they are correct.
+ * - Confirms that all blocks have been transferred.
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize of 1
+ * - Performs a checksum on the each block of data transferred
+ */
+static void
+test_list_xfr_with_interrupts2(void);
+
+/*!
+ * \brief Direct memory to memory transfer test without interrupts
+ * and various block sizes
+ *
+ * \par Test 6 (tests_to_run: 0x00000020)
+ * This test perform a single direct transfer without interrupts using an
+ * increasing blocks size as follows:
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to automatic
+ * - Transfers block sizes from 8 to MAX_BLOCK_SIZE bytes in step of 8.
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_xfr_block_sizes(void);
+
+/*!
+ * \brief Direct peripheral to memory transfer using source software
+ * handshaking
+ *
+ * \par Test 7 (tests_to_run: 0x00000040)
+ * The test uses a memory location as a dummy peripheral source
+ * and then requests the transfer of the element. It:
+ * - Uses PC302_DMA_MASTER as the source and destination port
+ * - Uses 64 bit transfer width, with a msize set to automatic
+ * - Requests a transfer of size max_block_size
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_src_sw_handshaking(void);
+
+/*!
+ * \brief Direct memory to peripheral transfer using destination
+ * software handshaking
+ *
+ * \par Test 8 (tests_to_run: 0x00000080)
+ * The test uses a memory location as a dummy peripheral destination
+ * and then requests the transfer of the element. It:
+ * - Uses PC302_DMA_MASTER as the source and destination port
+ * - Uses 64 bit transfer width, with a msize set to automatic
+ * - Requests a transfer of size max_block_size
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_dst_sw_handshaking(void);
+
+/*!
+ * \brief Direct peripheral to peripheral transfer using source and
+ * destination software handshaking.
+ *
+ * \par Test 9: (tests_to_run: 0x00000100)
+ * The test uses a memory location as a dummy peripheral source and
+ * another memory location as a dummy destination. It then requests
+ * the transfer of the element as follows:
+ * - Uses PC302_DMA_MASTER1 as the source and destination port
+ * - Uses 64 bit transfer width, with a msize set to automatic
+ * - Requests a transfer of size max_block_size
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_src_dst_sw_handshaking(void);
+
+/*!
+ * \brief Direct peripheral to peripheral transfer test using source and
+ * destination software handshaking controlled by interrupts.
+ *
+ * \par Test 10: (tests_to_run: 0x00000200)
+ * This test uses memory locations as dummy source and destination and
+ * then requests performs a software controlled DMA request as following:
+ * - Fills the block with pseudo random data
+ * - Installs a interrupt handler to process interrupts
+ * - Enables Transfer completion, Source transfer completion,
+ *   destination transfer completion, and Error detection interrupts
+ * - Counts the interrupts received, and confirms they are correct.
+ * - Confirms that all blocks have been transferred.
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize of 1
+ * - Transfers a block size of max_block_size
+ * - Performs a checksum on the each block of data transferred
+ */
+static void
+test_src_dst_sw_handshaking_int(void);
+
+/*!
+ * \brief Direct peripheral to peripheral transfer test using source and
+ * destination software handshaking and various block sizes.
+ *
+ * \par Test 11: (tests_to_run: 0x00000400)
+ * This test uses memory locations as dummy source and destination and
+ * does the following:
+ * - Fills the block with pseudo random data 
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to automatic
+ * - Requests a transfers of blocks ranging from 8 to max_block_size bytes
+ *   in steps od 8
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_src_dst_sw_handshaking_block_sizes(void);
+
+/*!
+ * \brief Direct peripheral to peripheral transfer using source and destination
+ * software handshaking and source flow control.
+ *
+ * \par Test 12: (tests_to_run: 0x00000800)
+ *  The test uses memory locations as dummy source and destination, and
+ * does the following:
+ * - Fills the block with pseudo random data
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to automatic
+ * - Transfers a block size of max_block_size
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_src_dst_sw_hand_src_flow_controller(void);
+
+/*!
+ * \brief Direct peripheral to peripheral transfer using source and destination
+ * software handshaking and destination flow control.
+ *
+ * \par Test 13: (tests_to_run: 0x00001000)
+ * The test uses memory locations as dummy source and destination and
+ * does the following:
+ * - Fills the block with pseudo random data
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to automatic
+ * - Transfers a block size of max_block_size
+ * - Performs a checksum on the data transferred
+*/
+static void
+test_src_dst_sw_hand_dst_flow_controller(void);
+
+/*!
+ * \brief Direct peripheral to peripheral transfer, source and destination
+ * software handshaking, and source flow control with various block sizes.
+ *
+ * \par Test 14: (tests_to_run: 0x00002000)
+ * The test uses memory locations as dummy source and destination and
+ * does the following:
+ * - Fills the block with pseudo random data
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to automatic
+ * - Transfers a block size of max_block_size
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_src_dst_sw_handshaking_src_fc_block_sizes(void);
+
+/*!
+ * \brief Direct peripheral to peripheral transfer, source and destination
+ * software handshaking, and destination flow control with various block sizes.
+ *
+ * \par Test 15: (tests_to_run: 0x00004000)
+ * The test uses memory locations as dummy source and destination and
+ * does the following:
+ * - Fills the block with pseudo random data
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to automatic
+ * - Transfers block sizes from 8 to MAX_BLOCK_SIZE bytes in step of 8.
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_src_dst_sw_handshaking_dst_fc_block_sizes(void);
+
+/*!
+ * \brief Direct memory to peripheral transfer with destination software
+ * handshaking and destination flow control.
+ *
+ * \par Test 16: (tests_to_run: 0x00008000)
+ * The test uses memory locations as a dummy destination and does the following:
+ * - Fills the block with pseudo random data
+ * - Use PC302_DMA_MASTER2 as the source port
+ * - Use PC302_DMA_MASTER3 as the destination port
+ * - Use 64 bit transfer width, with a msize set to automatic
+ * - Transfers a block size of max_block_size
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_dst_sw_hand_dst_flow_controller(void);
+
+/*!
+ * \brief Direct peripheral to memory various block size transfers
+ * with source software handshaking and source flow control
+ *
+ * \par Test 17: (tests_to_run: 0x00010000)
+ * The test uses memory locations as a dummy source and does the following:
+ * - Fills the block with pseudo random data
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to automatic
+ * - Transfers block size from 8 to max_block_size in steps of 8
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_src_sw_handshaking_src_fc_block_sizes(void);
+
+/*!
+ * \brief Test that reloads the transfers list
+ *
+ * \par Test 18: (tests_to_run: 0x00020000)
+ * This test uses a list containing one element on the source side referenced
+ * multiple times, and LIST_SIZE separate elements on the destination side.
+ * When the test is run the same source element is used multiple times.
+ * - Fills the block with pseudo random data
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to 1
+ * - Transfers a block size of max_block_size
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_reload_to_list_xfr(void);
+
+/*!
+ * \brief Test the reuse of DMA descriptors
+ *
+ * \par Test 19: (tests_to_run: 0x00040000)
+ * Test that sets up a list of transfers, performs the transfer, reuses
+ * some of the elements of the list, and proves that the second transfer works
+ * properly.
+ * - Fills the block with pseudo random data
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to 1
+ * - Transfers a block size of max_block_size
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_list_list_xfr_reuse_list(void);
+
+/*!
+ * \brief Direct peripheral to peripheral transfer using hardware handshaking.
+ *
+ * \par Test 20: (tests_to_run: 0x00080000)
+ * This test uses memory locations as dummy source and peripherals and sets
+ * up a transfer with a hardware interface. The parameters used are:
+ * - Use PC302_DMA_MASTER4 as the source and destination port
+ * - Use 64 bit transfer width, with a msize set to 4 
+ * \note
+ * - This function does not actually transfer any data as the hardware
+ *   to drive the handshaking is not setup. This test is only for checking
+ *   the register settings.
+ * - This test can not be run on DMAC 1 as PC302_DMA_MASTER4 connects to the
+ *   AXI2CFG bus rather than the AXI2PICO bus.
+ */
+static void
+test_direct_xfr_hw_handshaking(void);
+
+/*!
+ * \brief List with single element transfer test
+ *
+ * \par Test 21: (tests_to_run: 0x00100000)
+ * This test does a memory to memory list transfer using a list size of 1:
+ * - Use PC302_DMA_MASTER1 as the source and destination port
+ * - Use 64 bit transfer width, with a msize of 1
+ * - Transfers a total of 4*MAX_BLOCK_SIZE bytes
+ * - Performs a checksum on the data transferred
+ */
+static void
+test_single_element_list_list_xfr(void);
+
+/*!
+ * \brief Run all tests specified in structure
+ */
+static void
+run_tests(void);
+
+/*****************************************************************************
+ * Global variables & module parameters
+ *****************************************************************************/
+
+/*!
+ * State of all tests run so far
+ */
+static int test_state=SUCCESS;
+
+/*!
+ * DMAC device handle
+ */
+static struct device *device;
+
+/*!
+ *   Array of tests that will be carried out
+ */
+static struct test_tag
+{
+     /** Brief description of test */
+    char *name;
+
+    /** Test function pointer     */
+    tf test_fn;
+}
+tests[NUM_TESTS] =
+{
+    /*! Test 1: 0x00000001 */
+    {"Simple direct transfer test", test_direct_xfr}, 
+
+    /*! Test 2: 0x00000002 */
+    {"List to list transfer test", test_list_list_xfr}, 
+
+    /*! Test 3: 0x00000004 */
+    {"Simple direct transfer test with interrupts", 
+             test_direct_xfr_with_interrupts}, 
+
+    /*! Test 4: 0x00000008 */
+    {"List to list transfer test with interrupts", 
+             test_list_xfr_with_interrupts}, 
+
+    /*! Test 5: 0x00000010 */
+    {"List to list transfer test with interrupts and block control", 
+             test_list_xfr_with_interrupts2}, 
+
+    /*! Test 6: 0x00000020 */
+    {"Simple direct transfers of various block sizes", 
+             test_xfr_block_sizes}, 
+
+    /*! Test 7: 0x00000040 */
+    {"Simple direct transfer using source software handshaking", 
+             test_src_sw_handshaking}, 
+
+    /*! Test 8: 0x00000080 */
+    {"Simple direct transfer using destination software handshaking", 
+             test_dst_sw_handshaking}, 
+
+    /*! Test 9: 0x00000100 */
+    {"Simple direct transfer using source and destination software "
+        "handshaking", test_src_dst_sw_handshaking}, 
+
+    /*! Test 10: 0x00000200 */
+    {"Simple direct transfer using src/dest sw handshaking "
+        "controlled by interrupts", test_src_dst_sw_handshaking_int}, 
+
+    /*! Test 11: 0x00000400 */
+    {"Simple direct transfer, src/dest sw handshaking, various block sizes", 
+             test_src_dst_sw_handshaking_block_sizes}, 
+
+    /*! Test 12: 0x0000800 */
+    {"Simple direct transfer, src/dest sw handshaking, source flow "
+             "controller", test_src_dst_sw_hand_src_flow_controller}, 
+
+    /*! Test 13: 0x00001000 */
+    {"Simple direct transfer, src/dest sw handshaking, dest flow controller", 
+             test_src_dst_sw_hand_dst_flow_controller}, 
+
+    /*! Test 14: 0x00002000 */
+    {"Simple direct transfer, src/dest sw handshaking, source FC & various "
+        "block sizes", test_src_dst_sw_handshaking_src_fc_block_sizes}, 
+
+    /*! Test 15: 0x00004000 */
+    {"Simple direct transfer, src/dest sw handshaking, dest FC & various "
+        "block sizes", test_src_dst_sw_handshaking_dst_fc_block_sizes}, 
+
+    /*! Test 16: 0x00008000 */
+    {"Simple direct transfer, dest sw handshaking, dest flow controller", 
+             test_dst_sw_hand_dst_flow_controller}, 
+
+    /*! Test 17: 0x00010000 */
+    {"Simple direct transfer, src sw handshaking, source FC & various "
+        "block sizes", test_src_sw_handshaking_src_fc_block_sizes}, 
+
+    /*! Test 18: 0x00020000 */
+    {"Reload Block to list transfer test", test_reload_to_list_xfr}, 
+
+    /*! Test 19: 0x00040000 */
+    {"List to list transfer test, reuse list", test_list_list_xfr_reuse_list}, 
+
+    /*! Test 20: 0x00080000 */
+    {"Simple direct transfer test using hardware handshaking", 
+             test_direct_xfr_hw_handshaking}, 
+
+    /*! Test 21: 0x00100000 */
+    {"Single element list to list transfer test", 
+             test_single_element_list_list_xfr}, 
+};
+
+/*****************************************************************************
+ * Private function declarations
+ *****************************************************************************/
+
+/* Helper functions */
+
+/*****************************************************************************
+   Return the DMAC handle
+******************************************************************************/
+static pc302_dma_t
+get_dmac(int num)
+{
+    pc302_dma_t dma = pc302_dma_get_dma_handle(num);
+
+    if (!dma)
+    {
+        FAIL_TEST("pc302_dma_get_dma_handle");
+        return NULL;
+    }
+    else
+    {
+        printk("Returning handle for DMAC %d\n", num);
+        return dma;
+    }
+}
+
+/*****************************************************************************
+   Fill the specified area of memory with random data.
+   Use data on the stack as a way of generating pseudo random data
+
+   This function uses the address of 'i' in the stack as a starting
+   point to produce pseudo random data
+******************************************************************************/
+static void
+rand_fill(void *vaddr, 
+          unsigned size)
+{
+    unsigned i=0;
+    unsigned *p=(unsigned int*)(vaddr);
+
+    for (i = 0; i < size/4; i++)
+    {
+        p[i]  = *(&i + i);     /* any random data on stack */
+    }
+}
+
+/*****************************************************************************
+   This function performs a checksum for the area of memory specified
+******************************************************************************/
+static unsigned
+checksum(void *vaddr, 
+         unsigned size)
+{
+    unsigned i=0;
+    unsigned *p=NULL;
+    unsigned chk = 0;
+    unsigned bits = 0;
+
+    for (i = 0; i < size; i += 4)
+    {
+        p = (unsigned *)(((unsigned char *)vaddr) + i);
+
+        chk = chk + *p;     /* Checksum */
+        bits = bits | *p;
+    }
+
+    /* if all data is zero, return nonzero */
+    if (bits == 0)
+    {
+        return -1;
+    }
+
+    return chk;
+}
+
+/*****************************************************************************
+   Allocate an area of non cached memory
+******************************************************************************/
+static dma_addr_t
+get_dma_buffer(void **vaddr, 
+               unsigned size, 
+               unsigned do_checksum)
+{
+    dma_addr_t paddr=0x0;
+    unsigned *p=NULL;
+
+    *vaddr = dma_alloc_coherent(device, size, &paddr, GFP_KERNEL);
+    if (!(*vaddr))
+    {
+        FAIL_TEST("dma_alloc_coherent");
+        return 0;
+    }
+
+    if (do_checksum)
+    {
+        rand_fill(*vaddr, size);
+        /* Put the -ve checksum at the end */
+        p = (unsigned *)(((unsigned char *)(*vaddr)) + size-4);
+        *p = -checksum(*vaddr, size - 4);
+    }
+    else
+    {
+        /* Fill buffer with a constant octet */
+        memset(*vaddr, TEST_VALUE, size);
+    }
+
+    return paddr;
+}
+
+/*****************************************************************************
+   Perform a small delay be scheduling a timeout with the number of
+   jiffies supplied
+******************************************************************************/
+static void
+shortDelay(void)
+{
+    set_current_state(TASK_INTERRUPTIBLE);
+    schedule_timeout(SMALL_DELAY); /* Delay in jiffies */
+}
+
+/* Test functions... */
+/*****************************************************************************
+   Simple direct transfer test with no interrupts
+******************************************************************************/
+static void
+test_direct_xfr(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr=NULL;
+    void *src_vaddr=NULL;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Set debug level */
+    pc302_dma_set_debug_level(dma, 0xFFFF /* Max level */);
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_1_TRW;
+    src.auto_reload = 0;
+
+    dst = src;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    xfr = pc302_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, max_block_size, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_direct_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    udelay(100);
+
+    if (checksum(dest_vaddr, max_block_size) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+end:
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+    pc302_dma_set_debug_level(dma, 0);
+}
+
+/*****************************************************************************
+   Direct transfer using hardware handshaking.
+******************************************************************************/
+static void
+test_direct_xfr_hw_handshaking(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_handshake_t src_hs= {0, 0};
+    void *dest_vaddr=NULL;
+    void *src_vaddr=NULL;
+
+    /* DMAC2 does not have an H/W interfaces to the AXI2PICO bus */
+    if (dmac_to_test == 0)
+    {
+        /* Get a handle to a controller */
+        dma = get_dmac(dmac_to_test);
+        if (TEST_FAILED)
+        {
+            goto end;
+        }
+
+        /* Setup src hardware handshaking parameters */
+        src_hs.hwInterface = 1;
+        src_hs.active_low = 0;
+
+        /* Setup src/dest parameters */
+        src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+        src.master = PC302_DMA_MASTER4;
+        src.periph_not_mem = 1;
+        src.flow_controller = 0;
+        src.enable_sg = 0;
+        src.addr_inc = PC302_DMA_ADDR_NO_CHANGE;
+        src.tr_width = PC302_DMA_TR_WIDTH64;
+        src.msize = PC302_DMA_MS_4_TRW;
+        src.auto_reload = 0;
+
+        dst = src;
+        dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+        xfr = pc302_dma_setup_direct_xfr(
+                dma, &src, &dst, &src_hs, NULL, max_block_size*2, 
+                PC302_DMA_PROTCTL_1, NULL, NULL);
+        if (!xfr)
+        {
+            FAIL_TEST("pc302_dma_setup_direct_xfr");
+            goto end;
+        }
+
+        if (pc302_dma_start(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_start");
+            goto end;
+        }
+
+        pc302_dma_dump_regs(dma);
+
+        udelay(100);
+
+end:
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        } 
+
+        if (dest_vaddr)
+        {
+            dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+        }
+        if (src_vaddr)
+        {
+            dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+        }
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer test without interrupts using various block sizes
+******************************************************************************/
+static void
+test_xfr_block_sizes(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr=NULL;
+    void *src_vaddr=NULL;
+    unsigned bsize=0;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst = src;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+    /* Test block sizes */
+    for (bsize = 8; bsize < max_block_size; bsize += 8)
+    {
+        memset(dest_vaddr, TEST_VALUE, max_block_size);
+
+        xfr = pc302_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL, NULL);
+        if (!xfr)
+        {
+            FAIL_TEST("pc302_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (pc302_dma_start(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_start");
+            break;
+        }
+
+        udelay(100);
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0)
+        {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        } 
+        xfr = NULL;
+    }
+
+    if (bsize < max_block_size)
+    {
+        printk("Failed at block size %u\n", bsize);
+    }
+
+end:
+    if (xfr)
+    {
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        }
+    }
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Simple transfer of an entire list without interrupts
+******************************************************************************/
+static void
+test_list_list_xfr(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src[LIST_SIZE]; /* Cannot be initialised statically */
+    pc302_dma_endpoint_t dst[LIST_SIZE];
+    pc302_dma_list_t list=NULL;
+    void *dest_vaddr[LIST_SIZE];
+    void *src_vaddr[LIST_SIZE];
+    unsigned i=0;
+    unsigned buf_sz = max_block_size;
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        src_vaddr[i] = NULL;
+        dest_vaddr[i] = NULL;
+    }
+
+    /* Initialize endpoints */
+    memset(src, 0, sizeof(pc302_dma_endpoint_t)*LIST_SIZE);
+    memset(dst, 0, sizeof(pc302_dma_endpoint_t)*LIST_SIZE);
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    list = pc302_dma_list_create(dma, LIST_SIZE);
+    if (!list)
+    {
+        FAIL_TEST("pc302_dma_list_create");
+        goto end;
+    }
+
+    /* Setup 10 elements of the list */
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        /* Setup src/dest parameters */
+        src[i].dma_addr = get_dma_buffer(&src_vaddr[i], buf_sz, 1);
+        src[i].master = PC302_DMA_MASTER1;
+        src[i].periph_not_mem = 0;
+        src[i].flow_controller = 0;
+        src[i].enable_sg = 0;
+        src[i].addr_inc = PC302_DMA_ADDR_INCREMENT;
+        src[i].tr_width = PC302_DMA_TR_WIDTH64;
+        src[i].msize = PC302_DMA_MS_1_TRW;
+        src[i].auto_reload = 0;
+
+        dst[i] = src[i];
+        dst[i].dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (pc302_dma_list_add(list, &src[i], &dst[i], NULL, NULL, buf_sz) != 0)
+        {
+            FAIL_TEST("pc302_dma_list_add");
+            goto end;
+        }
+    }
+
+    xfr = pc302_dma_setup_list_xfr(list, NULL, NULL, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_list_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    shortDelay();
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        if (checksum(dest_vaddr[i], buf_sz) != 0)
+        {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    /* Check contents of list */
+    pc302_dma_dump_regs(dma);
+
+end:
+    /* Destroy the transfer */
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    /* Destroy the list */
+    if (pc302_dma_list_destroy(list) != 0)
+    {
+        FAIL_TEST("pc302_dma_list_destroy");
+    }
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        if (src_vaddr[i])
+        {
+            dma_free_coherent(device, buf_sz, src_vaddr[i], src[i].dma_addr);
+        }
+        if (dest_vaddr[i])
+        {
+            dma_free_coherent(device, buf_sz, dest_vaddr[i], dst[i].dma_addr);
+        }
+    }
+}
+
+/*****************************************************************************
+   Single element list transfer test
+******************************************************************************/
+static void
+test_single_element_list_list_xfr(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_list_t list=NULL;
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    unsigned buf_sz = max_block_size;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    list = pc302_dma_list_create(dma, 1);
+    if (!list)
+    {
+        FAIL_TEST("pc302_dma_list_create");
+        goto end;
+    }
+
+    /* Setup list of 1 element */
+    src.dma_addr = get_dma_buffer(&src_vaddr, buf_sz, 1);
+    src.master = PC302_DMA_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_1_TRW;
+    src.auto_reload = 0;
+
+    dst = src;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, buf_sz, 0);
+
+    if (pc302_dma_list_add(list, &src, &dst, NULL, NULL, buf_sz) != 0)
+    {
+        FAIL_TEST("pc302_dma_list_add");
+        goto end;
+    }
+
+    xfr = pc302_dma_setup_list_xfr(list, NULL, NULL, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_list_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    shortDelay();
+
+    if (checksum(dest_vaddr, buf_sz) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+end:
+    /* Destroy the transfer */
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    /* Destroy the list */
+    if (pc302_dma_list_destroy(list) != 0)
+    {
+        FAIL_TEST("pc302_dma_list_destroy");
+        goto end;
+    }
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, buf_sz, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, buf_sz, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Test that of transfers can be reused
+******************************************************************************/
+static void
+test_list_list_xfr_reuse_list(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src[LIST_SIZE+REUSE_LIST_SIZE];
+    pc302_dma_endpoint_t dst[LIST_SIZE+REUSE_LIST_SIZE];
+    pc302_dma_list_t list=NULL;
+    void *dest_vaddr[LIST_SIZE+REUSE_LIST_SIZE];
+    void *src_vaddr[LIST_SIZE+REUSE_LIST_SIZE];
+    unsigned i=0;
+    unsigned buf_sz = max_block_size;
+
+    for (i = 0; i < (LIST_SIZE+REUSE_LIST_SIZE); i++)
+    {
+        src_vaddr[i] = NULL;
+        dest_vaddr[i] = NULL;
+    }
+
+    /* Initialize endpoints */
+    memset(src, 0, sizeof(pc302_dma_endpoint_t)*(LIST_SIZE+REUSE_LIST_SIZE));
+    memset(dst, 0, sizeof(pc302_dma_endpoint_t)*(LIST_SIZE+REUSE_LIST_SIZE));
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    list = pc302_dma_list_create(dma, LIST_SIZE);
+    if (!list)
+    {
+        FAIL_TEST("pc302_dma_list_create");
+        goto end;
+    }
+
+    xfr = pc302_dma_setup_list_xfr(list, NULL, NULL, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_list_xfr");
+        goto end;
+    }
+
+    /* Setup LIST_SIZE elements of the list for first transfer */
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        /* Setup src/dest parameters */
+        src[i].dma_addr = get_dma_buffer(&src_vaddr[i], buf_sz, 1);
+        src[i].master = PC302_DMA_MASTER1;
+        src[i].periph_not_mem = 0;
+        src[i].flow_controller = 0;
+        src[i].enable_sg = 0;
+        src[i].addr_inc = PC302_DMA_ADDR_INCREMENT;
+        src[i].tr_width = PC302_DMA_TR_WIDTH64;
+        src[i].msize = PC302_DMA_MS_1_TRW;
+        src[i].auto_reload = 0;
+
+        dst[i] = src[i];
+        dst[i].dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (pc302_dma_list_add(list, &src[i], &dst[i], NULL, NULL, buf_sz) != 0)
+        {
+            FAIL_TEST("pc302_dma_list_add");
+            goto end;
+        }
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    shortDelay();
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        if (checksum(dest_vaddr[i], buf_sz) != 0)
+        {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    /* Reset the list and reuse it for second transfer */
+    if (pc302_dma_list_clear(list) != 0)
+    {
+        FAIL_TEST("pc302_dma_list_clear");
+        goto end;
+    }
+
+    /* Setup REUSE_LIST_SIZE elements of the list */
+    for (i = LIST_SIZE; i < (LIST_SIZE+REUSE_LIST_SIZE); i++)
+    {
+        /* Setup src/dest parameters */
+        src[i].dma_addr = get_dma_buffer(&src_vaddr[i], buf_sz, 1);
+        src[i].master = PC302_DMA_MASTER1;
+        src[i].periph_not_mem = 0;
+        src[i].flow_controller = 0;
+        src[i].enable_sg = 0;
+        src[i].addr_inc = PC302_DMA_ADDR_INCREMENT;
+        src[i].tr_width = PC302_DMA_TR_WIDTH64;
+        src[i].msize = PC302_DMA_MS_1_TRW;
+        src[i].auto_reload = 0;
+
+        dst[i] = src[i];
+        dst[i].dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+        if (pc302_dma_list_add(list, &src[i], &dst[i], NULL, NULL, buf_sz) != 0)
+        {
+            FAIL_TEST("pc302_dma_list_add");
+            goto end;
+        }
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    shortDelay();
+
+    for (i = 0; i < REUSE_LIST_SIZE; i++)
+    {
+        if (checksum(dest_vaddr[i], buf_sz) != 0)
+        {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+end:
+    /* Destroy the transfer */
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    /* Destroy the list */
+    if (pc302_dma_list_destroy(list) != 0)
+    {
+        FAIL_TEST("pc302_dma_list_destroy");
+        goto end;
+    }
+
+    for (i = 0; i < (LIST_SIZE+REUSE_LIST_SIZE); i++)
+    {
+        if (src_vaddr[i])
+        {
+            dma_free_coherent(device, buf_sz, src_vaddr[i], src[i].dma_addr);
+        }
+        if (dest_vaddr[i])
+        {
+            dma_free_coherent(device, buf_sz, dest_vaddr[i], dst[i].dma_addr);
+        }
+    }
+}
+
+/*****************************************************************************
+   Test that reloads the transfers list
+******************************************************************************/
+static void
+test_reload_to_list_xfr(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst[LIST_SIZE];
+    pc302_dma_list_t list=NULL;
+    void *dest_vaddr[LIST_SIZE];
+    void *src_vaddr = NULL;
+    unsigned i=0;
+    unsigned buf_sz = max_block_size;
+
+    for (i = 0; i < (LIST_SIZE); i++)
+    {
+        dest_vaddr[i] = NULL;
+    }
+
+    /* Initialize endpoints */
+    memset(dst, 0, sizeof(pc302_dma_endpoint_t)*LIST_SIZE);
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    list = pc302_dma_list_create(dma, LIST_SIZE);
+    if (!list)
+    {
+        FAIL_TEST("pc302_dma_list_create");
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.master = PC302_DMA_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_1_TRW;
+
+    /* Reload the source block so that the source block get copied to all
+     * list elements of the destination
+     */
+    src.auto_reload = 1;
+
+    dst[0].master = PC302_DMA_MASTER1;
+    dst[0].periph_not_mem = 0;
+    dst[0].flow_controller = 0;
+    dst[0].enable_sg = 0;
+    dst[0].addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst[0].tr_width = PC302_DMA_TR_WIDTH64;
+    dst[0].msize = PC302_DMA_MS_1_TRW;
+    dst[0].auto_reload = 0;
+
+    src.dma_addr = get_dma_buffer(&src_vaddr, buf_sz, 1);
+    dst[0].dma_addr = get_dma_buffer(&dest_vaddr[0], buf_sz, 0);
+
+    /* Setup first element of the list */
+    if (pc302_dma_list_add(list, &src, &dst[0], NULL, NULL, buf_sz) != 0)
+    {
+        FAIL_TEST("pc302_dma_list_add");
+        goto end;
+    }
+
+    /* Setup elements 2 to LIST_SIZE of the list */
+    for (i = 1; i < LIST_SIZE; i++)
+    {
+        dst[i] = dst[0];
+        dst[i].dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        /* No source endpoint for subsequent elements */
+        if (pc302_dma_list_add(list, NULL, &dst[i], NULL, NULL, buf_sz) != 0)
+        {
+            FAIL_TEST("pc302_dma_list_add");
+            goto end;
+        }
+    }
+
+    xfr = pc302_dma_setup_list_xfr(list, NULL, NULL, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_list_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    shortDelay();
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        if (checksum(dest_vaddr[i], buf_sz) != 0)
+        {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+end:
+    /* Destroy the transfer */
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    /* Destroy the list */
+    if (pc302_dma_list_destroy(list) != 0)
+    {
+        FAIL_TEST("pc302_dma_list_destroy");
+        goto end;
+    }
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, buf_sz, src_vaddr, src.dma_addr);
+    }
+    for (i = 0; i < (LIST_SIZE); i++)
+    {
+        if (dest_vaddr[i])
+        {
+            dma_free_coherent(device, buf_sz, dest_vaddr[i], dst[i].dma_addr);
+        }
+    }
+}
+
+/*****************************************************************************
+   Interrupt handler for the Direct transfer test using interrupts
+******************************************************************************/
+static int
+test_direct_xfr_with_interrupts_irq(void *cookie, 
+                                    int errno)
+{
+    return (*((int *)cookie))++;
+}
+
+/*****************************************************************************
+   Direct transfer test using interrupts
+******************************************************************************/
+static void
+test_direct_xfr_with_interrupts(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    unsigned irq_state = 0;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_1_TRW;
+    src.auto_reload = 0;
+
+    dst = src;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    xfr = pc302_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, max_block_size, 0, 
+                             &test_direct_xfr_with_interrupts_irq, &irq_state);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_direct_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_enable_int(xfr, PC302_DMA_INT_BLOCK |
+           PC302_DMA_INT_ERROR | PC302_DMA_INT_TRANSFER) != 0)
+    {
+       FAIL_TEST("pc302_dma_enable_int");
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    udelay(100);
+
+    if (checksum(dest_vaddr, max_block_size) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+    if (irq_state != 1)
+    {
+        FAIL_TEST("Wrong number of interrupts occurred");
+    }
+    
+    printk("%u interrupts received\n", irq_state);
+
+end:
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    if (pc302_dma_disable_int(xfr, PC302_DMA_INT_BLOCK |
+           PC302_DMA_INT_ERROR | PC302_DMA_INT_TRANSFER) != 0)
+    {
+        FAIL_TEST("pc302_dma_disable_int");
+    }
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Interrupt handler for the List transfer test using interrupts
+******************************************************************************/
+static int
+test_list_xfr_with_interrupts_irq(void *cookie, 
+                                  int errno)
+{
+    return (*((int *)cookie))++;
+}
+
+/*****************************************************************************
+   List transfer test using interrupts
+******************************************************************************/
+static void
+test_list_xfr_with_interrupts(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src[LIST_SIZE];
+    pc302_dma_endpoint_t dst[LIST_SIZE];
+    pc302_dma_list_t list=NULL;
+    void *dest_vaddr[LIST_SIZE];
+    void *src_vaddr[LIST_SIZE];
+    unsigned i=0;
+    unsigned buf_sz = max_block_size;
+    unsigned irq_state = 0;
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        src_vaddr[i] = NULL;
+        dest_vaddr[i] = NULL;
+    }
+
+    /* Initialize endpoints */
+    memset(src, 0, sizeof(pc302_dma_endpoint_t)*LIST_SIZE);
+    memset(dst, 0, sizeof(pc302_dma_endpoint_t)*LIST_SIZE);
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    list = pc302_dma_list_create(dma, LIST_SIZE);
+    if (!list)
+    {
+        FAIL_TEST("pc302_dma_list_create");
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src[0].master = PC302_DMA_MASTER1;
+    src[0].periph_not_mem = 0;
+    src[0].flow_controller = 0;
+    src[0].enable_sg = 0;
+    src[0].addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src[0].tr_width = PC302_DMA_TR_WIDTH64;
+    src[0].msize = PC302_DMA_MS_1_TRW;
+    src[0].auto_reload = 0;
+
+    /* Setup LIST_SIZE elements of the list */
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        dst[i] = src[0];
+        src[i] = src[0];
+        src[i].dma_addr = get_dma_buffer(&src_vaddr[i], buf_sz, 1);
+        dst[i].dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (pc302_dma_list_add(list, &src[i], &dst[i], NULL, NULL, buf_sz) != 0)
+        {
+            FAIL_TEST("pc302_dma_list_add");
+            goto end;
+        }
+    }
+
+    xfr = pc302_dma_setup_list_xfr(list, NULL, NULL, 0, 
+                   &test_list_xfr_with_interrupts_irq, &irq_state);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_list_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_enable_int(xfr, PC302_DMA_INT_BLOCK |
+              PC302_DMA_INT_ERROR | PC302_DMA_INT_TRANSFER) != 0)
+    {
+       FAIL_TEST("pc302_dma_enable_int");
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    shortDelay();
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        if (checksum(dest_vaddr[i], buf_sz) != 0)
+        {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    if (irq_state != LIST_SIZE)
+    {
+        FAIL_TEST("Wrong number of interrupts occurred");
+    }
+
+end:
+    /* Destroy the transfer */
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    /* Destroy the list */
+    if (pc302_dma_list_destroy(list) != 0)
+    {
+        FAIL_TEST("pc302_dma_list_destroy");
+        goto end;
+    }
+
+    printk("%u interrupts received\n", irq_state);
+
+    if (pc302_dma_disable_int(xfr, PC302_DMA_INT_BLOCK |
+              PC302_DMA_INT_ERROR | PC302_DMA_INT_TRANSFER) != 0)
+    {
+        FAIL_TEST("pc302_dma_disable_int");
+    }
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        if (src_vaddr[i])
+        {
+            dma_free_coherent(device, buf_sz, src_vaddr[i], src[i].dma_addr);
+        }
+        if (dest_vaddr[i])
+        {
+            dma_free_coherent(device, buf_sz, dest_vaddr[i], dst[i].dma_addr);
+        }
+    }
+}
+
+/*****************************************************************************
+   List to list transfer test with interrupts and block control
+******************************************************************************/
+static int
+test_list_xfr_with_interrupts2_irq(void *cookie, 
+                                   int errno)
+{
+    client_data_interrupt_test_t *p = (client_data_interrupt_test_t *)cookie;
+    unsigned valid_irq = 0;
+
+    p->irq_state++;
+
+    if (errno & PC302_DMA_INT_BLOCK)
+    {
+        p->tlxwi2_block_ints++;
+        p->blocks_left--;
+        valid_irq = 1;
+    }
+
+    if (errno &  PC302_DMA_INT_DST_TRANSACTION)
+    {
+        p->tlxwi2_dsttrx_ints++;
+        valid_irq = 1;
+    }
+
+    if (errno & PC302_DMA_INT_ERROR)
+    {
+        p->tlxwi2_err_ints++;
+        valid_irq = 1;
+    }
+
+    if (errno & PC302_DMA_INT_SRC_TRANSACTION)
+    {
+        p->tlxwi2_srctrx_ints++;
+        valid_irq = 1;
+    }
+
+    if (errno & PC302_DMA_INT_TRANSFER)
+    {
+        p->tlxwi2_trf_ints++;
+        valid_irq = 1;
+    }
+
+    if (!valid_irq)
+    {
+        char string[32];
+        (void)sprintf(string,"BAD INT TYPE (%d)\n",errno);
+        FAIL_TEST(string);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+   List to list transfer test with interrupts and block control.
+******************************************************************************/
+static void
+test_list_xfr_with_interrupts2(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src[LIST_SIZE];
+    pc302_dma_endpoint_t dst[LIST_SIZE];
+    pc302_dma_list_t list=NULL;
+    void *dest_vaddr[LIST_SIZE];
+    void *src_vaddr[LIST_SIZE];
+    unsigned i=0;
+    unsigned buf_sz = max_block_size;
+    client_data_interrupt_test_t p = {0, 0, 0, 0, 0, 0, 0};
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        src_vaddr[i] = NULL;
+        dest_vaddr[i] = NULL;
+    }
+
+    /* Initialize endpoints */
+    memset(src, 0, sizeof(pc302_dma_endpoint_t)*LIST_SIZE);
+    memset(dst, 0, sizeof(pc302_dma_endpoint_t)*LIST_SIZE);
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    list = pc302_dma_list_create(dma, LIST_SIZE);
+    if (!list)
+    {
+        FAIL_TEST("pc302_dma_list_create");
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src[0].master = PC302_DMA_MASTER1;
+    src[0].periph_not_mem = 0;
+    src[0].flow_controller = 0;
+    src[0].enable_sg = 0;
+    src[0].addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src[0].tr_width = PC302_DMA_TR_WIDTH64;
+    src[0].msize = PC302_DMA_MS_1_TRW;
+    src[0].auto_reload = 0;
+
+    /* Setup elements of the list */
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        dst[i] = src[0];
+        src[i] = src[0];
+
+        src[i].dma_addr = get_dma_buffer(&src_vaddr[i], buf_sz, 1);
+        dst[i].dma_addr = get_dma_buffer(&dest_vaddr[i], buf_sz, 0);
+
+        if (pc302_dma_list_add(list, &src[i], &dst[i], NULL, NULL, buf_sz) != 0)
+        {
+            FAIL_TEST("pc302_dma_list_add");
+            goto end;
+        }
+    }
+
+    xfr = pc302_dma_setup_list_xfr(list, NULL, NULL, 0, 
+                  &test_list_xfr_with_interrupts2_irq, &p);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_list_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_enable_int(xfr, PC302_DMA_INT_BLOCK |
+        PC302_DMA_INT_ERROR | PC302_DMA_INT_TRANSFER) != 0)
+    {
+       FAIL_TEST("pc302_dma_enable_int");
+    }
+
+    /* Set the blocks counter so that the driver can stop the transfer
+       when we get to the end of the block list.  */
+    p.blocks_left = LIST_SIZE;
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    shortDelay();
+
+    /* The transfer should have stopped by itself. Check that the
+       remaining blocks counter reached zero.  */
+    if (p.blocks_left != 0)
+    {
+        FAIL_TEST("Blocks left not zero!");
+    }
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        if (checksum(dest_vaddr[i], buf_sz) != 0)
+        {
+            FAIL_TEST("Checksum destination");
+        }
+    }
+
+    if (p.irq_state != LIST_SIZE)
+    {
+        FAIL_TEST("Wrong number of total interrupts received");
+    }
+    if (p.tlxwi2_trf_ints != 1)
+    {
+        FAIL_TEST("Wrong number of transfer complete interrupts occurred");
+    }
+    if (p.tlxwi2_block_ints != LIST_SIZE)
+    {
+        FAIL_TEST("Wrong number of block interrupts occurred");
+    }
+    if (p.tlxwi2_srctrx_ints != 0)
+    {
+        FAIL_TEST("Wrong number of total interrupts occurred");
+    }
+    if (p.tlxwi2_dsttrx_ints != 0)
+    {
+        FAIL_TEST("Wrong number of total interrupts occurred");
+    }
+    if (p.tlxwi2_err_ints != 0)
+    {
+        FAIL_TEST("Error interrupts have occured");
+    }
+
+    printk("%u total interrupts received\n", p.irq_state);
+    printk("%u TRF interrupts received\n", p.tlxwi2_trf_ints);
+    printk("%u BLOCK interrupts received\n", p.tlxwi2_block_ints);
+    printk("%u SRC Trans interrupts received\n", p.tlxwi2_srctrx_ints);
+    printk("%u DST Trans interrupts received\n", p.tlxwi2_dsttrx_ints);
+    printk("%u ERR interrupts received\n", p.tlxwi2_err_ints);
+    printk("%u blocks left\n", p.blocks_left);
+
+end:
+    /* Destroy the transfer */
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    /* Destroy the list */
+    if (pc302_dma_list_destroy(list) != 0)
+    {
+        FAIL_TEST("pc302_dma_list_destroy");
+        goto end;
+    }
+
+    if (pc302_dma_disable_int(xfr, PC302_DMA_INT_BLOCK |
+        PC302_DMA_INT_ERROR | PC302_DMA_INT_TRANSFER) != 0)
+    {
+        FAIL_TEST("pc302_dma_disable_int");
+    }
+
+    for (i = 0; i < LIST_SIZE; i++)
+    {
+        if (src_vaddr[i])
+        {
+            dma_free_coherent(device, buf_sz, src_vaddr[i], src[i].dma_addr);
+        }
+        if (dest_vaddr[i])
+        {
+            dma_free_coherent(device, buf_sz, dest_vaddr[i], dst[i].dma_addr);
+        }
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer using source software handshaking
+******************************************************************************/
+static void
+test_src_sw_handshaking(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr=NULL;
+    void *src_vaddr=NULL;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+       transaction requests on the source to progress the transfer */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    xfr = pc302_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, max_block_size, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_direct_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    /* Request transactions until the transfer stops */
+    while (pc302_dma_request_transaction(
+                          xfr, PC302_DMA_SRC, NULL) != -EINVAL) ;
+
+    if (checksum(dest_vaddr, max_block_size) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+end:
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer using destination software handshaking
+******************************************************************************/
+static void
+test_dst_sw_handshaking(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr=NULL;
+    void *src_vaddr=NULL;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+       to do transaction requests on the destination to progress the transfer */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    xfr = pc302_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, max_block_size, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_direct_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    /* Request transactions until the transfer stops */
+    while (pc302_dma_request_transaction(xfr, 
+                               PC302_DMA_DST, NULL) != -EINVAL) ;
+
+    if (checksum(dest_vaddr, max_block_size) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+end:
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+    Simple direct transfer using source and destination software handshaking.
+******************************************************************************/
+static void
+test_src_dst_sw_handshaking(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+       transaction requests on the source to progress the transfer */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+       to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    xfr = pc302_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, max_block_size, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_direct_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    /* Request transactions until the transfer stops */
+    while (1)
+    {
+        unsigned rc_s, rc_d;
+        rc_s = pc302_dma_request_transaction(xfr, PC302_DMA_SRC, NULL);
+        rc_d = pc302_dma_request_transaction(xfr, PC302_DMA_DST, NULL);
+        if (rc_s == -EINVAL && rc_d == -EINVAL)
+        {
+            break;
+        }
+    }
+
+    if (checksum(dest_vaddr, max_block_size) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+end:
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer using source and destination software
+   handshaking and source flow control.
+******************************************************************************/
+static void
+test_src_dst_sw_hand_src_flow_controller(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    unsigned bytes_left = max_block_size;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+       transaction requests on the source to progress the transfer */
+    src.periph_not_mem = 1;
+
+    /* Make the source is the flow controller. This means that the source
+       endpoint will control when the end of a block arrives through the
+       bytes_left parameter of the pc302_dma_request_transaction
+       function.  */
+    src.flow_controller = 1;
+
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+       to do transaction requests on the destination to progress the transfer */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, bytes_left, 0);
+
+    xfr = pc302_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, bytes_left, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_direct_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    /* Request transactions until the transfer stops */
+    while (1)
+    {
+        unsigned rc_s, rc_d;
+        rc_s = pc302_dma_request_transaction(xfr, PC302_DMA_SRC, &bytes_left);
+        rc_d = pc302_dma_request_transaction(xfr, PC302_DMA_DST, NULL);
+        if (rc_s == -EINVAL && rc_d == -EINVAL)
+        {
+            break;
+        }
+    }
+
+    if (checksum(dest_vaddr, max_block_size) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+end:
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer using source and destination software
+   handshaking and destination flow control.
+******************************************************************************/
+static void
+test_src_dst_sw_hand_dst_flow_controller(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    unsigned bytes_left=0;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+       transaction requests on the source to progress the transfer */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+       to do transaction requests on the destination to progress the transfer */
+    dst.periph_not_mem = 1;
+
+    /* Make the destination the flow controller. This means that the
+       destination endpoint will control when the end of a block arrives
+       through the bytes_left parameter of the
+       pc302_dma_request_transaction function.  */
+    dst.flow_controller = 1;
+
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    xfr = pc302_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, bytes_left, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_direct_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    /* Request transactions until the transfer stops */
+    bytes_left = max_block_size;
+    while (1)
+    {
+        unsigned rc_s, rc_d;
+        rc_s = pc302_dma_request_transaction(xfr, PC302_DMA_SRC, NULL);
+        rc_d = pc302_dma_request_transaction(xfr, PC302_DMA_DST, &bytes_left);
+        if (rc_s == -EINVAL && rc_d == -EINVAL)
+        {
+            break;
+        }
+    }
+
+    if (checksum(dest_vaddr, max_block_size) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+end:
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer, dest sw handshaking, dest flow controller
+******************************************************************************/
+static void
+test_dst_sw_hand_dst_flow_controller(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    unsigned bytes_left = 0;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER2;
+    src.periph_not_mem = 0;
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER3;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+       to do transaction requests on the destination to progress the transfer */
+    dst.periph_not_mem = 1;
+
+    /* Make the destination the flow controller. This means that the destination
+       endpoint will control when the end of a block arrives through the
+       bytes_left parameter of the pc302_dma_request_transaction function.  */
+    dst.flow_controller = 1;
+
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    xfr = pc302_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, bytes_left, 0, NULL, NULL);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_direct_xfr");
+        goto end;
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    /* Request transactions until the transfer stops */
+    bytes_left = max_block_size;
+    while (1)
+    {
+        unsigned rc_d;
+        rc_d = pc302_dma_request_transaction(xfr, PC302_DMA_DST, &bytes_left);
+        if (rc_d == -EINVAL)
+        {
+            break;
+        }
+    }
+
+    if (checksum(dest_vaddr, max_block_size) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+end:
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer, src / dest sw handshaking, various block sizes
+******************************************************************************/
+static void
+test_src_dst_sw_handshaking_block_sizes(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    unsigned bsize = 0;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+       transaction requests on the source to progress the transfer */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+       to do transaction requests on the destination to progress the transfer */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    /* Test block sizes */
+    for (bsize = 8; bsize < max_block_size; bsize += 8)
+    {
+        memset(dest_vaddr, TEST_VALUE, max_block_size);
+
+        xfr = pc302_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL, NULL);
+        if (!xfr)
+        {
+            FAIL_TEST("pc302_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (pc302_dma_start(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_start");
+            break;
+        }
+
+        /* Request transactions until the transfer stops */
+        while (1)
+        {
+            unsigned rc_s, rc_d;
+            rc_s = pc302_dma_request_transaction(xfr, PC302_DMA_SRC, NULL);
+            rc_d = pc302_dma_request_transaction(xfr, PC302_DMA_DST, NULL);
+            if (rc_s == -EINVAL && rc_d == -EINVAL)
+            {
+                break;
+            }
+        }
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0)
+        {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        } 
+        xfr = NULL;
+    }
+
+    if (bsize < max_block_size)
+    {
+        printk("Failed at block size %u\n", bsize);
+    }
+
+end:
+    if (xfr)
+    {
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        }
+    }
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer, src / dest sw handshaking, source flow
+   control and various block sizes
+******************************************************************************/
+static void
+test_src_dst_sw_handshaking_src_fc_block_sizes(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    unsigned bsize = 0;
+    unsigned bytes_left = 0;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+       transaction requests on the source to progress the transfer */
+    src.periph_not_mem = 1;
+
+    /* Make the source the flow controller. This means that the source endpoint
+       will control when the end of a block arrives through the bytes_left
+       parameter of the pc302_dma_request_transaction function.  */
+    src.flow_controller = 1;
+
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+       to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    /* Test block sizes */
+    for (bsize = 8; bsize < max_block_size; bsize += 8)
+    {
+        memset(dest_vaddr, TEST_VALUE, max_block_size);
+
+        xfr = pc302_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL, NULL);
+        if (!xfr)
+        {
+            FAIL_TEST("pc302_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (pc302_dma_start(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_start");
+            break;
+        }
+
+        /* Request transactions until the transfer stops */
+        bytes_left = bsize;
+        while (1)
+        {
+            unsigned rc_s, rc_d;
+            rc_s = pc302_dma_request_transaction(xfr, PC302_DMA_SRC, 
+                       &bytes_left);
+            rc_d = pc302_dma_request_transaction(xfr, PC302_DMA_DST, NULL);
+            if (rc_s == -EINVAL && rc_d == -EINVAL)
+            {
+                break;
+            }
+        }
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0)
+        {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        } 
+        xfr = NULL;
+    }
+
+    if (bsize < max_block_size)
+    {
+        printk("Failed at block size %u\n", bsize);
+    }
+
+end:
+    if (xfr)
+    {
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        }
+    }
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer, source sw handshaking, source flow
+   control and various block sizes
+******************************************************************************/
+static void
+test_src_sw_handshaking_src_fc_block_sizes(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    unsigned bsize = 0;
+    unsigned bytes_left = 0;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+       transaction requests on the source to progress the transfer */
+    src.periph_not_mem = 1;
+
+    /* Make the source the flow controller. This means that the source endpoint
+       will control when the end of a block arrives through the bytes_left
+       parameter of the pc302_dma_request_transaction function.  */
+    src.flow_controller = 1;
+
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+    dst.periph_not_mem = 0;
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    /* Test block sizes */
+    for (bsize = 8; bsize < max_block_size; bsize += 8)
+    {
+        memset(dest_vaddr, TEST_VALUE, max_block_size);
+
+        xfr = pc302_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL, NULL);
+        if (!xfr)
+        {
+            FAIL_TEST("pc302_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (pc302_dma_start(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_start");
+            break;
+        }
+
+        /* Request transactions until the transfer stops */
+        bytes_left = bsize;
+        while (1)
+        {
+            unsigned rc_s;
+            rc_s = pc302_dma_request_transaction(xfr, PC302_DMA_SRC, 
+                &bytes_left);
+            if (rc_s == -EINVAL)
+            {
+                break;
+            }
+        }
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0)
+        {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        } 
+        xfr = NULL;
+    }
+
+    if (bsize < max_block_size)
+    {
+        printk("Failed at block size %u\n", bsize);
+    }
+
+end:
+    if (xfr)
+    {
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        }
+    }
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Simple direct transfer, src / dest sw handshaking, destination
+   flow control and various block sizes
+******************************************************************************/
+static void
+test_src_dst_sw_handshaking_dst_fc_block_sizes(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    unsigned bsize = 0;
+    unsigned bytes_left = 0;
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+       transaction requests on the source to progress the transfer */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+       to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    /* Make the destination the flow controller. This means that the destination
+       endpoint will control when the end of a block arrives through the
+       bytes_left parameter of the pc302_dma_request_transaction function.  */
+    dst.flow_controller = 1;
+
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    /* Test block sizes */
+    for (bsize = 8; bsize < max_block_size; bsize += 8)
+    {
+        memset(dest_vaddr, TEST_VALUE, max_block_size);
+
+        xfr = pc302_dma_setup_direct_xfr(
+                dma, &src, &dst, NULL, NULL, bsize, 0, NULL, NULL);
+        if (!xfr)
+        {
+            FAIL_TEST("pc302_dma_setup_direct_xfr");
+            break;
+        }
+
+        if (pc302_dma_start(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_start");
+            break;
+        }
+
+        /* Request transactions until the transfer stops */
+        bytes_left = bsize;
+        while (1)
+        {
+            unsigned rc_s, rc_d;
+            rc_s = pc302_dma_request_transaction(xfr, PC302_DMA_SRC, NULL);
+            rc_d = pc302_dma_request_transaction(xfr, PC302_DMA_DST, 
+                &bytes_left);
+            if (rc_s == -EINVAL && rc_d == -EINVAL)
+            {
+                break;
+            }
+        }
+
+        if (memcmp(src_vaddr, dest_vaddr, bsize) != 0)
+        {
+            FAIL_TEST("Check destination");
+            break;
+        }
+
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        }
+        xfr = NULL; 
+    }
+
+    if (bsize < max_block_size)
+    {
+        printk("Failed at block size %u\n", bsize);
+    }
+
+end:
+    if (xfr)
+    {
+        if (pc302_dma_release(xfr) != 0)
+        {
+            FAIL_TEST("pc302_dma_release fail");
+        }
+    }
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Interrupt handler for the simple direct transfer test using src / dest
+   sw handshaking controlled by interrupts
+******************************************************************************/
+static int
+test_src_dst_sw_handshaking_int_irq(void *cookie, 
+                                    int errno)
+{
+    client_data_interrupt_test_t *p = (client_data_interrupt_test_t *)cookie;
+    unsigned valid_irq=0;
+
+    /* Repeat the following, for each interrupt type */
+    p->irq_state++;
+
+    if (errno &  PC302_DMA_INT_BLOCK)
+    {
+        p->tlxwi2_block_ints++;
+        valid_irq = 1;
+    }
+
+    if (errno &  PC302_DMA_INT_DST_TRANSACTION)
+    {
+        p->tlxwi2_dsttrx_ints++;
+        /* Service the destination transaction complete interrupt
+         * by requesting a new transaction */
+        if (pc302_dma_request_transaction(p->xfr, 
+                PC302_DMA_DST, NULL) == EBUSY)
+        {
+            FAIL_TEST("pc302_dma_request_transaction Busy");
+        }
+        valid_irq = 1;
+    }
+
+    if (errno &  PC302_DMA_INT_ERROR)
+    {
+        p->tlxwi2_err_ints++;
+        valid_irq = 1;
+    }
+
+    if (errno &  PC302_DMA_INT_SRC_TRANSACTION)
+    {
+        p->tlxwi2_srctrx_ints++;
+        /* Service the source transaction complete interrupt
+         * by requesting a new transaction */
+        if (pc302_dma_request_transaction(p->xfr, 
+                PC302_DMA_SRC, NULL) == EBUSY)
+        {
+            FAIL_TEST("pc302_dma_request_transaction Busy");
+        }
+        valid_irq = 1;
+    }
+
+    if (errno &  PC302_DMA_INT_TRANSFER)
+    {
+        p->tlxwi2_trf_ints++;
+        valid_irq = 1;
+    }
+
+    if (!valid_irq)
+    {
+        char string[32];
+        (void)sprintf(string,"BAD INT TYPE %d\n",errno);
+        FAIL_TEST(string);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+   Simple direct transfer test using src / dest sw handshaking
+   controlled by interrupts
+******************************************************************************/
+static void
+test_src_dst_sw_handshaking_int(void)
+{
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t xfr=NULL;
+    pc302_dma_endpoint_t src = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    pc302_dma_endpoint_t dst = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+    void *dest_vaddr = NULL;
+    void *src_vaddr = NULL;
+    client_data_interrupt_test_t p = {0, 0, 0, 0, 0, 0, 0};
+
+    /* Get a handle to a controller */
+    dma = get_dmac(dmac_to_test);
+    if (TEST_FAILED)
+    {
+        goto end;
+    }
+
+    /* Setup src/dest parameters */
+    src.dma_addr = get_dma_buffer(&src_vaddr, max_block_size, 1);
+    src.master = PC302_DMA_MASTER1;
+
+    /* Pretend the source is a peripheral. This means that we will have to do
+     * transaction requests on the source to progress the transfer
+     */
+    src.periph_not_mem = 1;
+
+    src.flow_controller = 0;
+    src.enable_sg = 0;
+    src.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src.tr_width = PC302_DMA_TR_WIDTH64;
+    src.msize = PC302_DMA_MS_AUTO;
+    src.auto_reload = 0;
+
+    dst.master = PC302_DMA_MASTER1;
+    dst.periph_not_mem = 0;
+
+    /* Pretend the destination is a peripheral. This means that we will have
+     * to do transaction requests on the destination to progress the transfer
+     */
+    dst.periph_not_mem = 1;
+
+    dst.flow_controller = 0;
+    dst.enable_sg = 0;
+    dst.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst.tr_width = PC302_DMA_TR_WIDTH64;
+    dst.msize = PC302_DMA_MS_AUTO;
+    dst.auto_reload = 0;
+    dst.dma_addr = get_dma_buffer(&dest_vaddr, max_block_size, 0);
+
+    xfr = pc302_dma_setup_direct_xfr(
+            dma, &src, &dst, NULL, NULL, max_block_size, 0, 
+                  &test_src_dst_sw_handshaking_int_irq, &p);
+    if (!xfr)
+    {
+        FAIL_TEST("pc302_dma_setup_direct_xfr");
+        goto end;
+    }
+    p.xfr = xfr;
+
+    if (pc302_dma_enable_int(xfr, 
+          PC302_DMA_INT_DST_TRANSACTION |
+          PC302_DMA_INT_SRC_TRANSACTION |
+          PC302_DMA_INT_ERROR |
+          PC302_DMA_INT_TRANSFER) != 0)
+    {
+        FAIL_TEST("pc302_dma_enable_int"); 
+    }
+
+    if (pc302_dma_start(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_start");
+        goto end;
+    }
+
+    /* Start the process by requesting the first transactions, When these
+     * are complete, the interrupt will trigger subsequent ones */
+    if (pc302_dma_request_transaction(xfr, PC302_DMA_SRC, NULL) != 0)
+    {
+        FAIL_TEST("pc302_dma_request_transaction for SRC");
+    }
+    if (pc302_dma_request_transaction(xfr, PC302_DMA_DST, NULL) != 0)
+    {
+        FAIL_TEST("pc302_dma_request_transaction for DST");
+    }
+
+    shortDelay();
+
+    if (checksum(dest_vaddr, max_block_size) != 0)
+    {
+        FAIL_TEST("Checksum destination");
+    }
+
+    if (max_block_size == 2048)
+    {
+      /* Can only predict interrupt counts at this block size */
+      if (p.irq_state != 8)
+      {
+          FAIL_TEST("Expected a total of 8 interrupts");
+      }
+      if (p.tlxwi2_srctrx_ints != 8)
+      {
+          FAIL_TEST("Expected 8 source transfer complete interrupts");
+      }
+      if (p.tlxwi2_dsttrx_ints != 8)
+      {
+          FAIL_TEST("Expected 8 destination transfer complete interrupts");
+      }
+    }
+    if (p.tlxwi2_trf_ints != 1)
+    {
+        FAIL_TEST("Expected a single transfer complete interrupt");
+    }
+    if (p.tlxwi2_block_ints != 0)
+    {
+        FAIL_TEST("Expected no block interrupts");
+    }
+    if (p.tlxwi2_err_ints != 0)
+    {
+        FAIL_TEST("Expected 0 error interrupts");
+    }
+
+    printk("%u total interrupts received\n", p.irq_state);
+    printk("%u TRF interrupts received\n", p.tlxwi2_trf_ints);
+    printk("%u BLOCK interrupts received\n", p.tlxwi2_block_ints);
+    printk("%u SRC Trans interrupts received\n", p.tlxwi2_srctrx_ints);
+    printk("%u DST Trans interrupts received\n", p.tlxwi2_dsttrx_ints);
+    printk("%u ERR interrupts received\n", p.tlxwi2_err_ints);
+
+end:
+    if (pc302_dma_release(xfr) != 0)
+    {
+        FAIL_TEST("pc302_dma_release fail");
+    } 
+
+    if (pc302_dma_disable_int(xfr, 
+          PC302_DMA_INT_DST_TRANSACTION |
+          PC302_DMA_INT_SRC_TRANSACTION |
+          PC302_DMA_INT_ERROR |
+          PC302_DMA_INT_TRANSFER) != 0)
+    {
+        FAIL_TEST("pc302_dma_disable_int");
+    }
+
+    if (src_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, src_vaddr, src.dma_addr);
+    }
+    if (dest_vaddr)
+    {
+        dma_free_coherent(device, max_block_size, dest_vaddr, dst.dma_addr);
+    }
+}
+
+/*****************************************************************************
+   Run all tests specified in structure
+******************************************************************************/
+static void
+run_tests(void)
+{
+    unsigned res = SUCCESS;
+    unsigned testnum=0;
+
+    for (testnum = 0; testnum < NUM_TESTS; testnum++)
+    {
+        if (tests_to_run & (1 << testnum))
+        {
+            printk(KERN_INFO "dmat: <%u> START %s\n", testnum +1,
+                tests[testnum].name);
+
+            RESET_TEST_RES();
+
+            tests[testnum].test_fn();
+
+            printk(KERN_INFO "dmat: TEST <%u> %s\n", testnum + 1, 
+                    (test_state == FAIL) ? "FAILED" : "SUCCESS");
+
+            if (test_state == FAIL)
+            {
+                res = FAIL;
+            }
+        }
+    }
+
+    if (res == SUCCESS)
+    {
+        printk(KERN_INFO "dmat: Passed all tests.\n");
+    }
+    else
+    {
+        printk(KERN_INFO "dmat: FAILED SOME TESTS!!\n");
+    }
+}
+
+/*****************************************************************************
+   Driver test init function
+******************************************************************************/
+static int __init pc302_dma_test_module_init(void)
+{
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " " __DATE__ " " __TIME__
+            " Loaded\n", TITLE);
+
+    run_tests();
+
+    return 0;
+}
+
+/*****************************************************************************
+   Driver test exit function
+******************************************************************************/
+static void __exit pc302_dma_test_module_exit(void)
+{
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " " __DATE__ " " __TIME__
+            " Unloaded\n", TITLE);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("picoChip PC302 DMA Test Driver");
+MODULE_AUTHOR("Andrew Watkins");
+
+module_init(pc302_dma_test_module_init);
+module_exit(pc302_dma_test_module_exit);
+
diff --git a/drivers/i2c/busses/i2c-versatile.c b/drivers/i2c/busses/i2c-versatile.c
index 4678bab..15b5e8a 100644
--- a/drivers/i2c/busses/i2c-versatile.c
+++ b/drivers/i2c/busses/i2c-versatile.c
@@ -96,13 +96,20 @@ static int i2c_versatile_probe(struct platform_device *dev)
 	writel(SCL | SDA, i2c->base + I2C_CONTROLS);
 
 	i2c->adap.owner = THIS_MODULE;
+	if (dev->id >= 0)
+		i2c->adap.nr = dev->id;
 	strlcpy(i2c->adap.name, "Versatile I2C adapter", sizeof(i2c->adap.name));
 	i2c->adap.algo_data = &i2c->algo;
 	i2c->adap.dev.parent = &dev->dev;
 	i2c->algo = i2c_versatile_algo;
 	i2c->algo.data = i2c;
 
-	ret = i2c_bit_add_bus(&i2c->adap);
+	if (dev->id >= 0)
+		/* static bus numbering */
+		ret = i2c_bit_add_numbered_bus(&i2c->adap);
+	else
+		/* dynamic bus numbering */
+		ret = i2c_bit_add_bus(&i2c->adap);
 	if (ret >= 0) {
 		platform_set_drvdata(dev, i2c);
 		return 0;
@@ -146,7 +153,7 @@ static void __exit i2c_versatile_exit(void)
 	platform_driver_unregister(&i2c_versatile_driver);
 }
 
-module_init(i2c_versatile_init);
+subsys_initcall(i2c_versatile_init);
 module_exit(i2c_versatile_exit);
 
 MODULE_DESCRIPTION("ARM Versatile I2C bus driver");
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index fee7304..f2b9532 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -498,6 +498,32 @@ config SGI_GRU_DEBUG
 	This option enables addition debugging code for the SGI GRU driver. If
 	you are unsure, say N.
 
+config PC302_FRACN
+        tristate "Frac-N Synth driver for picoChip PC302"
+        depends on ARCH_PC302 && PICOIF && PC302_GPIO
+        default n
+        help
+          This driver enables a driver for the PC302 Frac-N synth.
+
+config PC302_FUSEBLOCK
+        tristate "Fuseblock driver for picoChip PC302"
+        depends on ARCH_PC302
+        default n
+        help
+          This driver enables reading and writing of fuses in the PC302 device.
+
+config PC302_GPIO
+        tristate "picoChip PC302 GPIO driver"
+        depends on ARCH_PC302
+        ---help---
+            This option enables the PC302 GPIO driver.
+
+config PC202_GPIO
+        tristate "picoChip PC202 GPIO driver"
+        depends on ARCH_FIRECRACKER
+        ---help---
+            This option enables the PC202 GPIO driver.
+
 source "drivers/misc/c2port/Kconfig"
 
 endif # MISC_DEVICES
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 817f7f5..44ab0aa 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -33,3 +33,7 @@ obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
 obj-$(CONFIG_C2PORT)		+= c2port/
+obj-$(CONFIG_PC302_FUSEBLOCK)	+= pc302fuse.o
+obj-$(CONFIG_PC302_GPIO)	+= pc302gpio.o
+obj-$(CONFIG_PC302_FRACN)	+= pc302fracn.o
+obj-$(CONFIG_PC202_GPIO)	+= pc202gpio.o
diff --git a/drivers/misc/pc202gpio.c b/drivers/misc/pc202gpio.c
new file mode 100644
index 0000000..fd82c4c
--- /dev/null
+++ b/drivers/misc/pc202gpio.c
@@ -0,0 +1,2100 @@
+/**
+ * \file pc202gpio.c
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright 2009 picoChip Designs LTD, All Rights Reserved.
+ * http://www.picochip.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This file implements a driver for the GPIO pins on the picoChip PC202
+ * device. This includes both the ARM and SD GPIO. We provide 3 APIs for
+ * accessing the GPIO pins:
+ *   - kernel space with the GPIO guidelines (Documentation/gpio.txt)
+ *   - userspace through configfs
+ *     (Documentation/filesystems/configfs/configfs.txt)
+ *   - userspace through an ioctl() interface
+ */
+
+#include <linux/module.h>
+#include <linux/configfs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/miscdevice.h>
+#include <linux/picochip/devices/pc202.h>
+#include <linux/picochip/gpio_ioctl.h>
+#include <linux/picochip/gpio.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <mach/irqs.h>
+#include <mach/pc20x/gpio.h>
+#include <mach/pc20x/pc20x.h>
+
+#define CARDNAME "pc202gpio"
+#define PC202_GPIO_MINOR    ( 243 )
+
+/** The number of pads available for GPIO. */
+#define PC202_GPIO_NUM_PADS ( PICO_NUM_GPIOS )
+
+/** A name for this module */
+#define TITLE "PC202 GPIO Driver"
+
+/** The maximum length of a pin name. */
+#define PC202_GPIO_PIN_NAME_MAX ( 32 )
+
+/** The width of the arm gpio ports */
+#define PC202_ARM_GPIO_PORT_WIDTH   ( 8 )
+
+/** The AHB2PICO wake up command */
+#define PC202_AHB2PICO_WAKE_UP  ( 0 )
+
+/** The base address of SD-GPIO config registers in the AHB2Pico. */
+#define PC202_GPIO_SD_PIN_CONFIG_BASE         ( 0x9800 )
+
+/** The base address of SD-GPIO analogue value registers in the AHB2Pico. */
+#define PC202_GPIO_SD_PIN_ANALOGUE_VALUE_BASE ( 0x9801 )
+
+/** The base address of SD-GPIO analogue rate registers in the AHB2Pico. */
+#define PC202_GPIO_SD_PIN_ANALOGUE_RATE_BASE  ( 0x9802 )
+
+/** The address of the LSB SD-GPIOs input value register in the AHB2Pico. */
+#define PC202_GPIO_SD_INPUT_VAL_REG_LOW       ( 0x9880 )
+
+/** The address of the MSB SD_GPIO input value register in the AHB2Pico. */
+#define PC202_GPIO_SD_INPUT_VAL_REG_HIGH      ( 0x9881 )
+
+/** The address of the LSB SD-GPIOs control value register in the AHB2Pico. */
+#define PC202_GPIO_SD_CONTROL_VAL_REG_LOW     ( 0x9882 )
+
+/** The address of the MSB SD_GPIO control value register in the AHB2Pico. */
+#define PC202_GPIO_SD_CONTROL_VAL_REG_HIGH    ( 0x9883 )
+
+/** The address of the LSB SD-GPIOs output value register in the AHB2Pico. */
+#define PC202_GPIO_SD_OUTPUT_VAL_REG_LOW      ( 0x9884 )
+
+/** The address of the MSB SD_GPIO output value register in the AHB2Pico. */
+#define PC202_GPIO_SD_OUTPUT_VAL_REG_HIGH     ( 0x9885 )
+
+/** The address of the sleep register in the AHB2Pico. */
+#define PC202_AHB2PICO_SLEEP_REG        0xA060
+
+/** The spacing between SD-GPIO config registers. */
+#define PC202_GPIO_SD_PIN_CONFIG_SPACING    4
+
+/**
+ * Macro to get the address of a config register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC202_GPIO_SD_PIN_CONFIG( _n ) \
+    PC202_GPIO_SD_PIN_CONFIG_BASE + ( (_n) * PC202_GPIO_SD_PIN_CONFIG_SPACING )
+
+/**
+ * Macro to get the address of a analogue rate register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC202_GPIO_SD_PIN_ANALOGUE_RATE( _n ) \
+    PC202_GPIO_SD_PIN_ANALOGUE_RATE_BASE + \
+        ( (_n) * PC202_GPIO_SD_PIN_CONFIG_SPACING )
+
+/**
+ * Macro to get the address of a analogue value register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC202_GPIO_SD_PIN_ANALOGUE_VAL( _n ) \
+    PC202_GPIO_SD_PIN_ANALOGUE_VALUE_BASE + \
+        ( (_n) * PC202_GPIO_SD_PIN_CONFIG_SPACING )
+
+/** Control source bit. */
+#define PC202_GPIO_SD_CONFIG_CS_MASK ~( 1 << 15 )
+
+/** Analogue not digital bit. */
+#define PC202_GPIO_SD_CONFIG_AND ( 1 << 14 )
+
+/** The mask for analogue converter size in the config register. */
+#define PC202_GPIO_SD_CONV_SZ_MASK ( 0xF )
+
+/** PC202 AHB2Pico CAEID. */
+#define PC202_AHB2PICO_CAEID    ( 0x0008 )
+
+/** Define the number of SD-GPIOs allocated to lower register*/
+#define PC202_NUM_LSBS ( 16 + PC202_GPIO_PIN_SDGPIO_0 )
+
+static int pc202gpio_open( struct inode *inode,
+                           struct file *filp );
+
+static int pc202gpio_release( struct inode *inode,
+                              struct file *filp );
+
+static int pc202gpio_ioctl( struct inode *inode,
+                            struct file *filp,
+                            unsigned int cmd,
+                            unsigned long arg );
+
+/*****************************************************************************
+ * Data types.                                                               *
+ *****************************************************************************/
+
+/**
+ * The file operations for the GPIO driver.
+ */
+static const struct file_operations pc202gpio_fops = {
+    .open       = pc202gpio_open,
+    .release    = pc202gpio_release,
+    .ioctl      = pc202gpio_ioctl,
+};
+
+/** Private data storage for this module. */
+static struct {
+
+#ifdef CONFIG_DEBUG_FS
+    /**
+     * The directory entry for debugfs if we are using it.
+     */
+    struct dentry *debugfs_dir;
+
+    /**
+     * The list of all active GPIOs if we are using debugfs.
+     */
+    struct dentry *debugfs_file;
+#endif /* CONFIG_DEBUG_FS */
+
+    struct platform_device *pdev;
+    struct platform_driver *pdrv;
+    struct miscdevice dev;
+    void __iomem *mem_region;
+    spinlock_t lock;
+
+} pc202gpio_priv = {
+    .dev    = {
+        .minor  = PC202_GPIO_MINOR,
+        .name   = "gpio",
+        .fops   = &pc202gpio_fops,
+    },
+    .lock       = __SPIN_LOCK_UNLOCKED( pc202gpio_priv_lock ),
+};
+
+/** GPIO pin type. */
+typedef enum
+{
+    PC202_GPIO_ARM,
+    PC202_GPIO_SD,
+
+} pc202gpio_pin_type;
+
+/** Private representation to store state of a GPIO pin. */
+struct pc202gpio_pin_allocation
+{
+    /** The pin number (not pad number). */
+    int pin_num;
+
+    /** Boolean flag for an input GPIO. */
+    int is_input;
+
+    /** Boolean flag for whether the pin is active. */
+    int enabled;
+
+    /** The name of the pin - filled in when the pin is requested. */
+    char name[ PC202_GPIO_PIN_NAME_MAX ];
+
+    /** The cached value of the pin. Used for output GPIO pins to remember the
+     * last value set. */
+    int value;
+
+    /** Analogue not digital flag. 0 == digital, non-zero == analogue. */
+    int a_not_d;
+};
+
+#ifdef CONFIG_CONFIGFS_FS
+/** Structure to store the state of a pin in configfs. */
+struct pc202gpio_cfs_pin
+{
+    /** The configfs entry. */
+    struct config_item item;
+
+    /** The pin allocation. */
+    struct pc202gpio_pin_allocation *phys_pin;
+};
+
+/** Structure for setting and getting attributes through configfs. */
+struct pc202gpio_pin_attr
+{
+    /** The attribute itself. */
+    struct configfs_attribute attr;
+
+    ssize_t ( *show )( struct pc202gpio_cfs_pin *pin, char *buf );
+    ssize_t ( *store )( struct pc202gpio_cfs_pin *pin, const char *buf,
+                        size_t count );
+};
+#endif /* CONFIG_CONFIGFS_FS */
+
+static struct pc202gpio_pin_allocation *pc202gpio_pads[ PC202_GPIO_NUM_PADS ];
+
+static struct pc202gpio_pin_allocation * pc202gpio_find_pin( unsigned gpio );
+
+/*****************************************************************************
+ * Private function prototypes.                                              *
+ *****************************************************************************/
+
+static int
+pc202gpio_get_pad( picoifGpioPinNum_t pin );
+
+static struct pc202gpio_pin_allocation *
+pc202gpio_alloc_pin( const char *name );
+
+#ifdef CONFIG_CONFIGFS_FS
+static void
+pc202gpio_free_pin( struct pc202gpio_pin_allocation *p );
+#endif
+
+static int
+pc202gpio_set_direction( struct pc202gpio_pin_allocation *pin,
+                         int input );
+
+static int pc202gpio_set_direction( struct pc202gpio_pin_allocation *pin,
+                                    int input );
+
+static pc202gpio_pin_type
+pc202gpio_get_pin_type( struct pc202gpio_pin_allocation *pin );
+
+static int
+pc202gpio_pin_to_block_pin( struct pc202gpio_pin_allocation *pin );
+
+static int
+pc202gpio_set_value( struct pc202gpio_pin_allocation *pin,
+                     int value );
+
+static int
+pc202gpio_get_value( struct pc202gpio_pin_allocation *pin );
+
+#ifdef CONFIG_CONFIGFS_FS
+ssize_t pc202gpio_cfs_show_attribute( struct config_item *,
+                                      struct configfs_attribute *,
+                                      char * );
+
+ssize_t pc202gpio_cfs_store_attribute( struct config_item *,
+                                       struct configfs_attribute *,
+                                       const char *,
+                                       size_t );
+#endif /* CONFIG_CONFIGFS_FS */
+
+/*****************************************************************************
+ * Implementation.                                                           *
+ *****************************************************************************/
+
+/**
+ * Get the pad number for the requested GPIO pin. There are no multiplexed
+ * GPIOs in pc20x. Therefore there is a 1 to 1 mapping between pin and pad
+ * numbers.
+ *
+ * \param pin The pin number being requested.
+ * \return Returns the pad number in the range 0 ... PC202_GPIO_NUM_PADS on
+ * success or negative on failure (invalid pin number, pad already in use
+ * etc).
+ */
+static int
+pc202gpio_get_pad( picoifGpioPinNum_t pin )
+{
+    int ret = -EINVAL;
+
+    spin_lock( &pc202gpio_priv.lock );
+
+    if ( (pin >= PC202_GPIO_PIN_ARM_0) && (pin <= PC202_GPIO_PIN_SDGPIO_31) )
+    {
+        ret = pin - PC202_GPIO_PIN_ARM_0;
+    }
+
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Check if a GPIO pin number is a valid GPIO pin in this system.
+ *
+ * \param gpio The GPIO pin number to query.
+ * \return Returns 1 if gpio is a valid pin, 0 otherwise.
+ */
+int
+gpio_is_valid( int gpio )
+{
+    return ( (gpio >= PC202_GPIO_PIN_ARM_0) && (gpio <= PC202_GPIO_PIN_SDGPIO_31) );
+}
+EXPORT_SYMBOL( gpio_is_valid );
+
+/**
+ * Request a new GPIO pin. This implements part of the Linux GPIO guidelines.
+ *
+ * \param gpio The pin to request.
+ * \param label The name of the pin - this only serves as a tag for debugging
+ * so can be anything.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+gpio_request( unsigned gpio,
+              const char *label )
+{
+    int pad_num;
+    int ret = 0;
+
+    spin_lock( &pc202gpio_priv.lock );
+    pad_num = pc202gpio_get_pad( gpio );
+
+    ret = -EINVAL;
+    if ( pad_num < 0 )
+        goto out;
+
+    /* If the pad is already in use then fail. */
+    ret = -EBUSY;
+    if ( pc202gpio_pads[ pad_num ] )
+        goto out;
+
+    pc202gpio_pads[ pad_num ] = pc202gpio_alloc_pin( label );
+    pc202gpio_pads[ pad_num ]->pin_num = gpio;
+    ret = 0;
+
+out:
+    spin_unlock( &pc202gpio_priv.lock );
+
+    return ret;
+}
+EXPORT_SYMBOL( gpio_request );
+
+/**
+ * Free a GPIO pin previously requested with gpio_request().
+ *
+ * \param gpio The GPIO pin to free.
+ */
+void
+gpio_free( unsigned gpio )
+{
+    unsigned i;
+    unsigned found = 0;
+    struct pc202gpio_pin_allocation *pin;
+    pc202gpio_pin_type ptype;
+
+    spin_lock( &pc202gpio_priv.lock );
+
+    pin = pc202gpio_find_pin( gpio );
+    ptype = pc202gpio_get_pin_type( pin );
+
+    /* Find the pin. */
+    for ( i = 0; i < PC202_GPIO_NUM_PADS; ++i )
+    {
+        if ( pc202gpio_pads[ i ] && pc202gpio_pads[ i ]->pin_num == gpio )
+        {
+            found = 1;
+            break;
+        }
+    }
+
+    if ( !found )
+        goto out;
+
+    kfree( pc202gpio_pads[ i ] );
+    pc202gpio_pads[ i ] = NULL;
+
+out:
+    spin_unlock( &pc202gpio_priv.lock );
+}
+EXPORT_SYMBOL( gpio_free );
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * input.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+gpio_direction_input( unsigned gpio )
+{
+    int pad_num;
+    struct pc202gpio_pin_allocation *pin;
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+    pad_num = pc202gpio_get_pad( gpio );
+    if ( pad_num < 0 )
+    {
+        ret = pad_num;
+        goto out;
+    }
+
+    pin = pc202gpio_pads[ pad_num ];
+
+    ret = -ENXIO;
+    if ( !pin )
+        goto out;
+
+    pin->is_input = 1;
+    ret = pc202gpio_set_direction( pin, 1 );
+
+out:
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+EXPORT_SYMBOL( gpio_direction_input );
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * output.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \param value The initial output value for the gpio pin.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+gpio_direction_output( unsigned gpio,
+                       int value )
+{
+    int pad_num;
+    struct pc202gpio_pin_allocation *pin;
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+    pad_num = pc202gpio_get_pad( gpio );
+    if ( pad_num < 0 )
+    {
+        ret = pad_num;
+        goto out;
+    }
+
+    pin = pc202gpio_pads[ pad_num ];
+
+    ret = -ENXIO;
+    if ( !pin )
+        goto out;
+
+    pin->is_input = 0;
+    ret = pc202gpio_set_direction( pin, 0 );
+    if ( 0 != ret )
+    {
+        goto out;
+    }
+    else
+    {
+        ret = pc202gpio_set_value( pin, value );
+    }
+
+out:
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+EXPORT_SYMBOL( gpio_direction_output );
+
+/**
+ * Check if a GPIO pin can sleep.
+ *
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+gpio_cansleep( unsigned gpio )
+{
+    /* None of our GPIO pin accesses can sleep so always return 0. */
+    return 0;
+}
+EXPORT_SYMBOL( gpio_cansleep );
+
+/* We don't use gpiolib as it doesn't handle multiplexing of pins well so we
+ * don't get the sysfs export helpers. Rather than leave the functions
+ * undefined, always return an error. */
+int
+gpio_export( unsigned gpio,
+             bool direction_may_change )
+{
+    return -ENODEV;
+}
+EXPORT_SYMBOL( gpio_export );
+
+int
+gpio_unexport( unsigned gpio )
+{
+    return -ENODEV;
+}
+EXPORT_SYMBOL( gpio_unexport );
+
+/**
+ * Given a GPIO pin number, find the IRQ that it can generate.
+ *
+ * \param gpio The GPIO pin to get the IRQ line for.
+ * \return Returns the IRQ number on success, negative on failure.
+ */
+int
+gpio_to_irq( unsigned gpio )
+{
+    return ( gpio - PC202_GPIO_PIN_ARM_0 ) + IRQ_GPIO_0;
+}
+EXPORT_SYMBOL( gpio_to_irq );
+
+/**
+ * Given a IRQ line number, find the GPIO pin can generate it.
+ *
+ * \param irq The IRQ line that can be generated by the GPIO.
+ * \return Returns the GPIO pin number on success, negative on failure.
+ */
+int
+irq_to_gpio( unsigned irq )
+{
+    return ( irq - IRQ_GPIO_0 ) + PC202_GPIO_PIN_ARM_0;
+}
+
+/* None of our GPIOs can sleep and we could just implement these functions as
+ * wrappers around the spinlock safe functions, things could change in the
+ * future and its better to be explicit. Using these _cansleep() variants will
+ * always return -EIO. */
+int
+gpio_get_value_cansleep( unsigned gpio )
+{
+    return -EIO;
+}
+EXPORT_SYMBOL( gpio_get_value_cansleep );
+
+int
+gpio_set_value_cansleep( unsigned gpio,
+                         int value )
+{
+    return -EIO;
+}
+EXPORT_SYMBOL( gpio_set_value_cansleep );
+
+/**
+ * Set the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to set the value of.
+ * \param value The value to set the pin to.
+ */
+int
+gpio_set_value( unsigned gpio,
+                int value )
+{
+    struct pc202gpio_pin_allocation *pin;
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+
+    pin = pc202gpio_find_pin( gpio );
+    ret = -EINVAL;
+    if ( !pin )
+        goto out;
+
+    ret = pc202gpio_set_value( pin, value );
+
+out:
+
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+EXPORT_SYMBOL( gpio_set_value );
+
+/**
+ * Get the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to get the value of.
+ * \return Returns the value of the pin on success,
+ * negative on failure.
+ */
+int
+gpio_get_value( unsigned gpio )
+{
+    struct pc202gpio_pin_allocation *pin;
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+    pin = pc202gpio_find_pin( gpio );
+
+    ret = -EINVAL;
+    if ( !pin )
+        goto out;
+
+    ret = pc202gpio_get_value( pin );
+out:
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+EXPORT_SYMBOL( gpio_get_value );
+
+#ifdef CONFIG_CONFIGFS_FS
+/**
+ * Free a GPIO pin that has previously been allocated.
+ *
+ * \param p The pin to free.
+ */
+static void
+pc202gpio_free_pin( struct pc202gpio_pin_allocation *p )
+{
+    kfree( p );
+}
+#endif
+
+/**
+ * Allocate a GPIO pin state structure.
+ *
+ * \param name The name of the pin (this can be anything - it can be the
+ * function of the pin or the application using it for example).
+ * \return Returns a pointer to the pin on success, NULL on failure.
+ */
+static struct pc202gpio_pin_allocation *
+pc202gpio_alloc_pin( const char *name )
+{
+    struct pc202gpio_pin_allocation *p =
+        kzalloc( sizeof( *p ), GFP_KERNEL );
+
+    if ( p )
+    {
+        snprintf( p->name, PC202_GPIO_PIN_NAME_MAX, "%s", name );
+        p->pin_num = -1;
+        p->enabled = 0;
+        p->is_input = 0;
+        p->a_not_d = 0;
+    }
+
+    return p;
+}
+
+/**
+ * Get the pin type.
+ *
+ * \param pin The pin to query.
+ * \return Returns the type of GPIO pin.
+ */
+static pc202gpio_pin_type
+pc202gpio_get_pin_type( struct pc202gpio_pin_allocation *pin )
+{
+    int ret;
+    BUG_ON( !pin );
+
+    switch ( pin->pin_num )
+    {
+        case PC202_GPIO_PIN_ARM_0 ... PC202_GPIO_PIN_ARM_7:
+            ret = PC202_GPIO_ARM;
+            break;
+
+        case PC202_GPIO_PIN_SDGPIO_0 ... PC202_GPIO_PIN_SDGPIO_31:
+            ret = PC202_GPIO_SD;
+            break;
+
+        default:
+            ret = -EINVAL;
+            break;
+    }
+
+    return ret;
+}
+
+/**
+ * Given a GPIO pin number, find the number of the bit in the register.
+ * This function takes the pin number and turns it into a number
+ * in the range 0->15 for the bit that controls it.
+ *
+ * \param pin The pin to query.
+ * \return Returns the block pin number on success, non-zero on failure.
+ */
+static int
+pc202gpio_pin_to_block_pin( struct pc202gpio_pin_allocation *pin )
+{
+    unsigned ret;
+
+    BUG_ON( NULL == pin );
+
+    switch ( pin->pin_num )
+    {
+        case PC202_GPIO_PIN_ARM_0 ... PC202_GPIO_PIN_ARM_7:
+            ret =  pin->pin_num - PC202_GPIO_PIN_ARM_0;
+            break;
+
+        case PC202_GPIO_PIN_SDGPIO_0 ... PC202_GPIO_PIN_SDGPIO_15:
+            ret =  pin->pin_num - PC202_GPIO_PIN_SDGPIO_0;
+            break;
+
+        case PC202_GPIO_PIN_SDGPIO_16 ... PC202_GPIO_PIN_SDGPIO_31:
+            ret =  pin->pin_num - PC202_GPIO_PIN_SDGPIO_16;
+            break;
+
+        default:
+            ret = -1;
+            BUG();
+    }
+
+    return ret;
+}
+
+/**
+ * Set the value of an output SDGPIO pin.
+ *
+ * \param pin The pin to set the value of.
+ * \param value The value to set the pin to. Intepreted as non-zero == 1.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc202gpio_sd_set_value( struct pc202gpio_pin_allocation *pin,
+                        int value )
+{
+    unsigned block_pin=0;
+    int ret=0;
+
+    BUG_ON( NULL == pin );
+
+    if ( pin->is_input )
+        return -EINVAL;
+
+    block_pin = pc202gpio_pin_to_block_pin( pin );
+
+    if ( !pin->a_not_d )
+    {
+        /* Digital mode */
+        u16 data[2]={0,0};
+
+        ret = picoif_config_read( 0, PC202_AHB2PICO_CAEID,
+                                  PC202_GPIO_SD_OUTPUT_VAL_REG_LOW, 2, data );
+        if ( 2 != ret )
+        {
+            printk( KERN_ALERT "failed to read SDGPIO output value regs\n" );
+            return -EIO;
+        }
+
+        if ( pin->pin_num < PC202_NUM_LSBS )
+        {        
+            data[0] &= ~( 1 << block_pin );
+            data[0] |= ( !!value ) << block_pin;
+
+        }
+        else
+        {
+            data[1] &= ~( 1 << block_pin );
+            data[1] |= ( !!value ) << block_pin;
+        }
+
+        ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID,
+                    PC202_GPIO_SD_OUTPUT_VAL_REG_LOW, 2, data );
+        if ( 2 != ret )
+        {
+            printk( KERN_ALERT "failed to update output control register "
+                        "for SDGPIO pin %u\n", block_pin );
+            return -EIO;
+        }
+    }
+    else
+    {
+        /* Analogue mode */
+
+        u16 data = (u16)value;
+        ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID,
+                                   PC202_GPIO_SD_PIN_ANALOGUE_VAL
+                                       ( pin->pin_num - PC202_GPIO_PIN_SDGPIO_0 ),
+                                   1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to write analogue value register for "
+                    "SDGPIO pin %u\n", block_pin );
+            return -EIO;
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * Get the value of an input SDGPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value read on success, negative on failure.
+ */
+static int
+pc202gpio_sd_get_value( struct pc202gpio_pin_allocation *pin )
+{
+    unsigned block_pin=0;
+    int ret=0;
+    BUG_ON( NULL == pin );
+
+    if ( !pin->is_input && !pin->a_not_d )
+        return -EINVAL;
+
+    block_pin = pc202gpio_pin_to_block_pin( pin );
+
+    if ( !pin->a_not_d )
+    {
+        /* Digital mode */
+        u16 data[2]={0,0};
+
+        ret = picoif_config_read( 0, PC202_AHB2PICO_CAEID,
+                                  PC202_GPIO_SD_INPUT_VAL_REG_LOW, 2, data );
+        if ( 2 != ret )
+        {
+            printk( KERN_ALERT "failed to read SDGPIO input value regs\n" );
+            return -EIO;
+        }
+
+        if ( pin->pin_num < PC202_NUM_LSBS )
+        {
+            return !!( data[0] & ( 1 << block_pin ) );
+        }
+        else
+        {
+            return !!( data[1] & ( 1 << block_pin ) );
+        }
+    }
+    else
+    {
+        /* Analogue mode */
+        u16 data=0;
+
+        ret = picoif_config_read( 0, PC202_AHB2PICO_CAEID,
+                                  PC202_GPIO_SD_PIN_ANALOGUE_VAL
+                                       ( pin->pin_num - PC202_GPIO_PIN_SDGPIO_0 ),
+                                  1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to read the analogue value register "
+                    "for SDGPIO pin %u\n", block_pin );
+            return -EIO;
+        }
+
+        return (int)data;
+    }
+}
+
+/**
+ * Get the value of an input ARM GPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value read on success, negative on failure.
+ */
+static int
+pc202gpio_arm_get_value( struct pc202gpio_pin_allocation *pin )
+{
+    unsigned block_pin;
+    void __iomem *port_ds;
+    u32 pin_offset;
+    u32 val;
+    BUG_ON( NULL == pin );
+
+    if ( !pin->is_input )
+        return -EINVAL;
+
+    block_pin = pc202gpio_pin_to_block_pin( pin );
+
+    if ( block_pin >= PC202_GPIO_PIN_ARM_0 &&
+         block_pin <= PC202_GPIO_PIN_ARM_7 )
+    {
+        port_ds = pc202gpio_priv.mem_region + GPIO_EXT_PORT_A_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else
+    {
+        printk( KERN_INFO "cannot get value of ARM GPIO pin (%d)\n",
+                block_pin );
+        return -ENXIO;
+    }
+
+    val = ioread32( port_ds );
+
+    return !!( val & ( 1 << pin_offset ) );
+}
+
+/**
+ * Set the direction of an SD-GPIO pin.
+ *
+ * \param pin The pin to set the direction of.
+ * \param input Boolean flag to set the pin to input.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc202gpio_sd_set_direction( struct pc202gpio_pin_allocation *pin,
+                            int input )
+{
+    int ret=0;
+    u16 data=0;
+    unsigned block_pin=0;
+    u16 reg=0;
+
+    /* Set the pin to be controlled by the configuration bus. */
+    block_pin = pc202gpio_pin_to_block_pin( pin );
+
+    ret = picoif_config_read( 0, PC202_AHB2PICO_CAEID,
+                              PC202_GPIO_SD_PIN_CONFIG
+                                  ( pin->pin_num - PC202_GPIO_PIN_SDGPIO_0 ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    data &= PC202_GPIO_SD_CONFIG_CS_MASK;
+    ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID,
+                               PC202_GPIO_SD_PIN_CONFIG
+                               ( pin->pin_num - PC202_GPIO_PIN_SDGPIO_0 ),
+                               1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    /* Configure the pin to drive or not drive the output as appropriate. */
+    if ( pin->pin_num < PC202_NUM_LSBS)
+        reg = PC202_GPIO_SD_CONTROL_VAL_REG_LOW;
+    else
+        reg = PC202_GPIO_SD_CONTROL_VAL_REG_HIGH;
+ 
+    ret = picoif_config_read( 0, PC202_AHB2PICO_CAEID, reg, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read SDGPIO control value register\n" );
+        return -EIO;
+    }
+
+    if ( input )
+        data &= ~( 1 << block_pin );
+    else
+        data |= ( 1 << block_pin );
+
+    ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID, reg, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write the control value register "
+                "for SDGPIO pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    /* The output value upper register needs to be written in order for the configuration
+    change to take effect. This includes any reads of these registers. */
+
+    ret = picoif_config_read( 0, PC202_AHB2PICO_CAEID, PC202_GPIO_SD_OUTPUT_VAL_REG_HIGH,
+         1, & data);
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read the high value register "
+                "for SDGPIO pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID, PC202_GPIO_SD_OUTPUT_VAL_REG_HIGH,
+         1, & data);
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write the high value register "
+                "for SDGPIO pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/**
+ * Set the direction of an ARM GPIO pin.
+ *
+ * \param pin The pin to set the direction of.
+ * \param input Boolean flag to set the pin to input.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc202gpio_arm_set_direction( struct pc202gpio_pin_allocation *pin,
+                             int input )
+{
+    unsigned block_pin;
+    void __iomem *port_ddr;
+    void __iomem *port_cr;
+    u32 val;
+    u32 pin_offset;
+
+    /* Set the pin to be controlled by the configuration bus. */
+    block_pin = pc202gpio_pin_to_block_pin( pin );
+
+    if ( block_pin >= PC202_GPIO_PIN_ARM_0 &&
+         block_pin <= PC202_GPIO_PIN_ARM_7 )
+    {
+        port_ddr = pc202gpio_priv.mem_region + GPIO_SW_PORT_A_DDR_REG_OFFSET;
+        port_cr = pc202gpio_priv.mem_region + GPIO_SW_PORT_A_CTL_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else
+    {
+        printk( KERN_INFO "cannot set direction of ARM GPIO pin (%d)\n",
+                block_pin );
+        return -ENXIO;
+    }
+
+    /* Set the direction register (a bit set indicates output). */
+    val = ioread32( port_ddr );
+    if ( input )
+        val &= ~( 1 << pin_offset );
+    else
+        val |= ( 1 << pin_offset );
+    iowrite32( val, port_ddr );
+
+    /* Set the control register for the pin to be software controlled. */
+    val = ioread32( port_cr );
+    val &= ~( 1 << pin_offset );
+    iowrite32( val, port_cr );
+
+    return 0;
+}
+
+/**
+ * Set the value of an output ARM GPIO pin.
+ *
+ * \param pin The pin to set the value of.
+ * \param value The value to set the pin to. Intepreted as non-zero == 1.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc202gpio_arm_set_value( struct pc202gpio_pin_allocation *pin,
+                         int value )
+{
+    unsigned block_pin;
+    u32 val;
+    u32 pin_offset;
+    void __iomem *port_dr;
+    BUG_ON( NULL == pin );
+
+    if ( pin->is_input )
+        return -EINVAL;
+
+    block_pin = pc202gpio_pin_to_block_pin( pin );
+    if ( block_pin >= PC202_GPIO_PIN_ARM_0 &&
+         block_pin <= PC202_GPIO_PIN_ARM_7 )
+    {
+        port_dr = pc202gpio_priv.mem_region + GPIO_SW_PORT_A_DR_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else
+    {
+        printk( KERN_INFO "cannot set value of ARM GPIO pin (%d)\n",
+                block_pin );
+        return -ENXIO;
+    }
+
+    val = ioread32( port_dr );
+    val &= ~( 1 << pin_offset );
+    val |= ( !!value << pin_offset );
+
+    iowrite32( val, port_dr );
+
+    return 0;
+}
+
+/**
+ * Set the direction of a GPIO pin.
+ *
+ * \param pin The pin to set the direction of.
+ * \param input Flag for input GPIO pins.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc202gpio_set_direction( struct pc202gpio_pin_allocation *pin,
+                         int input )
+{
+    int ret;
+    pc202gpio_pin_type ptype;
+    BUG_ON( NULL == pin );
+
+    ptype = pc202gpio_get_pin_type( pin );
+
+    if ( PC202_GPIO_ARM == ptype )
+        ret = pc202gpio_arm_set_direction( pin, input );
+    else if ( PC202_GPIO_SD == ptype )
+        ret = pc202gpio_sd_set_direction( pin, input );
+    else
+        ret = -EINVAL;
+
+    if ( !ret )
+        pin->is_input = !!input;
+
+    return ret;
+}
+
+/**
+ * Set the value of a GPIO pin.
+ *
+ * \param pin The pin to set the value of.
+ * \param value The value to set.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc202gpio_set_value( struct pc202gpio_pin_allocation *pin,
+                     int value )
+{
+    int ret;
+    pc202gpio_pin_type ptype;
+    BUG_ON( NULL == pin );
+
+    ptype = pc202gpio_get_pin_type( pin );
+
+    if ( PC202_GPIO_ARM == ptype )
+        ret = pc202gpio_arm_set_value( pin, value );
+    else if ( PC202_GPIO_SD == ptype )
+        ret = pc202gpio_sd_set_value( pin, value );
+    else
+        ret = -EINVAL;
+
+    if ( !ret && !pin->a_not_d )
+    {
+        /* Digital mode */
+        pin->value = !!value;
+    }
+    else
+    {
+        /* Analogue mode */
+        pin->value = value;
+    }
+    return ret;
+}
+
+/**
+ * Get the value of a GPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value of the pin on success, 
+ * negative on failure.
+ */
+static int
+pc202gpio_get_value( struct pc202gpio_pin_allocation *pin )
+{
+    int ret;
+    pc202gpio_pin_type ptype;
+    BUG_ON( NULL == pin );
+
+    ptype = pc202gpio_get_pin_type( pin );
+
+    if ( PC202_GPIO_ARM == ptype )
+        ret = pc202gpio_arm_get_value( pin );
+    else if ( PC202_GPIO_SD == ptype )
+        ret = pc202gpio_sd_get_value( pin );
+    else
+        ret = -EINVAL;
+
+    if ( ret >= 0 && !pin->a_not_d )
+    {
+        /* Digital mode */
+        pin->value = !!ret;
+    }
+    else
+    {
+        /* Analogue mode */
+        pin->value = ret;
+    }
+    return ret;
+}
+
+/**
+ * Given a GPIO pin number, find the PC202 representation of it.
+ *
+ * \param gpio The GPIO pin number.
+ * \return Returns a pointer to the internal representation.
+ */
+static struct pc202gpio_pin_allocation *
+pc202gpio_find_pin( unsigned gpio )
+{
+    int i;
+
+    for ( i = 0 ; i < PC202_GPIO_NUM_PADS; ++i )
+    {
+        if ( pc202gpio_pads[ i ] && pc202gpio_pads[ i ]->pin_num == gpio )
+            return pc202gpio_pads[ i ];
+    }
+
+    return NULL;
+}
+
+static int
+pc202gpio_configure_dac( unsigned gpio,
+                         u8 converter_size,
+                         u16 analogue_rate )
+{
+    int ret;
+    u16 data;
+    unsigned block_pin;
+    struct pc202gpio_pin_allocation *pin = pc202gpio_find_pin( gpio );
+
+    if ( !pin )
+        return -EINVAL;
+        
+    /* Set the pin to be controlled by the configuration bus. */
+    block_pin = pc202gpio_pin_to_block_pin( pin );
+
+    ret = picoif_config_read( 0, PC202_AHB2PICO_CAEID,
+                              PC202_GPIO_SD_PIN_CONFIG
+                                  ( pin->pin_num - PC202_GPIO_PIN_SDGPIO_0 ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    data &= PC202_GPIO_SD_CONFIG_CS_MASK;
+    data |= ( PC202_GPIO_SD_CONFIG_AND |
+            ( converter_size & PC202_GPIO_SD_CONV_SZ_MASK ) );
+
+    ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID,
+                              PC202_GPIO_SD_PIN_CONFIG
+                                  ( pin->pin_num - PC202_GPIO_PIN_SDGPIO_0 ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    /* Configure the pin to drive the output. */
+    if ( pin->pin_num <= PC202_NUM_LSBS )
+    {
+        ret = picoif_config_read( 0, PC202_AHB2PICO_CAEID,
+                              PC202_GPIO_SD_CONTROL_VAL_REG_LOW, 1, &data );
+    }
+    else
+    {
+        ret = picoif_config_read( 0, PC202_AHB2PICO_CAEID,
+                              PC202_GPIO_SD_CONTROL_VAL_REG_HIGH, 1, &data );
+    }
+
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read SDGPIO control value register\n" );
+        return -EIO;
+    }
+
+    data |= ( 1 << block_pin );
+
+    if ( pin->pin_num < PC202_NUM_LSBS )
+    {
+        ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID,
+                               PC202_GPIO_SD_CONTROL_VAL_REG_LOW, 1, &data );
+    }
+    else
+    {
+        ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID,
+                               PC202_GPIO_SD_CONTROL_VAL_REG_HIGH, 1, &data );
+    }
+
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write control value register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+    
+    /* Write the Analogue rate register */
+    data = analogue_rate;
+    ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID,
+                              PC202_GPIO_SD_PIN_ANALOGUE_RATE
+                                  ( pin->pin_num - PC202_GPIO_PIN_SDGPIO_0 ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write analogue rate register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    /* Set the a_not_d flag in the pin allocation structure */
+    pin->a_not_d = 1;
+
+    return 0;  
+}
+
+#ifdef CONFIG_CONFIGFS_FS
+/**
+ * Show the pin number for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc202gpio_show_pin( struct pc202gpio_cfs_pin *pin,
+                    char *buf )
+{
+    int ret;
+    spin_lock( &pc202gpio_priv.lock );
+    ret = snprintf( buf, PAGE_SIZE, "%d\n", pin->phys_pin->pin_num );
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Store the pin number for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to read the value from.
+ * \param count The number of bytes available to read.
+ *
+ * \return Returns the length read on success, negative on failure.
+ */
+static ssize_t
+pc202gpio_store_pin( struct pc202gpio_cfs_pin *pin,
+                     const char *buf,
+                     size_t count )
+{
+    unsigned pin_num;
+    int pad_num;
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+
+    ret = -EINVAL;
+    if ( pin->phys_pin->enabled )
+        goto out;
+
+    pin_num = simple_strtoul( buf, NULL, 10 );
+    pad_num = pc202gpio_get_pad( pin_num );
+
+    ret = -EINVAL;
+    if ( pad_num < 0 || pc202gpio_pads[ pad_num ] )
+        goto out;
+
+    pin->phys_pin->pin_num = pin_num;
+    pc202gpio_pads[ pad_num ] = pin->phys_pin;
+
+    ret = strlen( buf );
+out:
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Show the enabled state for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc202gpio_show_enabled( struct pc202gpio_cfs_pin *pin,
+                        char *buf )
+{
+    int ret;
+    spin_lock( &pc202gpio_priv.lock );
+    ret = snprintf( buf, PAGE_SIZE, "%d\n", pin->phys_pin->enabled );
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Store the enabled state for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to read the value from.
+ * \param count The number of bytes available to read.
+ *
+ * \return Returns the length read on success, negative on failure.
+ */
+static ssize_t
+pc202gpio_store_enabled( struct pc202gpio_cfs_pin *pin,
+                         const char *buf,
+                         size_t count )
+{
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+    ret = pc202gpio_set_direction( pin->phys_pin, pin->phys_pin->is_input );
+
+    if ( !ret )
+    {
+        pin->phys_pin->enabled = !!simple_strtoul( buf, NULL, 10 );
+        ret = strlen( buf );
+    }
+    else
+        ret = -EINVAL;
+
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Show the direction for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc202gpio_show_is_input( struct pc202gpio_cfs_pin *pin,
+                          char *buf )
+{
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+    ret = snprintf( buf, PAGE_SIZE, "%d\n", pin->phys_pin->is_input );
+    spin_unlock( &pc202gpio_priv.lock );
+
+    return ret;
+}
+
+/**
+ * Store the direction for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to read the value from.
+ * \param count The number of bytes available to read.
+ *
+ * \return Returns the length read on success, negative on failure.
+ */
+static ssize_t
+pc202gpio_store_is_input( struct pc202gpio_cfs_pin *pin,
+                           const char *buf,
+                           size_t count )
+{
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+
+    ret = -EINVAL;
+    if ( pin->phys_pin->enabled )
+        goto out;
+
+    pin->phys_pin->is_input = simple_strtoul( buf, NULL, 10 );
+    pc202gpio_set_direction( pin->phys_pin, pin->phys_pin->is_input );
+
+    ret = strlen( buf );
+out:
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Show the name of the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc202gpio_show_name( struct pc202gpio_cfs_pin *pin,
+                     char *buf )
+{
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+    ret = snprintf( buf, PAGE_SIZE, "%s\n", pin->phys_pin->name );
+    spin_unlock( &pc202gpio_priv.lock );
+
+    return ret;
+}
+
+/**
+ * Show the value of the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc202gpio_show_value( struct pc202gpio_cfs_pin *pin,
+                      char *buf )
+{
+    int ret;
+
+    spin_lock( &pc202gpio_priv.lock );
+    if ( pin->phys_pin->is_input )
+    {
+        ret = pc202gpio_get_value( pin->phys_pin );
+        if ( ret < 0 )
+            goto out;
+    }
+    else
+        ret = pin->phys_pin->value;
+
+    ret = snprintf( buf, PAGE_SIZE, "%d\n", ret );
+out:
+    spin_unlock( &pc202gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Store the value for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to read the value from.
+ * \param count The number of bytes available to read.
+ *
+ * \return Returns the length read on success, negative on failure.
+ */
+static ssize_t
+pc202gpio_store_value( struct pc202gpio_cfs_pin *pin,
+                       const char *buf,
+                       size_t count )
+{
+    int ret;
+    spin_lock( &pc202gpio_priv.lock );
+
+    if ( 1 != pin->phys_pin->enabled || pin->phys_pin->is_input )
+    {
+        spin_unlock( &pc202gpio_priv.lock );
+        return -EINVAL;
+    }
+
+    pin->phys_pin->value = !!simple_strtoul( buf, NULL, 10 );
+    ret = pc202gpio_set_value( pin->phys_pin, pin->phys_pin->value );
+
+    spin_unlock( &pc202gpio_priv.lock );
+
+    if ( ret < 0 )
+        return -EIO;
+
+    return strlen( buf );
+}
+
+/**
+ * Create a read-only attribute in configfs.
+ *
+ * \param _name The name of the attribute.
+ */
+#define PC202GPIO_PIN_ATTR_RO( _name ) \
+    static struct pc202gpio_pin_attr pc202gpio_pin_##_name = \
+        __CONFIGFS_ATTR( _name, S_IRUGO, pc202gpio_show_##_name, NULL )
+
+/**
+ * Create a read/write attribute in configfs.
+ *
+ * \param _name The name of the attribute.
+ */
+#define PC202GPIO_PIN_ATTR_RW( _name ) \
+    static struct pc202gpio_pin_attr pc202gpio_pin_##_name = \
+        __CONFIGFS_ATTR( _name, S_IRUGO | S_IWUSR, pc202gpio_show_##_name, \
+                        pc202gpio_store_##_name )
+
+/** Pin number attribute. */
+PC202GPIO_PIN_ATTR_RW( pin );
+/** Direction attribute (1 == input, 0 == output). */
+PC202GPIO_PIN_ATTR_RW( is_input );
+/** The value of the pin (RO if input, RW if output). */
+PC202GPIO_PIN_ATTR_RW( value );
+/** Enabled attribute. */
+PC202GPIO_PIN_ATTR_RW( enabled );
+/** Name attribute */
+PC202GPIO_PIN_ATTR_RO( name );
+
+/** Attributes to be shown for each configfs pin. */
+static struct configfs_attribute *pc202gpio_pin_attrs[] = {
+    &pc202gpio_pin_pin.attr,
+    &pc202gpio_pin_is_input.attr,
+    &pc202gpio_pin_value.attr,
+    &pc202gpio_pin_enabled.attr,
+    &pc202gpio_pin_name.attr,
+    NULL,
+};
+
+/**
+ * From a configfs item, find the pin that it represents.
+ *
+ * \param item The configfs item.
+ * \return Returns a pointer to the pin on success, NULL on failure.
+ */
+static struct pc202gpio_cfs_pin *
+to_pin( struct config_item *item )
+{
+    return item ? container_of( item, struct pc202gpio_cfs_pin, item ) : NULL;
+}
+
+/**
+ * Show an attribute of a configfs pin.
+ *
+ * \param item The item that we want to see the attribute of.
+ * \param attr The attribute to show.
+ * \param buf The buffer to store the value in.
+ * \return Returns the number of bytes written to the buffer.
+ */
+static ssize_t
+pc202gpio_pin_attr_show( struct config_item *item,
+                            struct configfs_attribute *attr,
+                            char *buf )
+{
+    ssize_t ret = -EINVAL;
+    struct pc202gpio_cfs_pin *pin = to_pin( item );
+    struct pc202gpio_pin_attr *attribute =
+        container_of( attr, struct pc202gpio_pin_attr, attr );
+
+    if ( attribute->show )
+        ret = attribute->show( pin, buf );
+
+    return ret;
+}
+
+/**
+ * Store the value of an attribute in a configfs pin.
+ *
+ * \param item The item that we want to store the attribute value in.
+ * \param attr The attribute that we want to set.
+ * \param buf The value that we want to set.
+ * \param count The number of bytes in the value buffer.
+ * \return Returns the number of bytes read from the buffer.
+ */
+static ssize_t
+pc202gpio_pin_attr_store( struct config_item *item,
+                             struct configfs_attribute *attr,
+                             const char *buf,
+                             size_t count )
+{
+    ssize_t ret = -EINVAL;
+    struct pc202gpio_cfs_pin *pin = to_pin( item );
+    struct pc202gpio_pin_attr *attribute =
+        container_of( attr, struct pc202gpio_pin_attr, attr );
+
+    if ( attribute->show )
+        ret = attribute->store( pin, buf, count );
+
+    return ret;
+}
+
+/**
+ * Release a configfs pin.
+ *
+ * \param item The item to release. This frees the GPIO pin up for reuse.
+ */
+static void
+pc202gpio_pin_release( struct config_item *item )
+{
+    unsigned i;
+    struct pc202gpio_cfs_pin *t = to_pin( item );
+
+    for ( i = 0; i < PC202_GPIO_NUM_PADS; ++i )
+        if ( pc202gpio_pads[ i ] == t->phys_pin )
+        {
+            pc202gpio_free_pin( pc202gpio_pads[ i ] );
+            pc202gpio_pads[ i ] = NULL;
+        }
+
+    kfree( to_pin( item ) );
+}
+
+/** Operations that can happen on a configfs pin. */
+static struct configfs_item_operations pc202gpio_pin_item_ops = {
+    .release = pc202gpio_pin_release,
+    .show_attribute = pc202gpio_pin_attr_show,
+    .store_attribute = pc202gpio_pin_attr_store,
+};
+
+/** Description of a configfs GPIO pin and its associated attributes. */
+static struct config_item_type pc202gpio_cfs_pin_type = {
+    .ct_attrs = pc202gpio_pin_attrs,
+    .ct_item_ops = &pc202gpio_pin_item_ops,
+    .ct_owner = THIS_MODULE,
+};
+
+
+/**
+ * Create a new configfs pin. This will be called when the user calls mkdir()
+ * in /config/pc202gpio.
+ *
+ * \param group Not used.
+ * \param name The name of the new entry.
+ * \return Returns a pointer to the new entry on success, NULL on failure.
+ */
+static struct config_item *
+make_pc202gpio_pin( struct config_group *group,
+                    const char *name )
+{
+    struct pc202gpio_cfs_pin *t;
+    char tmp_buf[ PC202_GPIO_PIN_NAME_MAX ];
+
+    t = kzalloc( sizeof( *t ), GFP_KERNEL );
+    if ( !t )
+    {
+        printk( KERN_ERR "pc202gpio: failed to allocate memory\n" );
+        return NULL;
+    }
+    memset( t, sizeof( *t ), 0 );
+
+    snprintf( tmp_buf, sizeof( tmp_buf ) - 1, "configfs/%s", name );
+    t->phys_pin = pc202gpio_alloc_pin( tmp_buf );
+    if ( !t->phys_pin )
+    {
+        printk( KERN_ERR "pc202gpio: failed to allocate memory\n" );
+        kfree( t );
+        return NULL;
+    }
+
+    config_item_init_type_name( &t->item, name, &pc202gpio_cfs_pin_type );
+
+    return &t->item;
+}
+
+/**
+ * Drop a configfs pin. If the reference count reaches zero, the pin will be
+ * released.
+ *
+ * \param group Not used.
+ * \param item The item being dropped.
+ */
+static void
+drop_pc202gpio_pin( struct config_group *group,
+                    struct config_item *item )
+{
+    struct pc202gpio_cfs_pin *t = to_pin( item );
+
+    config_item_put( &t->item );
+}
+
+/** Operations table to describe how to create and drop pins through
+ *  configfs. */
+static struct configfs_group_operations pc202gpio_subsys_group_ops = {
+    .make_item = make_pc202gpio_pin,
+    .drop_item = drop_pc202gpio_pin,
+};
+
+/**
+ * Description of the pc202gpio configfs subsystem type. */
+static struct config_item_type pc202gpio_subsys_type = {
+    .ct_group_ops = &pc202gpio_subsys_group_ops,
+    .ct_owner = THIS_MODULE,
+};
+
+/** The configfs subsystem itself. */
+static struct configfs_subsystem pc202gpio_subsys = {
+    .su_group = {
+        .cg_item = {
+            .ci_namebuf = "pc202gpio",
+            .ci_type = &pc202gpio_subsys_type,
+        },
+    },
+};
+#endif /* CONFIG_CONFIGFS_FS */
+
+#ifdef CONFIG_DEBUG_FS
+static void *
+pc202gpio_seq_start( struct seq_file *f,
+                     loff_t *pos )
+{
+    return ( *pos < PC202_GPIO_NUM_PADS ) ? pos : NULL;
+}
+
+static void *
+pc202gpio_seq_next( struct seq_file *f,
+                    void *v,
+                    loff_t *pos )
+{
+    ( *pos )++;
+    if ( *pos >= PC202_GPIO_NUM_PADS )
+        return NULL;
+    return pos;
+}
+
+static void
+pc202gpio_seq_stop( struct seq_file *f,
+                    void *v )
+{
+    /* This function is intentionally left blank. */
+}
+
+static int
+pc202gpio_seq_show( struct seq_file *pi,
+                    void *v )
+{
+    unsigned pad_num = *( unsigned * )v;
+
+    if ( 0 == pad_num )
+        seq_printf( pi, "%-3s  %-3s  %-16s  %-s\n", "pin", "pad", "name",
+                    "is_input" );
+
+    if ( pc202gpio_pads[ pad_num ] )
+    {
+        seq_printf( pi, "%-3d  %-3d  %-16s  %-d\n",
+                    pc202gpio_pads[ pad_num]->pin_num, pad_num,
+                    pc202gpio_pads[ pad_num ]->name,
+                    pc202gpio_pads[ pad_num ]->is_input ? 1 : 0 );
+    }
+
+    return 0;
+}
+
+static struct seq_operations pc202gpio_seq_ops = {
+    .start = pc202gpio_seq_start,
+    .next  = pc202gpio_seq_next,
+    .stop  = pc202gpio_seq_stop,
+    .show  = pc202gpio_seq_show,
+};
+
+static int
+pc202gpio_debugfs_open( struct inode *inode,
+                       struct file *filp )
+{
+    return seq_open( filp, &pc202gpio_seq_ops );
+}
+
+static struct file_operations pc202gpio_debugfs_ops = {
+    .open    = pc202gpio_debugfs_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = seq_release,
+};
+
+static int
+pc202gpio_debugfs_init( void )
+{
+    pc202gpio_priv.debugfs_dir = debugfs_create_dir( "pc202gpio", NULL );
+    if ( !pc202gpio_priv.debugfs_dir )
+    {
+        return -ENOMEM;
+    }
+
+    if ( !debugfs_create_file( "list", 0444, pc202gpio_priv.debugfs_dir, NULL,
+                               &pc202gpio_debugfs_ops ) )
+    {
+        debugfs_remove( pc202gpio_priv.debugfs_dir );
+        return -ENOMEM;
+    }
+
+    return 0;
+}
+
+static void
+pc202gpio_debugfs_exit( void )
+{
+    debugfs_remove_recursive( pc202gpio_priv.debugfs_dir );
+}
+#endif /* CONFIG_DEBUG_FS */
+
+static int
+pc202gpio_ioctl( struct inode *inode,
+                 struct file *filp,
+                 unsigned int cmd,
+                 unsigned long arg )
+{
+    int ret;
+    struct pc202gpio_pin_allocation *pin;
+    picogpio_op_t op;
+    picogpio_analogue_config_t dac_cfg;
+
+    if ( _IOC_TYPE( cmd ) != PICOGPIO_IOCTL_BASE )
+    {
+        printk( KERN_DEBUG "pc202gpio: invalid command type\n" );
+        return -ENOTTY;
+    }
+
+    if ( _IOC_NR( cmd ) >
+            ( PICOGPIO_IOCTL_START + PICOGPIO_IOCTL_NUM_IOCTL ) ||
+         _IOC_NR( cmd ) < ( PICOGPIO_IOCTL_START ) )
+    {
+        printk( KERN_DEBUG "pc202gpio: invalid command\n" );
+        return -ENOTTY;
+    }
+
+    if ( cmd != PICOGPIO_ANALOGUE_CONFIG )
+        ret = copy_from_user( &op, ( void __user * )arg, sizeof( op ) );
+    else
+        ret = copy_from_user( &dac_cfg, ( void __user * )arg,
+                              sizeof( dac_cfg ) );
+
+    if ( ret )
+    {
+        printk( KERN_DEBUG "pc202gpio: failed to copy structure\n" );
+        return -EFAULT;
+    }
+
+    switch ( cmd )
+    {
+        case PICOGPIO_ACQUIRE:
+            ret = gpio_request( op.pin, "ioctl" );
+            break;
+
+        case PICOGPIO_RELEASE:
+            gpio_free( op.pin );
+            ret = 0;
+            break;
+
+        case PICOGPIO_SET_DIRECTION:
+            if ( PICOGPIO_INPUT == op.value )
+                ret = gpio_direction_input( op.pin );
+            else if ( PICOGPIO_OUTPUT == op.value )
+                ret = gpio_direction_output( op.pin, 0 );
+            else
+                ret = -EINVAL;
+            break;
+
+        case PICOGPIO_GET_DIRECTION:
+            pin = pc202gpio_find_pin( op.pin );
+            if ( pin )
+            {
+                op.value = pin->is_input ? PICOGPIO_INPUT : PICOGPIO_OUTPUT;
+                ret = copy_to_user( ( void __user * )arg, &op, sizeof( op ) );
+            }
+            break;
+
+        case PICOGPIO_SET_VALUE:
+            ret = gpio_set_value( op.pin, op.value );
+            break;
+
+        case PICOGPIO_GET_VALUE:
+            ret = gpio_get_value( op.pin );
+            if ( ret >= 0 )
+            {
+                op.value = ret;
+                ret = copy_to_user( ( void __user * )arg, &op, sizeof( op ) );
+            }
+            break;
+
+        case PICOGPIO_ANALOGUE_CONFIG:
+            ret = pc202gpio_configure_dac( dac_cfg.pin,
+                                           dac_cfg.converter_size,
+                                           dac_cfg.analogue_rate );
+            break;
+
+        default:
+            printk( KERN_DEBUG "pc202gpio: invalid ioctl(), cmd=%d\n", cmd );
+            ret = -EINVAL;
+            break;
+    }
+
+    return ret;
+}
+
+static int
+pc202gpio_open( struct inode *inode,
+                struct file *filp )
+{
+    return 0;
+}
+
+static int
+pc202gpio_release( struct inode *inode,
+                   struct file *filp )
+{
+    return 0;
+}
+
+static int pc202gpio_probe( struct platform_device *pdev );
+static int pc202gpio_remove( struct platform_device *pdev );
+
+static struct platform_driver pc202gpio_driver = {
+    .probe = pc202gpio_probe,
+    .remove = pc202gpio_remove,
+    .driver = {
+        .name = CARDNAME,
+    },
+};
+
+static int
+pc202gpio_probe( struct platform_device *pdev )
+{
+    int ret;
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+
+    if ( !mem )
+        return -EINVAL;
+
+    pc202gpio_priv.pdev = pdev;
+    pc202gpio_priv.pdrv = &pc202gpio_driver;
+
+    if ( !request_mem_region( mem->start, ( mem->end - mem->start ) + 1,
+                              CARDNAME ) )
+        return -EBUSY;
+
+    pc202gpio_priv.mem_region =
+        ioremap( mem->start, ( mem->end - mem->start ) + 1 );
+
+    if ( !pc202gpio_priv.mem_region )
+    {
+        ret = -EBUSY;
+        goto remap_failed;
+    }
+
+    ret = misc_register( &pc202gpio_priv.dev );
+
+    return ret;
+
+remap_failed:
+    release_mem_region( mem->start, ( mem->end - mem->start ) + 1 );
+
+    printk( KERN_ERR "PC202 GPIO driver registration failed\n" );
+
+    return ret;
+}
+
+static int
+pc202gpio_remove( struct platform_device *pdev )
+{
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+
+    misc_deregister( &pc202gpio_priv.dev );
+    iounmap( pc202gpio_priv.mem_region );
+    release_mem_region( mem->start, ( mem->end - mem->start ) + 1 );
+
+    return 0;
+}
+
+static int
+pc202gpio_init( void )
+{
+    int ret = -EINVAL;
+
+    u16 data = PC202_AHB2PICO_WAKE_UP;
+
+#ifdef CONFIG_CONFIGFS_FS
+    config_group_init( &pc202gpio_subsys.su_group );
+    mutex_init( &pc202gpio_subsys.su_mutex );
+    configfs_register_subsystem( &pc202gpio_subsys );
+#endif /* CONFIG_CONFIGFS_FS */
+
+#ifdef CONFIG_DEBUG_FS
+    pc202gpio_debugfs_init();
+#endif /* CONFIG_DEBUG_FS */
+
+    /* This driver can use the sdgpio, therefore before we do anything
+     * else we need to wake up the AHB2PICO block. */
+    ret = picoif_config_write( 0, PC202_AHB2PICO_CAEID,
+                               PC202_AHB2PICO_SLEEP_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to wake up the AHB2PICO block.\n");
+    }
+
+    ret = platform_driver_register( &pc202gpio_driver );
+    if ( 0 != ret )
+    {
+        printk(KERN_ERR "%s " CONFIG_LOCALVERSION " " __DATE__ " "  __TIME__
+               " failed to load\n", TITLE);
+        return ret;
+    }
+
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " " __DATE__ " "  __TIME__
+           " loaded\n", TITLE);
+    return 0;
+}
+
+static void
+pc202gpio_exit( void )
+{
+#ifdef CONFIG_CONFIGFS_FS
+    configfs_unregister_subsystem( &pc202gpio_subsys );
+#endif /* CONFIG_CONFIGFS_FS */
+
+#ifdef CONFIG_DEBUG_FS
+    pc202gpio_debugfs_exit();
+#endif /* CONFIG_DEBUGFS */
+
+    platform_driver_unregister( &pc202gpio_driver );
+    
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " " __DATE__ " "  __TIME__
+           " unloaded\n", TITLE);    
+}
+
+module_init( pc202gpio_init );
+module_exit( pc202gpio_exit );
+
+MODULE_AUTHOR( "picoChip" );
+MODULE_LICENSE( "GPL" );
+MODULE_DESCRIPTION( "picoChip PC202 GPIO driver" );
diff --git a/drivers/misc/pc302fracn.c b/drivers/misc/pc302fracn.c
new file mode 100644
index 0000000..1c5eced
--- /dev/null
+++ b/drivers/misc/pc302fracn.c
@@ -0,0 +1,615 @@
+/**
+ * \file pc302fracn.h
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright 2008 picoChip Designs LTD, All Rights Reserved.
+ * http://www.picochip.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This file implements a driver for configuring the Fractional-N synthesizer
+ * in the picoChip PC302 device.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/sysfs.h>
+#include <linux/device.h>
+#include <linux/picochip/picoif.h>
+#include <linux/gpio.h>
+#include <mach/pc302fracn.h>
+#include <mach/gpio.h>
+#include <mach/pc302/pc302.h>
+#include <mach/pc302/axi2cfg.h>
+
+/* CAEID of the Frac-N synth. */
+#define FRACN_CAEID             ( 0x0578 )
+#define FRACN_M_N_REG_OFFSET    ( 0x000A )  /* M&N register offset. */
+#define FRACN_K_LOW_REG_OFFSET  ( 0x000B )  /* K[15:0] register offset. */
+#define FRACN_K_HI_REG_OFFSET   ( 0x000C )  /* K[31:16] register offset. */
+#define FRACN_CTRL_REG_OFFSET   ( 0x000D )  /* Control register offset. */
+#define FRACN_LL_REG_OFFSET     ( 0x000E )  /* Lower limit register offset. */
+#define FRACN_UL_REG_OFFSET     ( 0x000F )  /* Upper limit register offset. */
+#define FRACN_STATUS_REG_OFFSET ( 0x0010 )  /* Status register offset. */
+
+/* Offset and mask for the M value in the M&N register. */
+#define FRACN_M_OFFSET          ( 8 )
+#define FRACN_M_MASK            ( 0xFF << FRACN_M_OFFSET )
+
+/* Offset and mask for the N value in the M&N register. */
+#define FRACN_N_OFFSET          ( 0 )
+#define FRACN_N_MASK            ( 0xFF << FRACN_N_OFFSET )
+
+/* Mask for the pulse width in the upper and lower limit registers. */
+#define FRACN_CV_PULSE_WIDTH_MASK   ( 0x7FF )
+
+/* Offset and mask for the load instruction bit in the control register. */
+#define FRACN_LOAD_OFFSET       ( 0 )
+#define FRACN_LOAD_MASK         ( 1 << FRACN_LOAD_OFFSET )
+
+/* Offset and mask for the reset instruction bit in the control register. */
+#define FRACN_RESET_OFFSET       ( 2 )
+#define FRACN_RESET_MASK         ( 1 << FRACN_RESET_OFFSET )
+
+/**
+ * The miscdevice for the driver. We don't need a device node but this
+ * provides the driver setup to allow us to use sysfs with minimal overhead.
+ */
+static struct miscdevice fracn_mdev = {
+    .minor  = MISC_DYNAMIC_MINOR,
+    .name   = "pc302fracn",
+};
+
+/**
+ * Read a register from the Frac-N over the config bus.
+ *
+ * \param reg_num The register to read.
+ * \param val Pointer to the result variable.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+fracn_read_reg( u16 reg_num,
+                u16 *val )
+{
+    int ret = picoif_config_read( 0, FRACN_CAEID, reg_num, 1, val );
+    return ( 1 == ret ) ? 0 : -EIO;
+}
+
+/**
+ * Write a register in the Frac-N via the config bus.
+ *
+ * \param reg_num The register to write to.
+ * \param mask Mask of the bits to write.
+ * \param val The value to write to the masked bits.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+fracn_write_reg( u16 reg_num,
+                 u16 mask,
+                 u16 val )
+{
+    u16 tmp;
+    int ret = picoif_config_read( 0, FRACN_CAEID, reg_num, 1, &tmp );
+    if ( 1 != ret )
+        return -EIO;
+    tmp &= ~mask;
+    tmp |= ( val & mask );
+    ret = picoif_config_write( 0, FRACN_CAEID, reg_num, 1, &tmp );
+
+    return ( 1 == ret ) ? 0 : -EIO;
+}
+
+/* Get M. */
+static int
+fracn_get_m( u8 *val )
+{
+    u16 tmp;
+    if ( fracn_read_reg( FRACN_M_N_REG_OFFSET, &tmp ) )
+        return -EIO;
+    *val = ( tmp & FRACN_M_MASK ) >> FRACN_M_OFFSET;
+    return 0;
+}
+EXPORT_SYMBOL( fracn_get_m );
+
+/* Set M. */
+static int
+fracn_set_m( u8 val )
+{
+    return fracn_write_reg( FRACN_M_N_REG_OFFSET, FRACN_M_MASK,
+                            val << FRACN_M_OFFSET );
+}
+EXPORT_SYMBOL( fracn_set_m );
+
+/* Get N. */
+static int
+fracn_get_n( u8 *val )
+{
+    u16 tmp;
+    if ( fracn_read_reg( FRACN_M_N_REG_OFFSET, &tmp ) )
+        return -EIO;
+    *val = ( tmp & FRACN_N_MASK ) >> FRACN_N_OFFSET;
+    return 0;
+}
+EXPORT_SYMBOL( fracn_get_n );
+
+/* Set N. */
+static int
+fracn_set_n( u8 val )
+{
+    return fracn_write_reg( FRACN_M_N_REG_OFFSET, FRACN_N_MASK,
+                            val << FRACN_N_OFFSET );
+}
+EXPORT_SYMBOL( fracn_set_n );
+
+/* Get K. */
+static int
+fracn_get_k( u32 *val )
+{
+    u16 k_low;
+    u16 k_high;
+
+    if ( fracn_read_reg( FRACN_K_LOW_REG_OFFSET, &k_low ) )
+        return -EIO;
+    if ( fracn_read_reg( FRACN_K_HI_REG_OFFSET, &k_high ) )
+        return -EIO;
+
+    *val = k_high << 16 | k_low;
+
+    return 0;
+}
+EXPORT_SYMBOL( fracn_get_k );
+
+/* Set K. */
+static int
+fracn_set_k( u32 val )
+{
+    u16 k_high = ( val >> 16 ) & 0xFFFF;
+    u16 k_low = val & 0xFFFF;
+
+    if ( fracn_write_reg( FRACN_K_HI_REG_OFFSET, 0xFFFF, k_high ) )
+        return -EIO;
+
+    if ( fracn_write_reg( FRACN_K_LOW_REG_OFFSET, 0xFFFF, k_low ) )
+        return -EIO;
+
+    return 0;
+}
+EXPORT_SYMBOL( fracn_set_k );
+
+/* Get the control voltage pulse lower limit. */
+static int
+fracn_get_cv_pulse_ll( u16 *val )
+{
+    if ( fracn_read_reg( FRACN_LL_REG_OFFSET, val ) )
+        return -EIO;
+    *val &= FRACN_CV_PULSE_WIDTH_MASK;
+    return 0;
+}
+EXPORT_SYMBOL( fracn_get_cv_pulse_ll );
+
+#define FRACN_CV_PULSE_LL_MAX   ( 0x7FF )
+
+/* Set the control voltage pulse lower limit. */
+static int
+fracn_set_cv_pulse_ll( u16 val )
+{
+    if ( val > FRACN_CV_PULSE_LL_MAX )
+        return -EINVAL;
+
+    return fracn_write_reg( FRACN_UL_REG_OFFSET,
+                            FRACN_CV_PULSE_WIDTH_MASK, val );
+}
+EXPORT_SYMBOL( fracn_set_cv_pulse_ll );
+
+/* Get the control voltage pulse upper limit. */
+static int
+fracn_get_cv_pulse_ul( u16 *val )
+{
+    if ( fracn_read_reg( FRACN_UL_REG_OFFSET, val ) )
+        return -EIO;
+    *val &= FRACN_CV_PULSE_WIDTH_MASK;
+    return 0;
+}
+EXPORT_SYMBOL( fracn_get_cv_pulse_ul );
+
+#define FRACN_CV_PULSE_UL_MAX   ( 0x7FF )
+
+/* Set the control voltage pulse upper limit. */
+static int
+fracn_set_cv_pulse_ul( u16 val )
+{
+    if ( val > FRACN_CV_PULSE_UL_MAX )
+        return -EINVAL;
+
+    return fracn_write_reg( FRACN_UL_REG_OFFSET,
+                            FRACN_CV_PULSE_WIDTH_MASK, val );
+}
+EXPORT_SYMBOL( fracn_set_cv_pulse_ul );
+
+/* Get the status register value. */
+static int
+fracn_get_status( u16 *val )
+{
+    if ( fracn_read_reg( FRACN_STATUS_REG_OFFSET, val ) )
+        return -EIO;
+    return 0;
+}
+EXPORT_SYMBOL( fracn_get_status );
+
+/* Reset the Frac-N synth. */
+static int
+fracn_reset( void )
+{
+    return fracn_write_reg( FRACN_CTRL_REG_OFFSET, FRACN_RESET_MASK,
+                            1 << FRACN_RESET_OFFSET );
+}
+EXPORT_SYMBOL( fracn_reset );
+
+/* Load the Frac-N with the new M, N and K values. */
+static int
+fracn_load( void )
+{
+    int ret = fracn_write_reg( FRACN_CTRL_REG_OFFSET, FRACN_LOAD_MASK,
+                               1 << FRACN_LOAD_OFFSET );
+    if ( ret )
+        goto out;
+
+    ret = fracn_write_reg( FRACN_CTRL_REG_OFFSET, FRACN_LOAD_MASK,
+                           0 << FRACN_LOAD_OFFSET );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( fracn_load );
+
+/* Show the current value of M. */
+static ssize_t
+fracn_sysfs_show_m( struct device *dev,
+                    struct device_attribute *attr,
+                    char *buf )
+{
+    u8 m;
+    int ret = fracn_get_m( &m );
+    if ( ret )
+        return ret;
+
+    return sprintf( buf, "%u\n", m );
+}
+
+/* Store a new value of M. */
+static ssize_t
+fracn_sysfs_store_m( struct device *dev,
+                     struct device_attribute *attr,
+                     const char *buf,
+                     size_t count )
+{
+    int ret = fracn_set_m( simple_strtoul( buf, NULL, 0 ) );
+    return ( !ret ) ? count : ret;
+}
+DEVICE_ATTR( m, 0644, fracn_sysfs_show_m, fracn_sysfs_store_m );
+
+/* Show the current value of N. */
+static ssize_t
+fracn_sysfs_show_n( struct device *dev,
+                    struct device_attribute *attr,
+                    char *buf )
+{
+    u8 n;
+    int ret = fracn_get_n( &n );
+    if ( ret )
+        return ret;
+
+    return sprintf( buf, "%u\n", n );
+}
+
+/* Store a new value of N. */
+static ssize_t
+fracn_sysfs_store_n( struct device *dev,
+                     struct device_attribute *attr,
+                     const char *buf,
+                     size_t count )
+{
+    int ret = fracn_set_n( simple_strtoul( buf, NULL, 0 ) );
+    return ( !ret ) ? count : ret;
+}
+DEVICE_ATTR( n, 0644, fracn_sysfs_show_n, fracn_sysfs_store_n );
+
+/* Show the current value of K. */
+static ssize_t
+fracn_sysfs_show_k( struct device *dev,
+                    struct device_attribute *attr,
+                    char *buf )
+{
+    u32 k;
+    int ret = fracn_get_k( &k );
+    if ( ret )
+        return ret;
+
+    return sprintf( buf, "%u\n", k );
+}
+
+/* Store a new value of K. */
+static ssize_t
+fracn_sysfs_store_k( struct device *dev,
+                     struct device_attribute *attr,
+                     const char *buf,
+                     size_t count )
+{
+    int ret = fracn_set_k( simple_strtoul( buf, NULL, 0 ) );
+    return ( !ret ) ? count : ret;
+}
+DEVICE_ATTR( k, 0644, fracn_sysfs_show_k, fracn_sysfs_store_k );
+
+/* Show the current control voltage pulse lower limit. */
+static ssize_t
+fracn_sysfs_show_cv_pulse_ll( struct device *dev,
+                              struct device_attribute *attr,
+                              char *buf )
+{
+    u16 cv_pulse_ll;
+    int ret = fracn_get_cv_pulse_ll( &cv_pulse_ll );
+    if ( ret )
+        return ret;
+
+    return sprintf( buf, "%u\n", cv_pulse_ll );
+}
+
+/* Store a new current control voltage pulse lower limit. */
+static ssize_t
+fracn_sysfs_store_cv_pulse_ll( struct device *dev,
+                               struct device_attribute *attr,
+                               const char *buf,
+                               size_t count )
+{
+    int ret = fracn_set_cv_pulse_ll( simple_strtoul( buf, NULL, 0 ) );
+    return ( !ret ) ? count : ret;
+}
+DEVICE_ATTR( cv_pulse_ll, 0644, fracn_sysfs_show_cv_pulse_ll,
+             fracn_sysfs_store_cv_pulse_ll );
+
+/* Show the current control voltage pulse upper limit. */
+static ssize_t
+fracn_sysfs_show_cv_pulse_ul( struct device *dev,
+                              struct device_attribute *attr,
+                              char *buf )
+{
+    u16 cv_pulse_ul;
+    int ret = fracn_get_cv_pulse_ul( &cv_pulse_ul );
+    if ( ret )
+        return ret;
+
+    return sprintf( buf, "%u\n", cv_pulse_ul );
+}
+
+/* Store a new current control voltage pulse upper limit. */
+static ssize_t
+fracn_sysfs_store_cv_pulse_ul( struct device *dev,
+                               struct device_attribute *attr,
+                               const char *buf,
+                               size_t count )
+{
+    int ret = fracn_set_cv_pulse_ul( simple_strtoul( buf, NULL, 0 ) );
+    return ( !ret ) ? count : ret;
+}
+DEVICE_ATTR( cv_pulse_ul, 0644, fracn_sysfs_show_cv_pulse_ul,
+             fracn_sysfs_store_cv_pulse_ul );
+
+/* Show whether the VCXO is running fast or not. */
+static ssize_t
+fracn_sysfs_show_running_fast( struct device *dev,
+                               struct device_attribute *attr,
+                               char *buf )
+{
+    u16 status;
+    int ret = fracn_get_status( &status );
+    int running_fast;
+    if ( ret )
+        return ret;
+
+    running_fast =
+        ( status & FRACN_RUNNING_FAST_MASK ) >> FRACN_RUNNING_FAST_OFFSET;
+
+    return sprintf( buf, "%u\n", running_fast );
+}
+DEVICE_ATTR( running_fast, 0444, fracn_sysfs_show_running_fast, NULL );
+
+/* Show whether the VCXO is running slow or not. */
+static ssize_t
+fracn_sysfs_show_running_slow( struct device *dev,
+                               struct device_attribute *attr,
+                               char *buf )
+{
+    u16 status;
+    int ret = fracn_get_status( &status );
+    int running_slow;
+    if ( ret )
+        return ret;
+
+    running_slow =
+        ( status & FRACN_RUNNING_SLOW_MASK ) >> FRACN_RUNNING_SLOW_OFFSET;
+
+    return sprintf( buf, "%u\n", running_slow );
+}
+DEVICE_ATTR( running_slow, 0444, fracn_sysfs_show_running_slow, NULL );
+
+/* Show the current control voltage pulse width. */
+static ssize_t
+fracn_sysfs_show_ctrl_v_pulse_width( struct device *dev,
+                                     struct device_attribute *attr,
+                                     char *buf )
+{
+    u16 status;
+    int ret = fracn_get_status( &status );
+    int pulse_width;
+    if ( ret )
+        return ret;
+
+    pulse_width = ( status & FRACN_CTRL_V_PULSE_WIDTH_MASK ) >>
+                    FRACN_CTRL_V_PULSE_WIDTH_OFFSET;
+
+    return sprintf( buf, "%u\n", pulse_width );
+}
+DEVICE_ATTR( ctrl_v_pulse_width, 0444, fracn_sysfs_show_ctrl_v_pulse_width,
+             NULL );
+
+/* Show the current control voltage under limit. */
+static ssize_t
+fracn_sysfs_show_ctrl_v_under_limit( struct device *dev,
+                                     struct device_attribute *attr,
+                                     char *buf )
+{
+    u16 status;
+    int ret = fracn_get_status( &status );
+    int under_limit;
+    if ( ret )
+        return ret;
+
+    under_limit = ( status & FRACN_CTRL_V_UNDER_LIMIT_MASK ) >>
+                    FRACN_CTRL_V_UNDER_LIMIT_OFFSET;
+
+    return sprintf( buf, "%u\n", under_limit );
+}
+DEVICE_ATTR( ctrl_v_under_limit, 0444, fracn_sysfs_show_ctrl_v_under_limit,
+             NULL );
+
+/* Show the current control voltage over limit. */
+static ssize_t
+fracn_sysfs_show_ctrl_v_over_limit( struct device *dev,
+                                    struct device_attribute *attr,
+                                    char *buf )
+{
+    u16 status;
+    int ret = fracn_get_status( &status );
+    int over_limit;
+    if ( ret )
+        return ret;
+
+    over_limit = ( status & FRACN_CTRL_V_OVER_LIMIT_MASK ) >>
+                    FRACN_CTRL_V_OVER_LIMIT_OFFSET;
+
+    return sprintf( buf, "%u\n", over_limit );
+}
+DEVICE_ATTR( ctrl_v_over_limit, 0444, fracn_sysfs_show_ctrl_v_over_limit,
+             NULL );
+
+/* Show whether the synth is locked or not (1 == synth not locked). */
+static ssize_t
+fracn_sysfs_show_not_locked( struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf )
+{
+    u16 status;
+    int ret = fracn_get_status( &status );
+    int not_locked;
+    if ( ret )
+        return ret;
+
+    not_locked = ( status & FRACN_NOT_LOCKED_MASK ) >>
+                    FRACN_NOT_LOCKED_OFFSET;
+
+    return sprintf( buf, "%u\n", not_locked );
+}
+DEVICE_ATTR( not_locked, 0444, fracn_sysfs_show_not_locked,
+             NULL );
+
+/* Reset the synth. Writing any value will trigger a reset. */
+static ssize_t
+fracn_sysfs_store_reset( struct device *dev,
+                         struct device_attribute *attr,
+                         const char *buf,
+                         size_t count )
+{
+    int ret = fracn_reset();
+    return ( !ret ) ? count : ret;
+}
+DEVICE_ATTR( reset, 0200, NULL, fracn_sysfs_store_reset );
+
+/* Load the new values of M, N and K into the synth. */
+static ssize_t
+fracn_sysfs_store_load( struct device *dev,
+                        struct device_attribute *attr,
+                        const char *buf,
+                        size_t count )
+{
+    int ret = fracn_load();
+    return ( !ret ) ? count : ret;
+}
+DEVICE_ATTR( load, 0200, NULL, fracn_sysfs_store_load );
+
+/* The attributes to export via sysfs. */
+static struct attribute *fracn_attrs[] = {
+    &dev_attr_m.attr,
+    &dev_attr_n.attr,
+    &dev_attr_k.attr,
+    &dev_attr_cv_pulse_ll.attr,
+    &dev_attr_cv_pulse_ul.attr,
+    &dev_attr_running_fast.attr,
+    &dev_attr_running_slow.attr,
+    &dev_attr_ctrl_v_pulse_width.attr,
+    &dev_attr_ctrl_v_under_limit.attr,
+    &dev_attr_ctrl_v_over_limit.attr,
+    &dev_attr_not_locked.attr,
+    &dev_attr_reset.attr,
+    &dev_attr_load.attr,
+    NULL,
+};
+
+/* Create an attribute group to add and remove. */
+static struct attribute_group fracn_attr_group = {
+    .attrs = fracn_attrs,
+};
+
+static int
+fracn_init( void )
+{
+    int ret = misc_register( &fracn_mdev );
+    u16 val = 0;
+    if ( ret )
+        return ret;
+
+    ret = sysfs_create_group( &fracn_mdev.this_device->kobj,
+                              &fracn_attr_group );
+    if ( ret )
+        goto sysfs_fail;
+
+    /* Wake the Frac-N up. */
+    if (1 != picoif_config_write(0, FRACN_CAEID, 0xA060, 1, &val))
+        goto sysfs_fail;
+
+    if ( gpio_request( PC302_GPIO_PIN_SDGPIO_0, "Frac-N" ) )
+        goto gpio_fail;
+
+    syscfg_update( AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK,
+		   AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK );
+
+    /* Load the Frac-N with the initial default M, N and K values. */
+    (void)fracn_load();
+
+    return ret;
+
+gpio_fail:
+    sysfs_remove_group( &fracn_mdev.this_device->kobj, &fracn_attr_group );
+
+sysfs_fail:
+    misc_deregister( &fracn_mdev );
+
+    return ret;
+}
+
+static void
+fracn_exit( void )
+{
+    gpio_free( PC302_GPIO_PIN_SDGPIO_0 );
+    sysfs_remove_group( &fracn_mdev.this_device->kobj, &fracn_attr_group );
+    misc_deregister( &fracn_mdev );
+}
+
+module_init( fracn_init );
+module_exit( fracn_exit );
+MODULE_LICENSE( "GPL" );
+MODULE_AUTHOR( "Jamie Iles" );
diff --git a/drivers/misc/pc302fuse.c b/drivers/misc/pc302fuse.c
new file mode 100644
index 0000000..cc4422f
--- /dev/null
+++ b/drivers/misc/pc302fuse.c
@@ -0,0 +1,833 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/pc302fuse.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <mach/hardware.h>
+
+#define PC302_FUSE_MINOR    ( 242 )
+
+/** The constant programming time when blowing a fuse. */
+#define PC302_FUSE_PROGRAM_TIME         ( 20 )
+
+/** The time from raising the programming voltage to delay for before
+ * initiating the programming. */
+#define PC302_FUSE_VDDQ_HIGH_DEL_DFL    ( 10 )
+
+/** The time from stopping programming until VDDQ goes low. This is only used
+ * in estimating the VDDQ time. */
+#define PC302_FUSE_VDDQ_LOW_DEL_DFL     ( 10 )
+
+#define CARDNAME    "pc302-fuse"
+
+static int test_mode;
+module_param( test_mode, bool, S_IRUSR );
+
+static unsigned vddq_high_delay = PC302_FUSE_VDDQ_HIGH_DEL_DFL;
+module_param( vddq_high_delay, uint, S_IRUSR );
+
+static unsigned vddq_low_delay = PC302_FUSE_VDDQ_LOW_DEL_DFL;
+module_param( vddq_low_delay, uint, S_IRUSR );
+
+static int pc302fuse_open( struct inode *inode,
+                           struct file *filp );
+
+static int pc302fuse_release( struct inode *inode,
+                              struct file *filp );
+
+static int pc302fuse_ioctl( struct inode *inode,
+                            struct file *filp,
+                            unsigned int cmd,
+                            unsigned long arg );
+
+static int pc302fuse_get_vddq( u32 *t );
+
+/**
+ * The file operations for the fuse driver.
+ */
+static const struct file_operations pc302fuse_fops = {
+    .open = pc302fuse_open,
+    .release = pc302fuse_release,
+    .ioctl = pc302fuse_ioctl,
+};
+
+/**
+ * Operation modes for the driver.
+ */
+typedef enum
+{
+    PC302_FUSE_OP_MODE_NORMAL = 0,  /*< Normal operation mode on hardware. */
+    PC302_FUSE_OP_MODE_TEST,        /*< Software test mode. */
+
+} pc302fuse_op_mode;
+
+static struct 
+{
+    /**
+     * The current operation mode. Used to select between real fuse
+     * operations and a test mode for debugging.
+     */
+    pc302fuse_op_mode op_mode;
+
+    /**
+     * The character device used for ioctl() calls to read and blow fuses.
+     */
+    struct miscdevice dev;
+
+    /**
+     * The platform device that this driver interfaces to.
+     */
+    struct platform_device *pdev;
+
+    /**
+     * The platform driver that this device interfaces to.
+     */
+    struct platform_driver *pdrv;
+
+    /**
+     * Boolean flag for signalling the completion of device registration.
+     */
+    int registered;
+
+    /**
+     * The memory that has been mapped for the fuses. This is a union to allow
+     * using real hardware memory or a software buffer.
+     */
+    union
+    {
+        /**
+         * The hardware memory of the fuse shadow map. This field is only used
+         * if op_mode is set to PC302_FUSE_OP_MODE_NORMAL.
+         */
+        void __iomem *hw;
+
+        /**
+         * The software memory that is used for testing the fuse driver. This
+         * field is only used if op_mode is set to PC302_FUSE_OP_MODE_TEST.
+         */
+        void *sw;
+
+    } mem_region;
+
+    spinlock_t hw_lock;
+
+} pc302fuse_int = {
+
+    .op_mode = PC302_FUSE_OP_MODE_TEST,
+
+    .dev = {
+        .minor = PC302_FUSE_MINOR,
+        .name = "picofuse",
+        .fops = &pc302fuse_fops,
+    },
+
+    .pdev = NULL,
+
+    .pdrv = NULL,
+
+    .registered = 0,
+
+    .mem_region.sw = NULL,
+
+    .hw_lock = __SPIN_LOCK_UNLOCKED( pc302fuse_hw_lock ),
+};
+
+/**
+ * Read the value of a fuse.
+ *
+ * \param indx The fuse number to read from.
+ * \return Returns 1 if blown, 0 if not blown, negative on error.
+ */
+static int pc302fuse_read_fuse( unsigned indx );
+
+/**
+ * Blow a fuse.
+ *
+ * \param indx The index of the fuse to blow.
+ * \return Returns 0 on success, non-zero on failure.
+ */
+static int pc302fuse_blow( unsigned indx );
+
+static int
+pc302fuse_read_byte( int indx )
+{
+    u8 val;
+
+    if ( test_mode )
+        val = ( ( u8 * )pc302fuse_int.mem_region.sw )[ indx / 8 ];
+    else
+        val = ioread8( pc302fuse_int.mem_region.hw + ( indx / 8 ) );
+
+    return val;
+}
+
+static ssize_t
+pc302fuse_print_range( char *buf, struct fuse_range_t range )
+{
+    int num_bytes = ( ( range.end - range.start ) + 1 ) / 8;
+    char *pos = buf;
+    int i;
+    int val;
+
+    WARN_ON( ( ( range.end - range.start ) + 1 ) % 8 );
+    WARN_ON( range.start % 8 );
+
+    for ( i = 0; i < num_bytes; ++i )
+    {
+        val = pc302fuse_read_byte( range.start + ( i * 8 ) );
+        sprintf( pos, "%02x", val );
+        pos += 2;
+    }
+
+    sprintf( pos, "\n" );
+    ++pos;
+
+    return pos - buf;
+}
+
+static ssize_t
+pc302fuse_sysfs_fb_show( struct device *dev,
+                               struct device_attribute *attr,
+                               char *buf )
+{
+    const char *name = attr->attr.name;
+    int val;
+
+    if ( !strcmp( name, "secure_boot" ) )
+        val = pc302fuse_read_fuse( PC302_FB_SECURE_BOOT );
+    else if ( !strcmp( name, "disable_trustzone" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DISABLE_TRUSTZONE );
+    else if ( !strcmp( name, "global_last_time_program" ) )
+        val = pc302fuse_read_fuse( PC302_FB_GLOBAL_LAST_TIME_PROGRAM );
+    else if ( !strcmp( name, "disable_debug" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DISABLE_DEBUG );
+    else if ( !strcmp( name, "disable_isc" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DISABLE_ISC );
+    else if ( !strcmp( name, "disable_jtag" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DISABLE_JTAG );
+    else if ( !strcmp( name, "disable_invasive_debug_in_secure" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DISABLE_INVASIVE_DEBUG_IN_SECURE );
+    else if ( !strcmp( name, "disable_non_invasive_debug_in_secure" ) )
+        val = pc302fuse_read_fuse(
+                PC302_FB_DISABLE_NON_INVASIVE_DEBUG_IN_SECURE );
+    else if ( !strcmp( name, "disable_cp15_register" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DISABLE_CP15_REGISTER );
+    else if ( !strcmp( name, "disable_memif_arm" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DUAL_SINGLE_MEMIF );
+    else if ( !strcmp( name, "disable_non_secure_parallel_flash" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DISABLE_NON_SECURE_PARALLEL_FLASH );
+    else if ( !strcmp( name, "key0_read_once_per_boot" ) )
+        val = pc302fuse_read_fuse( PC302_FB_SECURE_BOOTSTRAP_ROPB );
+    else if ( !strcmp( name, "key0_last_time_program" ) )
+        val = pc302fuse_read_fuse( PC302_FB_SECURE_BOOTSTRAP_LTP );
+    else if ( !strcmp( name, "key0_disable_jtag" ) )
+        val = pc302fuse_read_fuse( PC302_FB_SECURE_BOOTSTRAP_DJRK );
+    else if ( !strcmp( name, "counter_iv_read_once_per_boot" ) )
+        val = pc302fuse_read_fuse( PC302_FB_COUNTER_IV_ROPB );
+    else if ( !strcmp( name, "counter_iv_last_time_program" ) )
+        val = pc302fuse_read_fuse( PC302_FB_COUNTER_IV_LTP );
+    else if ( !strcmp( name, "counter_iv_disable_jtag" ) )
+        val = pc302fuse_read_fuse( PC302_FB_COUNTER_IV_DJRK );
+    else if ( !strcmp( name, "key2_read_once_per_boot" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY2_ROPB );
+    else if ( !strcmp( name, "key2_last_time_program" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY2_LTP );
+    else if ( !strcmp( name, "key2_disable_jtag" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY2_DJRK );
+    else if ( !strcmp( name, "key3_read_once_per_boot" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY3_ROPB );
+    else if ( !strcmp( name, "key3_last_time_program" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY3_LTP );
+    else if ( !strcmp( name, "key3_disable_jtag" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY3_DJRK );
+    else if ( !strcmp( name, "key4_read_once_per_boot" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY4_ROPB );
+    else if ( !strcmp( name, "key4_last_time_program" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY4_LTP );
+    else if ( !strcmp( name, "key4_disable_jtag" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY4_DJRK );
+    else if ( !strcmp( name, "key5_read_once_per_boot" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY5_ROPB );
+    else if ( !strcmp( name, "key5_last_time_program" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY5_LTP );
+    else if ( !strcmp( name, "key5_disable_jtag" ) )
+        val = pc302fuse_read_fuse( PC302_FB_KEY5_DJRK );
+    else if ( !strcmp( name, "die_ident_read_once_per_boot" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DIE_IDENT_ROPB );
+    else if ( !strcmp( name, "die_ident_last_time_program" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DIE_IDENT_LTP );
+    else if ( !strcmp( name, "die_ident_disable_jtag" ) )
+        val = pc302fuse_read_fuse( PC302_FB_DIE_IDENT_DJRK );
+    else
+        val = -1;
+
+    return sprintf( buf, "%d\n", val );
+}
+
+static ssize_t
+pc302fuse_sysfs_fr_show( struct device *dev,
+                                 struct device_attribute *attr,
+                                 char *buf )
+{
+    const char *name = attr->attr.name;
+    int val;
+    int ret = 0;
+
+    if ( !strcmp( name, "key0" ) )
+        ret = pc302fuse_print_range( buf, PC302_FR_SECURE_BOOTSTRAP );
+    if ( !strcmp( name, "key2" ) )
+        ret = pc302fuse_print_range( buf, PC302_FR_KEY2 );
+    if ( !strcmp( name, "key3" ) )
+        ret = pc302fuse_print_range( buf, PC302_FR_KEY3 );
+    if ( !strcmp( name, "key4" ) )
+        ret = pc302fuse_print_range( buf, PC302_FR_KEY4 );
+    if ( !strcmp( name, "key5" ) )
+        ret = pc302fuse_print_range( buf, PC302_FR_KEY5 );
+    if ( !strcmp( name, "die_ident" ) )
+        ret = pc302fuse_print_range( buf, PC302_FR_DIE_IDENT );
+    if ( !strcmp( name, "counter_iv" ) )
+        ret = pc302fuse_print_range( buf, PC302_FR_COUNTER_IV );
+    else
+        val = -1;
+
+    return ret;
+}
+
+static DEVICE_ATTR( secure_boot, S_IRUSR,pc302fuse_sysfs_fb_show, NULL );
+static DEVICE_ATTR( disable_trustzone, S_IRUSR,pc302fuse_sysfs_fb_show, NULL );
+static DEVICE_ATTR( global_last_time_program, S_IRUSR,
+                    pc302fuse_sysfs_fb_show, NULL );
+static DEVICE_ATTR( disable_debug, S_IRUSR,pc302fuse_sysfs_fb_show, NULL );
+static DEVICE_ATTR( disable_isc, S_IRUSR,pc302fuse_sysfs_fb_show, NULL );
+static DEVICE_ATTR( disable_jtag, S_IRUSR,pc302fuse_sysfs_fb_show, NULL );
+static DEVICE_ATTR( disable_invasive_debug_in_secure, S_IRUSR,
+                    pc302fuse_sysfs_fb_show, NULL );
+static DEVICE_ATTR( disable_non_invasive_debug_in_secure, S_IRUSR,
+                    pc302fuse_sysfs_fb_show, NULL );
+static DEVICE_ATTR( disable_cp15_register, S_IRUSR,
+                    pc302fuse_sysfs_fb_show, NULL );
+static DEVICE_ATTR( disable_memif_arm, S_IRUSR,pc302fuse_sysfs_fb_show,
+                    NULL );
+static DEVICE_ATTR( disable_non_secure_parallel_flash, S_IRUSR,
+                    pc302fuse_sysfs_fb_show, NULL );
+
+#define PC302_FUSE_SYSFS_PARTITION( _fuse_name ) \
+    static DEVICE_ATTR( _fuse_name, S_IRUSR, pc302fuse_sysfs_fr_show, NULL ); \
+    static DEVICE_ATTR( _fuse_name##_read_once_per_boot, S_IRUSR, \
+                        pc302fuse_sysfs_fb_show, NULL ); \
+    static DEVICE_ATTR( _fuse_name##_last_time_program, S_IRUSR, \
+                        pc302fuse_sysfs_fb_show, NULL ); \
+    static DEVICE_ATTR( _fuse_name##_disable_jtag, S_IRUSR, \
+                        pc302fuse_sysfs_fb_show, NULL )
+
+PC302_FUSE_SYSFS_PARTITION( die_ident );
+PC302_FUSE_SYSFS_PARTITION( key0 );
+PC302_FUSE_SYSFS_PARTITION( counter_iv );
+PC302_FUSE_SYSFS_PARTITION( key2 );
+PC302_FUSE_SYSFS_PARTITION( key3 );
+PC302_FUSE_SYSFS_PARTITION( key4 );
+PC302_FUSE_SYSFS_PARTITION( key5 );
+
+#define PC302_FUSE_SYSFS_PARTITION_ATTRIBUTES( _partition ) \
+    &dev_attr_##_partition.attr, \
+    &dev_attr_##_partition##_read_once_per_boot.attr, \
+    &dev_attr_##_partition##_last_time_program.attr, \
+    &dev_attr_##_partition##_disable_jtag.attr
+
+static struct attribute *pc302fuse_device_attrs[] = {
+    &dev_attr_secure_boot.attr,
+    &dev_attr_disable_trustzone.attr,
+    &dev_attr_global_last_time_program.attr,
+    &dev_attr_disable_debug.attr,
+    &dev_attr_disable_isc.attr,
+    &dev_attr_disable_jtag.attr,
+    &dev_attr_disable_invasive_debug_in_secure.attr,
+    &dev_attr_disable_non_invasive_debug_in_secure.attr,
+    &dev_attr_disable_cp15_register.attr,
+    &dev_attr_disable_memif_arm.attr,
+    &dev_attr_disable_non_secure_parallel_flash.attr,
+    PC302_FUSE_SYSFS_PARTITION_ATTRIBUTES( counter_iv ),
+    PC302_FUSE_SYSFS_PARTITION_ATTRIBUTES( key0 ),
+    PC302_FUSE_SYSFS_PARTITION_ATTRIBUTES( key2 ),
+    PC302_FUSE_SYSFS_PARTITION_ATTRIBUTES( key3 ),
+    PC302_FUSE_SYSFS_PARTITION_ATTRIBUTES( key4 ),
+    PC302_FUSE_SYSFS_PARTITION_ATTRIBUTES( key5 ),
+    PC302_FUSE_SYSFS_PARTITION_ATTRIBUTES( die_ident ),
+    NULL,
+};
+
+static struct attribute_group pc302fuse_device_attr_group = {
+    .name = "fuses",
+    .attrs = pc302fuse_device_attrs,
+};
+
+static ssize_t
+pc302fuse_sysfs_test_mode_show( struct device_driver *dev,
+                                char *buf )
+{
+    return sprintf( buf, "%d\n",
+                    pc302fuse_int.op_mode == PC302_FUSE_OP_MODE_TEST ? 1 : 0 );
+}
+
+static DRIVER_ATTR( test_mode, S_IRUSR, pc302fuse_sysfs_test_mode_show, NULL );
+
+static int
+pc302fuse_sysfs_add( void )
+{
+    int ret;
+
+    /* Create the driver attributes. */
+    ret = driver_create_file( &pc302fuse_int.pdrv->driver,
+                              &driver_attr_test_mode );
+    /* Create the device attributes. */
+    ret = sysfs_create_group( &pc302fuse_int.pdev->dev.kobj,
+                              &pc302fuse_device_attr_group );
+
+    return ret;
+}
+
+static void
+pc302fuse_sysfs_del( void )
+{
+    driver_remove_file( &pc302fuse_int.pdrv->driver,
+                        &driver_attr_test_mode );
+    sysfs_remove_group( &pc302fuse_int.pdev->dev.kobj,
+                        &pc302fuse_device_attr_group );
+}
+
+static int
+pc302fuse_open( struct inode *inode,
+                struct file *filp )
+{
+    return 0;
+}
+
+static int
+pc302fuse_release( struct inode *inode,
+                   struct file *filp )
+{
+    return 0;
+}
+
+static int
+pc302fuse_get_vddq( u32 *t )
+{
+    unsigned i;
+    int ret;
+    unsigned num_blown = 0;
+
+    for ( i = 0; i < PC302_FUSE_NUM_FUSES; ++i )
+    {
+        ret = pc302fuse_read_fuse( i );
+        if ( ret < 0 )
+            break;
+
+        if ( 1 == ret )
+            ++num_blown;
+    }
+
+    *t = num_blown * ( PC302_FUSE_PROGRAM_TIME + vddq_low_delay + 
+                       vddq_high_delay );
+
+    return ( ret >= 0 ) ? 0 : -1;
+}
+
+static int
+pc302fuse_ioctl( struct inode *inode,
+                 struct file *filp,
+                 unsigned int cmd,
+                 unsigned long arg )
+{
+    pcfuse_t fuse_struct;
+    u32 vddq;
+    int ret;
+
+    if ( _IOC_TYPE( cmd ) != PC302_FUSE_IOCTL_BASE )
+    {
+        printk( KERN_DEBUG "pc302fuse: invalid command type\n" );
+        return -ENOTTY;
+    }
+
+    if ( _IOC_NR( cmd ) >
+            ( PC302_FUSE_IOCTL_START + PC302_FUSE_IOCTL_NUM_IOCTL ) ||
+         _IOC_NR( cmd ) < ( PC302_FUSE_IOCTL_START ) )
+    {
+        printk( KERN_DEBUG "pc302fuse: invalid command\n" );
+        return -ENOTTY;
+    }
+
+    ret = copy_from_user( &fuse_struct, ( void __user * )arg,
+                          sizeof( fuse_struct ) );
+
+    if ( ret )
+    {
+        printk( KERN_DEBUG "pc302fuse: failed to copy structure\n" );
+        return -EFAULT;
+    }
+
+    switch ( cmd )
+    {
+        case PC302_FUSE_GET:
+            ret = pc302fuse_read_fuse( fuse_struct.offset );
+            fuse_struct.value = ret;
+            /* If the read was successful, copy the result. */
+            if ( ret >= 0 )
+            {
+                ret = copy_to_user( ( void __user * )arg, &fuse_struct,
+                                    sizeof( fuse_struct ) );
+            }
+            break;
+
+        case PC302_FUSE_BLOW:
+            ret = pc302fuse_blow( fuse_struct.offset );
+            if ( 0 == ret )
+            {
+                fuse_struct.value = 1;
+                ret = copy_to_user( ( void __user * )arg, &fuse_struct,
+                                    sizeof( fuse_struct ) );
+            }
+            break;
+
+        case PC302_FUSE_GET_VDDQ:
+            ret = pc302fuse_get_vddq( &vddq );
+            if ( 0 == ret )
+            {
+                fuse_struct.value = vddq;
+                ret = copy_to_user( ( void __user * )arg, &fuse_struct,
+                                    sizeof( fuse_struct ) );
+            }
+            ret = 0;
+            break;
+
+        default:
+            printk( KERN_DEBUG "pc302fuse: invalid ioctl(), cmd=%d\n", cmd );
+            ret = -EINVAL;
+            break;
+    }
+
+    return ret;
+}
+
+static int
+pc302fuse_read_fuse_tm( unsigned indx )
+{
+    unsigned byte_off = indx / 8;
+    unsigned bit_off = indx % 8;
+    u8 val;
+
+    val = ( ( u8 * )pc302fuse_int.mem_region.sw )[ byte_off ];
+
+    return !!( val & ( 1 << bit_off ) );
+}
+
+static int
+pc302fuse_read_fuse_hw( unsigned indx )
+{
+    unsigned byte_off = indx / 8;
+    unsigned bit_off = indx % 8;
+    u8 byte = ioread8( pc302fuse_int.mem_region.hw + byte_off );
+
+    return !!( byte & ( 1 << bit_off ) );
+}
+
+/** Check if a fuse is in a segment. */
+#define PC302_FUSE_IS_IN_SEGMENT( _seg, _indx ) \
+    (( _indx >= PC302_FR_##_seg.start && _indx <= PC302_FR_##_seg.end ))
+
+/** Check if a fuse in a segment can be blown. */
+#define PC302_SEGMENT_CAN_BLOW( _seg ) \
+    (( 0 == pc302fuse_read_fuse( PC302_FB_##_seg##_ROPB ) && \
+       0 == pc302fuse_read_fuse( PC302_FB_##_seg##_LTP ) ))
+
+static int
+pc302fuse_can_blow( unsigned indx )
+{
+    int ret = 0;
+
+    /* If the global last time program fuse is blown, we certainly can't blow
+     * another fuse. */
+    if ( 1 == pc302fuse_read_fuse( PC302_FB_GLOBAL_LAST_TIME_PROGRAM) )
+        return 0;
+
+    /* Check each segment to see if we are inside it and check the read once
+     * per boot and last time program bits for that segment. */
+
+    if ( PC302_FUSE_IS_IN_SEGMENT( SECURE_BOOTSTRAP, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( SECURE_BOOTSTRAP );
+    else if ( PC302_FUSE_IS_IN_SEGMENT( COUNTER_IV, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( COUNTER_IV );
+    else if ( PC302_FUSE_IS_IN_SEGMENT( KEY2, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( KEY2 );
+    else if ( PC302_FUSE_IS_IN_SEGMENT( KEY3, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( KEY3 );
+    else if ( PC302_FUSE_IS_IN_SEGMENT( KEY4, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( KEY4 );
+    else if ( PC302_FUSE_IS_IN_SEGMENT( KEY5, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( KEY5 );
+    else if ( PC302_FUSE_IS_IN_SEGMENT( DIE_IDENT, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( DIE_IDENT );
+    else if ( PC302_FUSE_IS_IN_SEGMENT( PARTITION_1, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( PARTITION_1 );
+    else if ( PC302_FUSE_IS_IN_SEGMENT( PARTITION_2, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( PARTITION_2 );
+    else if ( PC302_FUSE_IS_IN_SEGMENT( PARTITION_3, indx ) )
+        ret = PC302_SEGMENT_CAN_BLOW( PARTITION_3 );
+    else
+        ret = -EIO;
+
+    return ret;
+}
+
+static int
+pc302fuse_blow_tm( unsigned indx )
+{
+    unsigned byte_off = indx / 8;
+    unsigned bit_off = indx % 8;
+
+    /* Check that the fuse is in range. */
+    if ( indx >= PC302_FUSE_NUM_FUSES )
+        return -EFAULT;
+
+    if ( !pc302fuse_can_blow( indx ) )
+    {
+        printk( KERN_INFO "pc302fuse: cannot blow fuse %d\n", indx );
+        return -EIO;
+    }
+
+    ( ( u8 * )pc302fuse_int.mem_region.sw )[ byte_off ] |= ( 1 << bit_off );
+
+    return 0;
+}
+
+static int
+pc302fuse_blow_hw( unsigned indx )
+{
+    unsigned long flags;
+    u32 ctrl_reg;
+
+    /* Check that the fuse is in range. */
+    if ( indx >= PC302_FUSE_NUM_FUSES )
+        return -EFAULT;
+
+    if ( !pc302fuse_can_blow( indx ) )
+    {
+        printk( KERN_INFO "pc302fuse: cannot blow fuse %d\n", indx );
+        return -EIO;
+    }
+
+    spin_lock_irqsave( &pc302fuse_int.hw_lock, flags );
+
+    /* Make sure that the fuse process is not already active. */
+    do
+    {
+        ctrl_reg =
+            ioread32( pc302fuse_int.mem_region.hw + PC302_FUSE_CTRL_REG );
+    } while ( ctrl_reg & PC302_FUSE_CTRL_WRITE_BUSY );
+
+    iowrite32( indx,
+               pc302fuse_int.mem_region.hw + PC302_FUSE_WR_BIT_ADDRESS_REG );
+
+    /* Set VDDQ high. */
+    iowrite32( PC302_FUSE_WRITE_PAD_EN_VALUE,
+               pc302fuse_int.mem_region.hw + PC302_FUSE_WRITE_PAD_EN_REG );
+    iowrite32( PC302_FUSE_WRITE_PAD_VALUE,
+               pc302fuse_int.mem_region.hw + PC302_FUSE_WRITE_PAD_REG );
+
+    /* Wait for vddq_high_delay to allow VDDQ to raise to the required
+     * voltage. */
+    udelay( vddq_high_delay );
+
+    /* Start the fuse blowing process. */
+    iowrite32( PC302_FUSE_WR_PERFORM_VALUE,
+               pc302fuse_int.mem_region.hw + PC302_FUSE_WR_PERFORM_REG );
+
+    do
+    {
+        ctrl_reg =
+            ioread32( pc302fuse_int.mem_region.hw + PC302_FUSE_CTRL_REG );
+    } while ( ctrl_reg & PC302_FUSE_CTRL_WRITE_BUSY );
+
+    /* Set VDDQ low. */
+    iowrite32( 0, pc302fuse_int.mem_region.hw + PC302_FUSE_WRITE_PAD_REG );
+    iowrite32( 0, pc302fuse_int.mem_region.hw + PC302_FUSE_WRITE_PAD_EN_REG );
+
+    spin_unlock_irqrestore( &pc302fuse_int.hw_lock, flags );
+
+    return 0;
+}
+
+static int
+pc302fuse_read_fuse( unsigned indx )
+{
+    /* Check that the fuse is in range. If the read once per boot bit is set
+     * then the value may be invalid, but it may also have been unset in the
+     * shadow RAM so we have no way of knowing if we can perform the read so
+     * we just do the read anyway. */
+    if ( indx >= PC302_FUSE_NUM_FUSES )
+        return -EFAULT;
+
+    if ( PC302_FUSE_OP_MODE_TEST == pc302fuse_int.op_mode )
+        return pc302fuse_read_fuse_tm( indx );
+    else
+        return pc302fuse_read_fuse_hw( indx );
+}
+
+static int
+pc302fuse_blow( unsigned indx )
+{
+    /* Check that the fuse is in range. If the read once per boot bit is set
+     * then the value may be invalid, but it may also have been unset in the
+     * shadow RAM so we have no way of knowing if we can perform the write so
+     * we just do the write anyway. */
+    if ( indx >= PC302_FUSE_NUM_FUSES )
+        return -EFAULT;
+
+    /* Check that the fuse has not already been blown. */
+    if ( 1 == pc302fuse_read_fuse( indx ) )
+    {
+        printk( KERN_INFO "pc302fuse: fuse already blown (%d)\n", indx );
+        return -EIO;
+    }
+
+    if ( PC302_FUSE_OP_MODE_TEST == pc302fuse_int.op_mode )
+        return pc302fuse_blow_tm( indx );
+    else
+        return pc302fuse_blow_hw( indx );
+}
+
+static int pc302fuse_probe( struct platform_device *pdev );
+static int pc302fuse_remove( struct platform_device *pdev );
+
+static struct platform_driver pc302fuse_driver = {
+    .probe = pc302fuse_probe,
+    .remove = pc302fuse_remove,
+    .driver = {
+        .name = CARDNAME,
+    },
+};
+
+static int
+pc302fuse_probe( struct platform_device *pdev )
+{
+    int ret;
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+
+    if ( !mem )
+        return -EINVAL;
+
+    pc302fuse_int.pdev = pdev;
+    pc302fuse_int.pdrv = &pc302fuse_driver;
+
+    pc302fuse_int.op_mode =
+        test_mode == 1 ? PC302_FUSE_OP_MODE_TEST : PC302_FUSE_OP_MODE_NORMAL;
+
+    if ( test_mode )
+    {
+        pc302fuse_int.mem_region.sw =
+            kzalloc( PC302_FUSE_NUM_FUSES / 8, GFP_KERNEL );
+        if ( !pc302fuse_int.mem_region.sw )
+            return -ENOMEM;
+    }
+    else
+    {
+        if ( !request_mem_region( mem->start, ( mem->end - mem->start ) + 1,
+                                  CARDNAME ) )
+            return -EBUSY;
+        pc302fuse_int.mem_region.hw =
+            ioremap( mem->start, ( mem->end - mem->start ) + 1 );
+        if ( !pc302fuse_int.mem_region.hw )
+        {
+            ret = -EBUSY;
+            goto remap_failed;
+        }
+    }
+
+    ret = misc_register( &pc302fuse_int.dev );
+
+    if ( !ret )
+    {
+        pc302fuse_int.registered = 1;
+        pc302fuse_sysfs_add();
+    }
+    else
+        goto register_failed;
+
+    return ret;
+
+register_failed:
+    if ( test_mode )
+        kfree( pc302fuse_int.mem_region.sw );
+
+remap_failed:
+    if ( !test_mode )
+        release_mem_region( mem->start, ( mem->end - mem->start ) + 1 );
+    
+    printk( KERN_ERR "PC302 Fuseblock driver registration failed\n" );
+    
+    return ret;
+}
+
+static int
+pc302fuse_remove( struct platform_device *pdev )
+{
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+
+    if ( pc302fuse_int.registered )
+    {
+        misc_deregister( &pc302fuse_int.dev );
+        pc302fuse_sysfs_del();
+    }
+
+    if ( PC302_FUSE_OP_MODE_TEST == pc302fuse_int.op_mode )
+    {
+        if ( pc302fuse_int.mem_region.sw )
+            kfree( pc302fuse_int.mem_region.sw );
+    }
+    else
+    {
+        if ( pc302fuse_int.mem_region.hw )
+        {
+            iounmap( pc302fuse_int.mem_region.hw );
+            release_mem_region( mem->start, ( mem->end - mem->start ) + 1 );
+        }
+    }
+
+    return 0;
+}
+
+static int
+pc302fuse_init( void )
+{
+    int ret;
+
+    /* Check the vddq_high_delay and vddq_low_delay values are sensible. If
+     * we can't program all of the fuses in the maximum 1000000 uS, then don't
+     * make things worse! */
+    BUG_ON( PC302_FUSE_NUM_FUSES * 
+                ( vddq_high_delay + vddq_low_delay +
+                  PC302_FUSE_PROGRAM_TIME ) > 1000000 );
+
+    ret = platform_driver_register( &pc302fuse_driver );
+
+    return ret;
+}
+
+static void
+pc302fuse_exit( void )
+{
+    platform_driver_unregister( &pc302fuse_driver );
+}
+
+module_init( pc302fuse_init );
+module_exit( pc302fuse_exit );
+
+MODULE_AUTHOR( "Jamie Iles" );
+MODULE_DESCRIPTION( "PC302 Fuse Block Driver" );
+MODULE_LICENSE( "GPL" );
diff --git a/drivers/misc/pc302gpio.c b/drivers/misc/pc302gpio.c
new file mode 100644
index 0000000..db278ec
--- /dev/null
+++ b/drivers/misc/pc302gpio.c
@@ -0,0 +1,2627 @@
+/**
+ * \file pc302gpio.c
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright 2008 picoChip Designs LTD, All Rights Reserved.
+ * http://www.picochip.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This file implements a driver for the GPIO pins on the picoChip PC302
+ * device. This includes both the ARM and SD GPIO. We provide 3 APIs for
+ * accessing the GPIO pins:
+ *   - kernel space with the GPIO guidelines (Documentation/gpio.txt)
+ *   - userspace through configfs
+ *     (Documentation/filesystems/configfs/configfs.txt)
+ *   - userspace through an ioctl() interface
+ */
+
+#include <linux/module.h>
+#include <linux/configfs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+#include <linux/picochip/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/miscdevice.h>
+#include <linux/picochip/devices/pc302.h>
+#include <linux/picochip/gpio_ioctl.h>
+#include <linux/spinlock.h>
+#include <linux/irq.h>
+#include <asm/uaccess.h>
+#include <mach/irqs.h>
+#include <mach/pc302/gpio.h>
+#include <mach/pc302/axi2cfg.h>
+#include <mach/pc302/pc302.h>
+#include <mach/pc302/vic.h>
+#include <mach/hardware.h>
+
+#define CARDNAME "pc302gpio"
+#define PC302_GPIO_MINOR    ( 243 )
+
+/** A name for this module */
+#define TITLE "PC302 GPIO Driver"
+
+/** The number of pads available for GPIO. */
+#define PC302_GPIO_NUM_PADS ( 24 )
+
+/** The maximum length of a pin name. */
+#define PC302_GPIO_PIN_NAME_MAX ( 32 )
+
+/** The width of the arm gpio ports */
+#define PC302_ARM_GPIO_PORT_WIDTH   ( 8 )
+
+/** The AXI2PICO wake up command */
+#define PC302_AXI2PICO_WAKE_UP  ( 0 )
+
+/** The base address of SD-GPIO config registers in the AXI2Pico. */
+#define PC302_GPIO_SD_PIN_CONFIG_BASE   0x9800
+
+/** The base address of SD-GPIO analogue value registers in the AXI2Pico. */
+#define PC302_GPIO_SD_PIN_ANALOGUE_VALUE_BASE   0x9801
+
+/** The base address of SD-GPIO analogue rate registers in the AXI2Pico. */
+#define PC302_GPIO_SD_PIN_ANALOGUE_RATE_BASE    0x9802
+
+/** The address of the control value register in the AXI2Pico. */
+#define PC302_GPIO_SD_CONTROL_VAL_REG   0x9882
+
+/** The address of the output value register in the AXI2Pico. */
+#define PC302_GPIO_SD_OUTPUT_VAL_REG    0x9884
+
+/** The address of the input value register in the AXI2Pico. */
+#define PC302_GPIO_SD_INPUT_VAL_REG     0x9880
+
+/** The address of the sleep register in the AXI2Pico. */
+#define PC302_AXI2PICO_SLEEP_REG        0xA060
+
+/** The spacing between SD-GPIO config registers. */
+#define PC302_GPIO_SD_PIN_CONFIG_SPACING    4
+
+/**
+ * Macro to get the address of a config register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC302_GPIO_SD_PIN_CONFIG( _n ) \
+    PC302_GPIO_SD_PIN_CONFIG_BASE + ( _n * PC302_GPIO_SD_PIN_CONFIG_SPACING )
+
+/**
+ * Macro to get the address of a analogue rate register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC302_GPIO_SD_PIN_ANALOGUE_RATE( _n ) \
+    PC302_GPIO_SD_PIN_ANALOGUE_RATE_BASE + \
+        ( _n * PC302_GPIO_SD_PIN_CONFIG_SPACING )
+
+/**
+ * Macro to get the address of a analogue value register for a SD-GPIO pin.
+ *
+ * \param _n The SD-GPIO pin number.
+ * \return Returns the base address of the register.
+ */
+#define PC302_GPIO_SD_PIN_ANALOGUE_VAL( _n ) \
+    PC302_GPIO_SD_PIN_ANALOGUE_VALUE_BASE + \
+        ( _n * PC302_GPIO_SD_PIN_CONFIG_SPACING )
+
+/** Control source bit. */
+#define PC302_GPIO_SD_CONFIG_CS_MASK ~( 1 << 15 )
+
+/** Analogue not digital bit. */
+#define PC302_GPIO_SD_CONFIG_AND ( 1 << 14 )
+
+/** The mask for analogue converter size in the config register. */
+#define PC302_GPIO_SD_CONV_SZ_MASK ( 0xF )
+
+/** Soft reset lock bit. */
+#define PC302_GPIO_SD_CONFIG_SR_LOCK ( 1 << 13 )
+
+/** PC302 AXI2Pico CAEID. */
+#define PC302_AXI2PICO_CAEID    ( 0x00A8 )
+
+/** PC302 PAI CAEID. */
+#define PC302_PAI_CAEID         ( 0x0578 )
+
+/** The address of the sleep register in the PAI. */
+#define PC302_PAI_SLEEP_REG     ( 0xA060 )
+
+/** The PAI wake up command */
+#define PC302_PAI_WAKE_UP       ( 0 )
+
+/** Mask for valid bits in the PAI pai_io_ctrl register. */
+#define PC302_PAI_IO_CTRL_REG_MASK  ( 0xF )
+
+/** The address of the pai_io_ctrl register in the PAI. */
+#define PC302_PAI_IO_CTRL_REG   ( 0x0009 )
+
+/** Define some bit values for ARM_GPIO Muxing control */
+typedef enum
+{
+    PAI_GPIO_PIN_ARM_4 = 0xB,
+    PAI_GPIO_PIN_ARM_5 = 0xA,
+    PAI_GPIO_PIN_ARM_6 = 0x9,
+    PAI_GPIO_PIN_ARM_7 = 0x8,
+
+} pc302_pai_arm;
+
+/** Define some bit values for SDGPIO_GPIO Muxing control */
+typedef enum
+{
+    PAI_SDGPIO_PIN_ARM_4 = 0x7,
+    PAI_SDGPIO_PIN_ARM_5 = 0x6,
+    PAI_SDGPIO_PIN_ARM_6 = 0x5,
+    PAI_SDGPIO_PIN_ARM_7 = 0x4,
+
+} pc302_pai_sdgpio;
+
+static int pc302gpio_open( struct inode *inode,
+                           struct file *filp );
+
+static int pc302gpio_release( struct inode *inode,
+                              struct file *filp );
+
+static int pc302gpio_ioctl( struct inode *inode,
+                            struct file *filp,
+                            unsigned int cmd,
+                            unsigned long arg );
+
+/*****************************************************************************
+ * Data types.                                                               *
+ *****************************************************************************/
+
+/**
+ * The file operations for the GPIO driver.
+ */
+static const struct file_operations pc302gpio_fops = {
+    .open       = pc302gpio_open,
+    .release    = pc302gpio_release,
+    .ioctl      = pc302gpio_ioctl,
+};
+
+/** Private data storage for this module. */
+static struct {
+
+#ifdef CONFIG_DEBUG_FS
+    /**
+     * The directory entry for debugfs if we are using it.
+     */
+    struct dentry *debugfs_dir;
+
+    /**
+     * The list of all active GPIOs if we are using debugfs.
+     */
+    struct dentry *debugfs_file;
+#endif /* CONFIG_DEBUG_FS */
+
+    struct platform_device *pdev;
+    struct platform_driver *pdrv;
+    struct miscdevice dev;
+    void __iomem *mem_region;
+    spinlock_t lock;
+
+} pc302gpio_priv = {
+    .dev    = {
+        .minor  = PC302_GPIO_MINOR,
+        .name   = "gpio",
+        .fops   = &pc302gpio_fops,
+    },
+    .lock       = __SPIN_LOCK_UNLOCKED( pc302gpio_priv_lock ),
+};
+
+/** GPIO pin type. */
+typedef enum
+{
+    PC302_GPIO_ARM,
+    PC302_GPIO_SD,
+
+} pc302gpio_pin_type;
+
+/** Private representation to store state of a GPIO pin. */
+struct pc302gpio_pin_allocation
+{
+    /** The pin number (not pad number). */
+    int pin_num;
+
+    /** Boolean flag for an input GPIO. */
+    int is_input;
+
+    /** Boolean flag for whether the pin is active. */
+    int enabled;
+
+    /** The pad number. */
+    int pad;
+
+    /** The name of the pin - filled in when the pin is requested. */
+    char name[ PC302_GPIO_PIN_NAME_MAX ];
+
+    /** The cached value of the pin. Used for output GPIO pins to remember the
+     * last value set. */
+    int value;
+
+    /** Analogue not digital flag. 0 == digital, non-zero == analogue. */
+    int a_not_d;
+};
+
+#ifdef CONFIG_CONFIGFS_FS
+/** Structure to store the state of a pin in configfs. */
+struct pc302gpio_cfs_pin
+{
+    /** The configfs entry. */
+    struct config_item item;
+
+    /** The pin allocation. */
+    struct pc302gpio_pin_allocation *phys_pin;
+};
+
+/** Structure for setting and getting attributes through configfs. */
+struct pc302gpio_pin_attr
+{
+    /** The attribute itself. */
+    struct configfs_attribute attr;
+
+    ssize_t ( *show )( struct pc302gpio_cfs_pin *pin, char *buf );
+    ssize_t ( *store )( struct pc302gpio_cfs_pin *pin, const char *buf,
+                        size_t count );
+};
+#endif /* CONFIG_CONFIGFS_FS */
+
+/**
+ * The current boot mode.
+ */
+static u32 boot_mode = 1;
+
+static struct pc302gpio_pin_allocation *pc302gpio_pads[ PC302_GPIO_NUM_PADS ];
+
+/*****************************************************************************
+ * Private function prototypes.                                              *
+ *****************************************************************************/
+
+static int
+pc302gpio_get_pad( picoifGpioPinNum_t pin );
+
+static struct pc302gpio_pin_allocation *
+pc302gpio_alloc_pin( const char *name );
+
+static void
+pc302gpio_free_pin( struct pc302gpio_pin_allocation *p );
+
+static int
+pc302gpio_set_direction( struct pc302gpio_pin_allocation *pin,
+                         int input );
+
+static pc302gpio_pin_type
+pc302gpio_get_pin_type( struct pc302gpio_pin_allocation *pin );
+
+static struct pc302gpio_pin_allocation *
+pc302gpio_find_pin( unsigned gpio );
+
+static int
+pc302gpio_pin_to_block_pin( struct pc302gpio_pin_allocation *pin );
+
+static int
+pc302gpio_set_value( struct pc302gpio_pin_allocation *pin,
+                     int value );
+
+static int
+pc302gpio_get_value( struct pc302gpio_pin_allocation *pin );
+
+static int pc302gpio_configure_dac( unsigned gpio,
+                                    u8 converter_size,
+                                    u16 analogue_rate );
+
+static int pc302gpio_pai_muxing( picoifGpioPinNum_t pin );
+
+#ifdef CONFIG_CONFIGFS_FS
+ssize_t	pc302gpio_cfs_show_attribute( struct config_item *,
+                                      struct configfs_attribute *,
+                                      char * );
+
+ssize_t	pc302gpio_cfs_store_attribute( struct config_item *,
+                                       struct configfs_attribute *,
+                                       const char *,
+                                       size_t );
+#endif /* CONFIG_CONFIGFS_FS */
+
+/*****************************************************************************
+ * Implementation.                                                           *
+ *****************************************************************************/
+
+/**
+ * Get the pad number for the requested GPIO pin. This is needed as some pins
+ * are multiplexed and we need to check whether the pad is already in use
+ * either by the other shared pin or the EBI bus.
+ *
+ * \param pin The pin number being requested.
+ * \return Returns the pad number in the range 0 ... PC302_GPIO_NUM_PADS on
+ * success or negative on failure (invalid pin number, pad already in use
+ * etc).
+ */
+static int
+pc302gpio_get_pad( picoifGpioPinNum_t pin )
+{
+    int ret = -EINVAL;
+
+    if ( pin >= PC302_GPIO_PIN_ARM_0 && pin <= PC302_GPIO_PIN_ARM_7 )
+    {
+        /* ARM GPIO */
+
+        /* If we are in parallel boot mode, then to use the bottom 4
+         * bits of ARM GPIO we need to noodle with the PAI block
+         * gpio mux control.*/
+        ret = -EIO;
+        if ( 0 == boot_mode && pin >= PC302_GPIO_PIN_ARM_4 )
+        {
+            ret = pc302gpio_pai_muxing( pin );
+            if ( 0 != ret )
+                goto out;
+        }
+
+        ret = pin - PC302_GPIO_PIN_ARM_0;
+    }
+    else if ( pin >= PC302_GPIO_PIN_SDGPIO_0 && pin <= PC302_GPIO_PIN_SDGPIO_7 )
+    {
+        /* SD-GPIO */
+
+        /* If we are in parallel boot mode, then to use the bottom 4
+         * bits of SDGPIO GPIO we need to noodle with the PAI block
+         * gpio mux control. */
+        ret = -EIO;
+        if ( 0 == boot_mode && pin >= PC302_GPIO_PIN_SDGPIO_4 )
+        {
+            ret = pc302gpio_pai_muxing( pin );
+            if ( 0 != ret )
+                goto out;
+        }
+
+        ret = pin - PC302_GPIO_PIN_ARM_0;
+    }
+    else if ( pin >= PC302_GPIO_PIN_ARM_8 &&
+              pin <= PC302_GPIO_PIN_ARM_15 )
+    {
+        /* Shared ARM GPIO */
+        ret = pin - PC302_GPIO_PIN_ARM_0;
+
+    }
+    else if ( pin >= PC302_GPIO_PIN_SDGPIO_8 &&
+              pin <= PC302_GPIO_PIN_SDGPIO_15 )
+    {
+        /* Shared SD-GPIO */
+        ret = pin - PC302_GPIO_PIN_ARM_0 - 8;
+    }
+
+out:
+    return ret;
+}
+
+/**
+ * Check if a GPIO pin number is a valid GPIO pin in this system.
+ *
+ * \param gpio The GPIO pin number to query.
+ * \return Returns 1 if gpio is a valid pin, 0 otherwise.
+ */
+int
+gpio_is_valid( int gpio )
+{
+    return ( gpio >= PC302_GPIO_PIN_ARM_0 && gpio <= PC302_GPIO_PIN_SDGPIO_15 );
+}
+EXPORT_SYMBOL( gpio_is_valid );
+
+/**
+ * Set the pin multiplexing for shared GPIO pins.
+ *
+ * \param gpio The pin to set the multiplex value of.
+ * \return Returns zero on success or if the multiplexing does not need to be
+ * set, non-zero on failure.
+ */
+static int
+set_pin_mux( unsigned gpio )
+{
+    int is_arm = 0;
+    u32 val;
+    unsigned shared_pin_num;
+
+    if ( ( gpio >= PC302_GPIO_PIN_ARM_0 && gpio <= PC302_GPIO_PIN_SDGPIO_7 ) )
+    {
+        if ( gpio == PC302_GPIO_PIN_SDGPIO_0 )
+        {
+            /* Need to set SDGPIO Freq_Synth Mux bit to 0 */
+            syscfg_update( AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, (u32)0 );
+        }
+        return 0;
+    }
+
+    if ( ( gpio >= PC302_GPIO_PIN_ARM_8 && gpio <= PC302_GPIO_PIN_ARM_15 ) )
+        is_arm = 1;
+
+    switch ( gpio )
+    {
+        case PC302_GPIO_PIN_ARM_8 ... PC302_GPIO_PIN_ARM_15:
+            shared_pin_num = gpio - PC302_GPIO_PIN_ARM_8;
+            break;
+
+        case PC302_GPIO_PIN_SDGPIO_8 ... PC302_GPIO_PIN_SDGPIO_15:
+            shared_pin_num = gpio - PC302_GPIO_PIN_SDGPIO_8;
+            break;
+
+        default:
+            return -EINVAL;
+            BUG();
+    }
+
+    spin_lock( &pc302gpio_priv.lock );
+    val = syscfg_read();
+    val &=
+        ~( 1 << ( shared_pin_num + AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO ) );
+    if ( is_arm )
+        val |= ( 1 << ( shared_pin_num +
+                        AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO ) );
+    syscfg_update( AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_MASK, val );
+    spin_unlock( &pc302gpio_priv.lock );
+
+    return 0;
+}
+
+/**
+ * Set the value of the "Soft Reset Lock" bit of an SDGPIO. If this is set, the
+ * SDGPIO will not be reset along with the rest of the picoArray.
+ *
+ * \param pin The pin to configure
+ * \param value one to set the bit, zero to clear it
+ */
+static int
+pc302gpio_sd_reset_conifg( struct pc302gpio_pin_allocation *pin, int value )
+{
+    int ret, block_pin;
+    u16 data;
+
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+    ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -1;
+    }
+
+    if (value)
+        data |= PC302_GPIO_SD_CONFIG_SR_LOCK;
+    else
+        data &= ~PC302_GPIO_SD_CONFIG_SR_LOCK;
+    ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+                               PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                               1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -1;
+    }
+
+    return 0;
+}
+
+/**
+ * Request a new GPIO pin. This implements part of the Linux GPIO guidelines.
+ *
+ * \param gpio The pin to request.
+ * \param label The name of the pin - this only serves as a tag for debugging
+ * so can be anything.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+gpio_request( unsigned gpio,
+              const char *label )
+{
+    int pad_num;
+    int ret = 0;
+    struct pc302gpio_pin_allocation *pin;
+    pc302gpio_pin_type ptype;
+
+    spin_lock( &pc302gpio_priv.lock );
+    pad_num = pc302gpio_get_pad( gpio );
+
+    ret = -EINVAL;
+    if ( pad_num < 0 )
+        goto out;
+
+    /* If the pad is already in use then fail. */
+    ret = -EBUSY;
+    if ( pc302gpio_pads[ pad_num ] )
+        goto out;
+
+    ret = -EIO;
+    if ( set_pin_mux( gpio ) )
+        goto out;
+
+    pc302gpio_pads[ pad_num ] = pc302gpio_alloc_pin( label );
+    pc302gpio_pads[ pad_num ]->pin_num = gpio;
+    pc302gpio_pads[ pad_num ]->pad = pad_num;
+
+    pin = pc302gpio_find_pin( gpio );
+    ptype = pc302gpio_get_pin_type( pin );
+    if ( PC302_GPIO_SD == ptype )
+    {
+        /* Set the reset lock bit on SDGPIOs
+         * Note: Once set these bits never get reset by this
+         *       driver.
+         */
+        ret = pc302gpio_sd_reset_conifg( pin, 1 );
+        if ( ret )
+        {
+            ret = -EIO;
+            goto out;
+        }
+    }
+
+    ret = 0;
+
+out:
+    spin_unlock( &pc302gpio_priv.lock );
+
+    return ret;
+}
+EXPORT_SYMBOL( gpio_request );
+
+/**
+ * Free a GPIO pin previously requested with gpio_request().
+ *
+ * \param gpio The GPIO pin to free.
+ */
+void
+gpio_free( unsigned gpio )
+{
+    unsigned i;
+    unsigned found = 0;
+    struct pc302gpio_pin_allocation *pin;
+    pc302gpio_pin_type ptype;
+
+    spin_lock( &pc302gpio_priv.lock );
+
+    pin = pc302gpio_find_pin( gpio );
+    if (!pin)
+	    goto out;
+    ptype = pc302gpio_get_pin_type( pin );
+
+    /* Find the pin. */
+    for ( i = 0; i < PC302_GPIO_NUM_PADS; ++i )
+    {
+        if ( pc302gpio_pads[ i ] && pc302gpio_pads[ i ]->pin_num == gpio )
+        {
+            found = 1;
+            break;
+        }
+    }
+
+    if ( !found )
+        goto out;
+
+    kfree( pc302gpio_pads[ i ] );
+    pc302gpio_pads[ i ] = NULL;
+
+out:
+    spin_unlock( &pc302gpio_priv.lock );
+}
+EXPORT_SYMBOL( gpio_free );
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * input.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+gpio_direction_input( unsigned gpio )
+{
+    int pad_num;
+    struct pc302gpio_pin_allocation *pin;
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+    pad_num = pc302gpio_get_pad( gpio );
+    if ( pad_num < 0 )
+    {
+        ret = pad_num;
+        goto out;
+    }
+
+    pin = pc302gpio_pads[ pad_num ];
+
+    ret = -ENXIO;
+    if ( !pin )
+        goto out;
+
+    pin->is_input = 1;
+    ret = pc302gpio_set_direction( pin, 1 );
+
+out:
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+EXPORT_SYMBOL( gpio_direction_input );
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * output.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \param value The initial output value for the gpio pin.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+gpio_direction_output( unsigned gpio,
+                       int value )
+{
+    int pad_num;
+    struct pc302gpio_pin_allocation *pin;
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+    pad_num = pc302gpio_get_pad( gpio );
+    if ( pad_num < 0 )
+    {
+        ret = pad_num;
+        goto out;
+    }
+
+    pin = pc302gpio_pads[ pad_num ];
+
+    ret = -ENXIO;
+    if ( !pin )
+        goto out;
+
+    pin->is_input = 0;
+    ret = pc302gpio_set_direction( pin, 0 );
+    if ( 0 != ret )
+    {
+        goto out;
+    }
+    else
+    {
+        ret = pc302gpio_set_value( pin, value );
+    }
+
+out:
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+EXPORT_SYMBOL( gpio_direction_output );
+
+/**
+ * Check if a GPIO pin can sleep.
+ *
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+gpio_cansleep( unsigned gpio )
+{
+    /* None of our GPIO pin accesses can sleep so always return 0. */
+    return 0;
+}
+EXPORT_SYMBOL( gpio_cansleep );
+
+/* We don't use gpiolib as it doesn't handle multiplexing of pins well so we
+ * don't get the sysfs export helpers. Rather than leave the functions
+ * undefined, always return an error. */
+int
+gpio_export( unsigned gpio,
+             bool direction_may_change )
+{
+    return -ENODEV;
+}
+EXPORT_SYMBOL( gpio_export );
+
+int
+gpio_unexport( unsigned gpio )
+{
+    return -ENODEV;
+}
+EXPORT_SYMBOL( gpio_unexport );
+
+/**
+ * Given a GPIO pin number, find the IRQ that it can generate. This is only
+ * applicable to ARM GPIO pins 0-7.
+ *
+ * \param gpio The GPIO pin to get the IRQ line for.
+ * \return Returns the IRQ number on success, negative on failure.
+ */
+int
+gpio_to_irq( unsigned gpio )
+{
+    /* Only ARM GPIO pins 0..7 can generate interrupts. */
+    if ( !( gpio >= PC302_GPIO_PIN_ARM_0 && gpio <= PC302_GPIO_PIN_ARM_7 ) )
+        return -EINVAL;
+
+    return ( gpio - PC302_GPIO_PIN_ARM_0 ) + IRQ_GPIO0;
+}
+EXPORT_SYMBOL( gpio_to_irq );
+
+/**
+ * Given a IRQ line number, find the GPIO pin can generate it. This is only
+ * applicable to ARM GPIO pins 0-7.
+ *
+ * \param irq The IRQ line that can be generated by the GPIO.
+ * \return Returns the GPIO pin number on success, negative on failure.
+ */
+int
+irq_to_gpio( unsigned irq )
+{
+    if ( !( irq >= IRQ_GPIO0 && irq <= IRQ_GPIO7 ) )
+        return -EINVAL;
+
+    return ( irq - IRQ_GPIO0 ) + PC302_GPIO_PIN_ARM_0;
+}
+
+/* None of our GPIOs can sleep and we could just implement these functions as
+ * wrappers around the spinlock safe functions, things could change in the
+ * future and its better to be explicit. Using these _cansleep() variants will
+ * always return -EIO. */
+int
+gpio_get_value_cansleep( unsigned gpio )
+{
+    return -EIO;
+}
+EXPORT_SYMBOL( gpio_get_value_cansleep );
+
+int
+gpio_set_value_cansleep( unsigned gpio,
+                         int value )
+{
+    return -EIO;
+}
+EXPORT_SYMBOL( gpio_set_value_cansleep );
+
+/**
+ * Set the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to set the value of.
+ * \param value The value to set the pin to.
+ */
+int
+gpio_set_value( unsigned gpio,
+                int value )
+{
+    struct pc302gpio_pin_allocation *pin;
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+    pin = pc302gpio_find_pin( gpio );
+
+    ret = -EINVAL;
+    if ( !pin )
+        goto out;
+
+    ret = pc302gpio_set_value( pin, value );
+
+out:
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+EXPORT_SYMBOL( gpio_set_value );
+
+/**
+ * Get the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to get the value of.
+ * \return Returns the value of the pin on success,
+ * negative on failure.
+ */
+int
+gpio_get_value( unsigned gpio )
+{
+    struct pc302gpio_pin_allocation *pin;
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+    pin = pc302gpio_find_pin( gpio );
+
+    ret = -EINVAL;
+    if ( !pin )
+        goto out;
+
+    ret = pc302gpio_get_value( pin );
+out:
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+EXPORT_SYMBOL( gpio_get_value );
+
+/**
+ * Free a GPIO pin that has previously been allocated.
+ *
+ * \param p The pin to free.
+ */
+static void
+pc302gpio_free_pin( struct pc302gpio_pin_allocation *p )
+{
+    kfree( p );
+}
+
+/**
+ * Allocate a GPIO pin state structure.
+ *
+ * \param name The name of the pin (this can be anything - it can be the
+ * function of the pin or the application using it for example).
+ * \return Returns a pointer to the pin on success, NULL on failure.
+ */
+static struct pc302gpio_pin_allocation *
+pc302gpio_alloc_pin( const char *name )
+{
+    struct pc302gpio_pin_allocation *p =
+        kzalloc( sizeof( *p ), GFP_KERNEL );
+
+    if ( p )
+    {
+        snprintf( p->name, PC302_GPIO_PIN_NAME_MAX, "%s", name );
+        p->pin_num = -1;
+        p->pad = -1;
+        p->enabled = 0;
+        p->is_input = 0;
+        p->a_not_d = 0;
+    }
+
+    return p;
+}
+
+/**
+ * Get the pin type.
+ *
+ * \param pin The pin to query.
+ * \return Returns the type of GPIO pin.
+ */
+static pc302gpio_pin_type
+pc302gpio_get_pin_type( struct pc302gpio_pin_allocation *pin )
+{
+    int ret;
+    BUG_ON( !pin );
+
+    switch ( pin->pin_num )
+    {
+        case PC302_GPIO_PIN_ARM_0 ... PC302_GPIO_PIN_ARM_7:
+        case PC302_GPIO_PIN_ARM_8 ... PC302_GPIO_PIN_ARM_15:
+            ret = PC302_GPIO_ARM;
+            break;
+
+        case PC302_GPIO_PIN_SDGPIO_0 ... PC302_GPIO_PIN_SDGPIO_7:
+        case PC302_GPIO_PIN_SDGPIO_8 ... PC302_GPIO_PIN_SDGPIO_15:
+            ret = PC302_GPIO_SD;
+            break;
+
+        default:
+            ret = -EINVAL;
+            break;
+    }
+
+    return ret;
+}
+
+/**
+ * Given a GPIO pin number, find the number of the pin in the block. The
+ * global enumeration of pin numbers include both types and are non
+ * contiguous. This function takes the pin number and turns it into a number
+ * in the range 0->15 for the block that controls it.
+ *
+ * \param pin The pin to query.
+ * \return Returns the block pin number on success, non-zero on failure.
+ */
+static int
+pc302gpio_pin_to_block_pin( struct pc302gpio_pin_allocation *pin )
+{
+    unsigned ret;
+
+    BUG_ON( NULL == pin );
+
+    switch ( pin->pin_num )
+    {
+        case PC302_GPIO_PIN_ARM_0 ... PC302_GPIO_PIN_ARM_7:
+            ret =  pin->pin_num - PC302_GPIO_PIN_ARM_0;
+            break;
+
+        case PC302_GPIO_PIN_ARM_8 ... PC302_GPIO_PIN_ARM_15:
+            ret =  ( pin->pin_num - PC302_GPIO_PIN_ARM_8 ) + 8;
+            break;
+
+        case PC302_GPIO_PIN_SDGPIO_0 ... PC302_GPIO_PIN_SDGPIO_7:
+            ret =  pin->pin_num - PC302_GPIO_PIN_SDGPIO_0;
+            break;
+
+        case PC302_GPIO_PIN_SDGPIO_8 ... PC302_GPIO_PIN_SDGPIO_15:
+            ret =  ( pin->pin_num - PC302_GPIO_PIN_SDGPIO_8 ) + 8;
+            break;
+
+        default:
+            ret = -1;
+            BUG();
+    }
+
+    return ret;
+}
+
+/**
+ * Set the value of an output SDGPIO pin.
+ *
+ * \param pin The pin to set the value of.
+ * \param value The value to set the pin to. Intepreted as non-zero == 1.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_sd_set_value( struct pc302gpio_pin_allocation *pin,
+                        int value )
+{
+    unsigned block_pin;
+    int ret;
+    u16 data;
+    BUG_ON( NULL == pin );
+
+    if ( pin->is_input )
+        return -EINVAL;
+
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( !pin->a_not_d )
+    {
+        /* Digital mode */
+        ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                                  PC302_GPIO_SD_OUTPUT_VAL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to read SDGPIO output value reg\n" );
+            return -EIO;
+        }
+
+        data &= ~( 1 << block_pin );
+        data |= ( !!value ) << block_pin;
+
+        ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+                PC302_GPIO_SD_OUTPUT_VAL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to output control register for SDGPIO"
+                    "pin %u\n", block_pin );
+            return -EIO;
+        }
+    }
+    else
+    {
+        /* Analogue mode */
+        data = (u16)value;
+        ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+                                   PC302_GPIO_SD_PIN_ANALOGUE_VAL( block_pin ),
+                                   1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to write analogue value register for "
+                    "SDGPIO pin %u\n", block_pin );
+            return -EIO;
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * Get the value of an input SDGPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value read on success, negative on failure.
+ */
+static int
+pc302gpio_sd_get_value( struct pc302gpio_pin_allocation *pin )
+{
+    unsigned block_pin;
+    int ret;
+    u16 data;
+    BUG_ON( NULL == pin );
+
+    if ( !pin->is_input && !pin->a_not_d )
+        return -EINVAL;
+
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( !pin->a_not_d )
+    {
+        /* Digital mode */
+        ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                                  PC302_GPIO_SD_INPUT_VAL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to read SDGPIO input value reg\n" );
+            return -EIO;
+        }
+
+        return !!( data & ( 1 << block_pin ) );
+    }
+    else
+    {
+        /* Analogue mode */
+        ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                                  PC302_GPIO_SD_PIN_ANALOGUE_VAL( block_pin ),
+                                  1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to read the analogue value register "
+                    "for SDGPIO pin %u\n", block_pin );
+            return -EIO;
+        }
+
+        return (int)data;
+    }
+}
+
+/**
+ * Get the value of an input ARM GPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value read on success, negative on failure.
+ */
+static int
+pc302gpio_arm_get_value( struct pc302gpio_pin_allocation *pin )
+{
+    unsigned block_pin;
+    void __iomem *port_ds;
+    u32 pin_offset;
+    u32 val;
+    BUG_ON( NULL == pin );
+
+    if ( !pin->is_input )
+        return -EINVAL;
+
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( block_pin >= PC302_GPIO_PIN_ARM_0 &&
+         block_pin <= PC302_GPIO_PIN_ARM_7 )
+    {
+        port_ds = pc302gpio_priv.mem_region + GPIO_EXT_PORT_A_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else if ( block_pin >= ( PC302_GPIO_PIN_ARM_8 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) &&
+              block_pin <= ( PC302_GPIO_PIN_ARM_15 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) )
+    {
+        port_ds = pc302gpio_priv.mem_region + GPIO_EXT_PORT_B_REG_OFFSET;
+        pin_offset = block_pin - PC302_ARM_GPIO_PORT_WIDTH;
+    }
+    else
+    {
+        printk( KERN_INFO "cannot set value of ARM GPIO pin (%d)\n",
+                block_pin );
+        return -ENXIO;
+    }
+
+    val = ioread32( port_ds );
+
+    return !!( val & ( 1 << pin_offset ) );
+}
+
+/**
+ * Set the direction of an SD-GPIO pin.
+ *
+ * \param pin The pin to set the direction of.
+ * \param input Boolean flag to set the pin to input.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_sd_set_direction( struct pc302gpio_pin_allocation *pin,
+                            int input )
+{
+    int ret;
+    u16 data;
+    unsigned block_pin;
+
+    /* Set the pin to be controlled by the configuration bus. */
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    data &= PC302_GPIO_SD_CONFIG_CS_MASK;
+    ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+                               PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                               1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    /* Configure the pin to drive or not drive the output as appropriate.
+    */
+    ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_CONTROL_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read SDGPIO control value register\n" );
+        return -EIO;
+    }
+
+    if ( input )
+        data &= ~( 1 << block_pin );
+    else
+        data |= ( 1 << block_pin );
+
+    ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+                               PC302_GPIO_SD_CONTROL_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write control value register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/**
+ * Set the direction of an ARM GPIO pin.
+ *
+ * \param pin The pin to set the direction of.
+ * \param input Boolean flag to set the pin to input.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_arm_set_direction( struct pc302gpio_pin_allocation *pin,
+                             int input )
+{
+    unsigned block_pin;
+    void __iomem *port_ddr;
+    void __iomem *port_cr;
+    u32 val;
+    u32 pin_offset;
+
+    /* Set the pin to be controlled by the configuration bus. */
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( block_pin >= PC302_GPIO_PIN_ARM_0 &&
+         block_pin <= PC302_GPIO_PIN_ARM_7 )
+    {
+        port_ddr = pc302gpio_priv.mem_region + GPIO_SW_PORT_A_DDR_REG_OFFSET;
+        port_cr = pc302gpio_priv.mem_region + GPIO_SW_PORT_A_CTL_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else if ( block_pin >= ( PC302_GPIO_PIN_ARM_8 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) &&
+              block_pin <= ( PC302_GPIO_PIN_ARM_15 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) )
+    {
+        port_ddr = pc302gpio_priv.mem_region + GPIO_SW_PORT_B_DDR_REG_OFFSET;
+        port_cr = pc302gpio_priv.mem_region + GPIO_SW_PORT_B_CTL_REG_OFFSET;
+        pin_offset = block_pin - PC302_ARM_GPIO_PORT_WIDTH;
+    }
+    else
+    {
+        printk( KERN_INFO "cannot set direction of ARM GPIO pin (%d)\n",
+                block_pin );
+        return -ENXIO;
+    }
+
+    /* Set the direction register (a bit set indicates output). */
+    val = ioread32( port_ddr );
+    if ( input )
+        val &= ~( 1 << pin_offset );
+    else
+        val |= ( 1 << pin_offset );
+    iowrite32( val, port_ddr );
+
+    /* Set the control register for the pin to be software controlled. */
+    val = ioread32( port_cr );
+    val &= ~( 1 << pin_offset );
+    iowrite32( val, port_cr );
+
+    return 0;
+}
+
+/**
+ * Set the value of an output ARM GPIO pin.
+ *
+ * \param pin The pin to set the value of.
+ * \param value The value to set the pin to. Intepreted as non-zero == 1.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_arm_set_value( struct pc302gpio_pin_allocation *pin,
+                         int value )
+{
+    unsigned block_pin;
+    u32 val;
+    u32 pin_offset;
+    void __iomem *port_dr;
+    BUG_ON( NULL == pin );
+
+    if ( pin->is_input )
+        return -EINVAL;
+
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    if ( block_pin >= PC302_GPIO_PIN_ARM_0 &&
+         block_pin <= PC302_GPIO_PIN_ARM_7 )
+    {
+        port_dr = pc302gpio_priv.mem_region + GPIO_SW_PORT_A_DR_REG_OFFSET;
+        pin_offset = block_pin;
+    }
+    else if ( block_pin >= ( PC302_GPIO_PIN_ARM_8 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) &&
+              block_pin <= ( PC302_GPIO_PIN_ARM_15 -
+                             PC302_ARM_GPIO_PORT_WIDTH ) )
+    {
+        port_dr = pc302gpio_priv.mem_region + GPIO_SW_PORT_B_DR_REG_OFFSET;
+        pin_offset = block_pin - PC302_ARM_GPIO_PORT_WIDTH;
+    }
+    else
+    {
+        printk( KERN_INFO "cannot set value of ARM GPIO pin (%d)\n",
+                block_pin );
+        return -ENXIO;
+    }
+
+    val = ioread32( port_dr );
+    val &= ~( 1 << pin_offset );
+    val |= ( !!value << pin_offset );
+
+    iowrite32( val, port_dr );
+
+    return 0;
+}
+
+/**
+ * Set the direction of a GPIO pin.
+ *
+ * \param pin The pin to set the direction of.
+ * \param input Flag for input GPIO pins.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_set_direction( struct pc302gpio_pin_allocation *pin,
+                         int input )
+{
+    int ret;
+    pc302gpio_pin_type ptype;
+    BUG_ON( NULL == pin );
+
+    ptype = pc302gpio_get_pin_type( pin );
+
+    if ( PC302_GPIO_ARM == ptype )
+        ret = pc302gpio_arm_set_direction( pin, input );
+    else if ( PC302_GPIO_SD == ptype )
+        ret = pc302gpio_sd_set_direction( pin, input );
+    else
+        ret = -EINVAL;
+
+    if ( !ret )
+        pin->is_input = !!input;
+
+    return ret;
+}
+
+/**
+ * Set the value of a GPIO pin.
+ *
+ * \param pin The pin to set the value of.
+ * \param value The value to set.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_set_value( struct pc302gpio_pin_allocation *pin,
+                     int value )
+{
+    int ret;
+    pc302gpio_pin_type ptype;
+    BUG_ON( NULL == pin );
+
+    ptype = pc302gpio_get_pin_type( pin );
+
+    if ( PC302_GPIO_ARM == ptype )
+        ret = pc302gpio_arm_set_value( pin, value );
+    else if ( PC302_GPIO_SD == ptype )
+        ret = pc302gpio_sd_set_value( pin, value );
+    else
+        ret = -EINVAL;
+
+    if ( !ret && !pin->a_not_d )
+    {
+        /* Digital mode */
+        pin->value = !!value;
+    }
+    else
+    {
+        /* Analogue mode */
+        pin->value = value;
+    }
+    return ret;
+}
+
+/**
+ * Get the value of a GPIO pin.
+ *
+ * \param pin The pin to get the value of.
+ * \return Returns the value of the pin on success,
+ * negative on failure.
+ */
+static int
+pc302gpio_get_value( struct pc302gpio_pin_allocation *pin )
+{
+    int ret;
+    pc302gpio_pin_type ptype;
+    BUG_ON( NULL == pin );
+
+    ptype = pc302gpio_get_pin_type( pin );
+
+    if ( PC302_GPIO_ARM == ptype )
+        ret = pc302gpio_arm_get_value( pin );
+    else if ( PC302_GPIO_SD == ptype )
+        ret = pc302gpio_sd_get_value( pin );
+    else
+        ret = -EINVAL;
+
+    if ( ret >= 0 && !pin->a_not_d )
+    {
+        /* Digital mode */
+        pin->value = !!ret;
+    }
+    else
+    {
+        /* Analogue mode */
+        pin->value = ret;
+    }
+    return ret;
+}
+
+/**
+ * Given a GPIO pin number, find the PC302 representation of it.
+ *
+ * \param gpio The GPIO pin number.
+ * \return Returns a pointer to the internal representation.
+ */
+static struct pc302gpio_pin_allocation *
+pc302gpio_find_pin( unsigned gpio )
+{
+    int i;
+
+    for ( i = 0 ; i < PC302_GPIO_NUM_PADS; ++i )
+    {
+        if ( pc302gpio_pads[ i ] && pc302gpio_pads[ i ]->pin_num == gpio )
+            return pc302gpio_pads[ i ];
+    }
+
+    return NULL;
+}
+
+static int
+pc302gpio_configure_dac( unsigned gpio,
+                         u8 converter_size,
+                         u16 analogue_rate )
+{
+    int ret;
+    u16 data;
+    unsigned block_pin;
+    struct pc302gpio_pin_allocation *pin = pc302gpio_find_pin( gpio );
+
+    if ( !pin )
+        return -EINVAL;
+
+    /* Set the pin to be controlled by the configuration bus. */
+    block_pin = pc302gpio_pin_to_block_pin( pin );
+
+    ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    data &= PC302_GPIO_SD_CONFIG_CS_MASK;
+    data &= ~PC302_GPIO_SD_CONV_SZ_MASK;
+    data |= ( PC302_GPIO_SD_CONFIG_AND |
+            ( converter_size & PC302_GPIO_SD_CONV_SZ_MASK ) );
+
+    ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_PIN_CONFIG( block_pin ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write config register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    /* Configure the pin to drive the output. */
+    ret = picoif_config_read( 0, PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_CONTROL_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read SDGPIO control value register\n" );
+        return -EIO;
+    }
+
+    data |= ( 1 << block_pin );
+
+    ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+                               PC302_GPIO_SD_CONTROL_VAL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write control value register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    /* Write the Analogue rate register */
+    data = analogue_rate;
+    ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+                              PC302_GPIO_SD_PIN_ANALOGUE_RATE( block_pin ),
+                              1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to write analogue rate register for SDGPIO \
+                pin %u\n", block_pin );
+        return -EIO;
+    }
+
+    /* Set the a_not_d flag in the pin allocation structure */
+    pin->a_not_d = 1;
+
+    return 0;
+}
+
+/**
+ * Given a GPIO pin number, setup the pai gpio muxing.
+ *
+ * \param gpio The GPIO pin number.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int
+pc302gpio_pai_muxing( picoifGpioPinNum_t pin )
+{
+    int ret= -EINVAL;
+
+    u16 data = PC302_PAI_WAKE_UP;
+
+    /* We are about to setup a gpio mux in the PAI block,
+     * therefore before we do anything else we need to wake up
+     * the PAI block. */
+    ret = picoif_config_write( 0, PC302_PAI_CAEID,
+                               PC302_PAI_SLEEP_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to wake up the PAI block.\n");
+        return ret;
+    }
+
+    /* Read back the current value of the pai_io_ctrl register */
+    ret = picoif_config_read( 0, PC302_PAI_CAEID,
+                              PC302_PAI_IO_CTRL_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to read from the PAI io_ctrl register.\n");
+        return -EIO;
+    }
+
+    /* Make sure we have valid data */
+    data &= PC302_PAI_IO_CTRL_REG_MASK;
+
+    if ( ( pin >= PC302_GPIO_PIN_ARM_4 ) &&
+         ( pin <= PC302_GPIO_PIN_ARM_7 ) )
+    {
+        /* We are muxing an ARM gpio pin */
+        switch ( pin )
+        {
+            case PC302_GPIO_PIN_ARM_4:
+                data |= PAI_GPIO_PIN_ARM_4;
+                break;
+
+            case PC302_GPIO_PIN_ARM_5:
+                data |= PAI_GPIO_PIN_ARM_5;
+                break;
+
+            case PC302_GPIO_PIN_ARM_6:
+                data |= PAI_GPIO_PIN_ARM_6;
+                break;
+
+            case PC302_GPIO_PIN_ARM_7:
+                data |= PAI_GPIO_PIN_ARM_7;
+                break;
+
+            default:
+                break;
+        }
+        /* Write the updated value to the pai_io_ctrl register */
+        ret = picoif_config_write( 0, PC302_PAI_CAEID,
+                                   PC302_PAI_IO_CTRL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to write to the PAI "
+                                "io_ctrl register.\n");
+            return ret;
+        }
+    }
+    else if ( ( pin >= PC302_GPIO_PIN_SDGPIO_4 ) &&
+              ( pin <= PC302_GPIO_PIN_SDGPIO_7 ) )
+    {
+        /* We are muxing an sd gpio pin */
+        switch ( pin )
+        {
+            case PC302_GPIO_PIN_SDGPIO_4:
+                data |= PAI_SDGPIO_PIN_ARM_4;
+                break;
+
+            case PC302_GPIO_PIN_SDGPIO_5:
+                data |= PAI_SDGPIO_PIN_ARM_5;
+                break;
+
+            case PC302_GPIO_PIN_SDGPIO_6:
+                data |= PAI_SDGPIO_PIN_ARM_6;
+                break;
+
+            case PC302_GPIO_PIN_SDGPIO_7:
+                data |= PAI_SDGPIO_PIN_ARM_7;
+                break;
+
+            default:
+                break;
+        }
+        /* Write the updated value to the pai_io_ctrl register */
+        ret = picoif_config_write( 0, PC302_PAI_CAEID,
+                                   PC302_PAI_IO_CTRL_REG, 1, &data );
+        if ( 1 != ret )
+        {
+            printk( KERN_ALERT "failed to write to the PAI "
+                               "io_ctrl register.\n");
+            return ret;
+        }
+    }
+    else
+    {
+        /* We have been called with an out of range pin specified */
+        printk( KERN_DEBUG "pc302gpio: out of range gpio for "
+                            "pai muxing.\n");
+        return  -EINVAL;
+    }
+
+    return 0;
+}
+
+#ifdef CONFIG_CONFIGFS_FS
+/**
+ * Show the pin number for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc302gpio_show_pin( struct pc302gpio_cfs_pin *pin,
+                    char *buf )
+{
+    int ret;
+    spin_lock( &pc302gpio_priv.lock );
+    ret = snprintf( buf, PAGE_SIZE, "%d\n", pin->phys_pin->pin_num );
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Store the pin number for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to read the value from.
+ * \param count The number of bytes available to read.
+ *
+ * \return Returns the length read on success, negative on failure.
+ */
+static ssize_t
+pc302gpio_store_pin( struct pc302gpio_cfs_pin *pin,
+                     const char *buf,
+                     size_t count )
+{
+    unsigned pin_num;
+    int pad_num;
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+
+    ret = -EINVAL;
+    if ( pin->phys_pin->enabled )
+        goto out;
+
+    pin_num = simple_strtoul( buf, NULL, 10 );
+    pad_num = pc302gpio_get_pad( pin_num );
+
+    ret = -EINVAL;
+    if ( pad_num < 0 || pc302gpio_pads[ pad_num ] )
+        goto out;
+
+    ret = -EIO;
+    if ( set_pin_mux( pin_num ) )
+        goto out;
+
+    pin->phys_pin->pin_num = pin_num;
+    pc302gpio_pads[ pad_num ] = pin->phys_pin;
+    pin->phys_pin->pad = pad_num;
+
+    ret = strlen( buf );
+out:
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Show the enabled state for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc302gpio_show_enabled( struct pc302gpio_cfs_pin *pin,
+                        char *buf )
+{
+    int ret;
+    spin_lock( &pc302gpio_priv.lock );
+    ret = snprintf( buf, PAGE_SIZE, "%d\n", pin->phys_pin->enabled );
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Store the enabled state for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to read the value from.
+ * \param count The number of bytes available to read.
+ *
+ * \return Returns the length read on success, negative on failure.
+ */
+static ssize_t
+pc302gpio_store_enabled( struct pc302gpio_cfs_pin *pin,
+                         const char *buf,
+                         size_t count )
+{
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+    ret = pc302gpio_set_direction( pin->phys_pin, pin->phys_pin->is_input );
+
+    if ( !ret )
+    {
+        pin->phys_pin->enabled = !!simple_strtoul( buf, NULL, 10 );
+        ret = strlen( buf );
+    }
+    else
+        ret = -EINVAL;
+
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Show the direction for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc302gpio_show_is_input( struct pc302gpio_cfs_pin *pin,
+                          char *buf )
+{
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+    ret = snprintf( buf, PAGE_SIZE, "%d\n", pin->phys_pin->is_input );
+    spin_unlock( &pc302gpio_priv.lock );
+
+    return ret;
+}
+
+/**
+ * Store the direction for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to read the value from.
+ * \param count The number of bytes available to read.
+ *
+ * \return Returns the length read on success, negative on failure.
+ */
+static ssize_t
+pc302gpio_store_is_input( struct pc302gpio_cfs_pin *pin,
+                           const char *buf,
+                           size_t count )
+{
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+
+    ret = -EINVAL;
+    if ( pin->phys_pin->enabled )
+        goto out;
+
+    pin->phys_pin->is_input = simple_strtoul( buf, NULL, 10 );
+    pc302gpio_set_direction( pin->phys_pin, pin->phys_pin->is_input );
+
+    ret = strlen( buf );
+out:
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Show the name of the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc302gpio_show_name( struct pc302gpio_cfs_pin *pin,
+                     char *buf )
+{
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+    ret = snprintf( buf, PAGE_SIZE, "%s\n", pin->phys_pin->name );
+    spin_unlock( &pc302gpio_priv.lock );
+
+    return ret;
+}
+
+/**
+ * Show the pad number of the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc302gpio_show_pad( struct pc302gpio_cfs_pin *pin,
+                    char *buf )
+{
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+    ret = snprintf( buf, PAGE_SIZE, "%d\n", pin->phys_pin->pad );
+    spin_unlock( &pc302gpio_priv.lock );
+
+    return ret;
+}
+
+/**
+ * Show the value of the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to write the value in.
+ *
+ * \return Returns the number of bytes written.
+ */
+static ssize_t
+pc302gpio_show_value( struct pc302gpio_cfs_pin *pin,
+                      char *buf )
+{
+    int ret;
+
+    spin_lock( &pc302gpio_priv.lock );
+    if ( pin->phys_pin->is_input )
+    {
+        ret = pc302gpio_get_value( pin->phys_pin );
+        if ( ret < 0 )
+            goto out;
+    }
+    else
+        ret = pin->phys_pin->value;
+
+    ret = snprintf( buf, PAGE_SIZE, "%d\n", ret );
+out:
+    spin_unlock( &pc302gpio_priv.lock );
+    return ret;
+}
+
+/**
+ * Store the value for the given GPIO pin.
+ *
+ * \param pin The configfs representation of the pin being queried.
+ * \param buf The buffer to read the value from.
+ * \param count The number of bytes available to read.
+ *
+ * \return Returns the length read on success, negative on failure.
+ */
+static ssize_t
+pc302gpio_store_value( struct pc302gpio_cfs_pin *pin,
+                       const char *buf,
+                       size_t count )
+{
+    int ret;
+    spin_lock( &pc302gpio_priv.lock );
+
+    if ( 1 != pin->phys_pin->enabled || pin->phys_pin->is_input )
+    {
+        spin_unlock( &pc302gpio_priv.lock );
+        return -EINVAL;
+    }
+
+    pin->phys_pin->value = !!simple_strtoul( buf, NULL, 10 );
+    ret = pc302gpio_set_value( pin->phys_pin, pin->phys_pin->value );
+
+    spin_unlock( &pc302gpio_priv.lock );
+
+    if ( ret < 0 )
+        return -EIO;
+
+    return strlen( buf );
+}
+
+/**
+ * Create a read-only attribute in configfs.
+ *
+ * \param _name The name of the attribute.
+ */
+#define PC302GPIO_PIN_ATTR_RO( _name ) \
+    static struct pc302gpio_pin_attr pc302gpio_pin_##_name = \
+        __CONFIGFS_ATTR( _name, S_IRUGO, pc302gpio_show_##_name, NULL )
+
+/**
+ * Create a read/write attribute in configfs.
+ *
+ * \param _name The name of the attribute.
+ */
+#define PC302GPIO_PIN_ATTR_RW( _name ) \
+    static struct pc302gpio_pin_attr pc302gpio_pin_##_name = \
+        __CONFIGFS_ATTR( _name, S_IRUGO | S_IWUSR, pc302gpio_show_##_name, \
+                        pc302gpio_store_##_name )
+
+/** Pin number attribute. */
+PC302GPIO_PIN_ATTR_RW( pin );
+/** Direction attribute (1 == input, 0 == output). */
+PC302GPIO_PIN_ATTR_RW( is_input );
+/** The value of the pin (RO if input, RW if output). */
+PC302GPIO_PIN_ATTR_RW( value );
+/** Enabled attribute. */
+PC302GPIO_PIN_ATTR_RW( enabled );
+/** Name attribute */
+PC302GPIO_PIN_ATTR_RO( name );
+/** Pad number attribute */
+PC302GPIO_PIN_ATTR_RO( pad );
+
+/** Attributes to be shown for each configfs pin. */
+static struct configfs_attribute *pc302gpio_pin_attrs[] = {
+    &pc302gpio_pin_pin.attr,
+    &pc302gpio_pin_is_input.attr,
+    &pc302gpio_pin_value.attr,
+    &pc302gpio_pin_enabled.attr,
+    &pc302gpio_pin_name.attr,
+    &pc302gpio_pin_pad.attr,
+    NULL,
+};
+
+/**
+ * From a configfs item, find the pin that it represents.
+ *
+ * \param item The configfs item.
+ * \return Returns a pointer to the pin on success, NULL on failure.
+ */
+static struct pc302gpio_cfs_pin *
+to_pin( struct config_item *item )
+{
+    return item ? container_of( item, struct pc302gpio_cfs_pin, item ) : NULL;
+}
+
+/**
+ * Show an attribute of a configfs pin.
+ *
+ * \param item The item that we want to see the attribute of.
+ * \param attr The attribute to show.
+ * \param buf The buffer to store the value in.
+ * \return Returns the number of bytes written to the buffer.
+ */
+static ssize_t
+pc302gpio_pin_attr_show( struct config_item *item,
+                            struct configfs_attribute *attr,
+                            char *buf )
+{
+    ssize_t ret = -EINVAL;
+    struct pc302gpio_cfs_pin *pin = to_pin( item );
+    struct pc302gpio_pin_attr *attribute =
+        container_of( attr, struct pc302gpio_pin_attr, attr );
+
+    if ( attribute->show )
+        ret = attribute->show( pin, buf );
+
+    return ret;
+}
+
+/**
+ * Store the value of an attribute in a configfs pin.
+ *
+ * \param item The item that we want to store the attribute value in.
+ * \param attr The attribute that we want to set.
+ * \param buf The value that we want to set.
+ * \param count The number of bytes in the value buffer.
+ * \return Returns the number of bytes read from the buffer.
+ */
+static ssize_t
+pc302gpio_pin_attr_store( struct config_item *item,
+                             struct configfs_attribute *attr,
+                             const char *buf,
+                             size_t count )
+{
+    ssize_t ret = -EINVAL;
+    struct pc302gpio_cfs_pin *pin = to_pin( item );
+    struct pc302gpio_pin_attr *attribute =
+        container_of( attr, struct pc302gpio_pin_attr, attr );
+
+    if ( attribute->show )
+        ret = attribute->store( pin, buf, count );
+
+    return ret;
+}
+
+/**
+ * Release a configfs pin.
+ *
+ * \param item The item to release. This frees the GPIO pin up for reuse.
+ */
+static void
+pc302gpio_pin_release( struct config_item *item )
+{
+    unsigned i;
+    struct pc302gpio_cfs_pin *t = to_pin( item );
+
+    for ( i = 0; i < PC302_GPIO_NUM_PADS; ++i )
+        if ( pc302gpio_pads[ i ] == t->phys_pin )
+        {
+            pc302gpio_free_pin( pc302gpio_pads[ i ] );
+            pc302gpio_pads[ i ] = NULL;
+        }
+
+    kfree( to_pin( item ) );
+}
+
+/** Operations that can happen on a configfs pin. */
+static struct configfs_item_operations pc302gpio_pin_item_ops = {
+    .release = pc302gpio_pin_release,
+    .show_attribute = pc302gpio_pin_attr_show,
+    .store_attribute = pc302gpio_pin_attr_store,
+};
+
+/** Description of a configfs GPIO pin and its associated attributes. */
+static struct config_item_type pc302gpio_cfs_pin_type = {
+    .ct_attrs = pc302gpio_pin_attrs,
+    .ct_item_ops = &pc302gpio_pin_item_ops,
+    .ct_owner = THIS_MODULE,
+};
+
+
+/**
+ * Create a new configfs pin. This will be called when the user calls mkdir()
+ * in /config/pc302gpio.
+ *
+ * \param group Not used.
+ * \param name The name of the new entry.
+ * \return Returns a pointer to the new entry on success, NULL on failure.
+ */
+static struct config_item *
+make_pc302gpio_pin( struct config_group *group,
+                    const char *name )
+{
+    struct pc302gpio_cfs_pin *t;
+    char tmp_buf[ PC302_GPIO_PIN_NAME_MAX ];
+
+    t = kzalloc( sizeof( *t ), GFP_KERNEL );
+    if ( !t )
+    {
+        printk( KERN_ERR "pc302gpio: failed to allocate memory\n" );
+        return NULL;
+    }
+    memset( t, sizeof( *t ), 0 );
+
+    snprintf( tmp_buf, sizeof( tmp_buf ) - 1, "configfs/%s", name );
+    t->phys_pin = pc302gpio_alloc_pin( tmp_buf );
+    if ( !t->phys_pin )
+    {
+        printk( KERN_ERR "pc302gpio: failed to allocate memory\n" );
+        kfree( t );
+        return NULL;
+    }
+
+    config_item_init_type_name( &t->item, name, &pc302gpio_cfs_pin_type );
+
+    return &t->item;
+}
+
+/**
+ * Drop a configfs pin. If the reference count reaches zero, the pin will be
+ * released.
+ *
+ * \param group Not used.
+ * \param item The item being dropped.
+ */
+static void
+drop_pc302gpio_pin( struct config_group *group,
+                    struct config_item *item )
+{
+    struct pc302gpio_cfs_pin *t = to_pin( item );
+
+    config_item_put( &t->item );
+}
+
+/** Operations table to describe how to create and drop pins through
+ *  configfs. */
+static struct configfs_group_operations pc302gpio_subsys_group_ops = {
+    .make_item = make_pc302gpio_pin,
+    .drop_item = drop_pc302gpio_pin,
+};
+
+/**
+ * Description of the pc302gpio configfs subsystem type. */
+static struct config_item_type pc302gpio_subsys_type = {
+    .ct_group_ops = &pc302gpio_subsys_group_ops,
+    .ct_owner = THIS_MODULE,
+};
+
+/** The configfs subsystem itself. */
+static struct configfs_subsystem pc302gpio_subsys = {
+    .su_group = {
+        .cg_item = {
+            .ci_namebuf = "pc302gpio",
+            .ci_type = &pc302gpio_subsys_type,
+        },
+    },
+};
+#endif /* CONFIG_CONFIGFS_FS */
+
+#ifdef CONFIG_DEBUG_FS
+static void *
+pc302gpio_seq_start( struct seq_file *f,
+                     loff_t *pos )
+{
+    return ( *pos < PC302_GPIO_NUM_PADS ) ? pos : NULL;
+}
+
+static void *
+pc302gpio_seq_next( struct seq_file *f,
+                    void *v,
+                    loff_t *pos )
+{
+    ( *pos )++;
+    if ( *pos >= PC302_GPIO_NUM_PADS )
+        return NULL;
+    return pos;
+}
+
+static void
+pc302gpio_seq_stop( struct seq_file *f,
+                    void *v )
+{
+    /* This function is intentionally left blank. */
+}
+
+static int
+pc302gpio_seq_show( struct seq_file *pi,
+                    void *v )
+{
+    unsigned pad_num = *( unsigned * )v;
+
+    if ( 0 == pad_num )
+        seq_printf( pi, "%-3s  %-3s  %-16s  %-s\n", "pin", "pad", "name",
+                    "is_input" );
+
+    if ( pc302gpio_pads[ pad_num ] )
+    {
+        seq_printf( pi, "%-3d  %-3d  %-16s  %-d\n",
+                    pc302gpio_pads[ pad_num]->pin_num, pad_num,
+                    pc302gpio_pads[ pad_num ]->name,
+                    pc302gpio_pads[ pad_num ]->is_input ? 1 : 0 );
+    }
+
+    return 0;
+}
+
+static struct seq_operations pc302gpio_seq_ops = {
+    .start = pc302gpio_seq_start,
+    .next  = pc302gpio_seq_next,
+    .stop  = pc302gpio_seq_stop,
+    .show  = pc302gpio_seq_show,
+};
+
+static int
+pc302gpio_debugfs_open( struct inode *inode,
+                       struct file *filp )
+{
+    return seq_open( filp, &pc302gpio_seq_ops );
+}
+
+static struct file_operations pc302gpio_debugfs_ops = {
+    .open    = pc302gpio_debugfs_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = seq_release,
+};
+
+static int
+pc302gpio_debugfs_init( void )
+{
+    pc302gpio_priv.debugfs_dir = debugfs_create_dir( "pc302gpio", NULL );
+    if ( !pc302gpio_priv.debugfs_dir )
+        return -ENOMEM;
+
+    if ( !debugfs_create_file( "list", 0444, pc302gpio_priv.debugfs_dir, NULL,
+                               &pc302gpio_debugfs_ops ) )
+    {
+        debugfs_remove( pc302gpio_priv.debugfs_dir );
+        return -ENOMEM;
+    }
+
+    debugfs_create_u32( "boot_mode", 0555, pc302gpio_priv.debugfs_dir,
+                        &boot_mode );
+
+    return 0;
+}
+
+static void
+pc302gpio_debugfs_exit( void )
+{
+    debugfs_remove_recursive( pc302gpio_priv.debugfs_dir );
+}
+#endif /* CONFIG_DEBUG_FS */
+
+#ifndef MODULE
+static void
+pc302gpio_irq_enable(unsigned int irq)
+{
+    int gpio = (int)get_irq_data(irq);
+    void *port_inten;
+    u32 val;
+
+    port_inten = (pc302gpio_priv.mem_region + GPIO_INT_EN_REG_OFFSET);
+
+    val = ioread32(port_inten);
+    val |= (1 << gpio);
+
+    iowrite32(val, port_inten);
+
+    val = ioread32(__io(IO_ADDRESS(PC302_VIC1_BASE
+                                   + VIC_INT_ENABLE_REG_OFFSET)));
+    val |= (1 << irq);
+    iowrite32(val,
+              __io(IO_ADDRESS(PC302_VIC1_BASE + VIC_INT_ENABLE_REG_OFFSET)));
+}
+
+static void
+pc302gpio_irq_disable(unsigned int irq)
+{
+    int gpio = (int)get_irq_data(irq);
+    void *port_inten;
+    u32 val;
+
+    port_inten = (pc302gpio_priv.mem_region + GPIO_INT_EN_REG_OFFSET);
+
+    val = ioread32(port_inten);
+    val &= ~(1 << gpio);
+
+    iowrite32(val, port_inten);
+
+    val = ioread32(__io(IO_ADDRESS(PC302_VIC1_BASE
+                                   + VIC_INT_ENABLE_CLEAR_REG_OFFSET)));
+    val |= (1 << irq);
+    iowrite32(val,
+              __io(IO_ADDRESS(PC302_VIC1_BASE
+                              + VIC_INT_ENABLE_CLEAR_REG_OFFSET)));
+}
+
+static void
+pc302gpio_irq_mask(unsigned int irq)
+{
+    int gpio = (int)get_irq_data(irq);
+    void *port_intmask;
+    u32 val;
+
+    port_intmask = (pc302gpio_priv.mem_region + GPIO_INT_MASK_REG_OFFSET);
+
+    val = ioread32(port_intmask);
+    val |= (1 << gpio);
+
+    iowrite32(val, port_intmask);
+
+    val = ioread32(__io(IO_ADDRESS(PC302_VIC1_BASE
+                                   + VIC_INT_ENABLE_CLEAR_REG_OFFSET)));
+    val |= (1 << irq);
+    iowrite32(val,
+              __io(IO_ADDRESS(PC302_VIC1_BASE
+                              + VIC_INT_ENABLE_CLEAR_REG_OFFSET)));
+}
+
+static void
+pc302gpio_irq_ack(unsigned int irq)
+{
+    int gpio = (int)get_irq_data(irq);
+    void *port_intmask, *port_eoi, *port_inttype_level;
+    u32 val;
+
+    port_intmask = (pc302gpio_priv.mem_region + GPIO_INT_MASK_REG_OFFSET);
+    port_inttype_level = (pc302gpio_priv.mem_region
+                          + GPIO_INT_TYPE_LEVEL_REG_OFFSET);
+    port_eoi = (pc302gpio_priv.mem_region + GPIO_PORT_A_EOI_REG_OFFSET);
+
+    val = ioread32(port_inttype_level);
+
+    if (val & (1 << gpio))
+    {
+        /* Edge-sensitive */
+        val = ioread32(port_eoi);
+        val |= (1 << gpio);
+        iowrite32(val, port_eoi);
+    }
+    else
+    {
+        /* Level-sensitive */
+        val = ioread32(port_intmask);
+        val |= (1 << gpio);
+        iowrite32(val, port_intmask);
+    }
+
+}
+
+static void
+pc302gpio_irq_unmask(unsigned int irq)
+{
+    int gpio = (int)get_irq_data(irq);
+    void *port_intmask;
+    u32 val;
+
+    port_intmask = (pc302gpio_priv.mem_region + GPIO_INT_MASK_REG_OFFSET);
+
+    val = ioread32(port_intmask);
+    val &= ~(1 << gpio);
+
+    iowrite32(val, port_intmask);
+
+    val = ioread32(__io(IO_ADDRESS(PC302_VIC1_BASE
+                                   + VIC_INT_ENABLE_REG_OFFSET)));
+    val |= (1 << irq);
+    iowrite32(val,
+              __io(IO_ADDRESS(PC302_VIC1_BASE + VIC_INT_ENABLE_REG_OFFSET)));
+}
+
+static int
+pc302gpio_irq_set_type(unsigned int irq, unsigned int trigger)
+{
+    int gpio = (int)get_irq_data(irq);
+    void *port_inttype_level;
+    void *port_int_polarity;
+    u32 level, polar;
+    void *handler = handle_level_irq;
+
+    if (trigger & ~(IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING
+                    | IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW))
+        return -EINVAL;
+
+    port_inttype_level = (pc302gpio_priv.mem_region
+                          + GPIO_INT_TYPE_LEVEL_REG_OFFSET);
+    port_int_polarity = (pc302gpio_priv.mem_region
+                         + GPIO_INT_POLARITY_REG_OFFSET);
+
+    level = ioread32(port_inttype_level);
+    polar = ioread32(port_int_polarity);
+
+    if (trigger & IRQ_TYPE_EDGE_RISING)
+    {
+        level |= (1 << gpio);
+        polar |= (1 << gpio);
+    }
+    else if (trigger & IRQ_TYPE_EDGE_FALLING)
+    {
+        level |= (1 << gpio);
+        polar &= ~(1 << gpio);
+    }
+    else if (trigger & IRQ_TYPE_LEVEL_HIGH)
+    {
+        level &= ~(1 << gpio);
+        polar |= (1 << gpio);
+    }
+    else if (trigger & IRQ_TYPE_LEVEL_LOW)
+    {
+        level &= ~(1 << gpio);
+        polar &= ~(1 << gpio);
+    }
+
+    iowrite32(level, port_inttype_level);
+    iowrite32(polar, port_int_polarity);
+
+    if ((trigger & IRQ_TYPE_EDGE_RISING) || (trigger & IRQ_TYPE_EDGE_RISING))
+        handler = handle_edge_irq;
+
+    __set_irq_handler_unlocked(irq, handler);
+
+    return 0;
+}
+
+static struct irq_chip pc302gpio_irqchip = {
+    .name     = "pc302gpio",
+    .ack      = pc302gpio_irq_ack,
+    .mask     = pc302gpio_irq_mask,
+    .unmask   = pc302gpio_irq_unmask,
+    .enable   = pc302gpio_irq_enable,
+    .disable  = pc302gpio_irq_disable,
+    .set_type = pc302gpio_irq_set_type,
+};
+
+static int
+pc302gpio_irq_setup(void)
+{
+    int irq;
+    int gpio;
+
+    for (irq = IRQ_GPIO0; irq <= IRQ_GPIO7; irq++)
+    {
+        gpio = (irq - IRQ_GPIO0) + PC302_GPIO_PIN_ARM_0;
+        set_irq_chip(irq, &pc302gpio_irqchip);
+        set_irq_data(irq, (void*)gpio);
+        set_irq_handler(irq, handle_level_irq);
+    }
+
+    return 0;
+}
+#endif /* MODULE */
+
+static int
+pc302gpio_ioctl( struct inode *inode,
+                 struct file *filp,
+                 unsigned int cmd,
+                 unsigned long arg )
+{
+    int ret;
+    struct pc302gpio_pin_allocation *pin;
+    picogpio_op_t op;
+    picogpio_analogue_config_t dac_cfg;
+
+    if ( _IOC_TYPE( cmd ) != PICOGPIO_IOCTL_BASE )
+    {
+        printk( KERN_DEBUG "pc302gpio: invalid command type\n" );
+        return -ENOTTY;
+    }
+
+    if ( _IOC_NR( cmd ) >
+            ( PICOGPIO_IOCTL_START + PICOGPIO_IOCTL_NUM_IOCTL ) ||
+         _IOC_NR( cmd ) < ( PICOGPIO_IOCTL_START ) )
+    {
+        printk( KERN_DEBUG "pc302gpio: invalid command\n" );
+        return -ENOTTY;
+    }
+
+    if ( cmd != PICOGPIO_ANALOGUE_CONFIG )
+        ret = copy_from_user( &op, ( void __user * )arg, sizeof( op ) );
+    else
+        ret = copy_from_user( &dac_cfg, ( void __user * )arg,
+                              sizeof( dac_cfg ) );
+
+    if ( ret )
+    {
+        printk( KERN_DEBUG "pc302gpio: failed to copy structure\n" );
+        return -EFAULT;
+    }
+
+    switch ( cmd )
+    {
+        case PICOGPIO_ACQUIRE:
+            ret = gpio_request( op.pin, "ioctl" );
+            break;
+
+        case PICOGPIO_RELEASE:
+            gpio_free( op.pin );
+            ret = 0;
+            break;
+
+        case PICOGPIO_SET_DIRECTION:
+            if ( PICOGPIO_INPUT == op.value )
+                ret = gpio_direction_input( op.pin );
+            else if ( PICOGPIO_OUTPUT == op.value )
+                ret = gpio_direction_output( op.pin, 0 );
+            else
+                ret = -EINVAL;
+            break;
+
+        case PICOGPIO_GET_DIRECTION:
+            pin = pc302gpio_find_pin( op.pin );
+            if ( pin )
+            {
+                op.value = pin->is_input ? PICOGPIO_INPUT : PICOGPIO_OUTPUT;
+                ret = copy_to_user( ( void __user * )arg, &op, sizeof( op ) );
+            }
+            break;
+
+        case PICOGPIO_SET_VALUE:
+            ret = gpio_set_value( op.pin, op.value );
+            break;
+
+        case PICOGPIO_GET_VALUE:
+            ret = gpio_get_value( op.pin );
+            if ( ret >= 0 )
+            {
+                op.value = ret;
+                ret = copy_to_user( ( void __user * )arg, &op, sizeof( op ) );
+            }
+            break;
+
+        case PICOGPIO_ANALOGUE_CONFIG:
+            ret = pc302gpio_configure_dac( dac_cfg.pin,
+                                           dac_cfg.converter_size,
+                                           dac_cfg.analogue_rate );
+            break;
+
+        default:
+            printk( KERN_DEBUG "pc302gpio: invalid ioctl(), cmd=%d\n", cmd );
+            ret = -EINVAL;
+            break;
+    }
+
+    return ret;
+}
+
+static int
+pc302gpio_open( struct inode *inode,
+                struct file *filp )
+{
+    return 0;
+}
+
+static int
+pc302gpio_release( struct inode *inode,
+                   struct file *filp )
+{
+    return 0;
+}
+
+static int pc302gpio_probe( struct platform_device *pdev );
+static int pc302gpio_remove( struct platform_device *pdev );
+
+static struct platform_driver pc302gpio_driver = {
+    .probe = pc302gpio_probe,
+    .remove = pc302gpio_remove,
+    .driver = {
+        .name = CARDNAME,
+    },
+};
+
+static int
+pc302gpio_probe( struct platform_device *pdev )
+{
+    int ret;
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+
+    if ( !mem )
+        return -EINVAL;
+
+    pc302gpio_priv.pdev = pdev;
+    pc302gpio_priv.pdrv = &pc302gpio_driver;
+
+    if ( !request_mem_region( mem->start, ( mem->end - mem->start ) + 1,
+                              CARDNAME ) )
+        return -EBUSY;
+
+    pc302gpio_priv.mem_region =
+        ioremap( mem->start, ( mem->end - mem->start ) + 1 );
+
+    if ( !pc302gpio_priv.mem_region )
+    {
+        ret = -EBUSY;
+        goto remap_failed;
+    }
+
+#ifndef MODULE
+    pc302gpio_irq_setup();
+#endif
+
+    ret = misc_register( &pc302gpio_priv.dev );
+
+    return ret;
+
+remap_failed:
+    release_mem_region( mem->start, ( mem->end - mem->start ) + 1 );
+
+    printk( KERN_ERR "PC302 GPIO driver registration failed\n" );
+
+    return ret;
+}
+
+static int
+pc302gpio_remove( struct platform_device *pdev )
+{
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+
+    misc_deregister( &pc302gpio_priv.dev );
+    iounmap( pc302gpio_priv.mem_region );
+    release_mem_region( mem->start, ( mem->end - mem->start ) + 1 );
+
+    return 0;
+}
+
+static int
+pc302gpio_init( void )
+{
+    int ret = -EINVAL;
+
+    u16 data = PC302_AXI2PICO_WAKE_UP;
+
+    /* Get the current boot mode. */
+    u32 syscfg = syscfg_read();
+    boot_mode = ( syscfg & AXI2CFG_SYS_CONFIG_BOOT_MODE_MASK ) >>
+        AXI2CFG_SYS_CONFIG_BOOT_MODE_LO;
+#ifdef CONFIG_CONFIGFS_FS
+    config_group_init( &pc302gpio_subsys.su_group );
+    mutex_init( &pc302gpio_subsys.su_mutex );
+    configfs_register_subsystem( &pc302gpio_subsys );
+#endif /* CONFIG_CONFIGFS_FS */
+
+#ifdef CONFIG_DEBUG_FS
+    pc302gpio_debugfs_init();
+#endif /* CONFIG_DEBUG_FS */
+
+    /* This driver can use the sdgpio, therefore before we do anything
+     * else we need to wake up the AXI2PICO block. */
+    ret = picoif_config_write( 0, PC302_AXI2PICO_CAEID,
+                               PC302_AXI2PICO_SLEEP_REG, 1, &data );
+    if ( 1 != ret )
+    {
+        printk( KERN_ALERT "failed to wake up the AXI2PICO block.\n");
+    }
+
+    ret = platform_driver_register( &pc302gpio_driver );
+    if ( 0 != ret )
+    {
+        printk(KERN_ERR "%s " CONFIG_LOCALVERSION " " __DATE__ " "  __TIME__
+               " failed to load\n", TITLE);
+        return ret;
+    }
+
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " " __DATE__ " "  __TIME__
+           " loaded\n", TITLE);
+
+    return ret;
+}
+
+static void
+pc302gpio_exit( void )
+{
+#ifdef CONFIG_CONFIGFS_FS
+    configfs_unregister_subsystem( &pc302gpio_subsys );
+#endif /* CONFIG_CONFIGFS_FS */
+
+#ifdef CONFIG_DEBUG_FS
+    pc302gpio_debugfs_exit();
+#endif /* CONFIG_DEBUGFS */
+
+    platform_driver_unregister( &pc302gpio_driver );
+
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " " __DATE__ " "  __TIME__
+           " unloaded\n", TITLE);
+}
+
+module_init( pc302gpio_init );
+module_exit( pc302gpio_exit );
+MODULE_AUTHOR( "Jamie Iles" );
+MODULE_LICENSE( "GPL" );
+MODULE_DESCRIPTION( "picoChip PC302 GPIO driver" );
diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c
index 7a3f243..92abb32 100644
--- a/drivers/mmc/host/atmel-mci.c
+++ b/drivers/mmc/host/atmel-mci.c
@@ -55,7 +55,6 @@ enum atmel_mci_state {
 
 struct atmel_mci_dma {
 #ifdef CONFIG_MMC_ATMELMCI_DMA
-	struct dma_client		client;
 	struct dma_chan			*chan;
 	struct dma_async_tx_descriptor	*data_desc;
 #endif
@@ -593,10 +592,8 @@ atmci_submit_data_dma(struct atmel_mci *host, struct mmc_data *data)
 
 	/* If we don't have a channel, we can't do DMA */
 	chan = host->dma.chan;
-	if (chan) {
-		dma_chan_get(chan);
+	if (chan)
 		host->data_chan = chan;
-	}
 
 	if (!chan)
 		return -ENODEV;
@@ -1600,6 +1597,18 @@ static void __exit atmci_cleanup_slot(struct atmel_mci_slot *slot,
 	mmc_free_host(slot->mmc);
 }
 
+#ifdef CONFIG_MMC_ATMELMCI_DMA
+static bool filter(struct dma_chan *chan, void *slave)
+{
+	struct dw_dma_slave *dws = slave;
+
+	if (dws->dma_dev == chan->device->dev)
+		return true;
+	else
+		return false;
+}
+#endif
+
 static int __init atmci_probe(struct platform_device *pdev)
 {
 	struct mci_platform_data	*pdata;
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index 2fadf32..378175d 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -470,7 +470,7 @@ static void mmci_check_status(unsigned long data)
 
 	status = host->plat->status(mmc_dev(host->mmc));
 	if (status ^ host->oldstat)
-		mmc_detect_change(host->mmc, 0);
+		mmc_detect_change(host->mmc, (msecs_to_jiffies(500)));
 
 	host->oldstat = status;
 	mod_timer(&host->timer, jiffies + HZ);
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 6659b22..d740e6a 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -525,7 +525,7 @@ static struct flash_info __devinitdata m25p_data [] = {
 	{ "m25p10",  0x202011,  0, 32 * 1024, 4, },
 	{ "m25p20",  0x202012,  0, 64 * 1024, 4, },
 	{ "m25p40",  0x202013,  0, 64 * 1024, 8, },
-	{ "m25p80",         0,  0, 64 * 1024, 16, },
+	{ "m25p80",  0x202014,  0, 64 * 1024, 16, },
 	{ "m25p16",  0x202015,  0, 64 * 1024, 32, },
 	{ "m25p32",  0x202016,  0, 64 * 1024, 64, },
 	{ "m25p64",  0x202017,  0, 64 * 1024, 128, },
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index 5ea1693..127e24c 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -540,5 +540,13 @@ config MTD_PLATRAM
 
 	  This selection automatically selects the map_ram driver.
 
+config MTD_PICOHDP
+	tristate "picoHDP Flash driver"
+	depends on MTD_CFI && (PICOHDP || PICOHDP203 || ARCH_FIRECRACKER || ARCH_PC302)
+	help
+	 This enables support for the on-board parallel flash memory on
+         picoChip hardware platforms.
+	 If you have one of these boards, say Y.
+
 endmenu
 
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 6d9ba35..40ff924 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -56,6 +56,7 @@ obj-$(CONFIG_MTD_IXP4XX)	+= ixp4xx.o
 obj-$(CONFIG_MTD_IXP2000)	+= ixp2000.o
 obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
 obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
+obj-$(CONFIG_MTD_PICOHDP)	+= picohdp.o
 obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
 obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
diff --git a/drivers/mtd/maps/integrator-flash.c b/drivers/mtd/maps/integrator-flash.c
index 7100ee3..756d0de 100644
--- a/drivers/mtd/maps/integrator-flash.c
+++ b/drivers/mtd/maps/integrator-flash.c
@@ -35,28 +35,34 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
+#include <linux/mtd/concat.h>
 
 #include <asm/mach/flash.h>
 #include <mach/hardware.h>
 #include <asm/io.h>
 #include <asm/system.h>
 
-#ifdef CONFIG_ARCH_P720T
-#define FLASH_BASE		(0x04000000)
-#define FLASH_SIZE		(64*1024*1024)
-#endif
+#define SUBDEV_NAME_SIZE	(BUS_ID_SIZE + 2)
 
-struct armflash_info {
+struct armflash_subdev_info {
+	char			name[SUBDEV_NAME_SIZE];
+	struct mtd_info		*mtd;
+	struct map_info		map;
 	struct flash_platform_data *plat;
+};
+
+struct armflash_info {
 	struct resource		*res;
 	struct mtd_partition	*parts;
 	struct mtd_info		*mtd;
-	struct map_info		map;
+	int			nr_subdev;
+	struct armflash_subdev_info subdev[0];
 };
 
 static void armflash_set_vpp(struct map_info *map, int on)
 {
-	struct armflash_info *info = container_of(map, struct armflash_info, map);
+	struct armflash_subdev_info *info =
+		container_of(map, struct armflash_subdev_info, map);
 
 	if (info->plat && info->plat->set_vpp)
 		info->plat->set_vpp(on);
@@ -64,32 +70,17 @@ static void armflash_set_vpp(struct map_info *map, int on)
 
 static const char *probes[] = { "cmdlinepart", "RedBoot", "afs", NULL };
 
-static int armflash_probe(struct platform_device *dev)
+static int armflash_subdev_probe(struct armflash_subdev_info *subdev,
+				 struct resource *res)
 {
-	struct flash_platform_data *plat = dev->dev.platform_data;
-	struct resource *res = dev->resource;
-	unsigned int size = res->end - res->start + 1;
-	struct armflash_info *info;
-	int err;
+	struct flash_platform_data *plat = subdev->plat;
+	resource_size_t size = res->end - res->start + 1;
 	void __iomem *base;
+	int err = 0;
 
-	info = kzalloc(sizeof(struct armflash_info), GFP_KERNEL);
-	if (!info) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	info->plat = plat;
-	if (plat && plat->init) {
-		err = plat->init();
-		if (err)
-			goto no_resource;
-	}
-
-	info->res = request_mem_region(res->start, size, "armflash");
-	if (!info->res) {
+	if (!request_mem_region(res->start, size, subdev->name)) {
 		err = -EBUSY;
-		goto no_resource;
+		goto out;
 	}
 
 	base = ioremap(res->start, size);
@@ -101,27 +92,132 @@ static int armflash_probe(struct platform_device *dev)
 	/*
 	 * look for CFI based flash parts fitted to this board
 	 */
-	info->map.size		= size;
-	info->map.bankwidth	= plat->width;
-	info->map.phys		= res->start;
-	info->map.virt		= base;
-	info->map.name		= dev->dev.bus_id;
-	info->map.set_vpp	= armflash_set_vpp;
+	subdev->map.size	= size;
+	subdev->map.bankwidth	= plat->width;
+	subdev->map.phys	= res->start;
+	subdev->map.virt	= base;
+	subdev->map.name	= subdev->name;
+	subdev->map.set_vpp	= armflash_set_vpp;
 
-	simple_map_init(&info->map);
+	simple_map_init(&subdev->map);
 
 	/*
 	 * Also, the CFI layer automatically works out what size
 	 * of chips we have, and does the necessary identification
 	 * for us automatically.
 	 */
-	info->mtd = do_map_probe(plat->map_name, &info->map);
-	if (!info->mtd) {
+	subdev->mtd = do_map_probe(plat->map_name, &subdev->map);
+	if (!subdev->mtd) {
 		err = -ENXIO;
 		goto no_device;
 	}
 
-	info->mtd->owner = THIS_MODULE;
+	subdev->mtd->owner = THIS_MODULE;
+
+	/* Successful? */
+	if (err == 0)
+		return err;
+
+	if (subdev->mtd)
+		map_destroy(subdev->mtd);
+ no_device:
+	iounmap(base);
+ no_mem:
+	release_mem_region(res->start, size);
+ out:
+	return err;
+}
+
+static void armflash_subdev_remove(struct armflash_subdev_info *subdev)
+{
+	if (subdev->mtd)
+		map_destroy(subdev->mtd);
+	if (subdev->map.virt)
+		iounmap(subdev->map.virt);
+	release_mem_region(subdev->map.phys, subdev->map.size);
+}
+
+static int armflash_probe(struct platform_device *dev)
+{
+	struct flash_platform_data *plat = dev->dev.platform_data;
+	unsigned int size;
+	struct armflash_info *info;
+	int i, nr, err;
+
+	/* Count the number of devices */
+	for (nr = 0; ; nr++)
+		if (!platform_get_resource(dev, IORESOURCE_MEM, nr))
+			break;
+	if (nr == 0) {
+		err = -ENODEV;
+		goto out;
+	}
+
+	size = sizeof(struct armflash_info) +
+		sizeof(struct armflash_subdev_info) * nr;
+	info = kzalloc(size, GFP_KERNEL);
+	if (!info) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	if (plat && plat->init) {
+		err = plat->init();
+		if (err)
+			goto no_resource;
+	}
+
+	for (i = 0; i < nr; i++) {
+		struct armflash_subdev_info *subdev = &info->subdev[i];
+		struct resource *res;
+
+		res = platform_get_resource(dev, IORESOURCE_MEM, i);
+		if (!res)
+			break;
+
+		if (nr == 1)
+			/* No MTD concatenation, just use the default name */
+			snprintf(subdev->name, SUBDEV_NAME_SIZE, "%s",
+				 dev_name(&dev->dev));
+		else
+			snprintf(subdev->name, SUBDEV_NAME_SIZE, "%s-%d",
+				 dev_name(&dev->dev), i);
+		subdev->plat = plat;
+
+		err = armflash_subdev_probe(subdev, res);
+		if (err)
+			break;
+	}
+	info->nr_subdev = i;
+
+	if (err)
+		goto subdev_err;
+
+	if (info->nr_subdev == 1)
+		info->mtd = info->subdev[0].mtd;
+	else if (info->nr_subdev > 1) {
+#ifdef CONFIG_MTD_CONCAT
+		struct mtd_info *cdev[info->nr_subdev];
+
+		/*
+		 * We detected multiple devices.  Concatenate them together.
+		 */
+		for (i = 0; i < info->nr_subdev; i++)
+			cdev[i] = info->subdev[i].mtd;
+
+		info->mtd = mtd_concat_create(cdev, info->nr_subdev,
+					      dev_name(&dev->dev));
+		if (info->mtd == NULL)
+			err = -ENXIO;
+#else
+		printk(KERN_ERR "armflash: multiple devices found but "
+		       "MTD concat support disabled.\n");
+		err = -ENXIO;
+#endif
+	}
+
+	if (err < 0)
+		goto cleanup;
 
 	err = parse_mtd_partitions(info->mtd, probes, &info->parts, 0);
 	if (err > 0) {
@@ -131,28 +227,30 @@ static int armflash_probe(struct platform_device *dev)
 			       "mtd partition registration failed: %d\n", err);
 	}
 
-	if (err == 0)
+	if (err == 0) {
 		platform_set_drvdata(dev, info);
+		return err;
+	}
 
 	/*
-	 * If we got an error, free all resources.
+	 * We got an error, free all resources.
 	 */
-	if (err < 0) {
-		if (info->mtd) {
-			del_mtd_partitions(info->mtd);
-			map_destroy(info->mtd);
-		}
-		kfree(info->parts);
-
- no_device:
-		iounmap(base);
- no_mem:
-		release_mem_region(res->start, size);
- no_resource:
-		if (plat && plat->exit)
-			plat->exit();
-		kfree(info);
+ cleanup:
+	if (info->mtd) {
+		del_mtd_partitions(info->mtd);
+#ifdef CONFIG_MTD_CONCAT
+		if (info->mtd != info->subdev[0].mtd)
+			mtd_concat_destroy(info->mtd);
+#endif
 	}
+	kfree(info->parts);
+ subdev_err:
+	for (i = info->nr_subdev - 1; i >= 0; i--)
+		armflash_subdev_remove(&info->subdev[i]);
+ no_resource:
+	if (plat && plat->exit)
+		plat->exit();
+	kfree(info);
  out:
 	return err;
 }
@@ -160,22 +258,26 @@ static int armflash_probe(struct platform_device *dev)
 static int armflash_remove(struct platform_device *dev)
 {
 	struct armflash_info *info = platform_get_drvdata(dev);
+	struct flash_platform_data *plat = dev->dev.platform_data;
+	int i;
 
 	platform_set_drvdata(dev, NULL);
 
 	if (info) {
 		if (info->mtd) {
 			del_mtd_partitions(info->mtd);
-			map_destroy(info->mtd);
+#ifdef CONFIG_MTD_CONCAT
+			if (info->mtd != info->subdev[0].mtd)
+				mtd_concat_destroy(info->mtd);
+#endif
 		}
 		kfree(info->parts);
 
-		iounmap(info->map.virt);
-		release_resource(info->res);
-		kfree(info->res);
+		for (i = info->nr_subdev - 1; i >= 0; i--)
+			armflash_subdev_remove(&info->subdev[i]);
 
-		if (info->plat && info->plat->exit)
-			info->plat->exit();
+		if (plat && plat->exit)
+			plat->exit();
 
 		kfree(info);
 	}
diff --git a/drivers/mtd/maps/picohdp.c b/drivers/mtd/maps/picohdp.c
new file mode 100644
index 0000000..56159f0
--- /dev/null
+++ b/drivers/mtd/maps/picohdp.c
@@ -0,0 +1,186 @@
+/*
+ * picoHDP flash mappings (128M version)
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * David Warman <david.warman@zetetica.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * 29082006 - Ben Tucker, ported to the pc20x.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+/* PC20x based platforms */
+#if defined(CONFIG_MACH_PC72052_I10_REVA) || \
+    defined(CONFIG_MACH_PC72052_I10_REVB) || \
+    defined(CONFIG_MACH_FIRECRACKER_SVB)  || \
+    defined(CONFIG_MACH_PC7802)
+
+#include <asm/sizes.h>
+#include <mach/platform.h>
+
+/* Partitioning used on the PC20x based platforms (SVB20x/CPE20x) */
+#define FLASH_BASE          FIRECRACKER_FLASH_BASE
+#define FLASH_SIZE          FIRECRACKER_FLASH_SIZE
+#define FLASH_WIDTH         FIRECRACKER_FLASH_WIDTH
+
+/* Bootloader at start */
+#define FLASH_ADDR_BOOT     FLASH_BASE
+#define FLASH_SIZE_BOOT     SZ_256K
+
+/* Bootloader environment follows bootloader */
+#define FLASH_ADDR_BOOTENV  (FLASH_ADDR_BOOT + FLASH_SIZE_BOOT)
+#define FLASH_SIZE_BOOTENV  SZ_256K
+
+/* Kernel follows... */
+#define FLASH_ADDR_KERNEL   (FLASH_ADDR_BOOTENV + FLASH_SIZE_BOOTENV)
+#define FLASH_SIZE_KERNEL   SZ_2M
+
+/* Filesystem takes up the rest of the flash */
+#define FLASH_ADDR_JFFS2    (FLASH_ADDR_KERNEL + FLASH_SIZE_KERNEL)
+#define FLASH_SIZE_JFFS2    MTDPART_SIZ_FULL    /* The rest of the available
+                                                   flash (~125.5 Mbytes). */
+#define FLASH_PARTITIONS    4
+
+/* PC302 based platforms */
+#elif defined(CONFIG_MACH_PC7302)
+
+#include <asm/sizes.h>
+#include <mach/platform.h>
+
+/* Partitioning used on the PC302 based platforms (SVB302/PC7302) */
+#define FLASH_BASE          PC302_FLASH_BASE
+#define FLASH_SIZE          PC302_FLASH_SIZE
+#define FLASH_WIDTH         PC302_FLASH_WIDTH
+
+/* Bootloader at start */
+#define FLASH_ADDR_BOOT     FLASH_BASE
+#define FLASH_SIZE_BOOT     SZ_128K
+
+/* Bootloader environment follows bootloader */
+#define FLASH_ADDR_BOOTENV  (FLASH_ADDR_BOOT + FLASH_SIZE_BOOT)
+#define FLASH_SIZE_BOOTENV  SZ_128K
+
+/* Kernel follows... */
+#define FLASH_ADDR_KERNEL   (FLASH_ADDR_BOOTENV + FLASH_SIZE_BOOTENV)
+#define FLASH_SIZE_KERNEL   SZ_2M
+
+/* Filesystem takes up the rest of the flash */
+#define FLASH_ADDR_JFFS2    (FLASH_ADDR_KERNEL + FLASH_SIZE_KERNEL)
+#define FLASH_SIZE_JFFS2    MTDPART_SIZ_FULL    /* The rest of the available
+                                                   flash (~62.75 Mbytes). */
+#define FLASH_PARTITIONS    4
+
+#else
+
+/* Partitioning used on the PPC based platforms (HDP102/HDP203) */
+
+#define FLASH_BASE          0xF8000000
+#define FLASH_SIZE          0x08000000
+#define FLASH_WIDTH         4
+
+#define FLASH_ADDR_JFFS2    0xF8000000
+#define FLASH_SIZE_JFFS2    0x07E00000
+
+#define FLASH_ADDR_KERNEL   0xFFE00000
+#define FLASH_SIZE_KERNEL   0x00180000
+
+#define FLASH_ADDR_BOOTENV  0xFFF80000
+#define FLASH_SIZE_BOOTENV  0x00040000
+
+#define FLASH_ADDR_BOOT     0xFFFC0000
+#define FLASH_SIZE_BOOT     0x00040000
+
+#define FLASH_PARTITIONS    4
+
+#endif
+
+/* partition_info gives details on the logical partitions that the split the
+ * single flash device into.
+ */
+static struct mtd_partition partition_info[]={
+    {
+        .name   = "Application",
+        .offset = FLASH_ADDR_JFFS2 - FLASH_BASE,
+        .size   = FLASH_SIZE_JFFS2
+    },
+    {
+        .name   = "Kernel",
+        .offset = FLASH_ADDR_KERNEL - FLASH_BASE,
+        .size   = FLASH_SIZE_KERNEL
+    },
+    {
+        .name   = "Boot Environment",
+        .offset = FLASH_ADDR_BOOTENV - FLASH_BASE,
+        .size   = FLASH_SIZE_BOOTENV
+    },
+    {
+        .name   = "Boot",
+        .offset = FLASH_ADDR_BOOT - FLASH_BASE,
+        .size   = FLASH_SIZE_BOOT
+    }
+};
+
+
+static struct mtd_info *mymtd;
+
+struct map_info picohdp_map = {
+    .name = "picoFlash",
+    .size = FLASH_SIZE,
+    .phys = FLASH_BASE,
+    .bankwidth = FLASH_WIDTH,
+};
+
+int __init init_picohdp(void)
+{
+    printk(KERN_NOTICE "picoFlash: 0x%x at 0x%x\n",
+            FLASH_SIZE, FLASH_BASE);
+    picohdp_map.virt = ioremap(FLASH_BASE, FLASH_SIZE);
+
+    if (!picohdp_map.virt) {
+        printk("Failed to ioremap\n");
+        return -EIO;
+    }
+    simple_map_init(&picohdp_map);
+
+    mymtd = do_map_probe("cfi_probe", &picohdp_map);
+    if (mymtd) {
+        mymtd->owner = THIS_MODULE;
+        add_mtd_device(mymtd);
+        add_mtd_partitions(mymtd, partition_info, FLASH_PARTITIONS);
+        return 0;
+    }
+
+    iounmap((void *)picohdp_map.virt);
+    return -ENXIO;
+}
+
+static void __exit cleanup_picohdp(void)
+{
+    if (mymtd) {
+        del_mtd_device(mymtd);
+        map_destroy(mymtd);
+    }
+    if (picohdp_map.virt) {
+        iounmap((void *)picohdp_map.virt);
+        picohdp_map.virt = 0;
+    }
+}
+
+module_init(init_picohdp);
+module_exit(cleanup_picohdp);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Warman <david.warman@zetetica.co.uk>");
+MODULE_DESCRIPTION("MTD map for picoChip development platforms");
diff --git a/drivers/mtd/mtdconcat.c b/drivers/mtd/mtdconcat.c
index 789842d..1a05cf3 100644
--- a/drivers/mtd/mtdconcat.c
+++ b/drivers/mtd/mtdconcat.c
@@ -691,7 +691,7 @@ static int concat_block_markbad(struct mtd_info *mtd, loff_t ofs)
  */
 struct mtd_info *mtd_concat_create(struct mtd_info *subdev[],	/* subdevices to concatenate */
 				   int num_devs,	/* number of subdevices      */
-				   char *name)
+				   const char *name)
 {				/* name for the new device   */
 	int i;
 	size_t size;
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 1c2e945..a52526e 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -80,6 +80,13 @@ config MTD_NAND_TS7250
 	help
 	  Support for NAND flash on Technologic Systems TS-7250 platform.
 
+config MTD_NAND_PC7302
+        tristate "NAND Flash device on the picoChip PC7302 platform"
+	depends on MACH_PC7302
+	help
+	  Support for NAND flash on the picoChip PC7302 platform.
+
+
 config MTD_NAND_IDS
 	tristate
 
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index b661586..02c2436 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_MTD_NAND_H1900)		+= h1910.o
 obj-$(CONFIG_MTD_NAND_RTC_FROM4)	+= rtc_from4.o
 obj-$(CONFIG_MTD_NAND_SHARPSL)		+= sharpsl.o
 obj-$(CONFIG_MTD_NAND_TS7250)		+= ts7250.o
+obj-$(CONFIG_MTD_NAND_PC7302)		+= mt29f2g08aadwp.o
 obj-$(CONFIG_MTD_NAND_NANDSIM)		+= nandsim.o
 obj-$(CONFIG_MTD_NAND_CS553X)		+= cs553x_nand.o
 obj-$(CONFIG_MTD_NAND_NDFC)		+= ndfc.o
diff --git a/drivers/mtd/nand/mt29f2g08aadwp.c b/drivers/mtd/nand/mt29f2g08aadwp.c
new file mode 100644
index 0000000..e9b362e
--- /dev/null
+++ b/drivers/mtd/nand/mt29f2g08aadwp.c
@@ -0,0 +1,340 @@
+/* Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * mt29f2g08aadwp.c - Micron MT29F2G08AADWP NAND flash MTD driver FOR PC302
+ *
+ * Authors: Eric Le Bihan <eric.lebihan@sagem.com>
+ *
+ * Copyright (c) 2009 SAGEM
+ *
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/gpio.h>
+#include <asm/io.h>
+
+#include <mach/pc302/pc302.h>
+
+/* Macros ------------------------------------------------------------------ */
+#define NAND_BASE_ADDRESS EBI_CS2_BASE
+#define NAND_SIZE         (2 * SZ_1K)
+
+/* Define which gpio bits are used to control the NAND Flash on the
+ * PC7302 PLatform.
+ *
+ * Note: These pin definitions mean that we can only use NAND
+ *       Flash if we are running from RAM and have NOT booted
+ *       the device from parallel NOR Flash.
+ *
+ * Note: These GPIO bits are all ARM GPIO bits.
+ */
+#define CLE     4
+#define ALE     3
+#define NCE     2
+#define READY   1
+
+/* Constants --------------------------------------------------------------- */
+static struct mtd_info *mt29f2g08aadwp_mtd;
+static void __iomem *base_address;
+static unsigned int  scan_done = 0;
+
+/*
+ * Define partitions for flash devices
+ */
+static struct mtd_partition partition_info[] = {
+	{ .name		= "Boot",
+	  .offset	= 0,
+	  .size		= SZ_128K
+        },
+        { .name		= "Redundant Boot",
+	  .offset	= SZ_128K,
+	  .size		= SZ_128K
+        },
+        { .name		= "Boot Environment",
+	  .offset	= SZ_128K * 4,
+	  .size		= SZ_128K
+        },
+        { .name		= "Redundant Boot Environment",
+	  .offset	= SZ_128K * 5,
+	  .size		= SZ_128K
+        },
+        { .name		= "Kernel",
+	  .offset	= SZ_1M,
+	  .size		= 2 * SZ_1M
+        },
+        { .name		= "File System",
+	  .offset	= MTDPART_OFS_APPEND,
+	  .size		= 64 * SZ_1M
+        },
+        { .name		= "Data",
+	  .offset	= MTDPART_OFS_APPEND,
+	  .size		= MTDPART_SIZ_FULL
+        },
+};
+
+#define NUM_PARTITIONS 7
+
+#define MSG_PFX "mt29f2g08aadwp: "
+
+/* Prototypes--------------------------------------------------------------- */
+
+/*!
+ * \brief Hardware specific access to control-lines of the NAND Flash.
+ *
+ * \param mtd, pointer to the mtd_info structure
+ * \param dat, data to write to the device
+ * \param ctrl, control data to set up the transaction
+ *
+ */
+static void mt29f2g08aadwp_cmd_ctrl(struct mtd_info *mtd,
+				    int dat,
+				    unsigned int ctrl);
+
+/*!
+ * \brief Return the state of the NAND busy output.
+ *
+ * \param mtd, pointer to the mtd_info structure
+ * \return 0 - nand busy
+ *         1 - nand ready
+ *
+ */
+static int mt29f2g08aadwp_dev_ready(struct mtd_info *mtd);
+
+/*!
+ * \brief Module initialisation function.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int __init mt29f2g08aadwp_nand_init(void);
+
+/*!
+ * \brief Module exit function.
+ */
+static void mt29f2g08aadwp_nand_exit(void);
+
+/* Functions --------------------------------------------------------------- */
+
+static void mt29f2g08aadwp_cmd_ctrl(struct mtd_info *mtd,
+				    int dat,
+				    unsigned int ctrl)
+{
+
+	register struct nand_chip *this = mtd->priv;
+	int err = -1;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+
+		if (ctrl & NAND_NCE) {
+
+			err = gpio_set_value(NCE, 0);
+
+			if (err)
+				printk(KERN_WARNING MSG_PFX
+				       "GPIO for nCE can not be set to 0 "
+                                       "(%d)\n",
+				       err);
+
+			if (ctrl & NAND_CLE)
+				err = gpio_set_value(CLE, 1);
+			else
+				err = gpio_set_value(CLE, 0);
+
+			if (err)
+				printk(KERN_WARNING MSG_PFX
+				       "GPIO for CLE can not be set (%d)\n",
+				       err);
+
+			if (ctrl & NAND_ALE)
+				err = gpio_set_value(ALE, 1);
+			else
+				err = gpio_set_value(ALE, 0);
+
+			if (err)
+				printk(KERN_WARNING MSG_PFX
+				       "GPIO for ALE can not be set (%d)\n",
+				       err);
+
+		} else {
+			err = gpio_set_value(NCE, 1);
+
+			if (err)
+				printk(KERN_WARNING MSG_PFX
+				       "GPIO for nCE can not be set to 1 "
+                                       "(%d)\n",
+				       err);
+		}
+	}
+
+	if (dat != NAND_CMD_NONE)
+		writeb(dat, this->IO_ADDR_W);
+}
+
+static int mt29f2g08aadwp_dev_ready(struct mtd_info *mtd)
+{
+	return gpio_get_value(READY)? 1 : 0;
+}
+
+static int __init mt29f2g08aadwp_nand_init(void)
+{
+	struct nand_chip *this;
+	int err = 0;
+
+	/* Set GPIOs */
+	err = gpio_request(READY, "NAND R/B");
+	if (err)
+		return -EIO;
+
+	err = gpio_request(NCE, "NAND nCE");
+	if (err)
+		return -EIO;
+
+	err = gpio_request(ALE, "NAND ALE");
+	if (err)
+		return -EIO;
+
+	err = gpio_request(CLE, "NAND CLE");
+	if (err)
+		return -EIO;
+
+	err = gpio_direction_input(READY);
+	if (err)
+		return -EIO;
+
+	err = gpio_direction_output(NCE, 1);
+	if (err)
+		return -EIO;
+
+	err = gpio_direction_output(ALE, 0);
+	if (err)
+		return -EIO;
+
+	err = gpio_direction_output(CLE, 0);
+	if (err)
+		return -EIO;
+
+	/* Allocate memory for MTD device structure and private data */
+	mt29f2g08aadwp_mtd = kmalloc(sizeof(struct mtd_info) +
+				     sizeof(struct nand_chip), GFP_KERNEL);
+	if (!mt29f2g08aadwp_mtd) {
+		printk (KERN_DEBUG  MSG_PFX
+			"Unable to allocate NAND MTD device structure.\n");
+		err = -ENOMEM;
+		goto out_err;
+	}
+
+	/* Initialize structures */
+	memset((char *) mt29f2g08aadwp_mtd,
+	       0,
+	       sizeof(struct mtd_info) + sizeof(struct nand_chip));
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&mt29f2g08aadwp_mtd[1]);
+	/* Link the private data with the MTD structure */
+	mt29f2g08aadwp_mtd->priv  = this;
+	mt29f2g08aadwp_mtd->owner = THIS_MODULE;
+
+	this->ecc.mode = NAND_ECC_SOFT;
+
+	base_address = NULL;
+
+	if (request_mem_region(NAND_BASE_ADDRESS, NAND_SIZE,
+			       "MT29F2G08AADWP NAND Memory")) {
+
+		base_address = ioremap(NAND_BASE_ADDRESS, NAND_SIZE);
+
+		if (!base_address) {
+			err = -EIO;
+			printk(KERN_DEBUG MSG_PFX "can not remap nand "
+                               "region!\n");
+		}
+
+	} else {
+		err = -EBUSY;
+		printk(KERN_DEBUG MSG_PFX "can not allocate nand IO "
+                       "resource!\n");
+	}
+
+	if (err < 0)
+		goto out_err;
+
+	/* Set address of NAND IO lines */
+	this->IO_ADDR_R = base_address;
+	this->IO_ADDR_W = base_address;
+
+	this->cmd_ctrl	= mt29f2g08aadwp_cmd_ctrl;
+	this->dev_ready = mt29f2g08aadwp_dev_ready;
+
+	/* Scan to find existance of the device */
+	if (nand_scan(mt29f2g08aadwp_mtd, 1)) {
+		err = -ENXIO;
+		goto out_err;
+	}
+
+	scan_done = 1;
+
+	add_mtd_device((struct mtd_info *) mt29f2g08aadwp_mtd);
+	add_mtd_partitions(mt29f2g08aadwp_mtd,
+			   partition_info,
+			   NUM_PARTITIONS);
+	goto out;
+
+out_err:
+	mt29f2g08aadwp_nand_exit();
+out:
+	return err;
+}
+
+static void mt29f2g08aadwp_nand_exit(void)
+{
+	if (scan_done) {
+		nand_release(mt29f2g08aadwp_mtd);
+		scan_done = 0;
+	}
+
+	gpio_free(READY);
+	gpio_free(NCE);
+	gpio_free(ALE);
+	gpio_free(CLE);
+
+	if (base_address) {
+		iounmap(base_address);
+		release_mem_region(NAND_BASE_ADDRESS, NAND_SIZE);
+		base_address = NULL;
+	}
+
+	kfree(mt29f2g08aadwp_mtd);
+}
+
+module_init(mt29f2g08aadwp_nand_init);
+module_exit(mt29f2g08aadwp_nand_exit);
+
+MODULE_AUTHOR("Eric Le Bihan");
+MODULE_DESCRIPTION("MT29F2G08AADWP MTD NAND driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 231eeaf..2b46c87 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -218,6 +218,12 @@ config MACB
 	  To compile this driver as a module, choose M here: the module
 	  will be called macb.
 
+config PC302_EMAC
+	tristate "picoChip PC302 Ethernet support"
+	depends on ARCH_PC302
+	help
+          This driver provides Ethernet support for the picoChip PC302 device.
+          
 source "drivers/net/arm/Kconfig"
 
 config AX88796
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 017383a..b850408 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -230,6 +230,7 @@ obj-$(CONFIG_ENC28J60) += enc28j60.o
 obj-$(CONFIG_XTENSA_XT2000_SONIC) += xtsonic.o
 
 obj-$(CONFIG_MACB) += macb.o
+obj-$(CONFIG_PC302_EMAC) += pc302_emac.o
 
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_DEV_APPLETALK) += appletalk/
diff --git a/drivers/net/igb/e1000_82575.h b/drivers/net/igb/e1000_82575.h
index c1928b5..dd32a6f 100644
--- a/drivers/net/igb/e1000_82575.h
+++ b/drivers/net/igb/e1000_82575.h
@@ -116,6 +116,7 @@ union e1000_adv_tx_desc {
 };
 
 /* Adv Transmit Descriptor Config Masks */
+#define E1000_ADVTXD_MAC_TSTAMP   0x00080000 /* IEEE1588 Timestamp packet */
 #define E1000_ADVTXD_DTYP_CTXT    0x00200000 /* Advanced Context Descriptor */
 #define E1000_ADVTXD_DTYP_DATA    0x00300000 /* Advanced Data Descriptor */
 #define E1000_ADVTXD_DCMD_IFCS    0x02000000 /* Insert FCS (Ethernet CRC) */
diff --git a/drivers/net/igb/e1000_defines.h b/drivers/net/igb/e1000_defines.h
index ce70068..2a19698 100644
--- a/drivers/net/igb/e1000_defines.h
+++ b/drivers/net/igb/e1000_defines.h
@@ -104,6 +104,7 @@
 #define E1000_RXD_STAT_UDPCS    0x10    /* UDP xsum calculated */
 #define E1000_RXD_STAT_TCPCS    0x20    /* TCP xsum calculated */
 #define E1000_RXD_STAT_DYNINT   0x800   /* Pkt caused INT via DYNINT */
+#define E1000_RXD_STAT_TS       0x10000 /* Pkt was time stamped */
 #define E1000_RXD_ERR_CE        0x01    /* CRC Error */
 #define E1000_RXD_ERR_SE        0x02    /* Symbol Error */
 #define E1000_RXD_ERR_SEQ       0x04    /* Sequence Error */
diff --git a/drivers/net/igb/e1000_regs.h b/drivers/net/igb/e1000_regs.h
index 95523af..9dbffbf 100644
--- a/drivers/net/igb/e1000_regs.h
+++ b/drivers/net/igb/e1000_regs.h
@@ -75,6 +75,75 @@
 #define E1000_FCRTH    0x02168  /* Flow Control Receive Threshold High - RW */
 #define E1000_RDFPCQ(_n)  (0x02430 + (0x4 * (_n)))
 #define E1000_FCRTV    0x02460  /* Flow Control Refresh Timer Value - RW */
+
+/* IEEE 1588 TIMESYNCH */
+#define E1000_TSYNCTXCTL 0x0B614
+#define E1000_TSYNCTXCTL_VALID (1<<0)
+#define E1000_TSYNCTXCTL_ENABLED (1<<4)
+#define E1000_TSYNCRXCTL 0x0B620
+#define E1000_TSYNCRXCTL_VALID (1<<0)
+#define E1000_TSYNCRXCTL_ENABLED (1<<4)
+enum {
+	E1000_TSYNCRXCTL_TYPE_L2_V2 = 0,
+	E1000_TSYNCRXCTL_TYPE_L4_V1 = (1<<1),
+	E1000_TSYNCRXCTL_TYPE_L2_L4_V2 = (1<<2),
+	E1000_TSYNCRXCTL_TYPE_ALL = (1<<3),
+	E1000_TSYNCRXCTL_TYPE_EVENT_V2 = (1<<3) | (1<<1),
+};
+#define E1000_TSYNCRXCFG 0x05F50
+enum {
+	E1000_TSYNCRXCFG_PTP_V1_SYNC_MESSAGE = 0<<0,
+	E1000_TSYNCRXCFG_PTP_V1_DELAY_REQ_MESSAGE = 1<<0,
+	E1000_TSYNCRXCFG_PTP_V1_FOLLOWUP_MESSAGE = 2<<0,
+	E1000_TSYNCRXCFG_PTP_V1_DELAY_RESP_MESSAGE = 3<<0,
+	E1000_TSYNCRXCFG_PTP_V1_MANAGEMENT_MESSAGE = 4<<0,
+
+	E1000_TSYNCRXCFG_PTP_V2_SYNC_MESSAGE = 0<<8,
+	E1000_TSYNCRXCFG_PTP_V2_DELAY_REQ_MESSAGE = 1<<8,
+	E1000_TSYNCRXCFG_PTP_V2_PATH_DELAY_REQ_MESSAGE = 2<<8,
+	E1000_TSYNCRXCFG_PTP_V2_PATH_DELAY_RESP_MESSAGE = 3<<8,
+	E1000_TSYNCRXCFG_PTP_V2_FOLLOWUP_MESSAGE = 8<<8,
+	E1000_TSYNCRXCFG_PTP_V2_DELAY_RESP_MESSAGE = 9<<8,
+	E1000_TSYNCRXCFG_PTP_V2_PATH_DELAY_FOLLOWUP_MESSAGE = 0xA<<8,
+	E1000_TSYNCRXCFG_PTP_V2_ANNOUNCE_MESSAGE = 0xB<<8,
+	E1000_TSYNCRXCFG_PTP_V2_SIGNALLING_MESSAGE = 0xC<<8,
+	E1000_TSYNCRXCFG_PTP_V2_MANAGEMENT_MESSAGE = 0xD<<8,
+};
+
+#define E1000_SYSTIML 0x0B600
+#define E1000_SYSTIMH 0x0B604
+#define E1000_TIMINCA 0x0B608
+
+#define E1000_RXMTRL  0x0B634
+#define E1000_RXSTMPL 0x0B624
+#define E1000_RXSTMPH 0x0B628
+#define E1000_RXSATRL 0x0B62C
+#define E1000_RXSATRH 0x0B630
+
+#define E1000_TXSTMPL 0x0B618
+#define E1000_TXSTMPH 0x0B61C
+
+#define E1000_ETQF0   0x05CB0
+#define E1000_ETQF1   0x05CB4
+#define E1000_ETQF2   0x05CB8
+#define E1000_ETQF3   0x05CBC
+#define E1000_ETQF4   0x05CC0
+#define E1000_ETQF5   0x05CC4
+#define E1000_ETQF6   0x05CC8
+#define E1000_ETQF7   0x05CCC
+
+/* Filtering Registers */
+#define E1000_SAQF(_n) (0x5980 + 4 * (_n))
+#define E1000_DAQF(_n) (0x59A0 + 4 * (_n))
+#define E1000_SPQF(_n) (0x59C0 + 4 * (_n))
+#define E1000_FTQF(_n) (0x59E0 + 4 * (_n))
+#define E1000_SAQF0 E1000_SAQF(0)
+#define E1000_DAQF0 E1000_DAQF(0)
+#define E1000_SPQF0 E1000_SPQF(0)
+#define E1000_FTQF0 E1000_FTQF(0)
+#define E1000_SYNQF(_n) (0x055FC + (4 * (_n))) /* SYN Packet Queue Fltr */
+#define E1000_ETQF(_n)  (0x05CB0 + (4 * (_n))) /* EType Queue Fltr */
+
 /* Split and Replication RX Control - RW */
 /*
  * Convenience macros
diff --git a/drivers/net/igb/igb.h b/drivers/net/igb/igb.h
index 4ff6f05..d57b545 100644
--- a/drivers/net/igb/igb.h
+++ b/drivers/net/igb/igb.h
@@ -34,6 +34,9 @@
 #include "e1000_mac.h"
 #include "e1000_82575.h"
 
+#include <linux/clocksource.h>
+#include <linux/clocksync.h>
+
 struct igb_adapter;
 
 #ifdef CONFIG_IGB_LRO
@@ -262,6 +265,8 @@ struct igb_adapter {
 	struct napi_struct napi;
 	struct pci_dev *pdev;
 	struct net_device_stats net_stats;
+        struct clocksource clock;
+        struct clocksync sync;
 
 	/* structs defined in e1000_hw.h */
 	struct e1000_hw hw;
diff --git a/drivers/net/igb/igb_main.c b/drivers/net/igb/igb_main.c
index 20d27e6..2a35c30 100644
--- a/drivers/net/igb/igb_main.c
+++ b/drivers/net/igb/igb_main.c
@@ -34,6 +34,7 @@
 #include <linux/ipv6.h>
 #include <net/checksum.h>
 #include <net/ip6_checksum.h>
+#include <net/timestamping.h>
 #include <linux/mii.h>
 #include <linux/ethtool.h>
 #include <linux/if_vlan.h>
@@ -179,6 +180,61 @@ MODULE_DESCRIPTION("Intel(R) Gigabit Ethernet Network Driver");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(DRV_VERSION);
 
+/**
+ * Scale the NIC clock cycle by a large factor so that
+ * relatively small clock corrections can be added or
+ * substracted at each clock tick. The drawbacks of a
+ * large factor are a) that the clock register overflows
+ * more quickly (not such a big deal) and b) that the
+ * increment per tick has to fit into 24 bits.
+ *
+ * Note that
+ *   TIMINCA = IGB_TSYNC_CYCLE_TIME_IN_NANOSECONDS *
+ *             IGB_TSYNC_SCALE
+ *   TIMINCA += TIMINCA * adjustment [ppm] / 1e9
+ *
+ * The base scale factor is intentionally a power of two
+ * so that the division in clocksource can be done with
+ * a shift.
+ */
+#define IGB_TSYNC_SHIFT (19)
+#define IGB_TSYNC_SCALE (1<<IGB_TSYNC_SHIFT)
+
+/**
+ * The duration of one clock cycle of the NIC.
+ *
+ * @todo This hard-coded value is part of the specification and might change
+ * in future hardware revisions. Add revision check.
+ */
+#define IGB_TSYNC_CYCLE_TIME_IN_NANOSECONDS 16
+
+#if (IGB_TSYNC_SCALE * IGB_TSYNC_CYCLE_TIME_IN_NANOSECONDS) >= (1<<24)
+# error IGB_TSYNC_SCALE and/or IGB_TSYNC_CYCLE_TIME_IN_NANOSECONDS are too large to fit into TIMINCA
+#endif
+
+/**
+ * igb_read_clock - read raw cycle counter (to be used by clocksource)
+ */
+static cycle_t igb_read_clock(struct clocksource *cs)
+{
+	struct igb_adapter *adapter =
+		container_of(cs, struct igb_adapter, clock);
+	struct e1000_hw *hw = &adapter->hw;
+	u64 stamp;
+
+	stamp =  rd32(E1000_SYSTIML);
+	stamp |= (u64)rd32(E1000_SYSTIMH) << 32ULL;
+
+	return stamp;
+}
+
+static ktime_t igb_hwtstamp_raw2sys(struct net_device *netdev,
+					ktime_t stamp)
+{
+	struct igb_adapter *adapter = netdev_priv(netdev);
+	return clocksync_hw2sys(&adapter->sync, ktime_to_ns(stamp));
+}
+
 #ifdef DEBUG
 /**
  * igb_get_hw_dev_name - return device name string
@@ -189,6 +245,29 @@ char *igb_get_hw_dev_name(struct e1000_hw *hw)
 	struct igb_adapter *adapter = hw->back;
 	return adapter->netdev->name;
 }
+
+/**
+ * igb_get_time_str - format current NIC and system time as string
+ */
+static char *igb_get_time_str(struct igb_adapter *adapter,
+			char buffer[160])
+{
+	cycle_t hw = clocksource_read(&adapter->clock);
+        struct timespec nic = ns_to_timespec(clocksource_read_time(&adapter->clock));
+	struct timespec sys;
+	struct timespec delta;
+	getnstimeofday(&sys);
+
+	delta = timespec_sub(nic, sys);
+
+	ssprintf(buffer, "HW %llu, NIC %ld.%09lus, SYS %ld.%09lus, NIC-SYS %lds + %09luns",
+		 hw,
+		(long)nic.tv_sec, nic.tv_nsec,
+		(long)sys.tv_sec, sys.tv_nsec,
+		(long)delta.tv_sec, delta.tv_nsec);
+
+	return buffer;
+}
 #endif
 
 /**
@@ -1273,6 +1352,55 @@ static int __devinit igb_probe(struct pci_dev *pdev,
 	}
 #endif
 
+	/*
+	 * Initialize hardware timer: we keep it running just in case
+	 * that some program needs it later on.
+	 */
+	memset(&adapter->clock, 0, sizeof(adapter->clock));
+	adapter->clock.read_clock = igb_read_clock;
+	adapter->clock.mask = (u64)(s64)-1;
+	adapter->clock.mult = 1;
+	adapter->clock.shift = IGB_TSYNC_SHIFT;
+	wr32(E1000_TIMINCA, (1<<24) | IGB_TSYNC_CYCLE_TIME_IN_NANOSECONDS * IGB_TSYNC_SCALE);
+#if 0
+	/*
+	 * Avoid rollover while we initialize by resetting the time counter.
+	 */
+	wr32(E1000_SYSTIML, 0x00000000);
+	wr32(E1000_SYSTIMH, 0x00000000);
+#else
+	/*
+	 * Set registers so that rollover occurs soon to test this.
+	 */
+	wr32(E1000_SYSTIML, 0x00000000);
+	wr32(E1000_SYSTIMH, 0xFF800000);
+#endif
+	wrfl();
+	clocksource_init_time(&adapter->clock, ktime_to_ns(ktime_get_real()));
+
+	/*
+	 * Synchronize our NIC clock against system wall clock. NIC
+	 * time stamp reading requires ~3us per sample, each sample
+	 * was pretty stable even under load => only require 10
+	 * samples for each offset comparison.
+	 */
+	memset(&adapter->sync, 0, sizeof(adapter->sync));
+	adapter->sync.clock = &adapter->clock;
+	adapter->sync.systime = ktime_get_real;
+	adapter->sync.num_samples = 10;
+	clocksync_update(&adapter->sync, 0);
+	netdev->hwtstamp_raw2sys = igb_hwtstamp_raw2sys;
+
+#ifdef DEBUG
+	{
+		char buffer[160];
+		printk(KERN_DEBUG
+			"igb: %s: hw %p initialized timer\n",
+			igb_get_time_str(adapter, buffer),
+			&adapter->hw);
+	}
+#endif
+
 	dev_info(&pdev->dev, "Intel(R) Gigabit Ethernet Network Connection\n");
 	/* print bus type/speed/width info */
 	dev_info(&pdev->dev,
@@ -2630,6 +2758,7 @@ set_itr_now:
 #define IGB_TX_FLAGS_VLAN		0x00000002
 #define IGB_TX_FLAGS_TSO		0x00000004
 #define IGB_TX_FLAGS_IPV4		0x00000008
+#define IGB_TX_FLAGS_TSTAMP             0x00000010
 #define IGB_TX_FLAGS_VLAN_MASK	0xffff0000
 #define IGB_TX_FLAGS_VLAN_SHIFT	16
 
@@ -2850,7 +2979,10 @@ static inline void igb_tx_queue_adv(struct igb_adapter *adapter,
 	if (tx_flags & IGB_TX_FLAGS_VLAN)
 		cmd_type_len |= E1000_ADVTXD_DCMD_VLE;
 
-	if (tx_flags & IGB_TX_FLAGS_TSO) {
+	if (tx_flags & IGB_TX_FLAGS_TSTAMP)
+		cmd_type_len |= E1000_ADVTXD_MAC_TSTAMP;
+
+        if (tx_flags & IGB_TX_FLAGS_TSO) {
 		cmd_type_len |= E1000_ADVTXD_DCMD_TSE;
 
 		/* insert tcp checksum */
@@ -2962,9 +3094,29 @@ static int igb_xmit_frame_ring_adv(struct sk_buff *skb,
 		/* this is a hard error */
 		return NETDEV_TX_BUSY;
 	}
-	skb_orphan(skb);
 
-	if (adapter->vlgrp && vlan_tx_tag_present(skb)) {
+	/*
+	 * TODO: check that there currently is no other packet with
+	 * time stamping in the queue
+	 *
+	 * when doing time stamping, keep the connection to the socket
+	 * a while longer, it is still needed by skb_hwtstamp_tx(), either
+	 * in igb_clean_tx_irq() or
+	 */
+	if (skb_hwtstamp_check_tx_hardware(skb)) {
+		skb_hwtstamp_set_tx_in_progress(skb);
+		tx_flags |= IGB_TX_FLAGS_TSTAMP;
+	} else if (!skb_hwtstamp_check_tx_software(skb)) {
+		/*
+		 * TODO: can this be solved in dev.c:dev_hard_start_xmit()?
+		 * There are probably unmodified driver which do something
+		 * like this and thus don't work in combination with
+		 * SOF_TIMESTAMPING_TX_SOFTWARE.
+		 */
+		skb_orphan(skb);
+	}
+
+        if (adapter->vlgrp && vlan_tx_tag_present(skb)) {
 		tx_flags |= IGB_TX_FLAGS_VLAN;
 		tx_flags |= (vlan_tx_tag_get(skb) << IGB_TX_FLAGS_VLAN_SHIFT);
 	}
@@ -3653,6 +3805,28 @@ static bool igb_clean_tx_irq(struct igb_ring *tx_ring)
 					    skb->len;
 				total_packets += segs;
 				total_bytes += bytecount;
+
+				/*
+				 * if we were asked to do hardware
+				 * stamping and such a time stamp is
+				 * available, then it must have been
+				 * for this one here because we only
+				 * allow only one such packet into the
+				 * queue
+				 */
+				if (skb_hwtstamp_check_tx_hardware(skb)) {
+					u32 valid = rd32(E1000_TSYNCTXCTL) & E1000_TSYNCTXCTL_VALID;
+					if (valid) {
+						u64 tstamp = rd32(E1000_TXSTMPL);
+						tstamp |= (u64)rd32(E1000_TXSTMPH) << 32;
+						clocksync_update(&adapter->sync, tstamp);
+						skb_hwtstamp_tx(skb,
+								ns_to_ktime(clocksource_cyc2time(&adapter->clock,
+													tstamp)),
+								netdev);
+					}
+					skb_orphan(skb);
+				}
 			}
 
 			igb_unmap_and_free_tx_resource(adapter, buffer_info);
@@ -3835,7 +4009,8 @@ static bool igb_clean_rx_irq_adv(struct igb_ring *rx_ring,
 {
 	struct igb_adapter *adapter = rx_ring->adapter;
 	struct net_device *netdev = adapter->netdev;
-	struct pci_dev *pdev = adapter->pdev;
+	struct e1000_hw *hw = &adapter->hw;
+        struct pci_dev *pdev = adapter->pdev;
 	union e1000_adv_rx_desc *rx_desc , *next_rxd;
 	struct igb_buffer *buffer_info , *next_buffer;
 	struct sk_buff *skb;
@@ -3924,7 +4099,39 @@ send_up:
 			goto next_desc;
 		}
 
-		if (staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) {
+		/*
+		 * If this bit is set, then the RX registers contain
+		 * the time stamp. No other packet will be time
+		 * stamped until we read these registers, so read the
+		 * registers to make them available again. Because
+		 * only one packet can be time stamped at a time, we
+		 * know that the register values must belong to this
+		 * one here and therefore we don't need to compare
+		 * any of the additional attributes stored for it.
+		 *
+		 * TODO: can time stamping be triggered (thus locking
+		 * the registers) without the packet reaching this point
+		 * here? In that case RX time stamping would get stuck.
+		 *
+		 * TODO: in "time stamp all packets" mode this bit is
+		 * not set. Need a global flag for this mode and then
+		 * always read the registers. Cannot be done without
+		 * a race condition.
+		 */
+		if (staterr & E1000_RXD_STAT_TS) {
+			u64 tstamp;
+
+			WARN(!(rd32(E1000_TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID),
+				"igb: no RX time stamp available for time stamped packet");
+			tstamp = rd32(E1000_RXSTMPL);
+			tstamp |= (u64)rd32(E1000_RXSTMPH) << 32;
+			clocksync_update(&adapter->sync, tstamp);
+			skb_hwtstamp_set(skb,
+					ns_to_ktime(clocksource_cyc2time(&adapter->clock,
+										tstamp)));
+		}
+
+                if (staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) {
 			dev_kfree_skb_irq(skb);
 			goto next_desc;
 		}
@@ -4115,6 +4322,155 @@ static int igb_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
 }
 
 /**
+ * igb_hwtstamp_ioctl - control hardware time stamping
+ * @netdev:
+ * @ifreq:
+ * @cmd:
+ *
+ * Outgoing time stamping can be enabled and disabled. Play nice and
+ * disable it when requested, although it shouldn't case any overhead
+ * when no packet needs it. At most one packet in the queue may be
+ * marked for time stamping, otherwise it would be impossible to tell
+ * for sure to which packet the hardware time stamp belongs.
+ *
+ * Incoming time stamping has to be configured via the hardware
+ * filters. Not all combinations are supported, in particular event
+ * type has to be specified. Matching the kind of event packet is
+ * not supported, with the exception of "all V2 events regardless of
+ * level 2 or 4".
+ *
+**/
+static int igb_hwtstamp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+	struct igb_adapter *adapter = netdev_priv(netdev);
+	struct e1000_hw *hw = &adapter->hw;
+        struct hwtstamp_config config;
+	u32 tsync_tx_ctl_bit = E1000_TSYNCTXCTL_ENABLED;
+	u32 tsync_rx_ctl_bit = E1000_TSYNCRXCTL_ENABLED;
+	u32 tsync_rx_ctl_type = 0;
+	u32 tsync_rx_cfg = 0;
+	int is_l4 = 0;
+	int is_l2 = 0;
+	short port = 319; /* PTP */
+	u32 regval;
+
+	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	/* reserved for future extensions */
+	if (config.flags)
+		return -EINVAL;
+
+	switch (config.tx_type) {
+	case HWTSTAMP_TX_OFF:
+		tsync_tx_ctl_bit = 0;
+		break;
+	case HWTSTAMP_TX_ON:
+		tsync_tx_ctl_bit = E1000_TSYNCTXCTL_ENABLED;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (config.rx_filter_type) {
+	case HWTSTAMP_FILTER_NONE:
+		tsync_rx_ctl_bit = 0;
+		break;
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_ALL:
+		/*
+		 * register TSYNCRXCFG must be set, therefore it is not
+		 * possible to time stamp both Sync and Delay_Req messages
+		 * => fall back to time stamping all packets
+		 */
+		tsync_rx_ctl_type = E1000_TSYNCRXCTL_TYPE_ALL;
+		config.rx_filter_type = HWTSTAMP_FILTER_ALL;
+		break;
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+		tsync_rx_ctl_type = E1000_TSYNCRXCTL_TYPE_L4_V1;
+		tsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_SYNC_MESSAGE;
+		is_l4 = 1;
+		break;
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+		tsync_rx_ctl_type = E1000_TSYNCRXCTL_TYPE_L4_V1;
+		tsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_DELAY_REQ_MESSAGE;
+		is_l4 = 1;
+		break;
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+		tsync_rx_ctl_type = E1000_TSYNCRXCTL_TYPE_L2_L4_V2;
+		tsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V2_SYNC_MESSAGE;
+		is_l2 = 1;
+		is_l4 = 1;
+		config.rx_filter_type = HWTSTAMP_FILTER_SOME;
+		break;
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+		tsync_rx_ctl_type = E1000_TSYNCRXCTL_TYPE_L2_L4_V2;
+		tsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V2_DELAY_REQ_MESSAGE;
+		is_l2 = 1;
+		is_l4 = 1;
+		config.rx_filter_type = HWTSTAMP_FILTER_SOME;
+		break;
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		tsync_rx_ctl_type = E1000_TSYNCRXCTL_TYPE_EVENT_V2;
+		config.rx_filter_type = HWTSTAMP_FILTER_PTP_V2_EVENT;
+		is_l2 = 1;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	/* enable/disable TX */
+	regval = rd32(E1000_TSYNCTXCTL);
+	regval = (regval & ~E1000_TSYNCTXCTL_ENABLED) | tsync_tx_ctl_bit;
+	wr32(E1000_TSYNCTXCTL, regval);
+
+	/* enable/disable RX, define which PTP packets are time stamped */
+	regval = rd32(E1000_TSYNCRXCTL);
+	regval = (regval & ~E1000_TSYNCRXCTL_ENABLED) | tsync_rx_ctl_bit;
+	regval = (regval & ~0xE) | tsync_rx_ctl_type;
+	wr32(E1000_TSYNCRXCTL, regval);
+	wr32(E1000_TSYNCRXCFG, tsync_rx_cfg);
+
+	/*
+	 * Ethertype Filter Queue Filter[0][15:0] = 0x88F7 (Ethertype to filter on)
+	 * Ethertype Filter Queue Filter[0][26] = 0x1 (Enable filter)
+	 * Ethertype Filter Queue Filter[0][30] = 0x1 (Enable Timestamping)
+	 */
+	wr32(E1000_ETQF0, is_l2 ? 0x440088f7 : 0);
+
+	/* L4 Queue Filter[0]: only filter by source and destination port */
+	wr32(E1000_SPQF0, htons(port));
+	wr32(E1000_IMIREXT(0), is_l4 ?
+		((1<<12) | (1<<19) /* bypass size and control flags */) : 0);
+	wr32(E1000_IMIR(0), is_l4 ?
+		(htons(port)
+			| (0<<16) /* immediate interrupt disabled */
+			| 0 /* (1<<17) bit cleared: do not bypass destination port check */)
+		: 0);
+	wr32(E1000_FTQF0, is_l4 ?
+		(0x11 /* UDP */
+			| (1<<15) /* VF not compared */
+			| (1<<27) /* Enable Timestamping */
+			| (7<<28) /* only source port filter enabled, source/target address and protocol masked */ )
+		: ( (1<<15) | (15<<28) /* all mask bits set = filter not enabled */));
+
+	wrfl();
+
+	/* clear TX/RX time stamp registers, just to be sure */
+	regval = rd32(E1000_TXSTMPH);
+	regval = rd32(E1000_RXSTMPH);
+
+	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+		-EFAULT : 0;
+}
+
+/**
  * igb_ioctl -
  * @netdev:
  * @ifreq:
@@ -4127,6 +4483,8 @@ static int igb_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
 	case SIOCGMIIREG:
 	case SIOCSMIIREG:
 		return igb_mii_ioctl(netdev, ifr, cmd);
+	case SIOCSHWTSTAMP:
+		return igb_hwtstamp_ioctl(netdev, ifr, cmd);
 	default:
 		return -EOPNOTSUPP;
 	}
diff --git a/drivers/net/pc302_emac.c b/drivers/net/pc302_emac.c
new file mode 100644
index 0000000..df5fb49
--- /dev/null
+++ b/drivers/net/pc302_emac.c
@@ -0,0 +1,2821 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * \file pc302_emac.c
+ * \brief This module provides the kernel network interface to the
+ *        PC302 EMAC hardware.
+ *
+ * The driver is based on the Atmel MACB Ethernet Controller driver
+ * (macb.c/h) Copyright (C) 2004-2006 Atmel Corporation.
+ *
+ * Copyright (c) 2008 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/etherdevice.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/device.h>
+#include <linux/dmapool.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/autoconf.h>
+#include <linux/sysfs.h>
+#include "pc302_emac.h"
+
+/* Required for hw timestamping */
+#include <net/timestamping.h>
+
+/* Constants --------------------------------------------------------------- */
+
+/*!
+ * Data structure used to represent the DMA descriptors used for
+ * packet reception and transmission.
+ */
+struct dma_desc
+{
+    u32	addr;
+    u32	ctrl;
+};
+
+/*!
+ * Data structure used during packet transmission.
+ */
+struct ring_info
+{
+    struct sk_buff  *skb;
+    dma_addr_t	    mapping;
+    void            *vaddr;
+};
+
+/*!
+ * Data structure used for storage of EMAC (hardware) collected statistics.
+ */
+struct pc302emac_stats
+{
+    u32 tx_octets_31_0;
+    u32 tx_octets_47_32;
+    u32 tx_frames;
+    u32 tx_broadcast_frames;
+    u32 tx_multicast_frames;
+    u32 tx_pause_frames;
+    u32 tx_64_byte_frames;
+    u32 tx_65_127_byte_frames;
+    u32 tx_128_255_byte_frames;
+    u32 tx_256_511_byte_frames;
+    u32 tx_512_1023_byte_frames;
+    u32 tx_1024_1518_byte_frames;
+    u32 tx_greater_than_1518_byte_frames;
+    u32 tx_underrun;
+    u32 tx_single_collision_frames;
+    u32 tx_multiple_collision_frames;
+    u32 tx_excessive_collisions;
+    u32 tx_late_colloisions;
+    u32 tx_deferred_frames;
+    u32 tx_carrier_sense_errors;
+    u32 rx_octets_31_0;
+    u32 rx_octets_47_32;
+    u32 rx_frames;
+    u32 rx_broadcast_frames;
+    u32 rx_multicast_frames;
+    u32 rx_pause_frames;
+    u32 rx_64_byte_frames;
+    u32 rx_65_127_byte_frames;
+    u32 rx_128_255_byte_frames;
+    u32 rx_256_511_byte_frames;
+    u32 rx_512_1023_byte_frames;
+    u32 rx_1024_1518_byte_frames;
+    u32 rx_greater_than_1518_byte_frames;
+    u32 rx_undersized_frames;
+    u32 rx_oversize_frames;
+    u32 rx_jabbers;
+    u32 rx_frame_check_sequence_errors;
+    u32 rx_length_field_frame_errors;
+    u32 rx_symbol_errors;
+    u32 rx_alignment_errors;
+    u32 rx_resource_errors;
+    u32 rx_overruns;
+    u32 rx_ip_header_checksum_errors;
+    u32 rx_tcp_checksum_errors;
+    u32 rx_udp_checksum_errors;
+};
+
+/*!
+ * Data structure used to hold driver private data.
+ */
+struct pc302_emac
+{
+    void __iomem	    *regs;
+
+    unsigned int	    rx_tail;
+    struct dma_desc	    *rx_ring;
+    void		    *rx_buffers;
+
+    unsigned int	    tx_head, tx_tail;
+    struct dma_desc	    *tx_ring;
+    struct ring_info	    *tx_skb;
+
+    spinlock_t		    lock;
+    struct platform_device  *pdev;
+    struct net_device	    *dev;
+    struct napi_struct	    napi;
+    struct net_device_stats stats;
+    struct pc302emac_stats  hw_stats;
+
+    dma_addr_t		    rx_ring_dma;
+    dma_addr_t		    tx_ring_dma;
+    dma_addr_t		    rx_buffers_dma;
+
+    unsigned int	    rx_pending, tx_pending;
+
+    struct mii_bus	    *mii_bus;
+    struct phy_device	    *phy_dev;
+    int 	            link;
+    int 	            speed;
+    int 	            duplex;
+
+    /* Used to indicate whether hw timestamping
+       of received packets is required or not */
+    unsigned int            hw_timestamp_flag;
+
+    /* Cache of tx buffers. */
+    struct dma_pool         *tx_buf_pool;
+};
+
+/*!
+ * Data structure used for phy operations.
+ */
+struct eth_platform_data
+{
+    u32 phy_mask;
+    u8  phy_irq_pin;    /* PHY IRQ */
+    u8  is_rmii;        /* using RMII interface? */
+};
+
+/*!
+ * Default MAC address to use in this driver.
+ * The EMAC hardware is read at initialisation and if no
+ * valid mac address is found there, this one is used.
+ *
+ * Note: This is based on the picoChip OUI, see
+ * http://standards.ieee.org/regauth/oui/index.shtml
+ * for more information.
+ */
+static unsigned char default_mac_address[ETH_ALEN] =
+{
+    0x00, 0x15, 0xe1, 0x00, 0x00, 0x00
+};
+
+/*!
+ * \brief Function return codes
+ */
+enum return_codes
+{
+    SUCCESS = 0,            /* Successful outcome */
+    DROPPED_A_PACKET = 1,   /* Used by pc302emac_rx_frame()
+                               to indicate a dropped frame */
+    START_XMIT_ERROR = 1,   /* Used by the pc302emac_start_xmit()
+                               to indicate a problem */
+    BIT_IS_ONE = 1,         /* Used by the hash functions */
+    BIT_IS_ZERO = 0         /* Used by the hash functions */
+};
+
+/* Globals ----------------------------------------------------------------- */
+/*!
+ * \brief Keep a local pointer to the netdev structure.
+ *        Note: used for sysfs functions only.
+ */
+static struct net_device *sysfs_ndev;
+
+/* Macros ------------------------------------------------------------------ */
+
+/*!
+ * The name used for the platform device and driver to allow Linux to match up
+ * the correct ends.
+ */
+#define CARDNAME "pc302-emac"
+
+/*!
+ * The timeout value specified in jiffies used in Phy accesses.
+ */
+#define PC302_MII_WAIT_TIMEOUT  (100)
+
+/*!
+ * Macros used in the definition of the DMA Rx ring buffers.
+ */
+#define RX_BUFFER_SIZE		(2048)
+#define RX_RING_SIZE		(32)
+#define RX_RING_BYTES		(sizeof(struct dma_desc) * RX_RING_SIZE)
+
+/*!
+ * Make the IP header word-aligned (the ethernet header is 14 bytes)
+ */
+#define RX_OFFSET		(2)
+
+/*!
+ * Macros used in the definition of the DMA Tx ring buffers.
+ */
+#define TX_BUFFER_SIZE          (2048)
+#define TX_RING_SIZE		(32)
+#define DEF_TX_RING_PENDING	(TX_RING_SIZE - 1)
+#define TX_RING_BYTES		(sizeof(struct dma_desc) * TX_RING_SIZE)
+
+#define TX_RING_GAP(priv)					    \
+	(TX_RING_SIZE - (priv)->tx_pending)
+
+#define TX_BUFFS_AVAIL(priv)                                        \
+	(((priv)->tx_tail <= (priv)->tx_head) ?			    \
+	 (priv)->tx_tail + (priv)->tx_pending - (priv)->tx_head :   \
+	 (priv)->tx_tail - (priv)->tx_head - TX_RING_GAP(priv))
+
+#define NEXT_TX(n)		(((n) + 1) & (TX_RING_SIZE - 1))
+
+#define NEXT_RX(n)		(((n) + 1) & (RX_RING_SIZE - 1))
+
+/* minimum number of free TX descriptors before waking up TX process */
+#define EMAC_TX_WAKEUP_THRESH	(TX_RING_SIZE / 4)
+
+#define EMAC_RX_INT_FLAGS	(EMAC_ENABLE_RX_COMPLETE \
+                                 | EMAC_ENABLE_RX_USED_BIT_READ	\
+				 | EMAC_ENABLE_RX_OVERRUN)
+
+/*!
+ * Define the size (in bytes) of the received frame checksum (CRC)
+ */
+#define RX_FCS_SIZE		(4)
+
+/* Prototypes--------------------------------------------------------------- */
+
+/*!
+ * Read a 32 bit value from the EMAC hardware.
+ *
+ * \param dev A pointer to the net_device structure.
+ * \param register_offset The offset (from the base address of the EMAC) of the
+ *                        particular register we wish to read.
+ * \return The value read.
+ */
+static u32
+emac_ioread32(struct net_device *dev,
+              unsigned int register_offset);
+
+/*!
+ * Write a 32 bit value to the the EMAC hardware.
+ *
+ * \param dev A pointer to the net_device structure.
+ * \param value The value to write.
+ * \param register_offset The offset (from the base address of the EMAC) of the
+ *                        particular register we wish to write to.
+ */
+static void
+emac_iowrite32(struct net_device *dev,
+               u32 value,
+               unsigned int register_offset);
+
+/*!
+ * Set the MAC address used by the EMAC hardware.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_set_hwaddr(struct net_device *dev);
+
+/*!
+ * Read the EMAC hardware for a MAC address. We expect this to
+ * have been setup by the bootloader.
+ * If this MAC address is valid we'll use it. If not, the
+ * default MAC address will be used.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_get_hwaddr(struct net_device *dev);
+
+/*!
+ * Read from an Ethernet Phy conneccted to the EMAC management bus.
+ *
+ * \param bus A pointer to the mii_bus structure.
+ * \param mii_id The Phy ID of the Phy we wish to read from.
+ * \param regnum The register number of the Phy register we wish to read from.
+ * \return The value read from the Phy.
+ */
+static int
+pc302emac_mdio_read(struct mii_bus *bus,
+                    int mii_id,
+                    int regnum);
+
+/*!
+ * Write to an Ethernet Phy conneccted to the EMAC management bus.
+ *
+ * \param bus A pointer to the mii_bus structure.
+ * \param mii_id The Phy ID of the Phy we wish to write to.
+ * \param regnum The register number of the Phy register we wish to write to.
+ * \param value The value we wish to write to the Phy.
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_mdio_write(struct mii_bus *bus,
+                     int mii_id,
+                     int regnum,
+		     u16 value);
+
+/*!
+ * Wait with timeout for the Phy access to complete.
+ *
+ * \param priv A pointer to the pc302_emac private data structure.
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_phy_busy_wait(struct pc302_emac *priv);
+
+/*!
+ * Reset the Ethernet Phy conneccted to the EMAC management bus.
+ *
+ * \param bus A pointer to the mii_bus structure.
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_mdio_reset(struct mii_bus *bus);
+
+/*!
+ * Handle any link changes detected by the Ethernet Phy.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_handle_link_change(struct net_device *dev);
+
+/*!
+ * Probe for Ethernet Phys on the Mii bus.
+ *
+ * \param dev A pointer to the net_device structure.
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_mii_probe(struct net_device *dev);
+
+/*!
+ * Initialise the Mii bus.
+ *
+ * \param dev A pointer to the net_device structure.
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_mii_init(struct net_device *dev);
+
+/*!
+ * Update the statistics counters located in the private driver structure,
+ * from the statistics counters contained in the EMAC hardware.
+ *
+ * \param priv A pointer to the pc302_emac private data structure.
+ */
+static void
+pc302emac_update_stats(struct pc302_emac *priv);
+
+/*!
+ * Handle 'packet transmit' related interrupts.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_tx(struct net_device *dev);
+
+/*!
+ * Obtain the nS portion of the hardware timestamp from received packets.
+ *
+ * \param skb A pointer to the socket buffer used for the received packet.
+ *
+ * \return The value of nS.
+ */
+static inline s32
+pc302emac_get_ns_from_pkt(struct sk_buff *skb);
+
+/*!
+ * Handle received frames.
+ *
+ * \param dev A pointer to the net_device structure.
+ * \param first_frag Index to the first fragment of a received packet
+ * \param last_frag Index to the last fragment of a received packet
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_rx_frame(struct net_device *dev,
+                   unsigned int first_frag,
+		   unsigned int last_frag);
+
+/*!
+ * Used to discard partial received frames.
+ *
+ * \param dev A pointer to the net_device structure.
+ * \param begin Index to the first fragment of a recieved packet
+ *              to be discarded
+ * \param end Index to the last fragment of a received packet to
+ *            to be discarded.
+ */
+static void
+discard_partial_frame(struct net_device *dev,
+                      unsigned int begin,
+                      unsigned int end);
+
+/*!
+ * Handle received frames.
+ * This () is called from pc302emac_poll (NAPI implementation).
+ *
+ * \param dev A pointer to the net_device structure.
+ * \param budget Number of packets to process.
+ *
+ * \return The number of frames received.
+ */
+static int
+pc302emac_rx(struct net_device *dev,
+             int budget);
+
+/*!
+ * Poll for received packets (NAPI implementation).
+ *
+ * \param napi A pointer to the napi_struct data structure.
+ * \param budget Number of packets to process.
+ *
+ * \return The number of packets received.
+ */
+static int
+pc302emac_poll(struct napi_struct *napi,
+               int budget);
+
+/*!
+ * EMAC driver interrupt handler.
+ *
+ * \param irq The irq number being handled.
+ * \param dev_id Some useful device information.
+ *
+ * \return Zero on interrupt not handled, non zero on interrupt handled.
+ */
+static irqreturn_t
+pc302emac_interrupt(int irq,
+                    void *dev_id);
+
+/*!
+ * EMAC packet transmission.
+ *
+ * \param skb A pointer to a socket buffer containing the packet
+ *            data for transmission.
+ * \param dev A pointer to the net_device structure.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_start_xmit(struct sk_buff *skb,
+                     struct net_device *dev);
+
+/*!
+ * Free EMAC DMA buffers.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_free_consistent(struct net_device *dev);
+
+/*!
+ * Allocate EMAC DMA buffers.
+ *
+ * \param dev A pointer to the net_device structure.
+ *
+ * \return Zero on success, non zero on error.
+ */
+
+static int
+pc302emac_alloc_consistent(struct net_device *dev);
+
+/*!
+ * Initialise the DMA Tx and Rx descriptors.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_init_rings(struct net_device *dev);
+
+/*!
+ * Reset the EMAC hardware.
+ *
+ * Note: There is no software reset bit available to us, so we just
+ *       write known values to certain important registers.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_reset_hw(struct net_device *dev);
+
+/*!
+ * Initialise the EMAC hardware.
+ * Note: Interrupts get enabled in here.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_init_hw(struct net_device *dev);
+
+/*!
+ * Return a bit value from the hash table.
+ *
+ * Note: This function is called from hash_bit_value()
+ *
+ * \param bitnr The bit number we are interested in.
+ * \param addr The MAC Address
+ *
+ * \return The hash index.
+ */
+static inline int
+hash_bit_value(int bitnr,
+               __u8 *addr);
+
+/*!
+ * Return the hash index value for the MAC specified address.
+ *
+ * \param addr The MAC Address
+ *
+ * \return The hash index.
+ */
+static int
+hash_get_index(__u8 *addr);
+
+/*!
+ * Add multicast addresses to the internal multicast-hash table.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_sethashtable(struct net_device *dev);
+
+/*!
+ * Driver 'set_multicast_list' method.
+ *
+ * This function is used when the device flags change.
+ *
+ * \param dev A pointer to the net_device structure.
+ */
+static void
+pc302emac_set_rx_mode(struct net_device *dev);
+
+/*!
+ * Driver 'open' method.
+ *
+ * This function is used to open the Ethernet interface for business.
+ *
+ * \param dev A pointer to the net_device structure.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_open(struct net_device *dev);
+
+/*!
+ * Driver 'stop' method.
+ *
+ * This function is used to stop the Ethernet interface.
+ *
+ * \param dev A pointer to the net_device structure.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_close(struct net_device *dev);
+
+/*!
+ * Driver 'get statistics' method.
+ *
+ * This function is used whenever an application need to obtain
+ * statistic information from the Ethernet interface.
+ *
+ * \param dev A pointer to the net_device structure.
+ *
+ * \return A pointer to net_device_stats statistics.
+ */
+static struct
+net_device_stats *pc302emac_get_stats(struct net_device *dev);
+
+static int
+pc302emac_get_settings(struct net_device *dev,
+                       struct ethtool_cmd *cmd);
+
+static int
+pc302emac_set_settings(struct net_device *dev,
+                       struct ethtool_cmd *cmd);
+
+static void
+pc302emac_get_drvinfo(struct net_device *dev,
+	              struct ethtool_drvinfo *info);
+
+/*!
+ * Driver 'ioctl' method.
+ *
+ * Performs interface specific ioctl commands.
+ *
+ * \param dev A pointer to the net_device structure.
+ * \param rq A pointer to the interface request structure
+ *           used for socket ioctl's.
+ * \param cmd The requested command.
+ * \return A pointer to net_device_stats statistics.
+ */
+static int
+pc302emac_ioctl(struct net_device *dev,
+                struct ifreq *rq,
+                int cmd);
+
+/*!
+ * Control hardware time stamping of received packets.
+ *
+ * Note: We only support hardware timestamping for received packets.
+ *
+ * \param dev A pointer to the net_device structure.
+ * \param ifr A pointer to the interface request structure.
+ * \param cmd The ioctl requested command.
+ *
+ */
+static int
+pc302emac_hwtstamp_ioctl(struct net_device *dev,
+                         struct ifreq *ifr,
+                         int cmd);
+
+/*!
+ * sysfs show method for displaying the 1588 seconds register.
+ *
+ * \param dev A pointer to the device structure.
+ * \param attr A pointer to the device_attribute structure.
+ * \param buf A pointer the character buffer to use for returning
+ *            the requested data.
+ * \return The number of characters in buf.
+ */
+static ssize_t
+pc302emac_sysfs_1588_seconds_show(struct device *dev,
+                                  struct device_attribute *attr,
+                                  char *buf);
+
+/*!
+ * sysfs store method for updating the 1588 seconds register.
+ *
+ * \param dev A pointer to the device structure.
+ * \param attr A pointer to the device_attribute structure.
+ * \param buf A pointer the character buffer providing the
+ *            user data.
+ * \param count The number of characters in buf.
+ * \return The number of characters in buf.
+ */
+static ssize_t
+pc302emac_sysfs_1588_seconds_store(struct device *dev,
+                                   struct device_attribute *attr,
+                                   const char *buf,
+                                   size_t count);
+
+/*!
+ * sysfs show method for displaying the 1588 nano seconds register.
+ *
+ * \param dev A pointer to the device structure.
+ * \param attr A pointer to the device_attribute structure.
+ * \param buf A pointer the character buffer to use for returning
+ *            the requested data.
+ * \return The number of characters in buf.
+ */
+static ssize_t
+pc302emac_sysfs_1588_nano_seconds_show(struct device *dev,
+                                       struct device_attribute *attr,
+                                       char *buf);
+
+/*!
+ * sysfs store method for updating the 1588 nano seconds register.
+ *
+ * \param dev A pointer to the device structure.
+ * \param attr A pointer to the device_attribute structure.
+ * \param buf A pointer the character buffer providing the
+ *            user data.
+ * \param count The number of characters in buf.
+ * \return The number of characters in buf.
+ */
+static ssize_t
+pc302emac_sysfs_1588_nano_seconds_store(struct device *dev,
+                                        struct device_attribute *attr,
+                                        const char *buf,
+                                        size_t count);
+
+/*!
+ * sysfs store method for updating the 1588 timer adjust.
+ *
+ * Note: This accesses a write only register.
+ *
+ * \param dev A pointer to the device structure.
+ * \param attr A pointer to the device_attribute structure.
+ * \param buf A pointer the character buffer providing the
+ *            user data.
+ * \param count The number of characters in buf.
+ * \return The number of characters in buf.
+ */
+static ssize_t
+pc302emac_sysfs_1588_timer_adjust_store(struct device *dev,
+                                        struct device_attribute *attr,
+                                        const char *buf,
+                                        size_t count);
+
+/*!
+ * sysfs show method for displaying the 1588 timer increment register.
+ *
+ * \param dev A pointer to the device structure.
+ * \param attr A pointer to the device_attribute structure.
+ * \param buf A pointer the character buffer to use for returning
+ *            the requested data.
+ * \return The number of characters in buf.
+ */
+static ssize_t
+pc302emac_sysfs_1588_timer_increment_show(struct device *dev,
+                                          struct device_attribute *attr,
+                                          char *buf);
+
+
+/*!
+ * sysfs store method for updating the 1588 timer increment register.
+ *
+ * \param dev A pointer to the device structure.
+ * \param attr A pointer to the device_attribute structure.
+ * \param buf A pointer the character buffer providing the
+ *            user data.
+ * \param count The number of characters in buf.
+ * \return The number of characters in buf.
+ */
+static ssize_t
+pc302emac_sysfs_1588_timer_increment_store(struct device *dev,
+                                           struct device_attribute *attr,
+                                           const char *buf,
+                                           size_t count);
+
+/*!
+ * Add the sysfs files.
+ *
+ * \param pdev A pointer to the platform_device structure.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+pc302emac_sysfs_add(struct platform_device *pdev);
+
+/*!
+ * Remove the sysfs files.
+ *
+ * \param pdev A pointer to the platform_device structure.
+ */
+static void
+pc302emac_sysfs_remove(struct platform_device *pdev);
+
+/*!
+ * Platform driver 'probe' method.
+ *
+ * \param pdev A pointer to the platform_device structure.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+emac_drv_probe(struct platform_device *pdev);
+
+/*!
+ * Platform driver 'remove' method.
+ *
+ * \param pdev A pointer to the platform_device structure.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+emac_drv_remove(struct platform_device *pdev);
+
+/*!
+ * Module initialisation function.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+emac_init_module(void);
+
+/*!
+ * Module exit function.
+ */
+static void
+emac_cleanup_module(void);
+
+/* Functions --------------------------------------------------------------- */
+
+static u32
+emac_ioread32(struct net_device *dev,
+              unsigned int register_offset)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    void __iomem *p = priv->regs + register_offset;
+
+    return ioread32(p);
+}
+
+static void
+emac_iowrite32(struct net_device *dev,
+               u32 value,
+               unsigned int register_offset)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    void __iomem *p = priv->regs + register_offset;
+
+    iowrite32(value, p);
+}
+
+static void
+pc302emac_set_hwaddr(struct net_device *dev)
+{
+    u32 bottom = 0;
+    u32 top = 0;
+
+    /* Obtain the least significant 4 bytes of the MAC address from dev */
+    bottom = dev->dev_addr[3] << 24 |
+             dev->dev_addr[2] << 16 |
+             dev->dev_addr[1] << 8  |
+             dev->dev_addr[0];
+
+    /* Obtain the most sognificant 2 bytes of the MAC address from dev */
+    top = dev->dev_addr[5] << 8 |
+          dev->dev_addr[4];
+
+    /* Program the EMAC Specific Address #1 'bottom' register */
+    emac_iowrite32(dev, bottom, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
+
+    /* Program the EMAC Specific Address #1 'top' register */
+    emac_iowrite32(dev, (u32)top, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
+}
+
+static void
+pc302emac_get_hwaddr(struct net_device *dev)
+{
+    u32 bottom = 0;
+    u16 top = 0;
+    u8 addr[ETH_ALEN];
+
+    /* Obtain bytes 1-4 of the MAC address from the EMAC hardware */
+    bottom = emac_ioread32(dev, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
+
+    /* Obtain bytes 5-6 of the MAC address from the EMAC hardware */
+    top = emac_ioread32(dev, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
+
+    addr[0] = bottom & 0xff;
+    addr[1] = (bottom >> 8) & 0xff;
+    addr[2] = (bottom >> 16) & 0xff;
+    addr[3] = (bottom >> 24) & 0xff;
+    addr[4] = top & 0xff;
+    addr[5] = (top >> 8) & 0xff;
+
+    if (is_valid_ether_addr(addr))
+    {
+	/* We have read a valid MAC address from the EMAC hardware,
+           copy it into the net_device structure */
+        memcpy(dev->dev_addr, addr, ETH_ALEN);
+    }
+    else
+    {
+	/* We have read an invalid MAC address from the EMAC hardware,
+           use the default instead */
+        printk(KERN_INFO "%s: invalid MAC address read from hardware, "
+                         "using default\n", dev->name);
+	memcpy(dev->dev_addr, default_mac_address, ETH_ALEN);
+    }
+}
+
+static int
+pc302emac_mdio_read(struct mii_bus *bus,
+                    int mii_id,
+                    int regnum)
+{
+    struct pc302_emac *priv = bus->priv;
+
+    int ret = SUCCESS;
+
+    u32 write_data = EMAC_PHY_READ;
+    u32 value = 0;
+
+    /* Mask input parameters */
+    mii_id &= EMAC_PHY_ID_MASK;
+    regnum &= EMAC_PHY_REG_MASK;
+
+    /* Create the data to write to the EMAC (Phy) */
+    write_data |= ((mii_id << EMAC_PHY_ID_SHIFT) |
+                   (regnum << EMAC_PHY_REG_SHIFT));
+
+    /* Write to the EMAC (Phy) */
+    emac_iowrite32(priv->dev, write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
+
+    /* Ensure the write happens */
+    wmb();
+
+    /* Wait for the phy access to complete */
+    ret = pc302emac_phy_busy_wait(priv);
+
+    BUG_ON (ret != SUCCESS);
+
+    /* Read back the data obtained from the phy */
+    value = emac_ioread32(priv->dev, EMAC_PHY_MAINTAIN_REG_OFFSET);
+    value &= EMAC_PHY_DATA_MASK;
+
+    return (int)value;
+}
+
+static int
+pc302emac_mdio_write(struct mii_bus *bus,
+                     int mii_id,
+                     int regnum,
+		     u16 value)
+{
+    struct pc302_emac *priv = bus->priv;
+
+    int ret = SUCCESS;
+
+    u32 write_data = EMAC_PHY_WRITE;
+
+    /* Mask input parameters */
+    mii_id &= EMAC_PHY_ID_MASK;
+    regnum &= EMAC_PHY_REG_MASK;
+
+    /* Create the data to write to the EMAC (Phy) */
+    write_data |= ((mii_id << EMAC_PHY_ID_SHIFT) |
+                   (regnum << EMAC_PHY_REG_SHIFT) | value);
+
+    /* Write to the EMAC (Phy) */
+    emac_iowrite32(priv->dev, write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
+
+    /* Ensure the write happens */
+    wmb();
+
+    /* Wait for the phy access to complete */
+    ret = pc302emac_phy_busy_wait(priv);
+
+    BUG_ON (ret != SUCCESS);
+
+    return ret;
+}
+
+/* Wait with timeout for the PHY busy signal to be reset */
+static int
+pc302emac_phy_busy_wait(struct pc302_emac *priv)
+{
+    unsigned long timeout_jiffies = jiffies + PC302_MII_WAIT_TIMEOUT;
+
+    int ret = SUCCESS;
+
+    u32 status = 0;
+
+    while (1)
+    {
+        /* Check for time out */
+        if (time_after(jiffies, timeout_jiffies))
+        {
+            /* Oops we've timed out */
+            ret = -ETIMEDOUT;
+            break;
+        }
+
+        /* Check for phy access complete */
+        status = emac_ioread32(priv->dev, EMAC_NETWORK_STATUS_REG_OFFSET);
+        if (status & EMAC_PHY_MANAGEMENT_IDLE)
+        {
+            /* Phy access has completed */
+            break;
+        }
+
+        cpu_relax();
+    }
+
+    return ret;
+}
+
+static int
+pc302emac_mdio_reset(struct mii_bus *bus)
+{
+    return SUCCESS;
+}
+
+static void
+pc302emac_handle_link_change(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct phy_device *phydev = priv->phy_dev;
+
+    unsigned long flags = 0;
+
+    int status_change = 0;
+
+    u32 config = 0;
+
+    spin_lock_irqsave(&priv->lock, flags);
+
+    if (phydev->link)
+    {
+	if ((priv->speed != phydev->speed) || (priv->duplex != phydev->duplex))
+        {
+	    config = emac_ioread32(dev, EMAC_NETWORK_CFG_REG_OFFSET);
+	    config &= ~(EMAC_SPEED_100_MBPS | EMAC_FULL_DUPLEX);
+
+	    if (phydev->duplex)
+            {
+		config |= EMAC_FULL_DUPLEX;
+            }
+
+            if (phydev->speed == SPEED_100)
+            {
+		config |= EMAC_SPEED_100_MBPS;
+            }
+
+            emac_iowrite32(dev, config, EMAC_NETWORK_CFG_REG_OFFSET);
+
+	    priv->speed = phydev->speed;
+	    priv->duplex = phydev->duplex;
+	    status_change = 1;
+	}
+    }
+
+    if (phydev->link != priv->link)
+    {
+	if (!phydev->link)
+        {
+	    priv->speed = 0;
+	    priv->duplex = -1;
+	}
+	priv->link = phydev->link;
+
+	status_change = 1;
+    }
+
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    if (status_change)
+    {
+	if (phydev->link)
+        {
+	    printk(KERN_INFO "%s: link up (%d/%s)\n",
+			      dev->name, phydev->speed,
+			      DUPLEX_FULL == phydev->duplex ? "Full":"Half");
+        }
+	else
+        {
+	    printk(KERN_INFO "%s: link down\n", dev->name);
+        }
+    }
+}
+
+static int
+pc302emac_mii_probe(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct phy_device *phydev = NULL;
+    struct eth_platform_data *pdata = NULL;
+
+    int phy_addr = 0;
+
+    /* find the first phy */
+    for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++)
+    {
+    	if (priv->mii_bus->phy_map[phy_addr])
+        {
+	    phydev = priv->mii_bus->phy_map[phy_addr];
+	    break;
+	}
+    }
+
+    if (!phydev)
+    {
+	printk(KERN_ERR "%s: no Phy found\n", dev->name);
+	return -ENXIO;
+    }
+
+    pdata = priv->pdev->dev.platform_data;
+
+    /* attach the mac to the phy */
+    if (pdata && pdata->is_rmii)
+    {
+	phydev = phy_connect(dev, phydev->dev.bus_id,
+			     &pc302emac_handle_link_change,
+                             0, PHY_INTERFACE_MODE_RMII);
+    }
+    else
+    {
+	phydev = phy_connect(dev, phydev->dev.bus_id,
+			     &pc302emac_handle_link_change,
+                             0, PHY_INTERFACE_MODE_MII);
+    }
+
+    if (IS_ERR(phydev))
+    {
+	printk(KERN_ERR "%s: could not attach to Phy\n", dev->name);
+	return PTR_ERR(phydev);
+    }
+
+    /* mask with MAC supported features */
+    phydev->supported &= PHY_BASIC_FEATURES;
+
+    phydev->advertising = phydev->supported;
+
+    priv->link = 0;
+    priv->speed = 0;
+    priv->duplex = -1;
+    priv->phy_dev = phydev;
+
+    return SUCCESS;
+}
+
+static int
+pc302emac_mii_init(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct eth_platform_data *pdata = NULL;
+
+    int ret = -ENXIO;
+    int i = 0;
+
+    u32 control = 0;
+
+    /* Enable managment port */
+    control = emac_ioread32(dev, EMAC_NETWORK_CTRL_REG_OFFSET);
+    control |= EMAC_MDIO_ENABLE;
+    emac_iowrite32(dev, control, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    priv->mii_bus->name = "pc302_mii_bus";
+    priv->mii_bus->read = &pc302emac_mdio_read;
+    priv->mii_bus->write = &pc302emac_mdio_write;
+    priv->mii_bus->reset = &pc302emac_mdio_reset;
+    snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%02x", priv->pdev->id);
+    priv->mii_bus->priv = priv;
+    priv->mii_bus->parent = &priv->dev->dev;
+
+    pdata = priv->pdev->dev.platform_data;
+
+    if (pdata)
+    {
+	priv->mii_bus->phy_mask = pdata->phy_mask;
+    }
+
+    priv->mii_bus->irq = kmalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);
+    if (!priv->mii_bus->irq)
+    {
+
+        printk(KERN_ERR "%s: could not allocate memory for mii_bus.irq\n",
+               dev->name);
+        ret = -ENOMEM;
+	goto err_out;
+    }
+
+    /* Phy interrupts not supported */
+    for (i = 0; i < PHY_MAX_ADDR; i++)
+    {
+	priv->mii_bus->irq[i] = PHY_POLL;
+    }
+
+    platform_set_drvdata(priv->dev, &priv->mii_bus);
+
+    if (mdiobus_register(priv->mii_bus))
+    {
+	printk(KERN_ERR "%s: could not register mdio bus\n", dev->name);
+        ret = -ENXIO;
+        goto err_out_free_mii_bus_irq;
+    }
+
+    if (pc302emac_mii_probe(priv->dev) != 0)
+    {
+	printk(KERN_ERR "%s: pc302emac_mii_probe() failed\n", dev->name);
+        ret = -ENXIO;
+        goto err_out_unregister_mdio_bus;
+    }
+
+    return SUCCESS;
+
+err_out_unregister_mdio_bus:
+    mdiobus_unregister(priv->mii_bus);
+
+err_out_free_mii_bus_irq:
+    kfree(priv->mii_bus->irq);
+
+err_out:
+    return ret;
+}
+
+static void
+pc302emac_update_stats(struct pc302_emac *priv)
+{
+    u32 __iomem *reg = priv->regs + EMAC_OCTETS_TX_31_0_REG_OFFSET;
+    u32 *p = &priv->hw_stats.tx_octets_31_0;
+    u32 *end = &priv->hw_stats.rx_udp_checksum_errors + 1;
+
+    for(; p < end; p++, reg++)
+    {
+        /* Read from the EMAC status registers (reg) and update the statistics
+           counters (*p) in the private data structure */
+        *p += ioread32(reg);
+    }
+}
+
+static void
+pc302emac_tx(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    unsigned int tail = 0;
+    unsigned int head = 0;
+
+    u32 status = 0;
+    u32 control = 0;
+
+    status = emac_ioread32(dev, EMAC_TX_STATUS_REG_OFFSET);
+    emac_iowrite32(dev, status, EMAC_TX_STATUS_REG_OFFSET);
+
+    if (status & EMAC_TRANSMIT_UNDERRUN)
+    {
+        int i;
+	printk(KERN_ERR "%s: Tx underrun, resetting buffers\n",
+			 dev->name);
+
+	head = priv->tx_head;
+
+	/*Mark all the buffer as used to avoid sending a lost buffer*/
+	for (i = 0; i < TX_RING_SIZE; i++)
+        {
+	    priv->tx_ring[i].ctrl = EMAC_TX_DESC_HOST_OWN;
+        }
+
+        /* free transmit buffer in upper layer*/
+	for (tail = priv->tx_tail; tail != head; tail = NEXT_TX(tail))
+        {
+	    struct ring_info *rp = &priv->tx_skb[tail];
+	    struct sk_buff *skb = rp->skb;
+
+	    BUG_ON(skb == NULL);
+
+	    rmb();
+
+            dma_pool_free(priv->tx_buf_pool, rp->vaddr, rp->mapping);
+
+	    rp->skb = NULL;
+	    dev_kfree_skb_irq(skb);
+	}
+
+	priv->tx_head = priv->tx_tail = 0;
+    }
+
+    if (!(status & EMAC_TRANSMIT_COMPLETE))
+    {
+	/*
+	 * This may happen when a buffer becomes complete
+	 * between reading the ISR and scanning the
+	 * descriptors.  Nothing to worry about.
+	 */
+	return;
+    }
+
+    head = priv->tx_head;
+    for (tail = priv->tx_tail; tail != head; tail = NEXT_TX(tail))
+    {
+        struct ring_info *rp = &priv->tx_skb[tail];
+	struct sk_buff *skb = rp->skb;
+	u32 bufstat;
+
+	BUG_ON(skb == NULL);
+
+	rmb();
+	bufstat = priv->tx_ring[tail].ctrl;
+
+	if (!(bufstat & EMAC_TX_DESC_HOST_OWN))
+        {
+	    break;
+        }
+
+        dma_pool_free(priv->tx_buf_pool, rp->vaddr, rp->mapping);
+
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += skb->len;
+	rp->skb = NULL;
+	dev_kfree_skb_irq(skb);
+    }
+
+    /* Make sure that any other pending packets get sent by triggering the
+     * transmitter again. */
+    control = emac_ioread32(dev, EMAC_NETWORK_CTRL_REG_OFFSET);
+    control |= EMAC_START_TX;
+    emac_iowrite32(dev, control, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    priv->tx_tail = tail;
+    if (netif_queue_stopped(priv->dev) &&
+        (TX_BUFFS_AVAIL(priv) > EMAC_TX_WAKEUP_THRESH))
+    {
+	netif_wake_queue(priv->dev);
+    }
+}
+
+static inline s32
+pc302emac_get_ns_from_pkt(struct sk_buff *skb)
+{
+    /* Assuming the mac inserts the ns portion of the hardware
+       timestamp in little endian format */
+    return *(s32 *)(skb->data + (skb->len - RX_FCS_SIZE));
+}
+
+static int
+pc302emac_rx_frame(struct net_device *dev,
+                   unsigned int first_frag,
+		   unsigned int last_frag)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct sk_buff *skb = NULL;
+
+    unsigned int len = 0;
+    unsigned int frag = 0;
+    unsigned int offset = 0;
+    unsigned int frag_len = RX_BUFFER_SIZE;
+    u32 csum_status = 0;
+
+    ktime_t hw_timestamp;
+    s32 sec_from_hardware = 0;
+    s32 ns_from_hardware = 0;
+
+    len = priv->rx_ring[last_frag].ctrl & EMAC_RX_DESC_LENGTH_MASK;
+
+    skb = dev_alloc_skb(len + RX_OFFSET);
+    if (!skb)
+    {
+	priv->stats.rx_dropped++;
+	for (frag = first_frag; ; frag = NEXT_RX(frag))
+        {
+	    priv->rx_ring[frag].addr &= ~(EMAC_RX_DESC_HOST_OWN);
+	    if (frag == last_frag)
+            {
+		break;
+            }
+	}
+	wmb();
+	return DROPPED_A_PACKET;
+    }
+
+    skb_reserve(skb, RX_OFFSET);
+
+    /* Check the status of the Rx checksum offload calculation */
+    csum_status =
+        priv->rx_ring[last_frag].ctrl & EMAC_RX_DESC_CSUM_OFFLOAD_MASK;
+    if (!csum_status)
+    {
+        /* Neither the IP header nor the TCP/UDP checksum was checked */
+        skb->ip_summed = CHECKSUM_NONE;
+    }
+    else
+    {
+        /* Checksums checked ok */
+        skb->ip_summed = CHECKSUM_UNNECESSARY;
+    }
+
+    skb_put(skb, len);
+
+    for (frag = first_frag; ; frag = NEXT_RX(frag))
+    {
+	if (offset + frag_len > len)
+        {
+            BUG_ON(frag != last_frag);
+	    frag_len = len - offset;
+	}
+
+        skb_copy_to_linear_data_offset(skb, offset,
+				       (priv->rx_buffers +
+				       (RX_BUFFER_SIZE * frag)),
+				       frag_len);
+	offset += RX_BUFFER_SIZE;
+	priv->rx_ring[frag].addr &= ~(EMAC_RX_DESC_HOST_OWN);
+	wmb();
+
+	if (frag == last_frag)
+        {
+	    break;
+        }
+    }
+
+    skb->protocol = eth_type_trans(skb, priv->dev);
+
+    priv->stats.rx_packets++;
+    priv->stats.rx_bytes += len;
+    priv->dev->last_rx = jiffies;
+
+    if (priv->hw_timestamp_flag == HWTSTAMP_FILTER_ALL)
+    {
+        /* We have been asked to include the hardware timestamp of the
+           received packet in the socket buffer */
+
+        /* Read seconds value from hardware */
+        sec_from_hardware =
+        (s32)emac_ioread32(dev, EMAC_1588_TIMER_SECONDS_REG_OFFSET);
+
+        /* Read nS value from the hardware */
+        ns_from_hardware =
+        (s32)emac_ioread32(dev, EMAC_1588_TIMER_NANO_SECONDS_REG_OFFSET);
+
+        /* Re read seconds value from hardware */
+        hw_timestamp.tv.sec =
+        (s32)emac_ioread32(dev, EMAC_1588_TIMER_SECONDS_REG_OFFSET);
+
+        /* Read the nS portion of the timestamp from
+           the received packet */
+        hw_timestamp.tv.nsec = pc302emac_get_ns_from_pkt(skb);
+
+        /* Check for a seconds roll over */
+        if (sec_from_hardware != hw_timestamp.tv.sec)
+        {
+	    /* We have a seconds roll over, therefore
+               use the initial value read. */
+            hw_timestamp.tv.sec = sec_from_hardware;
+	}
+        else if (ns_from_hardware < hw_timestamp.tv.nsec)
+        {
+            /* Note: This 'adjustment' to the seconds value relies
+                     on the fact that less than 1 second has elapsed
+                     between the packet being received and the time
+                     now. */
+            hw_timestamp.tv.sec--;
+        }
+
+        /* Set hardware timestamp value in the socket buffer */
+        skb_hwtstamp_set(skb, hw_timestamp);
+    }
+
+    /* Pass received packet up to higher networking layers */
+    netif_receive_skb(skb);
+
+    return SUCCESS;
+}
+
+static void
+discard_partial_frame(struct net_device *dev,
+                      unsigned int begin,
+                      unsigned int end)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    unsigned int frag = 0;
+
+    for (frag = begin; frag != end; frag = NEXT_RX(frag))
+    {
+	priv->rx_ring[frag].addr &= ~(EMAC_RX_DESC_HOST_OWN);
+    }
+    wmb();
+
+    /*
+     * When this happens, the hardware stats registers for
+     * whatever caused this is updated, so we don't have to record
+     * anything.
+     */
+}
+
+static int
+pc302emac_rx(struct net_device *dev,
+             int budget)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    int received = 0;
+    int first_frag = -1;
+    int dropped = 0;
+
+    unsigned int tail = priv->rx_tail;
+
+    for (; budget > 0; tail = NEXT_RX(tail))
+    {
+	u32 addr, ctrl;
+
+	rmb();
+	addr = priv->rx_ring[tail].addr;
+	ctrl = priv->rx_ring[tail].ctrl;
+
+	if (!(addr & EMAC_RX_DESC_HOST_OWN))
+        {
+	    break;
+        }
+
+	if (ctrl & EMAC_RX_DESC_START_OF_FRAME)
+        {
+	    if (first_frag != -1)
+            {
+		discard_partial_frame(dev, first_frag, tail);
+            }
+	    first_frag = tail;
+	}
+
+	if (ctrl & EMAC_RX_DESC_END_OF_FRAME)
+        {
+	    BUG_ON(first_frag == -1);
+
+	    dropped = pc302emac_rx_frame(dev, first_frag, tail);
+	    first_frag = -1;
+	    if (!dropped)
+            {
+	        received++;
+		budget--;
+	    }
+	}
+    }
+
+    if (first_frag != -1)
+    {
+	priv->rx_tail = first_frag;
+    }
+    else
+    {
+	priv->rx_tail = tail;
+    }
+
+    return received;
+}
+
+static int
+pc302emac_poll(struct napi_struct *napi,
+               int budget)
+{
+    struct pc302_emac *priv = container_of(napi, struct pc302_emac, napi);
+    struct net_device *dev = priv->dev;
+
+    int work_done = 0;
+
+    u32 status = 0;
+
+    status = emac_ioread32(dev, EMAC_RX_STATUS_REG_OFFSET);
+    emac_iowrite32(dev, status, EMAC_RX_STATUS_REG_OFFSET);
+
+    work_done = 0;
+    if (!status)
+    {
+	/*
+	 * This may happen if an interrupt was pending before
+	 * this function was called last time, and no packets
+	 * have been received since.
+	 */
+	netif_rx_complete(dev, napi);
+	goto out;
+    }
+
+    if (!(status & EMAC_RX_BUFFER_NOT_AVAIL) &&
+        !(status & EMAC_FRAME_RECEIVED))
+    {
+	dev_warn(&priv->pdev->dev,
+	         "No RX buffers complete, status = %02lx\n",
+		 (unsigned long)status);
+	netif_rx_complete(dev, napi);
+	goto out;
+    }
+
+    work_done = pc302emac_rx(dev, budget);
+    if (work_done < budget)
+    {
+	netif_rx_complete(dev, napi);
+    }
+
+    /*
+     * We've done what we can to clean the buffers. Make sure we
+     * get notified when new packets arrive.
+     */
+out:
+    emac_iowrite32(dev, EMAC_RX_INT_FLAGS, EMAC_INT_ENABLE_REG_OFFSET );
+
+    return work_done;
+}
+
+static irqreturn_t
+pc302emac_interrupt(int irq,
+                    void *dev_id)
+{
+    struct net_device *dev = dev_id;
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    u32 status = 0;
+
+    /* Let find out why we are here */
+    status = emac_ioread32(dev, EMAC_INT_STATUS_REG_OFFSET);
+
+    if (unlikely(!status))
+    {
+	/* False alarm */
+        return IRQ_NONE;
+    }
+
+    spin_lock(&priv->lock);
+
+    while (status)
+    {
+	/* close possible race with dev_close */
+	if (unlikely(!netif_running(dev)))
+        {
+	    /* Disable all interrupts */
+            emac_iowrite32(dev, 0xFFFFFFFF, EMAC_INT_DISABLE_REG_OFFSET);
+	    break;
+	}
+
+        if (status & EMAC_RX_INT_FLAGS)
+        {
+            /* We have an Rx related interrupt */
+            if (netif_rx_schedule_prep(dev, &priv->napi))
+            {
+	        /*
+	         * There's no point taking any more interrupts
+	         * until we have processed the buffers
+	         */
+	        emac_iowrite32(dev, EMAC_RX_INT_FLAGS,
+                               EMAC_INT_DISABLE_REG_OFFSET);
+	        __netif_rx_schedule(dev, &priv->napi);
+	    }
+        }
+
+        if (status & (EMAC_ENABLE_TX_COMPLETE | EMAC_ENABLE_TX_BUFF_UNDERRUN))
+        {
+            /* We have a Tx related interrupt */
+            pc302emac_tx(dev);
+        }
+
+        if (status & EMAC_ENABLE_HRESP_NOT_OK)
+        {
+	    printk(KERN_ERR "%s: DMA bus error: HRESP not OK\n", dev->name);
+            BUG();
+        }
+
+        /* Check for further EMAC interrupts before exiting */
+        status = emac_ioread32(dev, EMAC_INT_STATUS_REG_OFFSET);
+    }
+
+    spin_unlock(&priv->lock);
+
+    return IRQ_HANDLED;
+}
+
+static int
+pc302emac_start_xmit(struct sk_buff *skb,
+                     struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    dma_addr_t mapping = 0;
+
+    unsigned int len = 0;
+    unsigned int entry = 0;
+
+    u32 ctrl = 0;
+    u32 control = 0;
+
+    len = skb->len;
+    spin_lock_irq(&priv->lock);
+
+    /* This is a hard error, log it. */
+    if (TX_BUFFS_AVAIL(priv) < 1)
+    {
+        netif_stop_queue(dev);
+	spin_unlock_irq(&priv->lock);
+
+        printk(KERN_ERR "%s: BUG! Tx Ring full when queue awake!\n",
+                        dev->name);
+	return START_XMIT_ERROR;
+    }
+
+    entry = priv->tx_head;
+
+    priv->tx_skb[entry].vaddr =
+        dma_pool_alloc(priv->tx_buf_pool, GFP_ATOMIC, &mapping );
+    memcpy(priv->tx_skb[entry].vaddr, skb->data, len);
+    priv->tx_skb[entry].skb = skb;
+    priv->tx_skb[entry].mapping = mapping;
+
+    ctrl = len & EMAC_TX_BUFFER_LENGTH_MASK;
+    ctrl |= EMAC_TX_LAST_BUFFER;
+    if (entry == (TX_RING_SIZE - 1))
+    {
+	ctrl |= EMAC_TX_DESC_WRAP;
+    }
+
+    priv->tx_ring[entry].addr = priv->tx_skb[entry].mapping;
+    priv->tx_ring[entry].ctrl = ctrl;
+    wmb();
+
+    entry = NEXT_TX(entry);
+    priv->tx_head = entry;
+
+    control = emac_ioread32(dev, EMAC_NETWORK_CTRL_REG_OFFSET);
+    control |= EMAC_START_TX;
+    emac_iowrite32(dev, control, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    if (TX_BUFFS_AVAIL(priv) < 1)
+    {
+	netif_stop_queue(dev);
+    }
+
+    spin_unlock_irq(&priv->lock);
+
+    dev->trans_start = jiffies;
+
+    return SUCCESS;
+}
+
+static void
+pc302emac_free_consistent(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    if (priv->tx_skb)
+    {
+	kfree(priv->tx_skb);
+	priv->tx_skb = NULL;
+    }
+
+    if (priv->rx_ring)
+    {
+        dma_free_coherent(&priv->pdev->dev, RX_RING_BYTES,
+		          priv->rx_ring, priv->rx_ring_dma);
+	priv->rx_ring = NULL;
+    }
+
+    if (priv->tx_ring)
+    {
+        dma_free_coherent(&priv->pdev->dev, TX_RING_BYTES,
+		          priv->tx_ring, priv->tx_ring_dma);
+	priv->tx_ring = NULL;
+    }
+
+    if (priv->rx_buffers)
+    {
+	dma_free_coherent(&priv->pdev->dev,
+		          RX_RING_SIZE * RX_BUFFER_SIZE,
+		          priv->rx_buffers, priv->rx_buffers_dma);
+	priv->rx_buffers = NULL;
+    }
+}
+
+static int
+pc302emac_alloc_consistent(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    int size = 0;
+
+    size = TX_RING_SIZE * sizeof(struct ring_info);
+    priv->tx_skb = kmalloc(size, GFP_KERNEL);
+    if (!priv->tx_skb)
+    {
+	goto out_err;
+    }
+
+    size = RX_RING_BYTES;
+    priv->rx_ring = dma_alloc_coherent(&priv->pdev->dev, size,
+				       &priv->rx_ring_dma, GFP_KERNEL);
+    if (!priv->rx_ring)
+    {
+	goto out_err;
+    }
+
+    printk(KERN_DEBUG "%s: allocated Rx ring of %d bytes at %08lx "
+                      "(mapped %p)\n", dev->name, size,
+                      (unsigned long)priv->rx_ring_dma, priv->rx_ring);
+
+    size = TX_RING_BYTES;
+    priv->tx_ring = dma_alloc_coherent(&priv->pdev->dev, size,
+				       &priv->tx_ring_dma, GFP_KERNEL);
+    if (!priv->tx_ring)
+    {
+	goto out_err;
+    }
+
+    printk(KERN_DEBUG "%s: allocated Tx ring of %d bytes at %08lx "
+                      "(mapped %p)\n",	dev->name, size,
+                      (unsigned long)priv->tx_ring_dma, priv->tx_ring);
+
+    size = RX_RING_SIZE * RX_BUFFER_SIZE;
+    priv->rx_buffers = dma_alloc_coherent(&priv->pdev->dev, size,
+					  &priv->rx_buffers_dma, GFP_KERNEL);
+    if (!priv->rx_buffers)
+    {
+	goto out_err;
+    }
+
+    printk(KERN_DEBUG "%s: allocated Rx buffers of %d bytes at %08lx "
+                      "(mapped %p)\n", dev->name, size,
+                      (unsigned long)priv->rx_buffers_dma, priv->rx_buffers);
+
+    return SUCCESS;
+
+out_err:
+    pc302emac_free_consistent(dev);
+    return -ENOMEM;
+}
+
+static void
+pc302emac_init_rings(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    int i = 0;
+    dma_addr_t addr = 0;;
+
+    /* Rx Ring */
+    addr = priv->rx_buffers_dma;
+    for (i = 0; i < RX_RING_SIZE; i++)
+    {
+        priv->rx_ring[i].addr = addr;
+        priv->rx_ring[i].ctrl = 0;
+	addr += RX_BUFFER_SIZE;
+    }
+
+    /* Mark the end of the ring */
+    priv->rx_ring[RX_RING_SIZE - 1].addr |= EMAC_RX_DESC_WRAP;
+
+    /* Tx Ring */
+    for (i = 0; i < TX_RING_SIZE; i++)
+    {
+        priv->tx_ring[i].addr = 0;
+        priv->tx_ring[i].ctrl = EMAC_TX_DESC_HOST_OWN;
+    }
+
+    /* Mark the end of the ring */
+    priv->tx_ring[TX_RING_SIZE - 1].ctrl |= EMAC_TX_DESC_WRAP;
+
+    priv->rx_tail = priv->tx_head = priv->tx_tail = 0;
+}
+
+static void
+pc302emac_reset_hw(struct net_device *dev)
+{
+    /* Make sure we have the write buffer for ourselves */
+    wmb();
+
+     /* Disable Rx and Tx */
+    emac_iowrite32(dev, 0, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Clear the EMAC statistics counters */
+    emac_iowrite32(dev, EMAC_CLEAR_STATS_REGISTERS,
+                        EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Clear The Tx and Rx status flags */
+    emac_iowrite32(dev, 0xFFFFFFFF, EMAC_TX_STATUS_REG_OFFSET);
+    emac_iowrite32(dev, 0xFFFFFFFF, EMAC_RX_STATUS_REG_OFFSET);
+
+    /* Disable all interrupts */
+    emac_iowrite32(dev, 0xFFFFFFFF, EMAC_INT_DISABLE_REG_OFFSET);
+    emac_ioread32(dev, EMAC_INT_STATUS_REG_OFFSET);
+}
+
+static void
+pc302emac_init_hw(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    u32 dma_config_register = 0;
+    u32 config = 0;
+    u32 control = 0;
+    u32 interrupt_enable = 0;
+
+    pc302emac_reset_hw(dev);
+    pc302emac_set_hwaddr(dev);
+
+    /* Setup the size of the DMA Receive Buffer */
+    dma_config_register = emac_ioread32(dev, EMAC_DMA_CFG_REG_OFFSET);
+    dma_config_register &= ~(EMAC_DMA_RX_BUFFER_SIZE_MASK);
+    dma_config_register |= EMAC_DMA_RX_BUFFER_SIZE;
+    emac_iowrite32(dev, dma_config_register, EMAC_DMA_CFG_REG_OFFSET);
+
+    /* Network configuration register setup */
+    config = emac_ioread32(dev, EMAC_NETWORK_CFG_REG_OFFSET);
+
+    /* Required for PC302 */
+    config |= EMAC_64_BIT_AMBA_DATA_BUS_WITDH;
+
+    /* Pause Enable */
+    config |= EMAC_PAUSE_ENABLE;
+
+    /* Discard frames with length errors */
+    config |= EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD;
+    if (priv->dev->flags & IFF_PROMISC)
+    {
+    	/* Copy all Frames */
+        config |= EMAC_COPY_ALL_FRAMES;
+    }
+    if (!(priv->dev->flags & IFF_BROADCAST))
+    {
+	/* No Broadcast frames */
+        config |= EMAC_NO_BROADCAST_FRAMES;
+    }
+
+    /* Enable Rx Checksum offload */
+    config |= EMAC_RX_CHKSUM_OFFLOAD_ENABLE;
+
+    emac_iowrite32(dev, config, EMAC_NETWORK_CFG_REG_OFFSET);
+
+    /* Initialize Tx and Rx buffer base address registers */
+    emac_iowrite32(dev, priv->rx_ring_dma,
+                   EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET);
+    emac_iowrite32(dev, priv->tx_ring_dma,
+                   EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET);
+
+    /* Network control register setup */
+    control = emac_ioread32(dev, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Enable the EMAC to store the nS portion of the timestamp
+     * of the received packet in the crc field of the received packet.
+     * Note: This functionality is required for packet timestamp
+     *       reporting.
+     */
+    control |= EMAC_STORE_TX_TIMESTAMP_IN_CRC;
+
+    control |= EMAC_RX_ENABLE;
+    control |= EMAC_TX_ENABLE;
+    control |= EMAC_MDIO_ENABLE;
+    emac_iowrite32(dev, control, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Initialise hw_timestamp_flag */
+    priv->hw_timestamp_flag = HWTSTAMP_FILTER_NONE;
+
+    /* Enable interrupts */
+    interrupt_enable = EMAC_ENABLE_RX_COMPLETE
+                     | EMAC_ENABLE_RX_USED_BIT_READ
+                     | EMAC_ENABLE_TX_BUFF_UNDERRUN
+                     | EMAC_ENABLE_TRANSMIT_CORRUPTION_AHB_ERROR
+                     | EMAC_ENABLE_TX_COMPLETE
+                     | EMAC_ENABLE_RX_OVERRUN
+                     | EMAC_ENABLE_HRESP_NOT_OK;
+
+    emac_iowrite32(dev, interrupt_enable, EMAC_INT_ENABLE_REG_OFFSET);
+}
+
+/*
+ * The hash address register is 64 bits long and takes up two
+ * locations in the memory map.  The least significant bits are stored
+ * in EMAC_HSL and the most significant bits in EMAC_HSH.
+ *
+ * The unicast hash enable and the multicast hash enable bits in the
+ * network configuration register enable the reception of hash matched
+ * frames. The destination address is reduced to a 6 bit index into
+ * the 64 bit hash register using the following hash function.  The
+ * hash function is an exclusive or of every sixth bit of the
+ * destination address.
+ *
+ * hi[5] = da[5] ^ da[11] ^ da[17] ^ da[23] ^ da[29] ^ da[35] ^ da[41] ^ da[47]
+ * hi[4] = da[4] ^ da[10] ^ da[16] ^ da[22] ^ da[28] ^ da[34] ^ da[40] ^ da[46]
+ * hi[3] = da[3] ^ da[09] ^ da[15] ^ da[21] ^ da[27] ^ da[33] ^ da[39] ^ da[45]
+ * hi[2] = da[2] ^ da[08] ^ da[14] ^ da[20] ^ da[26] ^ da[32] ^ da[38] ^ da[44]
+ * hi[1] = da[1] ^ da[07] ^ da[13] ^ da[19] ^ da[25] ^ da[31] ^ da[37] ^ da[43]
+ * hi[0] = da[0] ^ da[06] ^ da[12] ^ da[18] ^ da[24] ^ da[30] ^ da[36] ^ da[42]
+ *
+ * da[0] represents the least significant bit of the first byte
+ * received, that is, the multicast/unicast indicator, and da[47]
+ * represents the most significant bit of the last byte received.  If
+ * the hash index, hi[n], points to a bit that is set in the hash
+ * register then the frame will be matched according to whether the
+ * frame is multicast or unicast.  A multicast match will be signalled
+ * if the multicast hash enable bit is set, da[0] is 1 and the hash
+ * index points to a bit set in the hash register.  A unicast match
+ * will be signalled if the unicast hash enable bit is set, da[0] is 0
+ * and the hash index points to a bit set in the hash register.  To
+ * receive all multicast frames, the hash register should be set with
+ * all ones and the multicast hash enable bit should be set in the
+ * network configuration register.
+ */
+
+static inline int
+hash_bit_value(int bitnr,
+               __u8 *addr)
+{
+    if (addr[bitnr / 8] & (1 << (bitnr % 8)))
+    {
+	return BIT_IS_ONE;
+    }
+    return BIT_IS_ZERO;
+}
+
+static int
+hash_get_index(__u8 *addr)
+{
+    int i = 0;
+    int j = 0;
+    int bitval = 0;
+    int hash_index = 0;
+
+    for (j = 0; j < 6; j++)
+    {
+	for (i = 0, bitval = 0; i < 8; i++)
+        {
+	    bitval ^= hash_bit_value(i*6 + j, addr);
+        }
+
+        hash_index |= (bitval << j);
+    }
+
+    return hash_index;
+}
+
+static void
+pc302emac_sethashtable(struct net_device *dev)
+{
+    struct dev_mc_list *curr = NULL;
+    unsigned long mc_filter[2];
+    unsigned int i = 0;
+    unsigned int bitnr = 0;
+
+    mc_filter[0] = mc_filter[1] = 0;
+
+    curr = dev->mc_list;
+    for (i = 0; i < dev->mc_count; i++, curr = curr->next)
+    {
+        if (!curr)
+        {
+            break;	/* unexpected end of list */
+        }
+
+	bitnr = hash_get_index(curr->dmi_addr);
+	mc_filter[bitnr >> 5] |= 1 << (bitnr & 31);
+    }
+
+    emac_iowrite32(dev, (u32)mc_filter[0], EMAC_HASH_BOT_31_0_REG_OFFSET);
+    emac_iowrite32(dev, (u32)mc_filter[1], EMAC_HASH_TOP_63_32_REG_OFFSET);
+}
+
+static void
+pc302emac_set_rx_mode(struct net_device *dev)
+{
+    u32 config = 0;
+
+    config = emac_ioread32(dev, EMAC_NETWORK_CFG_REG_OFFSET);
+
+    if (dev->flags & IFF_PROMISC)
+    {
+    	/* Enable promiscuous mode */
+	config |= EMAC_COPY_ALL_FRAMES;
+    }
+    else if (dev->flags & (~IFF_PROMISC))
+    {
+	/* Disable promiscuous mode */
+	config &= ~(EMAC_COPY_ALL_FRAMES);
+    }
+    if (dev->flags & IFF_ALLMULTI)
+    {
+	/* Enable all multicast mode */
+	emac_iowrite32(dev, 0xFFFFFFFF, EMAC_HASH_BOT_31_0_REG_OFFSET);
+	emac_iowrite32(dev, 0xFFFFFFFF, EMAC_HASH_TOP_63_32_REG_OFFSET);
+	config |= EMAC_MULTICAST_HASH_ENABLE;
+    }
+    else if (dev->mc_count > 0)
+    {
+	/* Enable specific multicasts */
+	pc302emac_sethashtable(dev);
+	config |= EMAC_MULTICAST_HASH_ENABLE;
+    }
+    else if (dev->flags & (~IFF_ALLMULTI))
+    {
+	/* Disable all multicast mode */
+	emac_iowrite32(dev, 0, EMAC_HASH_BOT_31_0_REG_OFFSET);
+	emac_iowrite32(dev, 0, EMAC_HASH_TOP_63_32_REG_OFFSET);
+	config &= ~(EMAC_MULTICAST_HASH_ENABLE);
+    }
+
+    emac_iowrite32(dev, config, EMAC_NETWORK_CFG_REG_OFFSET);
+}
+
+static int
+pc302emac_open(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    int ret = 0;
+
+    /* If the phy is not yet registered, retry later */
+    if (!priv->phy_dev)
+    {
+    	return -EAGAIN;
+    }
+
+    if (!is_valid_ether_addr(dev->dev_addr))
+    {
+    	return -EADDRNOTAVAIL;
+    }
+
+    ret = pc302emac_alloc_consistent(dev);
+    if (ret)
+    {
+	printk(KERN_ERR "%s: unable to allocate DMA memory (error %d)\n",
+                         dev->name, ret);
+	return ret;
+    }
+
+    napi_enable(&priv->napi);
+
+    pc302emac_init_rings(dev);
+    pc302emac_init_hw(dev);
+
+    /* schedule a link state check */
+    phy_start(priv->phy_dev);
+
+    netif_start_queue(dev);
+
+    return SUCCESS;
+}
+
+static int
+pc302emac_close(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    unsigned long flags = 0;
+
+    netif_stop_queue(dev);
+    napi_disable(&priv->napi);
+
+    if (priv->phy_dev)
+    {
+        phy_stop(priv->phy_dev);
+    }
+
+    spin_lock_irqsave(&priv->lock, flags);
+    pc302emac_reset_hw(dev);
+    netif_carrier_off(dev);
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    pc302emac_free_consistent(dev);
+
+    return SUCCESS;
+}
+
+static struct
+net_device_stats *pc302emac_get_stats(struct net_device *dev)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct net_device_stats *stats = &priv->stats;
+    struct pc302emac_stats *hwstat = &priv->hw_stats;
+
+    /* Update statistics from the EMAC hardware counters */
+    pc302emac_update_stats(priv);
+
+    /* Convert the EMAC hardware counter values into net_device_stats */
+    stats->rx_errors = (hwstat->rx_frame_check_sequence_errors +
+                        hwstat->rx_alignment_errors +
+                        hwstat->rx_resource_errors +
+                        hwstat->rx_overruns +
+                        hwstat->rx_oversize_frames +
+                        hwstat->rx_jabbers +
+                        hwstat->rx_undersized_frames +
+                        hwstat->rx_length_field_frame_errors);
+
+    stats->tx_errors = (hwstat->tx_late_colloisions +
+                        hwstat->tx_excessive_collisions +
+                        hwstat->tx_underrun +
+                        hwstat->tx_carrier_sense_errors);
+
+    stats->collisions = (hwstat->tx_single_collision_frames +
+                         hwstat->tx_multiple_collision_frames +
+                         hwstat->tx_excessive_collisions);
+
+    stats->rx_length_errors = (hwstat->rx_oversize_frames +
+                               hwstat->rx_jabbers +
+                               hwstat->rx_undersized_frames +
+                               hwstat->rx_length_field_frame_errors);
+
+    stats->rx_over_errors = hwstat->rx_resource_errors;
+
+    stats->rx_crc_errors = hwstat->rx_frame_check_sequence_errors;
+
+    stats->rx_frame_errors = hwstat->rx_alignment_errors;
+
+    stats->rx_fifo_errors = hwstat->rx_overruns;
+
+    stats->tx_aborted_errors = hwstat->tx_excessive_collisions;
+
+    stats->tx_carrier_errors = hwstat->tx_carrier_sense_errors;
+
+    stats->tx_fifo_errors = hwstat->tx_underrun;
+
+    return stats;
+}
+
+static int
+pc302emac_get_settings(struct net_device *dev,
+                       struct ethtool_cmd *cmd)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct phy_device *phydev = priv->phy_dev;
+
+    if (!phydev)
+    {
+	return -ENODEV;
+    }
+
+    return phy_ethtool_gset(phydev, cmd);
+}
+
+static int
+pc302emac_set_settings(struct net_device *dev,
+                       struct ethtool_cmd *cmd)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct phy_device *phydev = priv->phy_dev;
+
+    if (!phydev)
+    {
+        return -ENODEV;
+    }
+
+    return phy_ethtool_sset(phydev, cmd);
+}
+
+static void
+pc302emac_get_drvinfo(struct net_device *dev,
+	              struct ethtool_drvinfo *info)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+
+    strcpy(info->driver, priv->pdev->dev.driver->name);
+    strcpy(info->bus_info, priv->pdev->dev.bus_id);
+}
+
+static struct
+ethtool_ops pc302emac_ethtool_ops =
+{
+    .get_settings   = pc302emac_get_settings,
+    .set_settings   = pc302emac_set_settings,
+    .get_drvinfo    = pc302emac_get_drvinfo,
+    .get_link	    = ethtool_op_get_link,
+};
+
+static int
+pc302emac_ioctl(struct net_device *dev,
+                struct ifreq *rq,
+                int cmd)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct phy_device *phydev = priv->phy_dev;
+
+    /* Is the network interface up and running ?*/
+    if (!netif_running(dev))
+    {
+	return -EINVAL;
+    }
+
+    /* Do we have a connected phy ? */
+    if (!phydev)
+    {
+	return -ENODEV;
+    }
+
+    switch (cmd)
+    {
+        case SIOCGMIIPHY:
+            /* Fall through intentional */
+
+        case SIOCGMIIREG:
+            /* Fall through intentional */
+
+        case SIOCSMIIREG:
+            return phy_mii_ioctl(phydev, if_mii(rq), cmd);
+
+        case SIOCSHWTSTAMP:
+	    return pc302emac_hwtstamp_ioctl(dev, rq, cmd);
+
+        default:
+	    return -EOPNOTSUPP;
+    }
+}
+
+static int pc302emac_hwtstamp_ioctl(struct net_device *dev,
+                                    struct ifreq *ifr,
+                                    int cmd)
+{
+    struct pc302_emac *priv = netdev_priv(dev);
+    struct hwtstamp_config config;
+
+    if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+    {
+        return -EFAULT;
+    }
+
+    /* reserved for future extensions */
+    if (config.flags)
+    {
+	return -EINVAL;
+    }
+
+    /* We do not support hardware timestamping of outgoing packets,
+       leave the frame work in here for possible future software
+       enhancements */
+    switch (config.tx_type)
+    {
+        case HWTSTAMP_TX_OFF:
+	    break;
+
+        case HWTSTAMP_TX_ON:
+	    break;
+
+        default:
+	    return -ERANGE;
+    }
+
+    switch (config.rx_filter_type)
+    {
+        case HWTSTAMP_FILTER_NONE:
+            /* Hardware timestamping not required */
+            priv->hw_timestamp_flag = HWTSTAMP_FILTER_NONE;
+
+            printk(KERN_INFO "%s: Hardware timestamping of received "
+                             "packets disabled\n", dev->name);
+            break;
+
+        case HWTSTAMP_FILTER_ALL:
+	    /* Hardware timestamping of received packets is required */
+            priv->hw_timestamp_flag = HWTSTAMP_FILTER_ALL;
+
+            printk(KERN_INFO "%s: Hardware timestamping of received "
+                             "packets enabled\n", dev->name);
+	    config.rx_filter_type = HWTSTAMP_FILTER_ALL;
+	    break;
+
+        case HWTSTAMP_FILTER_SOME:
+            printk(KERN_INFO "%s: HWTSTAMP_FILTER_SOME not "
+                             "supported by driver\n", dev->name);
+            break;
+
+        case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+            printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V1_L4_EVENT"
+                             " not supported by driver\n", dev->name);
+            break;
+
+        case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V1_L4_SYNC"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L4_EVENT"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L4_SYNC"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L2_EVENT"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L2_SYNC"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_EVENT"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_SYNC"
+                              " not supported by driver\n", dev->name);
+            break;
+
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+             printk(KERN_INFO "%s: HWTSTAMP_FILTER_PTP_V2_DELAY_REQ"
+                              " not supported by driver\n", dev->name);
+            break;
+
+        default:
+	    return -ERANGE;
+    }
+
+    return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ? -EFAULT : 0;
+}
+
+/* Sysfs functions and data structures */
+static ssize_t
+pc302emac_sysfs_1588_seconds_show(struct device *dev,
+                                  struct device_attribute *attr,
+                                  char *buf)
+{
+    u32 value = emac_ioread32(sysfs_ndev,
+                              EMAC_1588_TIMER_SECONDS_REG_OFFSET);
+
+    return snprintf(buf, PAGE_SIZE, "%u\n", value);
+}
+
+static ssize_t
+pc302emac_sysfs_1588_seconds_store(struct device *dev,
+                                   struct device_attribute *attr,
+                                   const char *buf,
+                                   size_t count)
+{
+    unsigned long value = 0;
+    char *endp;
+
+    value = simple_strtoul(buf, &endp, 0);
+
+    if (buf != endp)
+    {
+        /* We have some valid data to write */
+        emac_iowrite32(sysfs_ndev, (u32)value,
+                       EMAC_1588_TIMER_SECONDS_REG_OFFSET);
+    }
+
+    return (ssize_t)count;
+}
+
+static DEVICE_ATTR(1588_timer_seconds, (S_IRUGO | S_IWUGO),
+                   pc302emac_sysfs_1588_seconds_show,
+                   pc302emac_sysfs_1588_seconds_store);
+
+static ssize_t
+pc302emac_sysfs_1588_nano_seconds_show(struct device *dev,
+                                       struct device_attribute *attr,
+                                       char *buf)
+{
+    u32 value = emac_ioread32(sysfs_ndev,
+                              EMAC_1588_TIMER_NANO_SECONDS_REG_OFFSET);
+
+    return snprintf(buf, PAGE_SIZE, "%u\n", value);
+}
+
+static ssize_t
+pc302emac_sysfs_1588_nano_seconds_store(struct device *dev,
+                                        struct device_attribute *attr,
+                                        const char *buf,
+                                        size_t count)
+{
+    unsigned long value = 0;
+    char *endp;
+
+    value = simple_strtoul(buf, &endp, 0);
+
+    if (buf != endp)
+    {
+        /* We have some valid data to write */
+        emac_iowrite32(sysfs_ndev,
+                       (u32)value, EMAC_1588_TIMER_NANO_SECONDS_REG_OFFSET);
+    }
+
+    return (ssize_t)count;
+}
+
+static DEVICE_ATTR(1588_timer_nano_seconds, (S_IRUGO | S_IWUGO),
+                   pc302emac_sysfs_1588_nano_seconds_show,
+                   pc302emac_sysfs_1588_nano_seconds_store);
+
+static ssize_t
+pc302emac_sysfs_1588_timer_adjust_store(struct device *dev,
+                                        struct device_attribute *attr,
+                                        const char *buf,
+                                        size_t count)
+{
+    unsigned long value = 0;
+    char *endp;
+
+    value = simple_strtoul(buf, &endp, 0);
+
+    if (buf != endp)
+    {
+        /* We have some valid data to write */
+        emac_iowrite32(sysfs_ndev, (u32)value,
+                       EMAC_1588_TIMER_ADJUST_REG_OFFSET);
+    }
+
+    return (ssize_t)count;
+}
+
+static DEVICE_ATTR(1588_timer_adjust, S_IWUGO,
+                   NULL,
+                   pc302emac_sysfs_1588_timer_adjust_store);
+
+static ssize_t
+pc302emac_sysfs_1588_timer_increment_show(struct device *dev,
+                                          struct device_attribute *attr,
+                                          char *buf)
+{
+    u32 value = emac_ioread32(sysfs_ndev,
+                              EMAC_1588_TIMER_INCREMENT_REG_OFFSET);
+
+    return snprintf(buf, PAGE_SIZE, "%u\n", value);
+}
+
+static ssize_t
+pc302emac_sysfs_1588_timer_increment_store(struct device *dev,
+                                           struct device_attribute *attr,
+                                           const char *buf,
+                                           size_t count)
+{
+    unsigned long value = 0;
+    char *endp;
+
+    value = simple_strtoul(buf, &endp, 0);
+
+    if (buf != endp)
+    {
+        /* We have some valid data */
+        emac_iowrite32(sysfs_ndev, (u32)value,
+                       EMAC_1588_TIMER_INCREMENT_REG_OFFSET);
+    }
+
+    return (ssize_t)count;
+}
+
+static DEVICE_ATTR(1588_timer_increment, (S_IRUGO | S_IWUGO),
+                   pc302emac_sysfs_1588_timer_increment_show,
+                   pc302emac_sysfs_1588_timer_increment_store);
+
+/*!
+ * The group of sysfs attributes that should be added
+ * to the sysfs filesystem.
+ */
+static struct attribute *pc302emac_attrs[] =
+{
+    &dev_attr_1588_timer_seconds.attr,
+    &dev_attr_1588_timer_nano_seconds.attr,
+    &dev_attr_1588_timer_adjust.attr,
+    &dev_attr_1588_timer_increment.attr,
+    NULL
+};
+
+/*!
+ * Add the sysfs attributes as a group
+ */
+static struct attribute_group pc302emac_attr_group =
+{
+    .attrs = pc302emac_attrs
+};
+
+static int
+pc302emac_sysfs_add(struct platform_device *pdev)
+{
+    return sysfs_create_group(&pdev->dev.kobj, &pc302emac_attr_group);
+}
+
+static void
+pc302emac_sysfs_remove(struct platform_device *pdev)
+{
+    sysfs_remove_group(&pdev->dev.kobj, &pc302emac_attr_group);
+}
+
+static int
+emac_drv_probe(struct platform_device *pdev)
+{
+    struct resource *regs;
+    struct resource *irq;
+    struct net_device *dev;
+    struct pc302_emac *priv;
+    struct phy_device *phydev;
+
+    int ret = -ENXIO;
+
+    u32 config;
+
+    /* Obtain some platform resources */
+    regs = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+    irq = platform_get_resource( pdev, IORESOURCE_IRQ, 0 );
+
+    if (!regs || ! irq)
+    {
+        /* Oops, we can't obtain any resources */
+        printk(KERN_ERR "%s: could not obtain platform resources.\n",
+                         CARDNAME);
+        ret = -EINVAL;
+        goto out;
+    }
+
+    if (!request_mem_region(regs->start, (regs->end - regs->start) + 1,
+                            CARDNAME))
+    {
+        /* Oops, we can't obtain the required memory region */
+        printk(KERN_ERR "%s: memory mapping error, Address=0x%08x,"
+                        " Size=0x%08x\n", CARDNAME, regs->start,
+                         (regs->end - regs->start) + 1);
+        ret = -ENOMEM;
+        goto out;
+    }
+
+    dev = alloc_etherdev(sizeof(*priv));
+    if (!dev)
+    {
+        /* Oops, we can't allocate the net_device structure */
+        printk(KERN_ERR "%s: could not allocate net_device structure.\n",
+                         CARDNAME);
+        ret = -ENOMEM;
+        goto out_alloc_failed;
+    }
+
+    SET_NETDEV_DEV(dev, &pdev->dev);
+
+    priv = netdev_priv(dev);
+    priv->mii_bus = mdiobus_alloc();
+    priv->pdev = pdev;
+    priv->dev = dev;
+    /* Create a DMA pool for the transmit buffers. We use this to copy the
+     * transmit data into here to make sure that we are aligned to a 16 bit
+     * boundary. */
+    priv->tx_buf_pool =
+        dma_pool_create("pc302emac_tx", &pdev->dev, TX_BUFFER_SIZE, 16, 0 );
+    if (!priv->tx_buf_pool)
+    {
+        printk(KERN_ERR "%s: failed to allocate tx buf cache\n", CARDNAME);
+        ret = -ENOMEM;
+        goto out_tx_cache_failed;
+    }
+
+    spin_lock_init(&priv->lock);
+
+    priv->regs = ioremap(regs->start, (regs->end - regs->start) + 1);
+    if (!priv->regs)
+    {
+        /* Oops, we can't remap io memory */
+        printk(KERN_ERR "%s: could not remap io addresses.\n",
+                         CARDNAME);
+	ret = -ENOMEM;
+	goto out_ioremap_failed;
+    }
+
+    dev->irq = irq->start;
+    ret = request_irq(dev->irq, pc302emac_interrupt, 0,
+		      dev->name, dev);
+    if (ret)
+    {
+        printk(KERN_ERR "%s: unable to request IRQ %d (error %d)\n",
+		        CARDNAME, dev->irq, ret);
+        ret = -ENXIO;
+        goto out_req_irq_failed;
+    }
+
+    dev->open = pc302emac_open;
+    dev->stop = pc302emac_close;
+    dev->hard_start_xmit = pc302emac_start_xmit;
+    dev->get_stats = pc302emac_get_stats;
+    dev->set_multicast_list = pc302emac_set_rx_mode;
+    dev->do_ioctl = pc302emac_ioctl;
+    netif_napi_add(dev, &priv->napi, pc302emac_poll, 16);
+    dev->ethtool_ops = &pc302emac_ethtool_ops;
+
+    dev->base_addr = regs->start;
+
+    /* Set MII management clock divider */
+    config = emac_ioread32(dev, EMAC_NETWORK_CFG_REG_OFFSET);
+    config &= EMAC_MDC_CLOCK_DIV_MASK;
+    config |= EMAC_MDC_CLOCK_DIV_96;
+    emac_iowrite32(dev, config, EMAC_NETWORK_CFG_REG_OFFSET);
+
+    /* Get MAC address */
+    pc302emac_get_hwaddr(dev);
+
+    priv->tx_pending = DEF_TX_RING_PENDING;
+
+    /* Register the network device */
+    ret = register_netdev(dev);
+    if (ret)
+    {
+	printk(KERN_ERR "%s: could not register net device\n", CARDNAME);
+
+        ret = -ENOMEM;
+        goto out_reg_netdev_failed;
+    }
+
+    if (pc302emac_mii_init(dev) != 0)
+    {
+        ret = -ENXIO;
+        goto out_mii_init_failed;
+    }
+
+    platform_set_drvdata(pdev, dev);
+
+    /* Initislise our local copy for sysfs use */
+    sysfs_ndev = dev;
+
+    /* Setup sysfs support */
+    ret = pc302emac_sysfs_add(pdev);
+    if (ret)
+    {
+        /* Oops, something not right here */
+        printk(KERN_ERR "%s: failed to create sysfs device attributes\n",
+               CARDNAME);
+    }
+
+    printk(KERN_INFO "%s: Ethernet driver " CONFIG_LOCALVERSION " loaded\n",
+           CARDNAME);
+
+    phydev = priv->phy_dev;
+    printk(KERN_INFO "%s: attached Phy driver [%s] "
+		     "(mii_bus:phy_addr=%s, irq=%d)\n",
+		     dev->name, phydev->drv->name, phydev->dev.bus_id,
+                     phydev->irq);
+
+    return SUCCESS;
+
+out_mii_init_failed:
+    unregister_netdev(dev);
+
+out_reg_netdev_failed:
+    free_netdev(dev);
+
+out_req_irq_failed:
+    free_irq(dev->irq, dev);
+
+out_ioremap_failed:
+    iounmap(priv->regs);
+
+out_tx_cache_failed:
+out_alloc_failed:
+    release_mem_region (regs->start, (regs->end - regs->start) + 1);
+
+out:
+    /* We have failed in some way */
+    printk(KERN_ERR "%s: Ethernet driver registration failed\n", CARDNAME);
+    return ret;
+}
+
+static int
+emac_drv_remove(struct platform_device *pdev)
+{
+    struct net_device *dev = NULL;
+    struct pc302_emac *priv = NULL;
+
+    dev = platform_get_drvdata(pdev);
+
+    if (dev)
+    {
+        priv = netdev_priv(dev);
+	if (priv->phy_dev)
+        {
+	    phy_disconnect(priv->phy_dev);
+        }
+	mdiobus_unregister(priv->mii_bus);
+	kfree(priv->mii_bus->irq);
+        mdiobus_free(priv->mii_bus);
+	unregister_netdev(dev);
+	free_irq(dev->irq, dev);
+	iounmap(priv->regs);
+        dma_pool_destroy(priv->tx_buf_pool);
+	free_netdev(dev);
+	platform_set_drvdata(pdev, NULL);
+
+        /* Remove sysfs support */
+        pc302emac_sysfs_remove(pdev);
+    }
+
+    return SUCCESS;
+}
+
+/*!
+ * Platform driver data structure.
+ */
+static struct
+platform_driver emac_driver =
+{
+    .probe      = emac_drv_probe,
+    .remove     = emac_drv_remove,
+    .driver     =
+    {
+        .name   = CARDNAME,
+    }
+};
+
+static int
+emac_init_module(void)
+{
+    int ret = 0;
+
+    /* Register the platform driver */
+    ret = platform_driver_register(&emac_driver);
+    if (ret != 0)
+    {
+        printk(KERN_ERR "%s: Failed to register EMAC driver\n", CARDNAME);
+    }
+
+    return ret;
+}
+
+static void
+emac_cleanup_module(void)
+{
+    platform_driver_unregister(&emac_driver);
+}
+
+module_init(emac_init_module);
+module_exit(emac_cleanup_module);
+
+MODULE_AUTHOR("picoChip");
+MODULE_DESCRIPTION("picoChip PC302 Ethernet Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/pc302_emac.h b/drivers/net/pc302_emac.h
new file mode 100644
index 0000000..0fe3372
--- /dev/null
+++ b/drivers/net/pc302_emac.h
@@ -0,0 +1,263 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file
+* \brief pc302_emac.h
+*
+* Copyright (c) 2006-2008 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_EMAC_H
+#define PC302_EMAC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/*!
+ * Register Offset Addresses
+ */
+#define EMAC_NETWORK_CTRL_REG_OFFSET                                (0x0000)
+#define EMAC_NETWORK_CFG_REG_OFFSET                                 (0x0004)
+#define EMAC_NETWORK_STATUS_REG_OFFSET                              (0x0008)
+#define EMAC_USER_IO_REG_OFFSET                                     (0x000C)
+#define EMAC_DMA_CFG_REG_OFFSET                                     (0x0010)
+#define EMAC_TX_STATUS_REG_OFFSET                                   (0x0014)
+#define EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x0018)
+#define EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x001C)
+#define EMAC_RX_STATUS_REG_OFFSET                                   (0x0020)
+#define EMAC_INT_STATUS_REG_OFFSET                                  (0x0024)
+#define EMAC_INT_ENABLE_REG_OFFSET                                  (0x0028)
+#define EMAC_INT_DISABLE_REG_OFFSET                                 (0x002C)
+#define EMAC_INT_MASK_REG_OFFSET                                    (0x0030)
+#define EMAC_PHY_MAINTAIN_REG_OFFSET                                (0x0034)
+#define EMAC_RX_PAUSE_QUANTUM_REG_OFFSET                            (0x0038)
+#define EMAC_TX_PAUSE_QUATNUM_REG_OFFSET                            (0x003C)
+#define EMAC_HASH_BOT_31_0_REG_OFFSET                               (0x0080)
+#define EMAC_HASH_TOP_63_32_REG_OFFSET                              (0x0084)
+#define EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET                        (0x0088)
+#define EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET                       (0x008C)
+#define EMAC_SPEC_ADDR_2_BOT_31_0_REG_OFFSET                        (0x0090)
+#define EMAC_SPEC_ADDR_2_TOP_47_32_REG_OFFSET                       (0x0094)
+#define EMAC_SPEC_ADDR_3_BOT_31_0_REG_OFFSET                        (0x0098)
+#define EMAC_SPEC_ADDR_3_TOP_47_32_REG_OFFSET                       (0x009C)
+#define EMAC_SPEC_ADDR_4_BOT_31_0_REG_OFFSET                        (0x00A0)
+#define EMAC_SPEC_ADDR_4_TOP_47_32_REG_OFFSET                       (0x00A4)
+#define EMAC_TYPE_ID_MATCH_1_REG_OFFSET                             (0x00A8)
+#define EMAC_TYPE_ID_MATCH_2_REG_OFFSET                             (0x00AC)
+#define EMAC_TYPE_ID_MATCH_3_REG_OFFSET                             (0x00B0)
+#define EMAC_TYPE_ID_MATCH_4_REG_OFFSET                             (0x00B4)
+#define EMAC_WOL_REG_OFFSET                                         (0x00B8)
+#define EMAC_IPG_STRETCH_REG_OFFSET                                 (0x00BC)
+#define EMAC_STACKED_VLAN_REG_OFFSET                                (0x00C0)
+
+#define EMAC_MODULE_ID_REG_OFFSET                                   (0x00FC)
+
+#define EMAC_OCTETS_TX_31_0_REG_OFFSET                              (0x0100)
+#define EMAC_OCTETS_TX_47_32_REG_OFFSET                             (0x0104)
+#define EMAC_FRAMES_TX_NO_ERROR_REG_OFFSET                          (0x0108)
+#define EMAC_BROADCAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x010C)
+#define EMAC_MULTICAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x0110)
+#define EMAC_TX_PAUSE_FRAMES_REG_OFFSET                             (0x0114)
+#define EMAC_64_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET                  (0x0118)
+#define EMAC_65_127_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET              (0x011C)
+#define EMAC_128_255_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0120)
+#define EMAC_256_511_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0124)
+#define EMAC_512_1023_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET            (0x0128)
+#define EMAC_1024_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET           (0x012C)
+#define EMAC_GREATER_THAN_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET   (0x0130)
+#define EMAC_TX_UNDER_RUN_ERROR_REG_OFFSET                          (0x0134)
+#define EMAC_SINGLE_COLLISION_FRAMES_REG_OFFSET                     (0x0138)
+#define EMAC_MULTIPLE_COLLISION_FRAMES_REG_OFFSET                   (0x013C)
+#define EMAC_EXCESSIVE_COLLISIONS_REG_OFFSET                        (0x0140)
+#define EMAC_LATE_COLLISIONS_REG_OFFSET                             (0x0144)
+#define EMAC_DEFFERED_TX_FRAMES_REG_OFFSET                          (0x0148)
+#define EMAC_CARRIER_SENSE_ERRORS_REG_OFFSET                        (0x014C)
+#define EMAC_OCTETS_RX_31_0_NO_ERROR_REG_OFFSET                     (0x0150)
+#define EMAC_OCTETS_RX_47_32_NO_ERROR_REG_OFFSET                    (0x0154)
+#define EMAC_FRAMES_RX_NO_ERROR_REG_OFFSET                          (0x0158)
+#define EMAC_BROADCAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x015C)
+#define EMAC_MULTICAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x0160)
+#define EMAC_PAUSE_FRAME_RX_REG_OFFSET                              (0x0164)
+#define EMAC_64_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET                  (0x0168)
+#define EMAC_65_127_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x016C)
+#define EMAC_128_255_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0170)
+#define EMAC_256_511_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0174)
+#define EMAC_512_1023_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET            (0x0178)
+#define EMAC_1024_1518_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET           (0x017C)
+#define EMAC_1519_TO_MAX_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x0180)
+#define EMAC_UNDERSIZE_FRAMES_RX_REG_OFFSET                         (0x0184)
+#define EMAC_OVERSIZE_FRAMES_RX_REG_OFFSET                          (0x0188)
+#define EMAC_JABBER_FRAMES_RX_REG_OFFSET                            (0x018C)
+#define EMAC_FCS_ERRORS_REG_OFFSET                                  (0x0190)
+#define EMAC_LENGTH_FIELD_FRAME_ERRORS_REG_OFFSET                   (0x0194)
+#define EMAC_RX_SYMBOL_ERRORS_REG_OFFSET                            (0x0198)
+#define EMAC_ALLIGNMENT_ERRORS_REG_OFFSET                           (0x019C)
+#define EMAC_RX_RESOURCE_ERRORS_REG_OFFSET                          (0x01A0)
+#define EMAC_RX_OVERRUN_ERRORS_REG_OFFSET                           (0x01A4)
+#define EMAC_IP_HDR_CHECKSUM_ERRORS_REG_OFFSET                      (0x01A8)
+#define EMAC_TCP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01AC)
+#define EMAC_UDP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01B0)
+
+#define EMAC_1588_TIMER_SECONDS_REG_OFFSET                          (0x01D0)
+#define EMAC_1588_TIMER_NANO_SECONDS_REG_OFFSET                     (0x01D4)
+#define EMAC_1588_TIMER_ADJUST_REG_OFFSET                           (0x01D8)
+#define EMAC_1588_TIMER_INCREMENT_REG_OFFSET                        (0x01DC)
+
+#define EMAC_PTP_EVENT_FRAME_TX_SECONDS_REG_OFFSET                  (0x01E0)
+#define EMAC_PTP_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET             (0x01E4)
+#define EMAC_PTP_EVENT_FRAME_RX_SECONDS_REG_OFFSET                  (0x01E8)
+#define EMAC_PTP_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET             (0x01EC)
+#define EMAC_PTP_PEER_EVENT_FRAME_TX_SECONDS_REG_OFFSET             (0x01F0)
+#define EMAC_PTP_PEER_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET        (0x01F4)
+#define EMAC_PTP_PEER_EVENT_FRAME_RX_SECONDS_REG_OFFSET             (0x01F8)
+#define EMAC_PTP_PEER_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET        (0x01FC)
+
+#define EMAC_PCS_CTRL_REG_OFFSET                                    (0x0200)
+#define EMAC_PCS_STATUS_REG_OFFSET                                  (0x0204)
+#define EMAC_PCS_UPPER_PHY_ID_REG_OFFSET                            (0x0208)
+#define EMAC_PCS_LOWER_PHY_ID_REG_OFFSET                            (0x020C)
+#define EMAC_PCS_AUTO_NEG_ADVERT_REG_OFFSET                         (0x0210)
+#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_AB_REG_OFFSET                (0x0214)
+#define EMAC_PCS_AUTO_NEG_EXPANSION_REG_OFFSET                      (0x0218)
+#define EMAC_PCS_AUTO_NEG_NEXT_PAGE_REG_OFFSET                      (0x021C)
+#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_NEXT_PAGE_REG_OFFSET         (0x0220)
+#define EMAC_PCS_EXTENDED_STATUS_REG_OFFSET                         (0x023C)
+
+/*!
+ * EMAC_NETWORK_CTRL_REG_OFFSET bits
+ */
+#define EMAC_STORE_TX_TIMESTAMP_IN_CRC                              (1 << 15)
+#define EMAC_TRANSMIT_HALT                                          (1 << 10)
+#define EMAC_START_TX                                               (1 << 9)
+#define EMAC_CLEAR_STATS_REGISTERS                                  (1 << 5)
+#define EMAC_MDIO_ENABLE                                            (1 << 4)
+#define EMAC_TX_ENABLE                                              (1 << 3)
+#define EMAC_RX_ENABLE                                              (1 << 2)
+
+/*!
+ * EMAC_NETWORK_CFG_REG_OFFSET bits
+ */
+#define EMAC_RX_CHKSUM_OFFLOAD_ENABLE                               (1 << 24)
+#define EMAC_64_BIT_AMBA_DATA_BUS_WITDH                             (1 << 21)
+#define EMAC_MDC_CLOCK_DIV_MASK                                     (0x7 <<18)
+#define EMAC_MDC_CLOCK_DIV_96                                       (0x5 <<18)
+#define EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD                       (1 << 16)
+#define EMAC_PAUSE_ENABLE                                           (1 << 13)
+#define EMAC_MULTICAST_HASH_ENABLE                                  (1 << 6)
+#define EMAC_NO_BROADCAST_FRAMES                                    (1 << 5)
+#define EMAC_COPY_ALL_FRAMES                                        (1 << 4)
+#define EMAC_FULL_DUPLEX                                            (1 << 1)
+#define EMAC_SPEED_100_MBPS                                         (1 << 0)
+
+/*!
+ * EMAC_NETWORK_STATUS_REG_OFFSET bits
+ */
+#define EMAC_PHY_MANAGEMENT_IDLE                                    (1 << 2)
+
+/*!
+ * EMAC_DMA_CFG_REG_OFFSET bits
+ */
+#define EMAC_DMA_RX_BUFFER_SIZE_IDX                                 (16)
+#define EMAC_DMA_RX_BUFFER_SIZE_MASK                                (0xFF << EMAC_DMA_RX_BUFFER_SIZE_IDX)
+#define EMAC_DMA_RX_BUFFER_SIZE                                     (0x18 << EMAC_DMA_RX_BUFFER_SIZE_IDX)
+
+/*!
+ * EMAC_PHY_MAINTAIN_REG_OFFSET bits
+ */
+#define EMAC_PHY_ID_MASK                                            (0x1F)
+#define EMAC_PHY_ID_SHIFT                                           (23)
+#define EMAC_PHY_REG_MASK                                           (0x1F)
+#define EMAC_PHY_REG_SHIFT                                          (18)
+#define EMAC_PHY_DATA_MASK                                          (0xFFFF)
+#define EMAC_PHY_READ                                               (0x60020000)
+#define EMAC_PHY_WRITE                                              (0x50020000)
+
+/*!
+ * EMAC_TX_STATUS_REG_OFFSET bits
+ */
+#define EMAC_TRANSMIT_UNDERRUN                                      (1 << 6)
+#define EMAC_TRANSMIT_COMPLETE                                      (1 << 5)
+
+/*!
+ * EMAC_RX_STATUS_REG_OFFSET bits
+ */
+#define EMAC_RECEIVE_OVERRUN                                        (1 << 2)
+#define EMAC_FRAME_RECEIVED                                         (1 << 1)
+#define EMAC_RX_BUFFER_NOT_AVAIL                                    (1 << 0)
+
+/*!
+ * EMAC_INT_STATUS_REG_OFFSET bits
+ * EMAC_INT_ENABLE_REG_OFFSET bits
+ * EMAC_INT_DISABLE_REG_OFFSET bits
+ * EMAC_INT_MASK_REG_OFFSET bits
+ */
+/* Bits 31-27 reserved */
+#define EMAC_ENABLE_TSU_SECONDS_REG_INCREMENT                       (1 << 26)
+#define EMAC_ENABLE_PTP_PDELAY_RESP_FRAME_TX                        (1 << 25)
+#define EMAC_ENABLE_PTP_PDELAY_REQ_FRAME_TX                         (1 << 24)
+#define EMAC_ENABLE_PTP_PDELAY_RESP_FRAME_RX                        (1 << 23)
+#define EMAC_ENABLE_PTP_PDELAY_REQ_FRAME_RX                         (1 << 22)
+#define EMAC_ENABLE_PTP_SYNC_FRAME_TX                               (1 << 21)
+#define EMAC_ENABLE_PTP_DELAY_REQ_FRAME_TX                          (1 << 20)
+#define EMAC_ENABLE_PTP_SYNC_FRAME_RX                               (1 << 19)
+#define EMAC_ENABLE_PTP_DELAY_REQ_FRAME_RX                          (1 << 18)
+#define EMAC_ENABLE_PCS_LINK_PARTNER_PAGE_RX                        (1 << 17)
+#define EMAC_ENABLE_PCS_AUTONEG_COMPLETE                            (1 << 16)
+#define EMAC_ENABLE_EXTERNAL_INTERRUPT                              (1 << 15)
+#define EMAC_ENABLE_PAUSE_FRAME_TX                                  (1 << 14)
+#define EMAC_ENABLE_PAUSE_FRAME_TIME_ZERO                           (1 << 13)
+#define EMAC_ENABLE_PAUSE_FRAME_NON_ZERO_PAUSE                      (1 << 12)
+#define EMAC_ENABLE_HRESP_NOT_OK                                    (1 << 11)
+#define EMAC_ENABLE_RX_OVERRUN                                      (1 << 10)
+#define EMAC_ENABLE_LINK_CHANGE                                     (1 << 9)
+/* Bit 8 not used */
+#define EMAC_ENABLE_TX_COMPLETE                                     (1 << 7)
+#define EMAC_ENABLE_TRANSMIT_CORRUPTION_AHB_ERROR                   (1 << 6)
+#define EMAC_ENABLE_RETRY_LIMIT_EXCEEDED                            (1 << 5)
+#define EMAC_ENABLE_TX_BUFF_UNDERRUN                                (1 << 4)
+#define EMAC_ENABLE_TX_USED_BIT_READ                                (1 << 3)
+#define EMAC_ENABLE_RX_USED_BIT_READ                                (1 << 2)
+#define EMAC_ENABLE_RX_COMPLETE                                     (1 << 1)
+#define EMAC_ENABLE_MANAGEMENT_DONE                                 (1 << 0)
+
+/*!
+ * Rx Descriptor Bits
+ */
+#define EMAC_RX_DESC_WRAP                                           (1 << 1)
+#define EMAC_RX_DESC_HOST_OWN                                       (1 << 0)
+
+#define EMAC_RX_DESC_CSUM_OFFLOAD_IDX                               (22)
+#define EMAC_RX_DESC_CSUM_OFFLOAD_MASK                              (0x3 << EMAC_RX_DESC_CSUM_OFFLOAD_IDX)
+#define EMAC_RX_DESC_END_OF_FRAME                                   (1 << 15)
+#define EMAC_RX_DESC_START_OF_FRAME                                 (1 << 14)
+#define EMAC_RX_DESC_LENGTH_MASK                                    (0x1FFF)
+
+/*!
+ * Tx Descriptor Bits
+ */
+#define EMAC_TX_DESC_HOST_OWN                                       (1 << 31)
+#define EMAC_TX_DESC_WRAP                                           (1 << 30)
+#define EMAC_TX_RETRY_ERROR                                         (1 << 29)
+#define EMAC_TX_UNDERRUN_ERROR                                      (1 << 28)
+#define EMAC_TX_FRAME_CORRUPTION_ERROR                              (1 << 27)
+#define EMAC_TX_LATE_COLLISION_ERROR                                (1 << 26)
+#define EMAC_TX_NO_CRC_APPEND                                       (1 << 16)
+#define EMAC_TX_LAST_BUFFER                                         (1 << 15)
+#define EMAC_TX_BUFFER_LENGTH_MASK                                  (0x3FFF)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_EMAC_H */
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 25acbbd..4fe2a53 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -227,17 +227,8 @@ struct phy_device * get_phy_device(struct mii_bus *bus, int addr)
 	if (r)
 		return ERR_PTR(r);
 
-	/* If the phy_id is mostly Fs, there is no device there */
-	if ((phy_id & 0x1fffffff) == 0x1fffffff)
-		return NULL;
-
-	/*
-	 * Broken hardware is sometimes missing the pull down resistor on the
-	 * MDIO line, which results in reads to non-existent devices returning
-	 * 0 rather than 0xffff. Catch this here and treat 0 as a non-existent
-	 * device as well.
-	 */
-	if (phy_id == 0)
+	/* If the phy_id is all Fs, there is no device there */
+	if (0xffffffff == phy_id)
 		return NULL;
 
 	dev = phy_device_create(bus, addr, phy_id);
diff --git a/drivers/perfcounters/Kconfig b/drivers/perfcounters/Kconfig
new file mode 100644
index 0000000..6389091
--- /dev/null
+++ b/drivers/perfcounters/Kconfig
@@ -0,0 +1,21 @@
+# $picoChipHeaderSubst$
+#
+# performance counter subsystem
+#
+
+menuconfig PERFCOUNTERS
+    bool "Performance counter subsystem"
+    help
+      This enables the performance counter subsystem
+
+if PERFCOUNTERS
+
+# ARMv6 Performance counters
+config ARMV6_PERFCOUNTER
+        tristate "ARMv6 performance counter support"
+        depends on CPU_V6 || CPU_32v6K
+        default m
+        help
+          Enable performance counter support for ARMv6 cores.
+
+endif
diff --git a/drivers/perfcounters/Makefile b/drivers/perfcounters/Makefile
new file mode 100644
index 0000000..eeb0f64
--- /dev/null
+++ b/drivers/perfcounters/Makefile
@@ -0,0 +1,5 @@
+# BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+
+obj-$(CONFIG_PERFCOUNTERS) 		+= perfcounters.o
+obj-$(CONFIG_ARMV6_PERFCOUNTER)		+= perfcounters_arm11v6.o
+
diff --git a/drivers/perfcounters/perfcounters.c b/drivers/perfcounters/perfcounters.c
new file mode 100644
index 0000000..bd94bca
--- /dev/null
+++ b/drivers/perfcounters/perfcounters.c
@@ -0,0 +1,479 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/perfcounters.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+
+#include <mach/irqs.h>
+
+#define MAX_PERFCOUNTERS            ( 8 )
+
+/*
+ * Private data structure for the driver. This contains all of the registered
+ * performance counters and any other associated data.
+ */
+static struct
+{
+    /* The first device in the chardev region. */
+    dev_t                   first_dev;
+
+    /* The counters that have been registered. */
+    struct perfcounter      *counters[ MAX_PERFCOUNTERS ];
+
+    /* The sysfs class for the performance counter sybsystem. */
+    struct class            *sysfs_class;
+
+    /* Serialisation lock. */
+    spinlock_t              lock;
+
+} perfcounter_internal;
+
+/* Get a performance counter from the device minor number. Used to get the
+ * counter from a device node so the application can read the count. */
+static struct perfcounter *
+minor_to_perfcounter( int minor )
+{
+    struct perfcounter *counter = NULL;
+    int i;
+
+    spin_lock( &perfcounter_internal.lock );
+
+    for ( i = 0; i < MAX_PERFCOUNTERS; ++i )
+        if ( perfcounter_internal.counters[ i ] &&
+             MINOR( perfcounter_internal.counters[ i ]->cdev.dev ) == minor )
+        {
+            counter = perfcounter_internal.counters[ i ];
+            break;
+        }
+
+    spin_unlock( &perfcounter_internal.lock );
+
+    return counter;
+}
+
+/* Open the counter device node. Store a pointer to the counter in the
+ * private_data field for fast access when reading. */
+static int
+perfcounter_open( struct inode *inode,
+                  struct file *filp )
+{
+    struct perfcounter *counter = minor_to_perfcounter( iminor( inode ) );
+    if ( !counter )
+        return -ENODEV;
+
+    filp->private_data = counter;
+
+    if ( !counter->enabled )
+        return counter->ops->enable( counter );
+
+    return 0;
+}
+
+/* Release method for the counter. We could disable the counter here, but for
+ * counters that share an enable method this could be bad! */
+static int
+perfcounter_release( struct inode *inode,
+                     struct file *filp )
+{
+    return 0;
+}
+
+/* Read the value of a counter. */
+static ssize_t
+perfcounter_read( struct file *filp,
+                  char __user *buf,
+                  size_t len,
+                  loff_t *offp )
+{
+    struct perfcounter *counter = filp->private_data;
+    u64 val;
+    int ret;
+
+    if ( unlikely( !counter->ops->read ) )
+        return -EOPNOTSUPP;
+
+    if ( unlikely( len < sizeof( u64 ) ) )
+        return -EMSGSIZE;
+
+    ret = counter->ops->read( counter, &val );
+    if ( !ret )
+    {
+        ret = copy_to_user( buf, &val, sizeof( val ) );
+        if ( ret )
+            ret = -EFAULT;
+    }
+
+    return ret ?: sizeof( val );
+}
+
+/* Write method for performance counters. This is used to clear a counter. */
+static ssize_t
+perfcounter_write( struct file *filp,
+                   const char __user *buf,
+                   size_t len,
+                   loff_t *offp )
+{
+    struct perfcounter *counter = filp->private_data;
+    int ret;
+
+    /* Write is nothing intelligent. We just ignore the value the user gave us
+     * and reset the counter. */
+    if ( unlikely( !counter->ops->reset ) )
+        return -EOPNOTSUPP;
+
+    ret = counter->ops->reset( counter );
+
+    return ret ?: len;
+}
+
+/* File operations for performance counters. */
+static struct file_operations perfcounter_fops = {
+    .owner      = THIS_MODULE,
+    .open       = perfcounter_open,
+    .release    = perfcounter_release,
+    .read       = perfcounter_read,
+    .write      = perfcounter_write,
+};
+
+/* Read the event that the counter is counting. */
+static ssize_t
+perfcounter_event_show( struct device *dev,
+                        struct device_attribute *attr,
+                        char *buf )
+{
+    struct perfcounter *counter = dev_get_drvdata( dev );
+    return sprintf( buf, "0x%04x\n", counter->event );
+}
+
+/* Set the counter to count a new event type. */
+static ssize_t
+perfcounter_event_store( struct device *dev,
+                         struct device_attribute *attr,
+                         const char *buf,
+                         size_t len )
+{
+    int event = simple_strtoul( buf, NULL, 0 );
+    struct perfcounter *counter = dev_get_drvdata( dev );
+
+    if ( unlikely( !counter->ops->set_event ) )
+        return -EOPNOTSUPP;
+
+    return counter->ops->set_event( counter, event ) ?: len;
+}
+DEVICE_ATTR( event, 0644, perfcounter_event_show,
+             perfcounter_event_store );
+
+/* Show the enabled status of a counter. */
+static ssize_t
+perfcounter_enabled_show( struct device *dev,
+                          struct device_attribute *attr,
+                          char *buf )
+{
+    struct perfcounter *counter = dev_get_drvdata( dev );
+    return sprintf( buf, "%d\n", !!counter->enabled );
+}
+
+/* Enable or disable a counter. */
+static ssize_t
+perfcounter_enabled_store( struct device *dev,
+                           struct device_attribute *attr,
+                           const char *buf,
+                           size_t len )
+{
+    int en = !!simple_strtoul( buf, NULL, 0 );
+    struct perfcounter *counter = dev_get_drvdata( dev );
+    int ret;
+
+    if ( unlikely( !counter->ops->enable ) )
+        return -EOPNOTSUPP;
+
+    ret = en ? counter->ops->enable( counter ) :
+               counter->ops->disable( counter );
+
+    return ret ?: len;
+}
+DEVICE_ATTR( enabled, 0644, perfcounter_enabled_show,
+             perfcounter_enabled_store );
+
+/* Show the current value of a counter. */
+static ssize_t
+perfcounter_value_show( struct device *dev,
+                        struct device_attribute *attr,
+                        char *buf )
+{
+    u64 val;
+    struct perfcounter *counter = dev_get_drvdata( dev );
+    int ret;
+
+    ret = -EOPNOTSUPP;
+    if ( unlikely( !counter->ops->read ) )
+        goto out;
+
+    ret = counter->ops->read( counter, &val );
+
+    if ( ret )
+        goto out;
+
+    ret = sprintf( buf, "%llu\n", val );
+out:
+    return ret;
+}
+
+/* Reset the counter back to 0. */
+static ssize_t
+perfcounter_value_store( struct device *dev,
+                         struct device_attribute *attr,
+                         const char *buf,
+                         size_t len )
+{
+    struct perfcounter *counter = dev_get_drvdata( dev );
+    int ret;
+
+    ret = -EOPNOTSUPP;
+    if ( unlikely( !counter->ops->reset ) )
+        goto out;
+
+    ret = counter->ops->reset( counter );
+
+out:
+    return ret ?: len;
+}
+DEVICE_ATTR( value, 0644, perfcounter_value_show, perfcounter_value_store );
+
+/* Create the device attributes in sysfs for the counter. */
+static int
+perfcounter_create_attrs( struct perfcounter *counter )
+{
+    int ret = 0;
+
+    ret = device_create_file( counter->dev, &dev_attr_value );
+    if ( ret )
+        goto out;
+
+    ret = device_create_file( counter->dev, &dev_attr_enabled );
+    if ( ret )
+        goto enabled_fail;
+
+    if ( counter->ops->set_event )
+    {
+        ret = device_create_file( counter->dev, &dev_attr_event );
+        if ( ret )
+            goto set_event_failed;
+    }
+
+    goto out;
+
+set_event_failed:
+    device_remove_file( counter->dev, &dev_attr_value );
+enabled_fail:
+    device_remove_file( counter->dev, &dev_attr_enabled );
+out:
+    return ret;
+}
+
+/* Remove the device attributes for a given counter. */
+static void
+perfcounter_remove_attrs( struct perfcounter *counter )
+{
+    if ( counter->ops->set_event )
+        device_remove_file( counter->dev, &dev_attr_event );
+    device_remove_file( counter->dev, &dev_attr_value );
+    device_remove_file( counter->dev, &dev_attr_enabled );
+}
+
+/* Performance counter interrupt. Call the overflow method for the counter so
+ * that it can maintain a 64 bit count from a 32 bit counter. */
+static irqreturn_t
+perfcounter_irq( int irq,
+                 void *dev )
+{
+    struct perfcounter *counter = dev_get_drvdata( dev );
+
+    return counter->ops->overflow( counter );
+}
+
+/* Register a new performance counter. This will register the counter with the
+ * performance counter subsystem and leave it disabled at start. */
+int
+perfcounter_register( struct perfcounter *counter )
+{
+    int indx = -1;
+    unsigned i;
+    dev_t devno;
+    int ret;
+
+    spin_lock( &perfcounter_internal.lock );
+    for ( i = 0; i < MAX_PERFCOUNTERS; ++i )
+        if ( !perfcounter_internal.counters[ i ] )
+        {
+            indx = i;
+            break;
+        }
+
+    ret = -ENOMEM;
+    if ( indx < 0 )
+        goto insert_failed;
+
+    spin_unlock( &perfcounter_internal.lock );
+
+    cdev_init( &counter->cdev, &perfcounter_fops );
+    counter->cdev.owner = THIS_MODULE;
+    counter->cdev.ops   = &perfcounter_fops;
+
+    devno = MKDEV( MAJOR( perfcounter_internal.first_dev ),
+                   MINOR( perfcounter_internal.first_dev ) + indx );
+
+    ret = cdev_add( &counter->cdev, devno, 1 );
+    if ( ret )
+        goto out;
+
+    counter->dev = device_create( perfcounter_internal.sysfs_class, NULL,
+                                  counter->cdev.dev, NULL, counter->name );
+    if ( IS_ERR( counter->dev ) )
+    {
+        ret = PTR_ERR( counter->dev );
+        goto dev_fail;
+    }
+    dev_set_drvdata( counter->dev, counter );
+
+    ret = perfcounter_create_attrs( counter );
+    if ( ret )
+        goto attr_fail;
+
+    if ( counter->ops->overflow )
+    {
+        ret = request_irq( counter->irq, perfcounter_irq, counter->irq_flags,
+                           counter->name, counter->dev );
+        if ( ret )
+            goto irq_failed;
+    }
+
+    /* Make sure the counter is disabled at start. */
+    ret = counter->ops->disable( counter );
+    if ( ret )
+        goto disable_fail;
+
+    spin_lock( &perfcounter_internal.lock );
+    perfcounter_internal.counters[ indx ] = counter;
+    spin_unlock( &perfcounter_internal.lock );
+
+    goto out;
+
+insert_failed:
+    free_irq( counter->irq, counter->dev );
+disable_fail:
+    perfcounter_remove_attrs( counter );
+irq_failed:
+    if ( counter->ops->overflow )
+        free_irq( counter->irq, counter->dev );
+attr_fail:
+    device_destroy( perfcounter_internal.sysfs_class, counter->cdev.dev );
+dev_fail:
+    cdev_del( &counter->cdev );
+out:
+
+    return ret;
+}
+EXPORT_SYMBOL( perfcounter_register );
+
+/* Remove a counter from the performance counter subsystem. */
+int
+perfcounter_unregister( struct perfcounter *counter )
+{
+    unsigned i;
+    int ret = -EINVAL;
+
+    spin_lock( &perfcounter_internal.lock );
+
+    if ( counter->ops->overflow )
+        free_irq( counter->irq, counter->dev );
+
+    for ( i = 0; i < MAX_PERFCOUNTERS; ++i )
+        if ( perfcounter_internal.counters[ i ] == counter )
+        {
+            perfcounter_internal.counters[ i ] = NULL;
+            ret = 0;
+            break;
+        }
+
+    spin_unlock( &perfcounter_internal.lock );
+
+    cdev_del( &counter->cdev );
+    perfcounter_remove_attrs( counter );
+    device_destroy( perfcounter_internal.sysfs_class, counter->cdev.dev );
+
+    module_put( counter->owner );
+
+    return ret;
+}
+EXPORT_SYMBOL( perfcounter_unregister );
+
+static int __init
+perfcounter_init( void )
+{
+    int ret = alloc_chrdev_region( &perfcounter_internal.first_dev,
+                                   0, MAX_PERFCOUNTERS, "perfcounter" );
+
+    if ( ret )
+        goto out;
+
+    spin_lock_init( &perfcounter_internal.lock );
+
+    perfcounter_internal.sysfs_class = class_create( THIS_MODULE,
+                                                     "perfcounter" );
+    if ( IS_ERR( perfcounter_internal.sysfs_class ) )
+    {
+        ret = PTR_ERR( perfcounter_internal.sysfs_class );
+        goto class_fail;
+    }
+
+    goto out;
+
+class_fail:
+    unregister_chrdev_region( perfcounter_internal.first_dev,
+                              MAX_PERFCOUNTERS );
+out:
+    return ret;
+}
+
+static void __exit
+perfcounter_exit( void )
+{
+    unsigned i;
+
+    for ( i = 0; i < MAX_PERFCOUNTERS; ++i )
+    {
+        if ( perfcounter_internal.counters[ i ] )
+            perfcounter_unregister( perfcounter_internal.counters[ i ] );
+    }
+
+    unregister_chrdev_region( perfcounter_internal.first_dev,
+                              MAX_PERFCOUNTERS );
+
+    class_destroy( perfcounter_internal.sysfs_class );
+}
+
+module_init( perfcounter_init );
+module_exit( perfcounter_exit );
+
+MODULE_AUTHOR( "Jamie Iles" );
+MODULE_LICENSE( "GPL" );
+MODULE_DESCRIPTION( "Performance counter subsystem" );
diff --git a/drivers/perfcounters/perfcounters_arm11v6.c b/drivers/perfcounters/perfcounters_arm11v6.c
new file mode 100644
index 0000000..b10a149
--- /dev/null
+++ b/drivers/perfcounters/perfcounters_arm11v6.c
@@ -0,0 +1,517 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+#include <linux/module.h>
+#include <linux/perfcounters.h>
+#include <mach/irqs.h>
+
+/*
+ * Spinlock for the ARM counters. We need a lock as the counters share a
+ * configuration register and some bits inside it. In particular, there is a
+ * global enable bit for all 3 counters - disabling one counter will also
+ * disable the others.
+ */
+static DEFINE_SPINLOCK( arm_counter_lock );
+
+/* Mask for the IRQ bits in the control register. */
+#define ARM_COUNTERS_IRQS       ( 7 << 8 )
+
+/* The cycle count IRQ status bit in the control register. */
+#define CYCLE_COUNT_IRQ         ( 1 << 10 )
+
+/* Handle a cycle count overflow. */
+static irqreturn_t
+arm_ccount_overflow( struct perfcounter *counter )
+{
+    u32 control;
+    u32 irqs;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+
+    /* We need to read the interrupts that have been read and then write back
+     * the control register to clear the interrupt. Make sure that we don't
+     * clear the interrupts for the other counters at the same time though. */
+    irqs = control & ARM_COUNTERS_IRQS;
+    control &= ~ARM_COUNTERS_IRQS;
+    if ( irqs & CYCLE_COUNT_IRQ )
+    {
+        control |= CYCLE_COUNT_IRQ;
+        asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+        /* We have overflowed. Add a full 32-bit integer + 1 to the base
+         * count. */
+        counter->base_count += 0x100000000LLU;
+        spin_unlock_irqrestore( &arm_counter_lock, flags );
+        return IRQ_HANDLED;
+    }
+    else
+    {
+        spin_unlock_irqrestore( &arm_counter_lock, flags );
+        return IRQ_NONE;
+    }
+}
+
+/* Read the value of the cycle count performance monitor register. */
+static int
+arm_ccount_read( struct perfcounter *counter,
+                 u64 *val )
+{
+    u32 ccount_low;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    asm( "mrc p15, 0, %0, c15, c12, 1" : "=r"( ccount_low ) );
+    *val = ccount_low + counter->base_count;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/*
+ * Global counter enable bit. Setting this will enable all 3 performance
+ * counters.
+ */
+#define COUNTERS_ENABLE         ( 1 << 0 )
+
+/*
+ * Cycle count divider bit. If set, the counter will increment every cycle. If
+ * unset it will increment every 64 cycles.
+ */
+#define CYCLE_COUNT_DIVIDER     ( 1 << 3 )
+
+/* IRQ enable bit for the cycle count overflow. */
+#define CYCLE_COUNT_IRQEN       ( 1 << 6 )
+
+/* Enable the cycle count performance monitor. */
+static int
+arm_ccount_enable( struct perfcounter *counter )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    /* Configure the cycle count to tick every cycle. */
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control |= COUNTERS_ENABLE | CYCLE_COUNT_IRQEN;
+    control &= ~CYCLE_COUNT_DIVIDER;
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->enabled = 1;
+
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* Disable the cycle count performance monitor. */
+static int
+arm_ccount_disable( struct perfcounter *counter )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    /* Configure the cycle count to tick every cycle. */
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control &= ~( COUNTERS_ENABLE | CYCLE_COUNT_IRQEN );
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->enabled = 0;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/*
+ * Global reset bit for the ARM performance counters. Setting this bit will
+ * reset all 3 counters.
+ */
+#define CYCLE_COUNT_RESET   ( 1 << 2 )
+
+/* Reset the cycle count register. */
+static int
+arm_ccount_reset( struct perfcounter *counter )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control |= CYCLE_COUNT_RESET;
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->base_count = 0;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* The counter operations for the cycle counter. */
+struct perfcounter_ops ccount_ops = {
+    .read           = arm_ccount_read,
+    .enable         = arm_ccount_enable,
+    .disable        = arm_ccount_disable,
+    .overflow       = arm_ccount_overflow,
+    .reset          = arm_ccount_reset,
+};
+
+/* The cycle count performance monitor. */
+static struct perfcounter ccount = {
+    .name           = "ccount",
+    .ops            = &ccount_ops,
+    .irq            = IRQ_NPMUIRQ,
+    .irq_flags      = IRQF_DISABLED | IRQF_SHARED,
+    .owner          = THIS_MODULE,
+};
+
+/* The count0 performance counter IRQ status bit. */
+#define COUNT0_IRQ         ( 1 << 8 )
+
+/* The overflow ISR for the count0 performance counter. */
+static irqreturn_t
+arm_count0_overflow( struct perfcounter *counter )
+{
+    u32 control;
+    u32 irqs;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+
+    /* We need to read the interrupts that have been read and then write back
+     * the control register to clear the interrupt. Make sure that we don't
+     * clear the interrupts for the other counters at the same time though. */
+    irqs = control & ARM_COUNTERS_IRQS;
+    control &= ~ARM_COUNTERS_IRQS;
+    if ( irqs & COUNT0_IRQ )
+    {
+        control |= COUNT0_IRQ;
+        asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+        /* We have overflowed. Add a full 32-bit integer + 1 to the base
+         * count. */
+        counter->base_count += 0x100000000LLU;
+        spin_unlock_irqrestore( &arm_counter_lock, flags );
+        return IRQ_HANDLED;
+    }
+    else
+    {
+        spin_unlock_irqrestore( &arm_counter_lock, flags );
+        return IRQ_NONE;
+    }
+}
+
+/* Read the count0 performance counter. */
+static int
+arm_count0_read( struct perfcounter *counter,
+                 u64 *val )
+{
+    u32 count0_low;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    asm( "mrc p15, 0, %0, c15, c12, 2" : "=r"( count0_low ) );
+    *val = count0_low + counter->base_count;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* The count0 IRQ enable bit. */
+#define COUNT0_IRQEN       ( 1 << 4 )
+
+/* Enable the count0 performance counter. */
+static int
+arm_count0_enable( struct perfcounter *counter )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    /* Configure the cycle count to tick every cycle. */
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control |= COUNTERS_ENABLE | COUNT0_IRQEN;
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->enabled = 1;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* Enable the count0 performance monitor. */
+static int
+arm_count0_disable( struct perfcounter *counter )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    /* Configure the cycle count to tick every cycle. */
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control &= ~( COUNTERS_ENABLE | COUNT0_IRQEN );
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->enabled = 0;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/*
+ * The offset of the event selection bits for the count0 performance monitor.
+ */
+#define EVENT_COUNT_0_OFFSET    ( 20 )
+
+/* Mask for the event selection bits for the count0 performance monitor. */
+#define EVENT_COUNT_0_MASK      ( 0xFF << EVENT_COUNT_0_OFFSET )
+
+/* Set the event the count0 performance monitor will count. */
+static int
+arm_count0_set_event( struct perfcounter *counter,
+                      int event )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    event &= 0xFF;
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control &= ~EVENT_COUNT_0_MASK;
+    control |= ( event << EVENT_COUNT_0_OFFSET );
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->event = event;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* The offset of the count0/count1 reset bit. */
+#define COUNT_N_RESET           ( 1 << 1 )
+
+/* Reset ARM counters 0 and 1. */
+static int
+arm_countn_reset( struct perfcounter *counter )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control |= COUNT_N_RESET;
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->base_count = 0;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* The counter operations for count0. */
+struct perfcounter_ops count0_ops = {
+    .read           = arm_count0_read,
+    .enable         = arm_count0_enable,
+    .disable        = arm_count0_disable,
+    .overflow       = arm_count0_overflow,
+    .set_event      = arm_count0_set_event,
+    .reset          = arm_countn_reset,
+};
+
+/* ARM counter count0. */
+static struct perfcounter count0 = {
+    .name           = "count0",
+    .ops            = &count0_ops,
+    .irq            = IRQ_NPMUIRQ,
+    .irq_flags      = IRQF_DISABLED | IRQF_SHARED,
+    .owner          = THIS_MODULE,
+};
+
+/* Counter count1 interrupt status bit. */
+#define COUNT1_IRQ         ( 1 << 9 )
+
+/* Overflow interrupt for the count1 counter. */
+static irqreturn_t
+arm_count1_overflow( struct perfcounter *counter )
+{
+    u32 control;
+    u32 irqs;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+
+    /* We need to read the interrupts that have been read and then write back
+     * the control register to clear the interrupt. Make sure that we don't
+     * clear the interrupts for the other counters at the same time though. */
+    irqs = control & ARM_COUNTERS_IRQS;
+    control &= ~ARM_COUNTERS_IRQS;
+    if ( irqs & COUNT1_IRQ )
+    {
+        control |= COUNT1_IRQ;
+        asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+        /* We have overflowed. Add a full 32-bit integer + 1 to the base
+         * count. */
+        counter->base_count += 0x100000000LLU;
+        spin_unlock_irqrestore( &arm_counter_lock, flags );
+        return IRQ_HANDLED;
+    }
+    else
+    {
+        spin_unlock_irqrestore( &arm_counter_lock, flags );
+        return IRQ_NONE;
+    }
+}
+
+/* Read the value of the count1 counter. */
+static int
+arm_count1_read( struct perfcounter *counter,
+                 u64 *val )
+{
+    u32 count1_low;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    asm( "mrc p15, 0, %0, c15, c12, 3" : "=r"( count1_low ) );
+    *val = count1_low + counter->base_count;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* Interrupt enable bit for count1 overflow. */
+#define COUNT1_IRQEN       ( 1 << 5 )
+
+/* Enable the count1 counter. */
+static int
+arm_count1_enable( struct perfcounter *counter )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    /* Configure the cycle count to tick every cycle. */
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control |= COUNTERS_ENABLE | COUNT1_IRQEN;
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->enabled = 1;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* Disable the count1 counter. */
+static int
+arm_count1_disable( struct perfcounter *counter )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    /* Configure the cycle count to tick every cycle. */
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control &= ~( COUNTERS_ENABLE | COUNT1_IRQEN );
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->enabled = 0;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* Offset for the count1 event selection bits in the control register. */
+#define EVENT_COUNT_1_OFFSET    ( 12 )
+
+/* Mask for the count1 event selection bits in the control register. */
+#define EVENT_COUNT_1_MASK      ( 0xFF << EVENT_COUNT_1_OFFSET )
+
+/* Set the event that count1 counts. */
+static int
+arm_count1_set_event( struct perfcounter *counter,
+                      int event )
+{
+    u32 control;
+    unsigned long flags;
+
+    spin_lock_irqsave( &arm_counter_lock, flags );
+    event &= 0xFF;
+    asm( "mrc p15, 0, %0, c15, c12, 0" : "=r"( control ) );
+    control &= ~EVENT_COUNT_1_MASK;
+    control |= ( event << EVENT_COUNT_1_OFFSET );
+    asm( "mcr p15, 0, %0, c15, c12, 0" : : "r"( control ) );
+
+    counter->event = event;
+    spin_unlock_irqrestore( &arm_counter_lock, flags );
+
+    return 0;
+}
+
+/* Counter count1 operations. */
+struct perfcounter_ops count1_ops = {
+    .read           = arm_count1_read,
+    .enable         = arm_count1_enable,
+    .disable        = arm_count1_disable,
+    .overflow       = arm_count1_overflow,
+    .set_event      = arm_count1_set_event,
+    .reset          = arm_countn_reset,
+};
+
+/* ARM count1 counter. */
+static struct perfcounter count1 = {
+    .name           = "count1",
+    .ops            = &count1_ops,
+    .irq            = IRQ_NPMUIRQ,
+    .irq_flags      = IRQF_DISABLED | IRQF_SHARED,
+    .owner          = THIS_MODULE,
+};
+
+static int
+arm_perfcounters_init( void )
+{
+    int ret = perfcounter_register( &ccount );
+    if ( ret )
+        goto out;
+
+    ret = perfcounter_register( &count0 );
+    if ( ret )
+        goto count0_fail;
+
+    ret = perfcounter_register( &count1 );
+    if ( ret )
+        goto count1_fail;
+
+    goto out;
+
+count1_fail:
+    perfcounter_unregister( &count0 );
+count0_fail:
+    perfcounter_unregister( &ccount );
+out:
+    return ret;
+}
+
+static void
+arm_perfcounters_exit( void )
+{
+    perfcounter_unregister( &count0 );
+    perfcounter_unregister( &count1 );
+    perfcounter_unregister( &ccount );
+}
+
+module_init( arm_perfcounters_init );
+module_exit( arm_perfcounters_exit );
+
+MODULE_AUTHOR( "Jamie Iles" );
+MODULE_LICENSE( "GPL" );
+MODULE_DESCRIPTION( "ARMv6 Performance Monitor Access" );
diff --git a/drivers/picochip/Doxyfile b/drivers/picochip/Doxyfile
new file mode 100644
index 0000000..dcecb35
--- /dev/null
+++ b/drivers/picochip/Doxyfile
@@ -0,0 +1,1511 @@
+# Doxyfile 1.5.8
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file 
+# that follow. The default is UTF-8 which is also the encoding used for all 
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the 
+# iconv built into libc) for the transcoding. See 
+# http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = picoif
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = 
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = docs
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional, 
+# Croatian, Czech, Danish, Dutch, Farsi, Finnish, French, German, Greek, 
+# Hungarian, Italian, Japanese, Japanese-en (Japanese with English messages), 
+# Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian, Polish, 
+# Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak, Slovene, 
+# Spanish, Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like regular Qt-style comments 
+# (thus requiring an explicit @brief command for a brief description.)
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will 
+# interpret the first line (until the first dot) of a Qt-style 
+# comment as the brief description. If set to NO, the comments 
+# will behave just like regular Qt-style comments (thus requiring 
+# an explicit \brief command for a brief description.)
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Java. For instance, namespaces will be presented as packages, qualified 
+# scopes will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Fortran.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL 
+# sources. Doxygen will then generate output that is tailored for 
+# VHDL.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it parses. 
+# With this tag you can assign which parser to use for a given extension. 
+# Doxygen has a built-in mapping, but you can override or extend it using this tag. 
+# The format is ext=language, where ext is a file extension, and language is one of 
+# the parsers supported by doxygen: IDL, Java, Javascript, C#, C, C++, D, PHP, 
+# Objective-C, Python, Fortran, VHDL, C, C++. For instance to make doxygen treat 
+# .inc files as Fortran files (default is PHP), and .f files as C (default is Fortran), 
+# use: inc=Fortran f=C
+
+EXTENSION_MAPPING      = 
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want 
+# to include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to 
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only. 
+# Doxygen will parse them like normal C++ but will assume all classes use public 
+# instead of private inheritance when no explicit protection keyword is present.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate getter 
+# and setter methods for a property. Setting this option to YES (the default) 
+# will make doxygen to replace the get and set methods by a property in the 
+# documentation. This will only work if the methods are indeed getting or 
+# setting a simple type. If this is not the case, or you want to show the 
+# methods anyway, you should set this option to NO.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum 
+# is documented as struct, union, or enum with the name of the typedef. So 
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct 
+# with name TypeT. When disabled the typedef will appear as a member of a file, 
+# namespace, or class. And the struct will be named TypeS. This can typically 
+# be useful for C code in case the coding convention dictates that all compound 
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to 
+# determine which symbols to keep in memory and which to flush to disk. 
+# When the cache is full, less often used symbols will be written to disk. 
+# For small to medium size projects (<1000 input files) the default value is 
+# probably good enough. For larger projects a too small cache size can cause 
+# doxygen to be busy swapping symbols to and from disk most of the time 
+# causing a significant performance penality. 
+# If the system has enough physical memory increasing the cache will improve the 
+# performance by keeping more symbols in memory. Note that the value works on 
+# a logarithmic scale so increasing the size by one will rougly double the 
+# memory usage. The cache size is given by this formula: 
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0, 
+# corresponding to a cache size of 2^16 = 65536 symbols
+
+SYMBOL_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = YES
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be 
+# extracted and appear in the documentation as a namespace called 
+# 'anonymous_namespace{file}', where file will be replaced with the base 
+# name of the file that contains the anonymous namespace. By default 
+# anonymous namespace are hidden.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the 
+# hierarchy of group names into alphabetical order. If set to NO (the default) 
+# the group names will appear in their defined order.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES. 
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. 
+# This will remove the Files entry from the Quick Index and from the 
+# Folder Tree View (if specified). The default is YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the 
+# Namespaces page. 
+# This will remove the Namespaces entry from the Quick Index 
+# and from the Folder Tree View (if specified). The default is YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from 
+# the version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed by 
+# doxygen. The layout file controls the global structure of the generated output files 
+# in an output format independent way. The create the layout file that represents 
+# doxygen's defaults, run doxygen with the -l option. You can optionally specify a 
+# file name after the option, if omitted DoxygenLayout.xml will be used as the name 
+# of the layout file.
+
+LAYOUT_FILE            = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = YES
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = . ../../include/linux/picochip
+
+# This tag can be used to specify the character encoding of the source files 
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is 
+# also the default input encoding. Doxygen uses libiconv (or the iconv built 
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for 
+# the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
+
+FILE_PATTERNS          = 
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = soft_reset.c soft_reset_memif.h ../../include/linux/picochip/fpga_cpe20x.h ../../include/linux/picochip/gpio.h ../../include/linux/picochip/cpld_hdp102.c cpld_cpe20x.h fpga_cpe20x_main.c cpld_hdp102.c
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names 
+# (namespaces, classes, functions, etc.) that should be excluded from the 
+# output. The symbol name can be a fully qualified name, a word, or if the 
+# wildcard * is used, a substring. Examples: ANamespace, AClass, 
+# AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output. 
+# If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = "grep -v \"EXPORT_SYMBOL\|module_init\|module_exit\|MODULE_LICENSE\|MODULE_AUTHOR\|MODULE_DESCRIPTION\" "
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis. 
+# Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match. 
+# The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default) 
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from 
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will 
+# link to the source code. 
+# Otherwise they will link to the documentation.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = .
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML 
+# documentation will contain sections that can be hidden and shown after the 
+# page has loaded. For this to work a browser that supports 
+# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox 
+# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files 
+# will be generated that can be used as input for Apple's Xcode 3 
+# integrated development environment, introduced with OSX 10.5 (Leopard). 
+# To create a documentation set, doxygen will generate a Makefile in the 
+# HTML output directory. Running make will produce the docset in that 
+# directory and running "make install" will install the docset in 
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find 
+# it at startup. 
+# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html for more information.
+
+GENERATE_DOCSET        = NO
+
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the 
+# feed. A documentation feed provides an umbrella under which multiple 
+# documentation sets from a single provider (such as a company or product suite) 
+# can be grouped.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that 
+# should uniquely identify the documentation set bundle. This should be a 
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen 
+# will append .docset to the name.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING 
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file 
+# content.
+
+CHM_INDEX_ENCODING     = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and QHP_VIRTUAL_FOLDER 
+# are set, an additional index file will be generated that can be used as input for 
+# Qt's qhelpgenerator to generate a Qt Compressed Help (.qch) of the generated 
+# HTML documentation.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can 
+# be used to specify the file name of the resulting .qch file. 
+# The path specified is relative to the HTML output folder.
+
+QCH_FILE               = 
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#namespace
+
+QHP_NAMESPACE          = 
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#virtual-folders
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to add. 
+# For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#custom-filters
+
+QHP_CUST_FILTER_NAME   = 
+
+# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the custom filter to add.For more information please see 
+# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">Qt Help Project / Custom Filters</a>.
+
+QHP_CUST_FILTER_ATTRS  = 
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this project's 
+# filter section matches. 
+# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">Qt Help Project / Filter Attributes</a>.
+
+QHP_SECT_FILTER_ATTRS  = 
+
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can 
+# be used to specify the location of Qt's qhelpgenerator. 
+# If non-empty doxygen will try to run qhelpgenerator on the generated 
+# .qhp file.
+
+QHG_LOCATION           = 
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index 
+# structure should be generated to display hierarchical information. 
+# If the tag value is set to FRAME, a side panel will be generated 
+# containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature. Other possible values 
+# for this tag are: HIERARCHIES, which will generate the Groups, Directories, 
+# and Class Hierarchy pages using a tree view instead of an ordered list; 
+# ALL, which combines the behavior of FRAME and HIERARCHIES; and NONE, which 
+# disables this behavior completely. For backwards compatibility with previous 
+# releases of Doxygen, the values YES and NO are equivalent to FRAME and NONE 
+# respectively.
+
+GENERATE_TREEVIEW      = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+# Use this tag to change the font size of Latex formulas included 
+# as images in the HTML documentation. The default is 10. Note that 
+# when you change the font size after a successful doxygen run you need 
+# to manually remove any form_*.png images from the HTML output directory 
+# to force them to be regenerated.
+
+FORMULA_FONTSIZE       = 10
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader. 
+# This is useful 
+# if you want to understand what is going on. 
+# On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = __KERNEL__ \
+                         CONFIG_DEBUG_FS
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#  
+# TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#  
+# TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links. 
+# Note that each tag file must have a unique name 
+# (where the name does NOT include the path) 
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc 
+# command. Doxygen will then run the mscgen tool (see 
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the 
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where 
+# the mscgen tool resides. If left empty the tool is assumed to be found in the 
+# default search path.
+
+MSCGEN_PATH            = 
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = YES
+
+# By default doxygen will write a font called FreeSans.ttf to the output 
+# directory and reference it in all dot files that doxygen generates. This 
+# font does not include all possible unicode characters however, so when you need 
+# these (or just want a differently looking font) you can specify the font name 
+# using DOT_FONTNAME. You need need to make sure dot is able to find the font, 
+# which can be done by putting it in a standard location or by setting the 
+# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory 
+# containing the font.
+
+DOT_FONTNAME           = FreeSans
+
+# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs. 
+# The default size is 10pt.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the output directory to look for the 
+# FreeSans.ttf font (which doxygen will put there itself). If you specify a 
+# different font using DOT_FONTNAME you can set the path where dot 
+# can find it using this tag.
+
+DOT_FONTPATH           = 
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = YES
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then 
+# doxygen will generate a call dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable call graphs 
+# for selected functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then 
+# doxygen will generate a caller dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable caller 
+# graphs for selected functions only using the \callergraph command.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include 
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif 
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of 
+# nodes that will be shown in the graph. If the number of nodes in a graph 
+# becomes larger than this value, doxygen will truncate the graph, which is 
+# visualized by representing a node as a red box. Note that doxygen if the 
+# number of direct children of the root node in a graph is already larger than 
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note 
+# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that the size of a graph can be further restricted by 
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, because dot on Windows does not 
+# seem to support this out of the box. Warning: Depending on the platform used, 
+# enabling this option may lead to badly anti-aliased labels on the edges of 
+# a graph (i.e. they become hard to read).
+
+DOT_TRANSPARENT        = YES
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Options related to the search engine
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO
diff --git a/drivers/picochip/Kconfig b/drivers/picochip/Kconfig
new file mode 100644
index 0000000..65c6152
--- /dev/null
+++ b/drivers/picochip/Kconfig
@@ -0,0 +1,67 @@
+# $picoChipHeaderSubst$
+#
+# picoChip device drivers
+#
+
+menu "picoChip Drivers"
+
+config PICOCHIP
+    tristate
+
+config PICOHDP_CPLD
+    tristate "HDP CPLD Support"
+    depends on PICOHDP || PICOHDP203
+    ---help---
+      This driver controls periperhals managed via the picoHDP main CPLD
+
+config PICOCPE20X_FPGA
+    tristate "CPE20X FPGA Support"
+    depends on ARCH_FIRECRACKER && SPI_FIRECRACKER
+    ---help---
+      This driver exports an interface for accessing the CPE20x FPGAs. 
+      The driver uses bit-bashed SPI interface via GPIO pins.
+      Note: The kernel uses this driver to implement a hard reset. If
+      it is not installed, the kernel will not reset the board.
+
+config PICOIF
+    tristate "picoIf driver"
+    ---help---
+      This driver provides a kernelspace API for accessing picoArray devices
+      and a userspace interface through /dev/picoif
+
+config PICOIF_PC203
+    bool "PC203 picoIf support"
+    select FSL_DMA
+    depends on PICOIF && PICOHDP203
+    ---help---
+      Selecting yes here enables PC203 support in picoIf.
+
+config PICOIF_PC202
+    bool "PC202/5 picoIf support"
+    depends on PICOIF && ARCH_FIRECRACKER
+    ---help---
+      Selecting yes here enables PC202 and PC205 support in picoIf.
+
+config PICOIF_PC302
+    bool "PC302 picoIf support"
+    depends on PICOIF && ARCH_PC302
+    ---help---
+      Selecting yes here enables PC302 support in picoIf.
+
+config PICOIF_DEFAULT_DEBUG_LEVEL
+    int "Default debugging level for the picoIf driver (0 = quiet, 9 = noisy)"
+    default "1"
+    help
+      This sets the default debug verbosity of the driver at load time. The
+      values for each component may then be ajusted with the *lvl entries in
+      /debug/picoif/.
+
+config PICOIF_DEBUG_TO_CONSOLE
+    bool "Print picoIf debug messages to the console"
+    default false
+    help
+      Enabling this causes picoIf debug messages to be printed to the console
+      in addition to the debug log in /debug/picoconnect/log. This is mainly
+      useful when working on the drivers themselves.
+
+endmenu
diff --git a/drivers/picochip/Makefile b/drivers/picochip/Makefile
new file mode 100644
index 0000000..2b15279
--- /dev/null
+++ b/drivers/picochip/Makefile
@@ -0,0 +1,20 @@
+# BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+#
+# Makefile for pico driver
+# HDP102 CPLD driver
+obj-$(CONFIG_PICOHDP_CPLD) 	+= cpld_hdp102.o
+
+# CPE20x FPGA driver
+obj-$(CONFIG_PICOCPE20X_FPGA) 	+= fpga_cpe20x.o
+fpga_cpe20x-y := fpga_cpe20x_main.o
+
+obj-$(CONFIG_PICOIF)	      	+= picoif.o
+picoif-y := picoif_main.o resource.o \
+	    debug.o soft_reset.o gpr_interrupt.o dma.o \
+	    dma_fifo.o hwif.o hwif2.o utilities_internal.o
+
+picoifktest-y := kerneltest.o
+
+picoif-$(CONFIG_PICOIF_PC203)	+= pc203.o procif.o
+picoif-$(CONFIG_PICOIF_PC202)	+= pc202.o procif.o
+picoif-$(CONFIG_PICOIF_PC302)	+= pc302.o axi2cfg.o
diff --git a/drivers/picochip/axi2cfg.c b/drivers/picochip/axi2cfg.c
new file mode 100644
index 0000000..e4a9789
--- /dev/null
+++ b/drivers/picochip/axi2cfg.c
@@ -0,0 +1,161 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file axi2cfg.c
+ * \brief axi2cfg access functions.
+ *
+ * This file implements functions for using the axi2cfg to configure and debug
+ * picoArray systems providing configuration bus access over the axi2cfg.
+ */
+
+#include <linux/types.h>
+#include <asm/io.h>
+#include <linux/pci.h>
+#include "debug.h"
+#include "axi2cfg.h"
+
+/* Configuration port write bit positions. */
+#define CAEID_BIT_MASK     ( 1 << 19 )    /*!< Bit 19 - AE ID signal. */
+#define CADDR_BIT_MASK     ( 1 << 18 )    /*!< Bit 18 - AE ADDR signal. */
+#define CREAD_BIT_MASK     ( 1 << 17 )    /*!< Bit 17 - READ data signal. */
+#define CWRITE_BIT_MASK    ( 1 << 16 )    /*!< Bit 16 - WRITE data signal. */
+
+#define RB_FAIL_MASK       ( 1 << 17 )    /*!< Bit 17 - readback failed. */
+#define RB_VALID_MASK      ( 1 << 16 )    /*!< Bit 16 - readback valid. */
+
+#define RETRIES ( 10 )                  /*!< The number of retries for an \
+                                         *   AXI2Cfg config read. */
+
+int
+axi2cfg_config_read( void __iomem *axi2cfg_base,
+                    u16 aeid,
+                    u16 ae_addr,
+                    u16 *buf,
+                    u16 count )
+{
+    u32 val;
+    void __iomem *write_p = axi2cfg_base + AXI2CFG_REG_CFG_WR;
+    void __iomem *read_p = axi2cfg_base + AXI2CFG_REG_CFG_RD;
+    u16 to_read = count;
+    u16 rc;
+    unsigned i;
+    unsigned retries;
+
+    PRINTD( COMPONENT_AXI2CFG, DBG_TRACE, "reading %u words from %04x@%04x",
+            count, aeid, ae_addr );
+
+    val = aeid | CAEID_BIT_MASK;
+    iowrite32( val, write_p );
+    wmb();
+
+    while ( to_read )
+    {
+        /* Output the address to read from. */
+        val = ( ae_addr + ( count - to_read ) ) | CADDR_BIT_MASK;
+        iowrite32( val, write_p );
+        wmb();
+
+        /* Dispatch the read requests. */
+        rc = ( to_read > 64 ) ? 64 : to_read;
+        val = CREAD_BIT_MASK | rc;
+        iowrite32( val, write_p );
+        wmb();
+
+        /* Now read the values. */
+        for ( i = 0; i < rc; ++i )
+        {
+            retries = RETRIES;
+            while ( retries )
+            {
+                val = ioread32( read_p );
+                if ( val & ( RB_VALID_MASK | RB_FAIL_MASK ) )
+                    break;
+                --retries;
+                rmb();
+            }
+
+            if ( !retries || ( val & RB_FAIL_MASK ) )
+            {
+                PRINTD( COMPONENT_AXI2CFG, DBG_ERROR,
+                        "config read %04x@%04x failed", aeid,
+                        ( ae_addr + ( count - to_read ) + i ) );
+                break;
+            }
+            else
+                buf[ ( count - to_read ) + i ] = val & 0xFFFF;
+        }
+
+        if ( val & RB_FAIL_MASK )
+            break;
+
+        to_read -= rc;
+    }
+
+    return !( val & RB_FAIL_MASK ) ? count : -EIO;
+}
+
+int
+axi2cfg_config_write( void __iomem *axi2cfg_base,
+                     u16 aeid,
+                     u16 ae_addr,
+                     u16 *buf,
+                     u16 count )
+{
+    u32 val;
+    void __iomem *write_p = axi2cfg_base + AXI2CFG_REG_CFG_WR;
+    unsigned i;
+
+    PRINTD( COMPONENT_AXI2CFG, DBG_TRACE, "writing %u words to %04x@%04x",
+            count, aeid, ae_addr );
+
+    val = aeid | CAEID_BIT_MASK;
+    iowrite32( val, write_p );
+    wmb();
+
+    /* Output the address to read from. */
+    val = ae_addr | CADDR_BIT_MASK;
+    iowrite32( val, write_p );
+    wmb();
+
+    /* Now read the values. */
+    for ( i = 0; i < count; ++i )
+    {
+        val = buf[ i ] | CWRITE_BIT_MASK;
+        iowrite32( val, write_p );
+        wmb();
+    }
+
+    return i;
+}
+
+int
+axi2cfg_reg_write( void __iomem *axi2cfg_base,
+                    unsigned offset,
+                    u32 value )
+{
+    iowrite32( value, axi2cfg_base + offset );
+    return 0;
+}
+
+int
+axi2cfg_reg_read( void __iomem *axi2cfg_base,
+                  unsigned offset,
+                  u32 *value )
+{
+    *value = ioread32( axi2cfg_base + offset );
+    return 0;
+}
+
+
diff --git a/drivers/picochip/axi2cfg.h b/drivers/picochip/axi2cfg.h
new file mode 100644
index 0000000..d189d7b
--- /dev/null
+++ b/drivers/picochip/axi2cfg.h
@@ -0,0 +1,102 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file axi2cfg.h
+ * \brief axi2cfg access functions.
+ *
+ * This file provides a set of functions for using the axi2cfg in picoArray
+ * devices and should be used to implement the device files for devices that
+ * contain a axi2cfg.
+ */
+
+#ifndef __PICOIF_AXI2CFG__
+#define __PICOIF_AXI2CFG__
+
+/*! Register offset for the config bus read port (from the axi2cfg1 base
+ *  address). */
+#define AXI2CFG_REG_PURGE_CFG ( 0x00 )
+
+/*! Register offset for the config bus write port (from the axi2cfg1 base
+ *  address). */
+#define AXI2CFG_REG_DMAC1_CFG ( 0x04 )
+
+/*! Register offset for the config bus write port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_WR ( 0x000 )
+
+/*! Register offset for the config bus read port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_RD ( 0x100 )
+
+/*!
+ * Read a number of 16 bit words from a picoArray axi2cfg.
+ *
+ * @param axi2cfg_base The base address of the upper axi2cfg.
+ * @param aeid The CAEID of the AE to read from.
+ * @param ae_addr The address to begin reading from within the AE.
+ * @param[out] buf The buffer to store the results in.
+ * @param count The number of 16 bit words to read.
+ * @return Returns the number of words read on success, negative on failure.
+ */
+int axi2cfg_config_read( void __iomem *axi2cfg_base,
+                         u16 aeid,
+                         u16 ae_addr,
+                         u16 *buf,
+                         u16 count );
+
+/*!
+ * Write a number of 16 bit words to a picoArray axi2cfg.
+ *
+ * @param axi2cfg_base The base address of the upper axi2cfg.
+ * @param aeid The CAEID of the AE to write to.
+ * @param ae_addr The address to begin writing to within the AE.
+ * @param[in] buf The buffer to read the words from.
+ * @param count The number of 16 bit words to write.
+ * @return Returns the number of words written on success, negative on failure.
+ */
+int axi2cfg_config_write( void __iomem *axi2cfg_base,
+                          u16 aeid,
+                          u16 ae_addr,
+                          u16 *buf,
+                          u16 count );
+
+
+/*!
+ * Write a register in the axi2cfg.
+ *
+ * @param address The base address of the axi2cfg (lower or upper region)
+ * @param offset The offset of the register in bytes.
+ * @param value The value of the register to write.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+axi2cfg_reg_write( void __iomem *address,
+                   unsigned offset,
+                   u32 value );
+
+/*!
+ * Read a register in the axi2cfg.
+ *
+ * @param address The base address of the axi2cfg (lower or upper region)
+ * @param offset The offset of the register in bytes.
+ * @param[out] value The address to store the register value in.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+axi2cfg_reg_read( void __iomem *address,
+                  unsigned offset,
+                  u32 *value );
+
+#endif /* __PICOIF_AXI2CFG__ */
diff --git a/drivers/picochip/cpld_cpe20x.h b/drivers/picochip/cpld_cpe20x.h
new file mode 100644
index 0000000..0722414
--- /dev/null
+++ b/drivers/picochip/cpld_cpe20x.h
@@ -0,0 +1,145 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2007 picoChip Designs Ltd.
+ *
+ * * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file cpld_cpe20x.h
+ * \brief Header file for CPE20x FPGA access
+ *
+ * This file defines the internal CPLD access functions.
+ */
+
+#ifndef _CPLD_CPE20X_H__
+#define _CPLD_CPE20X_H__
+
+#include <asm/types.h>
+
+typedef struct cpld_reg_param
+{
+    __u16 device;
+    __u16 reg;
+    __u16 data;
+} cpld_reg_param_t;
+
+#define PICO_CPLD_IOC_MAGIC   'C'
+#define PICO_CPLD_IOC_BASE     0
+#define PICO_CPLD_IOCWRITEREG \
+    _IOW(   PICO_CPLD_IOC_MAGIC, PICO_CPLD_IOC_BASE + 0, cpld_reg_param_t)
+#define PICO_CPLD_IOCREADREG \
+    _IOWR(  PICO_CPLD_IOC_MAGIC, PICO_CPLD_IOC_BASE + 1, cpld_reg_param_t)
+#define PICO_CPLD_IOC_MAXNUM (PICO_CPLD_IOC_BASE + 1)
+
+/* Platform stuff */
+#define PICO_CPLD_MAX_NUM_DEV 2   /* Two programmable devices on the cpe20x
+                                        platform */
+
+/** Register definitions  **/
+/*
+ * Please maintain the comments on the ends of the lines - these are for
+ * code-generattion in the cpld util.
+ */
+
+/* Bank #0 - Generic Registers */
+#define PICO_CPLD_REG_BOARD_TYPE     (0x0)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_CODE_VERSION   (0x1)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_BOARD_MODE     (0x2)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_TEST_DEBUG     (0x3)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_DEBUG_COUNTER  (0x4)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IRQ_SELECT     (0x5)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IRQ_STATUS     (0x6)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IRQ_ENABLE     (0x7)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_DMA_SELECT     (0x8)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_PA_RESET       (0x9)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_PICE_CONTROL   (0xA)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_RESERVED_01    (0xB)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_RESERVED_02    (0xC)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_RESERVED_03    (0xD)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_RESERVED_04    (0xE)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_RESERVED_05    (0xF)  /* codegen_cpld_reg */
+
+/* Bank #1 - Input registers */
+#define PICO_CPLD_REG_IP_REG_00      (0x10)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_01      (0x11)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_02      (0x12)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_03      (0x13)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_04      (0x14)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_05      (0x15)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_06      (0x16)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_07      (0x17)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_08      (0x18)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_09      (0x19)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_10      (0x1A)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_11      (0x1B)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_12      (0x1C)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_13      (0x1D)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_14      (0x1E)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_IP_REG_15      (0x1F)  /* codegen_cpld_reg */
+
+/* Bank #2 - Output registers */
+#define PICO_CPLD_REG_OP_REG_00      (0x20)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_01      (0x21)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_02      (0x22)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_03      (0x23)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_04      (0x24)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_05      (0x25)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_06      (0x26)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_07      (0x27)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_08      (0x28)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_09      (0x29)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_10      (0x2A)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_11      (0x2B)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_12      (0x2C)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_13      (0x2D)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_14      (0x2E)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_OP_REG_15      (0x2F)  /* codegen_cpld_reg */
+
+/* Bank #3 - Select registers */
+#define PICO_CPLD_REG_SEL_REG_00     (0x30)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_01     (0x31)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_02     (0x32)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_03     (0x33)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_04     (0x34)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_05     (0x35)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_06     (0x36)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_07     (0x37)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_08     (0x38)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_09     (0x39)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_10     (0x3A)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_11     (0x3B)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_12     (0x3C)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_13     (0x3D)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_14     (0x3E)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_SEL_REG_15     (0x3F)  /* codegen_cpld_reg */
+
+/* Bank #4 - Tri-State registers */
+#define PICO_CPLD_REG_ENB_REG_00     (0x40)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_01     (0x41)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_02     (0x42)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_03     (0x43)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_04     (0x44)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_05     (0x45)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_06     (0x46)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_07     (0x47)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_08     (0x48)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_09     (0x49)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_10     (0x4A)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_11     (0x4B)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_12     (0x4C)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_13     (0x4D)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_14     (0x4E)  /* codegen_cpld_reg */
+#define PICO_CPLD_REG_ENB_REG_15     (0x4F)  /* codegen_cpld_reg */
+
+#define PICO_CPLD_REG_NREGS          (0x50)
+
+#endif  /* _CPLD_CPE20X_H__ */
+
diff --git a/drivers/picochip/cpld_hdp102.c b/drivers/picochip/cpld_hdp102.c
new file mode 100644
index 0000000..64176eb
--- /dev/null
+++ b/drivers/picochip/cpld_hdp102.c
@@ -0,0 +1,713 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright 2005 Zetetica Ltd.  <david.warman@zetetica.co.uk>
+ * Copyright (c) 2006 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file cpld_hdp.c
+ * \brief HDP102 CPLD access
+ *
+ * picoHDP CPLD register access
+ *     - provides interface for other device drivers, no direct access
+ *       from user space at present.  Should attempt API compatibility
+ *      with Airspan asmax/cpld driver.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/jiffies.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+
+#include <asm/cpld_hdp102.h>
+
+/** asmax version has Fan RPM control and FPGA control which do not
+ *  exist on this target
+ */
+
+/* Exported functions */
+
+EXPORT_SYMBOL(cpld_fpga_reset);
+EXPORT_SYMBOL(cpld_fpga_reset_assert);
+EXPORT_SYMBOL(cpld_fpga_reset_deassert);
+EXPORT_SYMBOL(cpld_pico_reset_assert);
+EXPORT_SYMBOL(cpld_pico_reset_deassert);
+EXPORT_SYMBOL(cpld_reg_read);
+EXPORT_SYMBOL(cpld_reg_write);
+EXPORT_SYMBOL(cpld_dma_enable);
+EXPORT_SYMBOL(cpld_dma_disable);
+EXPORT_SYMBOL(cpld_dma_reset);
+
+
+/* Dummy fan functions (no fan control on this target */
+EXPORT_SYMBOL(cpld_fan_on);
+EXPORT_SYMBOL(cpld_fan_off);
+
+#define PRINTD(lvl, format, ...)  \
+    do { \
+        if(debug>=lvl)\
+        { \
+            printk(KERN_INFO PREFIX format, ##__VA_ARGS__); \
+        } \
+    } while(0)
+
+#define PRINTE(format, ...)  \
+    printk(KERN_ERR __FILE__ ":%d:" format, __LINE__, ##__VA_ARGS__)
+
+
+/*******************************************************************************
+Module Parameters
+
+   The major device number is assigned dynamically, unless:
+   1) CPLD_MAJOR is #defined non-zero in the Makefile
+   2) "major" is set at module load time on the insmod command line
+*******************************************************************************/
+#ifndef CPLD_MAJOR
+#define CPLD_MAJOR 248
+#endif
+
+#define CPLD_DEVNAME "picoHDP-cpld"
+
+static int major = CPLD_MAJOR;
+module_param(major, int, 0); /* Device major number */
+
+/*** internal data structures ***/
+
+typedef struct cpld
+{
+    struct miscdevice miscdev;           /* character device info */
+    volatile u16* regs;                  /* pointer to the actual registers */
+    u16 mirror[PICO_CPLD_REG_NREGS];  /* mirrors for bit-access */
+} cpld_t;
+
+/* private device structure for each open device instance */
+typedef struct cpld_dev
+{
+    int minor;
+} cpld_dev_t;
+
+static int
+cpld_open(struct inode *inode,
+          struct file *filp);
+
+static int
+cpld_ioctl(struct inode *inode,
+           struct file *filp,
+           unsigned int cmd,
+           unsigned long arg);
+
+static ssize_t
+cpld_read(struct file *filp,
+          char *buf,
+          size_t bufsize,
+          loff_t *offset);
+
+static ssize_t
+cpld_write(struct file *filp,
+           const char *buf,
+           size_t bufsize,
+           loff_t *offset);
+
+static int
+cpld_release(struct inode *inode,
+             struct file *filp);
+
+static struct file_operations cpld_fops =
+{
+    .open = cpld_open,
+    .ioctl = cpld_ioctl,
+    .read = cpld_read,
+    .write = cpld_write,
+    .release = cpld_release,
+};
+
+static cpld_t cpld =
+{
+    .miscdev =
+    {
+        .minor  = MISC_DYNAMIC_MINOR,
+        .name   = "cpld",
+        .fops   = &cpld_fops,
+    },
+};
+
+/* internal functions */
+static int
+request_and_map(const char* name,
+                unsigned long address,
+                int size,
+                void** virt_addr);
+
+static int
+cpld_set_dma_map(int map_number)
+{
+    cpld_dma_disable(0);
+    cpld_dma_disable(1);
+    cpld_dma_disable(2);
+    cpld_dma_disable(3);
+    udelay(10);
+    cpld_dma_reset(0);
+    cpld_dma_reset(1);
+    cpld_dma_reset(2);
+    cpld_dma_reset(3);
+    cpld_reg_write(PICO_CPLD_REG_DMA_SELECT, map_number);
+    cpld_dma_reset(0);
+    cpld_dma_reset(1);
+    cpld_dma_reset(2);
+    cpld_dma_reset(3);
+
+    return 0;
+}
+
+static const char *mapping_names[] = {
+    "ALL_PICOARRAY_0",
+    "ALL_PICOARRAY_1",
+    "SPLIT",
+    "ALL_PICOARRAY_2",
+    "ALL_PICOARRAY_3",
+};
+
+static ssize_t
+cpld_show_dma_mapping(struct device *dev,
+                      struct device_attribute *attr,
+                      char *buf)
+{
+    int mapping = cpld_reg_read(PICO_CPLD_REG_DMA_SELECT);
+    const char *name;
+
+    /* Bottom 4 bits show the mapping. */
+    mapping &= 0xF;
+
+    if (mapping >= 0 && mapping < ARRAY_SIZE(mapping_names))
+        name = mapping_names[mapping];
+    else
+        name = "INVALID";
+
+    return sprintf(buf, "%s\n", name);
+}
+
+static ssize_t
+cpld_store_dma_mapping(struct device *dev,
+                       struct device_attribute *attr,
+                       const char *buf,
+                       size_t count)
+{
+    unsigned i = 0;
+    int mapping = -1;
+    size_t len = count;
+
+    /* Strip the newline if there is one. */
+    for (i = 0; i < count; ++i)
+        if (buf[i] == '\n')
+        {
+            len = i;
+            break;
+        }
+
+    for (i = 0; i < ARRAY_SIZE(mapping_names); ++i)
+        if (!strncmp(mapping_names[i], buf, len))
+        {
+            mapping = i;
+            break;
+        }
+
+    if (mapping >= 0)
+        cpld_set_dma_map(mapping);
+    return mapping >= 0 ? count : -EINVAL;
+}
+DEVICE_ATTR(dma_mapping, 0644, cpld_show_dma_mapping, cpld_store_dma_mapping);
+
+static struct attribute *cpld_attrs[] = {
+    &dev_attr_dma_mapping.attr,
+    NULL,
+};
+
+static struct attribute_group cpld_attr_group = {
+    .attrs = cpld_attrs,
+};
+
+static int
+cpld_init(void)
+{
+    int err, i;
+    cpld.regs = 0;    /* Ensure null on failure */
+
+    /*** do char device setup ***/
+
+    if (misc_register(&cpld.miscdev))
+        return -EFAULT;
+
+    err = request_and_map("picoHDP CPLD", PICOHDP_CPLD_BASE,
+                          PICO_CPLD_REG_BLOCKSIZE, (void**)&(cpld.regs));
+    if (err)
+    {
+        PRINTE("%s: cannot map, major=%d; err=%d\n",
+               CPLD_DEVNAME, major, err);
+    }
+    else
+    {
+        /* Mapped ok */
+        printk(KERN_INFO "cpld: picoChip HDP target CPLD driver\n");
+    }
+
+    /* initialise mirrors to zero */
+    for (i = 0; i < PICO_CPLD_REG_NREGS; i++)
+    {
+        cpld.mirror[i] = 0;
+    }
+
+    err = sysfs_create_group(&cpld.miscdev.this_device->kobj,
+                             &cpld_attr_group);
+    if (err)
+        goto fail;
+
+    return err;
+
+fail:
+    misc_deregister(&cpld.miscdev);
+    iounmap(cpld.regs);
+    release_mem_region(PICOHDP_CPLD_BASE, PICO_CPLD_REG_BLOCKSIZE);
+
+    return err;
+}
+
+static void
+cpld_exit(void)
+{
+    sysfs_remove_group(&cpld.miscdev.this_device->kobj, &cpld_attr_group);
+    /* unregister the char device */
+    misc_deregister(&cpld.miscdev);
+
+    if (cpld.regs != 0)
+    {
+        iounmap(cpld.regs);
+        release_mem_region(PICOHDP_CPLD_BASE,
+                           PICO_CPLD_REG_BLOCKSIZE);
+    }
+    printk(KERN_INFO "cpld: picoChip CPLD driver unloaded\n");
+}
+
+/* Dummy functions */
+void
+cpld_fpga_reset(int fpga)
+{
+}
+
+void
+cpld_fpga_reset_assert(int fpga)
+{
+}
+
+void
+cpld_fpga_reset_deassert(int fpga)
+{
+}
+
+/* Only reset_assert is used; our reset is auto-clearing */
+void
+cpld_pico_reset_assert(int pico)
+{
+    u16 resetbit = 0;
+    u16 regReadValue;
+
+    switch(pico)
+    {
+        case 0:
+            resetbit = PICO_CPLD_BIT_LEDRESET_PA0RESET;
+            break;
+        case 1:
+            resetbit = PICO_CPLD_BIT_LEDRESET_PA1RESET;
+            break;
+#ifdef CONFIG_PICOHDP203
+        case 2:
+            resetbit = PICO_CPLD_BIT_LEDRESET_PA2RESET;
+            break;
+        case 3:
+            resetbit = PICO_CPLD_BIT_LEDRESET_PA3RESET;
+            break;
+#endif
+        default:
+            printk(KERN_INFO "Warning: CPLD driver asked to reset "
+                "picoChip %d, which does not exist\n", pico);
+            break;
+    }
+
+    if (cpld.regs != 0)
+    {
+        /* Reset bits are active low, but read back as '1';
+         * the reset returns to the inactive state automatically
+         */
+        /* cpld.regs[PICO_CPLD_REG_LEDRESET] &= resetbit; */
+
+        /* For 'some reason' we need to do a couple of dummy reads from the
+           cpld before we get 'real' data */
+
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+
+        cpld.regs[PICO_CPLD_REG_LEDRESET] = regReadValue & ~resetbit;
+
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+    }
+}
+
+void
+cpld_pico_reset_deassert(int pico)
+{
+    /* Reset is self-clearing on this target */
+    /* not any more... */
+
+    u16 resetbit = 0;
+    u16 regReadValue;
+    switch(pico)
+    {
+        case 0:
+            resetbit = PICO_CPLD_BIT_LEDRESET_PA0RESET;
+            break;
+        case 1:
+            resetbit = PICO_CPLD_BIT_LEDRESET_PA1RESET;
+            break;
+#ifdef CONFIG_PICOHDP203
+        case 2:
+            resetbit = PICO_CPLD_BIT_LEDRESET_PA2RESET;
+            break;
+        case 3:
+            resetbit = PICO_CPLD_BIT_LEDRESET_PA3RESET;
+            break;
+#endif
+        default:
+            printk(KERN_INFO "Warning: CPLD driver asked to reset "
+                "picoChip %d, which does not exist\n", pico);
+            break;
+    }
+    if (cpld.regs != 0)
+    {
+        /* Reset bits are active low, but read back as '1';
+         * the reset returns to the inactive state automatically
+         */
+        /* cpld.regs[PICO_CPLD_REG_LEDRESET] &= resetbit; */
+
+        /* For 'some reason' we need to do a couple of dummy reads from the
+           cpld before we get 'real' data */
+
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+
+        cpld.regs[PICO_CPLD_REG_LEDRESET] = regReadValue | resetbit;
+
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+        regReadValue = cpld.regs[PICO_CPLD_REG_LEDRESET];
+    }
+}
+
+/* Host CTRL Register - not implemented on this target, so dummy functions */
+void
+cpld_fan_on(int fan)
+{
+}
+
+void
+cpld_fan_off(int fan)
+{
+}
+
+/* CPLD Version Register - not used at present */
+u8
+cpld_version(void)
+{
+    return 0;
+}
+
+/* Not used on this target */
+u8
+cpld_diagnostics(void)
+{
+    return 0;
+}
+
+/* Helper function for gaining access to a physical region */
+static int
+request_and_map(const char* name,
+                unsigned long address,
+                int size,
+                void** virt_addr)
+{
+    int err = 0;
+    struct resource *r;
+
+    r = request_mem_region(address, size, name);
+    if (r != NULL)
+    {
+        *virt_addr = ioremap(address, size);
+        if (*virt_addr == NULL)
+        {
+            release_resource(r);
+            err = -EIO;
+        }
+    }
+    else
+    {
+        err = -EBUSY;
+        printk(KERN_DEBUG "cpld: failed to allocate %s\n", name);
+    }
+
+    return err;
+}
+
+/*
+ * CPLD char device File Ops methods
+ */
+static int
+cpld_open(struct inode *inode,
+          struct file *filp)
+{
+    int ret = 0;
+    cpld_dev_t *dev;
+
+    dev = (cpld_dev_t *)kzalloc(sizeof(cpld_dev_t), GFP_KERNEL);
+    if (!dev)
+    {
+        ret = -ENOMEM;
+    }
+    else
+    {
+        dev->minor = iminor(inode);
+        filp->private_data = dev;
+    }
+    return ret;
+}
+
+static int
+cpld_ioctl(struct inode *inode,
+           struct file *filp,
+           unsigned int cmd,
+           unsigned long arg)
+{
+    cpld_reg_param_t params;
+    int ret = 0;
+
+    /* check that the requested command is in range */
+    if (_IOC_TYPE(cmd) != PICO_CPLD_IOC_MAGIC)
+        return -ENOTTY;
+    if (_IOC_NR(cmd) > PICO_CPLD_IOC_MAXNUM)
+        return -ENOTTY;
+
+    switch (cmd)
+    {
+        case PICO_CPLD_IOCWRITEREG :
+        {
+            if (copy_from_user(&params, (void *)arg, sizeof(params)))
+            {
+                ret = -EFAULT;
+                break;
+            }
+            if (params.reg >= PICO_CPLD_REG_NREGS)
+            {
+                PRINTE("invalid register %d",
+                    params.reg);
+                ret = -EINVAL;
+                break;
+            }
+            cpld.regs[params.reg] = params.data;
+            break;
+        }
+        case PICO_CPLD_IOCREADREG :
+        {
+            if (copy_from_user(&params, (void *)arg, sizeof(params)))
+            {
+                ret = -EFAULT;
+                break;
+            }
+            if (params.reg >= PICO_CPLD_REG_NREGS)
+            {
+                PRINTE("invalid register %d",
+                    params.reg);
+                ret = -EINVAL;
+                break;
+            }
+            params.data = cpld_reg_read(params.reg);
+            if (copy_to_user((void *)arg, &params, sizeof(params)))
+                ret = -EFAULT;
+            break;
+        }
+        default:
+            PRINTE("invalid ioctl command 0x%08X", cmd);
+            return -ENOTTY;
+    }
+    return ret;
+}
+
+/*
+ * Wrapper function for CPLD register reads.
+ */
+u16
+cpld_reg_read(unsigned char regno)
+{
+    if (regno >= PICO_CPLD_REG_NREGS)
+    {
+        PRINTE("invalid register %d", regno);
+        return 0;
+    }
+    return cpld.regs[regno];
+}
+
+/*
+ * Wrapper function for CPLD register writes.
+ */
+void
+cpld_reg_write(unsigned char regno, u16 data)
+{
+    if (regno >= PICO_CPLD_REG_NREGS)
+    {
+        PRINTE("invalid register %d", regno);
+        return;
+    }
+    cpld.mirror[regno] = data;
+    cpld.regs[regno] = cpld.mirror[regno];
+}
+
+/*
+ * Write a value to a register using a bitmask. An internal mirror maintains
+ * the state of the un-altered bits.
+ */
+void
+cpld_bit_write(unsigned char regno, u16 data, u16 mask)
+{
+    if (regno >= PICO_CPLD_REG_NREGS)
+    {
+        PRINTE("invalid register %d", regno);
+        return;
+    }
+    cpld.mirror[regno] &= ~mask;
+    cpld.mirror[regno] |= (data & mask);
+    cpld.regs[regno] = cpld.mirror[regno];
+    wmb();
+}
+
+/*
+ * Enable a DMA state machine. The DMA state machines have been added
+ * to get around a problem with the MPC8560's DMAC whereby external start/
+ * pause mode will prevent software control or initiation of transfers
+ * and will not otherwise stop at the end of a descriptor list.
+ * CPLD VHDL mod credits to Duncan Smith at PicoChip.
+ */
+void
+cpld_dma_enable(unsigned char chan)
+{
+    if (chan >= PICO_CPLD_DMA_NCHANS)
+    {
+        PRINTE("invalid channel number %d", chan);
+        return;
+    }
+
+    /* set enable bit, clear reset bit */
+    cpld_bit_write(PICO_CPLD_REG_DREQCTRL, 0xf0, 0x11 << chan );
+}
+
+/*
+ * Disable a DMA state machine.
+ */
+void
+cpld_dma_disable(unsigned char chan)
+{
+    if (chan >= PICO_CPLD_DMA_NCHANS)
+    {
+        PRINTE("invalid channel number %d", chan);
+        return;
+    }
+
+    /* clear enable and reset bits */
+    cpld_bit_write(PICO_CPLD_REG_DREQCTRL, 0x00, 0x11 << chan );
+}
+
+/*
+ * Reset the DMA state machine in the CPLD.
+ */
+void
+cpld_dma_reset(unsigned char chan)
+{
+    if (chan >= PICO_CPLD_DMA_NCHANS)
+    {
+        PRINTE("invalid channel number %d", chan);
+        return;
+    }
+
+    /* set then clear the reset bit to start a DMA */
+    cpld_bit_write(PICO_CPLD_REG_DREQCTRL, 0xff, 0x01 << chan );
+    cpld_bit_write(PICO_CPLD_REG_DREQCTRL, 0x00, 0x01 << chan );
+}
+
+/*
+ * fops read method (currently unimplemented)
+ */
+static
+ssize_t cpld_read(struct file *filp,
+                  char *buf,
+                  size_t bufsize,
+                  loff_t *offset)
+{
+    return 0;
+}
+
+/*
+ * fops write method (currently unimplemented)
+ */
+static
+ssize_t cpld_write(struct file *filp,
+                   const char *buf,
+                   size_t bufsize,
+                   loff_t *offset)
+{
+    return 0;
+}
+
+/*
+ * fops release (close) method
+ */
+static int
+cpld_release(struct inode *inode,
+             struct file *filp)
+{
+    cpld_dev_t *dev = filp->private_data;
+
+    kfree(dev);
+    return 0;
+}
+
+/*
+ * Module details
+ */
+MODULE_AUTHOR("David Warman <david.warman@zetetica.co.uk>, with picoChip mods");
+MODULE_DESCRIPTION("picoChip CPLD driver.");
+MODULE_LICENSE("GPL");
+
+module_init(cpld_init);
+module_exit(cpld_exit);
+
diff --git a/drivers/picochip/debug.c b/drivers/picochip/debug.c
new file mode 100644
index 0000000..7ec8af4
--- /dev/null
+++ b/drivers/picochip/debug.c
@@ -0,0 +1,366 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file debug.c
+ * \brief picoIf debug implementation.
+ *
+ * This file implements functions for reading and writing debug messages
+ * through debugfs.
+ */
+
+#include <linux/module.h>
+#include <stdarg.h>
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/configfs.h>
+#include <linux/kfifo.h>
+#include <asm/uaccess.h>
+#include "debug.h"
+
+#ifdef CONFIG_DEBUG_FS
+
+/*! The maximum number of bytes that may be stored in the ring buffer. If the
+ *  ring fills, the oldest data will be lost first. */
+#define DEBUG_RING_SIZE  32768
+
+/*! The maximum length of a debug message. Messages longer than this will be
+ *  truncated. */
+#define MAX_MSG_LEN     256
+
+/*! The current picoIf debug level. */
+static u8 picoif_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current PC202 debug level. */
+static u8 pc202_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current PC203 debug level. */
+static u8 pc203_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current PC302 debug level. */
+static u8 pc302_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current procif debug level. */
+static u8 procif_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current AXI2Cfg debug level. */
+static u8 axi2cfg_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current GPR interrupt transport module debug level. */
+static u8 gpr_int_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current DMA transport module debug level. */
+static u8 dma_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current HwIf transport module debug level. */
+static u8 hwif_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current HwIf2 transport module debug level. */
+static u8 hwif2_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current debug module debug level. */
+static u8 debug_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+
+/*! picoIf debug component. */
+struct dbg_component picoif_dbg_component = {
+    .curr_lvl   = &picoif_dbg_lvl,
+    .name       = "picoif",
+};
+
+/*! PC202 debug component. */
+struct dbg_component pc202_dbg_component = {
+    .curr_lvl   = &pc202_dbg_lvl,
+    .name       = "pc202",
+};
+
+/*! PC203 debug component. */
+struct dbg_component pc203_dbg_component = {
+    .curr_lvl   = &pc203_dbg_lvl,
+    .name       = "pc203",
+};
+
+/*! PC302 debug component. */
+struct dbg_component pc302_dbg_component = {
+    .curr_lvl   = &pc302_dbg_lvl,
+    .name       = "pc302",
+};
+
+/*! Procif debug component. */
+struct dbg_component procif_dbg_component = {
+    .curr_lvl   = &procif_dbg_lvl,
+    .name       = "procif",
+};
+
+/*! AXI2Cfg debug component. */
+struct dbg_component axi2cfg_dbg_component = {
+    .curr_lvl   = &axi2cfg_dbg_lvl,
+    .name       = "axi2cfg",
+};
+
+/*! GPR interrupt debug component. */
+struct dbg_component gpr_int_dbg_component = {
+    .curr_lvl   = &gpr_int_dbg_lvl,
+    .name       = "gpr_int",
+};
+
+/*! DMA debug component. */
+struct dbg_component dma_dbg_component = {
+    .curr_lvl   = &dma_dbg_lvl,
+    .name       = "dma",
+};
+
+/*! HwIF debug component. */
+struct dbg_component hwif_dbg_component = {
+    .curr_lvl   = &hwif_dbg_lvl,
+    .name       = "hwif",
+};
+
+/*! HwIF2 debug component. */
+struct dbg_component hwif2_dbg_component = {
+    .curr_lvl   = &hwif2_dbg_lvl,
+    .name       = "hwif2",
+};
+
+/*! Debug module debug component. */
+struct dbg_component debug_dbg_component = {
+    .curr_lvl   = &debug_dbg_lvl,
+    .name       = "debug",
+};
+
+/*! The debug ring itself. */
+static struct kfifo *debug_ring;
+
+/*! The spinlock protecting the ring. */
+static spinlock_t debug_ring_lock;
+
+/*! Temorary structure for storing messages before writing to the ring buffer.
+ */
+static char msg_buf[ MAX_MSG_LEN ];
+
+/*!
+ * Move the len bytes of msg_buf into the debug ring.
+ *
+ * @param len The number of bytes to move into the debug ring. If there isn't
+ * enough space, then discard some old data to make sure it fits.
+ * @return Returns the number of bytes put into the debug ring.
+ */
+ssize_t
+static __pc_debug_put( size_t len )
+{
+    size_t space;
+    ssize_t ret;
+
+    space = DEBUG_RING_SIZE - __kfifo_len( debug_ring );
+
+    /* If there isn't enough space in the fifo for the message, then discard
+     * the oldest data so that we can fit the latest message in. */
+    if ( len > space )
+        debug_ring->in += ( space - len );
+
+    ret = __kfifo_put( debug_ring, msg_buf, len );
+
+    return ret;
+}
+
+ssize_t
+pc_debug_print( const char *component,
+                const char *fmt,
+                ... )
+{
+    va_list args;
+    int len;
+    int added;
+    unsigned long flags;
+
+    spin_lock_irqsave( debug_ring->lock, flags );
+
+    len = sprintf( msg_buf, "[%s] ", component );
+    added = __pc_debug_put( len );
+#ifdef CONFIG_PICOIF_DEBUG_TO_CONSOLE
+    printk( msg_buf );
+#endif /* CONFIG_PICOIF_DEBUG_TO_CONSOLE */
+
+    va_start( args, fmt );
+    len = vsnprintf( msg_buf, sizeof( msg_buf ), fmt, args );
+#ifdef CONFIG_PICOIF_DEBUG_TO_CONSOLE
+    printk( msg_buf );
+#endif /* CONFIG_PICOIF_DEBUG_TO_CONSOLE */
+    va_end( args );
+    added += __pc_debug_put( len );
+
+    spin_unlock_irqrestore( debug_ring->lock, flags );
+
+    return added;
+}
+EXPORT_SYMBOL( pc_debug_print );
+
+/*!
+ * Dump the debug ring to the console.
+ */
+void
+debug_dump( void )
+{
+    char tmp;
+    unsigned long flags;
+
+    spin_lock_irqsave( debug_ring->lock, flags );
+    while ( kfifo_get( debug_ring, &tmp, 1 ) )
+        printk( "%c", tmp );
+    printk( "\n" );
+    spin_unlock_irqrestore( debug_ring->lock, flags );
+}
+EXPORT_SYMBOL( debug_dump );
+
+/*!
+ * Open method for the debug ring file.
+ *
+ * @param inode The inode of the debugfs log entry.
+ * @param filp File structure for the opened instance.
+ * @return Always returns zero.
+ */
+static int
+debug_log_open( struct inode *inode,
+                struct file *filp )
+{
+    return 0;
+}
+
+/*!
+ * Read from the debug ring.
+ *
+ * @param filp The file structure for the instance.
+ * @param buf The buffer to write the debug messages into.
+ * @param count The maximum number of bytes to read.
+ * @param offp The offset in the file.
+ * @return Returns the number of bytes read from the ring.
+ */
+static ssize_t
+debug_log_read( struct file *filp,
+                char __user *buf,
+                size_t count,
+                loff_t *offp )
+{
+    char *tmp_buf = kmalloc( count, GFP_KERNEL );
+    int ret = -ENOMEM;
+    unsigned nbytes;
+    if ( !tmp_buf )
+        goto out;
+
+    nbytes = kfifo_get( debug_ring, tmp_buf, count );
+    ret = copy_to_user( buf, tmp_buf, nbytes );
+    if ( !ret )
+        ret = nbytes;
+out:
+    if ( tmp_buf )
+        kfree( tmp_buf );
+    return ret;
+}
+
+/*!
+ * Seek the debug log. The log isn't seekable as the output is consumed as it
+ * is read.
+ *
+ * @param filp File structure for the open instance.
+ * @param orig The original offset in the file.
+ * @param offset The offset to seek from orig.
+ * @return Always returns zero.
+ */
+static loff_t
+debug_log_lseek( struct file *filp,
+                 loff_t orig,
+                 int offset )
+{
+    return orig;
+}
+
+/*!
+ * Release method for the debug log.
+ *
+ * @param inode The inode of the debugfs log entry.
+ * @param filp The file structure for the open instance.
+ * @return Always returns zero.
+ */
+static int
+debug_log_release( struct inode *inode,
+                   struct file *filp )
+{
+    return 0;
+}
+
+/*! File operations for the debugfs log entry. */
+static struct file_operations debug_log_fops = {
+    .open       = debug_log_open,
+    .read       = debug_log_read,
+    .llseek     = debug_log_lseek,
+    .release    = debug_log_release,
+};
+
+struct dentry *
+pc_debug_create_log_file( struct dentry *parent )
+{
+    debug_ring = kfifo_alloc( DEBUG_RING_SIZE, GFP_KERNEL, &debug_ring_lock );
+    if ( !debug_ring )
+        goto fail;
+
+    PRINTD( COMPONENT_DEBUG, DBG_TRACE, "debugfs log initialised" );
+
+    debugfs_create_u8( "picoif_dbg_lvl", 0644, parent, &picoif_dbg_lvl );
+#ifdef CONFIG_PICOIF_PC202
+    debugfs_create_u8( "pc202_dbg_lvl", 0644, parent, &pc202_dbg_lvl );
+#endif /* CONFIG_PICOIF_PC202 */
+#ifdef CONFIG_PICOIF_PC203
+    debugfs_create_u8( "pc203_dbg_lvl", 0644, parent, &pc203_dbg_lvl );
+#endif /* CONFIG_PICOIF_PC203 */
+#ifdef CONFIG_PICOIF_PC302
+    debugfs_create_u8( "pc302_dbg_lvl", 0644, parent, &pc302_dbg_lvl );
+#endif /* CONFIG_PICOIF_PC302 */
+#if ( defined(CONFIG_PICOIF_PC202) || defined(CONFIG_PICOIF_PC203) )
+    debugfs_create_u8( "procif_dbg_lvl", 0644, parent, &procif_dbg_lvl );
+#endif /* CONFIG_PICOIF_PC202 || CONFIG_PICOIF_PC203 */
+#ifdef CONFIG_PICOIF_PC302
+    debugfs_create_u8( "axi2cfg_dbg_lvl", 0644, parent, &axi2cfg_dbg_lvl );
+#endif /* CONFIG_PICOIF_PC302 */
+    debugfs_create_u8( "gpr_int_dbg_lvl", 0644, parent, &gpr_int_dbg_lvl );
+    debugfs_create_u8( "dma_dbg_lvl", 0644, parent, &dma_dbg_lvl );
+    debugfs_create_u8( "hwif_dbg_lvl", 0644, parent, &hwif_dbg_lvl );
+    debugfs_create_u8( "hwif2_dbg_lvl", 0644, parent, &hwif2_dbg_lvl );
+    debugfs_create_u8( "debug_dbg_lvl", 0644, parent, &debug_dbg_lvl );
+
+    spin_lock_init( &debug_ring_lock );
+
+    return debugfs_create_file( "log", 0444, parent, NULL, &debug_log_fops );
+fail:
+    return NULL;
+}
+
+void
+pc_debug_close( void )
+{
+    kfifo_free( debug_ring );
+}
+
+#else  /* CONFIG_DEBUG_FS */
+
+/*!
+ * Create a log file for the driver in debugfs. If debugfs is not enabled,
+ * this will do nothing.
+ *
+ * @param parent Ignored.
+ * @return Always returns NULL.
+ */
+struct dentry *
+debug_create_log_file( struct dentry *parent )
+{
+    return NULL;
+}
+
+ssize_t
+pc_debug_print( const char *fmt,
+                ... )
+{
+    return -ENODEV;
+}
+
+#endif /* CONFIG_DEBUG_FS */
diff --git a/drivers/picochip/debug.h b/drivers/picochip/debug.h
new file mode 100644
index 0000000..32ce06a
--- /dev/null
+++ b/drivers/picochip/debug.h
@@ -0,0 +1,205 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/* Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file debug.h
+ * \brief picoIf debug definitions.
+ *
+ * This file defines a set of macros and functions for adding debug into the
+ * picoIf driver. All debug information is exported through debugfs.
+ *
+ * \page debugging Debugging the picoIf driver
+ *
+ * \section introduction Introduction
+ *
+ * The picoIf kernel module provides some debug capability through debugfs. If
+ * the kernel is compiled with debugfs support, then picoIf will create a
+ * hierarchy in /debug/picoif. A typical hierarchy (depending on what
+ * transports and devices are enabled) may look like:
+ *
+ * \code
+ * root@picocpe:~# ls /debug/picoif/
+ * debug_dbg_lvl    gpr_int_dbg_lvl  pc202_dbg_lvl    procif_dbg_lvl
+ * dma_dbg_lvl      log              picoif_dbg_lvl
+ * \endcode
+ *
+ * Each of these *lvl files contain the current logging level of that
+ * component where higher numbers are decreasing priority. These levels can be
+ * queried and set by accessing the file. For example, to set the PC202 debug
+ * level to 5:
+ *
+ * \code
+ * root@picocpe:~# echo -n "5" > /debug/picoif/pc202_dbg_lvl
+ * root@picocpe:~# cat /debug/picoif/pc202_dbg_lvl
+ * 5
+ * root@picocpe:~#
+ * \endcode
+ *
+ * The debug log itself can be read through the /debug/picoif/log file. Note
+ * that reading this file will consume the log and the log itself is not
+ * seekable. The log is implemented as a circular buffer, and if the buffer
+ * fills, the oldest data is discarded to allow new messages to be logged.
+ *
+ * To prevent the debug information from slowing down applications by printing
+ * to the serial console, by default the debug messages won't be printed to
+ * the console. If you do want to send debug messages to the console in
+ * addition to the ring buffer, then DBG_TO_CONSOLE should be defined in
+ * debug.c. To disable this, simply undef it.
+ *
+ * \section addingnewcomponents Adding new debug components
+ *
+ * To add new debug components:
+ *  \li Create a static u8 for the current debug level of the component in
+ *  debug.c
+ *  \li Create a dbg_component in debug.c for the new component.
+ *  \li In pc_debug_create_log_file(), add a debugfs_create_u8() call for the
+ *  new components debug level. This will export the debug level through
+ *  debugfs.
+ *  \li In debug.h, create a new COMPONENT_xxx and corresponding extern
+ *  dbg_component declaration so that the component can be used in the code.
+ *
+ * \section debugfromkernel Printing the debug from kernelspace
+ *
+ * It is also possible to dump the contents of the debug ring buffer from
+ * kernel space. This is achieved with debug_dump().
+ */
+#ifndef __PICOIF_DEBUG_H__
+#define __PICOIF_DEBUG_H__
+
+#include <linux/fs.h>
+
+/*!
+ * \brief Debug component structure. Used so that we can control debug levels
+ * through debugfs and prefix messages with a component name.
+ */
+struct dbg_component
+{
+    u8          *curr_lvl;  /*!< Pointer to the current debug level of the
+                             *   component. */
+    const char  *name;      /*!< The name of the debug component. */
+};
+
+extern struct dbg_component picoif_dbg_component;
+extern struct dbg_component pc202_dbg_component;
+extern struct dbg_component pc203_dbg_component;
+extern struct dbg_component pc302_dbg_component;
+extern struct dbg_component procif_dbg_component;
+extern struct dbg_component axi2cfg_dbg_component;
+extern struct dbg_component gpr_int_dbg_component;
+extern struct dbg_component dma_dbg_component;
+extern struct dbg_component hwif_dbg_component;
+extern struct dbg_component hwif2_dbg_component;
+extern struct dbg_component debug_dbg_component;
+
+/*! Main picoIf debug component. */
+#define COMPONENT_PICOIF    (&picoif_dbg_component)
+/*! PC202 debug component. */
+#define COMPONENT_PC202     (&pc202_dbg_component)
+/*! PC203 debug component. */
+#define COMPONENT_PC203     (&pc203_dbg_component)
+/*! PC302 debug component. */
+#define COMPONENT_PC302     (&pc302_dbg_component)
+/*! procif debug component. */
+#define COMPONENT_PROCIF    (&procif_dbg_component)
+/*! AXI2Cfg debug component. */
+#define COMPONENT_AXI2CFG   (&axi2cfg_dbg_component)
+/*! GPR IRQ transport module component. */
+#define COMPONENT_GPR_INT   (&gpr_int_dbg_component)
+/*! DMA transport module component. */
+#define COMPONENT_DMA       (&dma_dbg_component)
+/*! HwIF transport module component. */
+#define COMPONENT_HWIF     (&hwif_dbg_component)
+/*! HwIF2 transport module component. */
+#define COMPONENT_HWIF2     (&hwif2_dbg_component)
+/*! Debug module component. */
+#define COMPONENT_DEBUG     (&debug_dbg_component)
+
+/*! Debug levels for the debug subsystem. Higher numeric values are of lower
+ *  importance. */
+enum dbg_level
+{
+    DBG_ERROR,
+    DBG_WARN,
+    DBG_TRACE,
+    DBG_TRIVIAL,
+};
+
+#undef DBG_SHOW_LOCATION
+
+#ifdef DBG_SHOW_LOCATION
+/*!
+ * Print a debug message if the current debug level is appropriate for the
+ * severity of the debug message.
+ *
+ * @param _component The component to tag the message with.
+ * @param _level The level of the message.
+ * @param _fmt The format string for the message.
+ */
+#define PRINTD( _component, _level, _fmt, ... ) \
+    do { \
+        if ( _level < *( _component->curr_lvl ) ) { \
+            pc_debug_print( _component->name, "%s %u: " _fmt "\n", __FILE__, \
+                            __LINE__, ##__VA_ARGS__ ); \
+        } \
+    } while ( 0 )
+#else /* DBG_SHOW_LOCATION */
+/*!
+ * Print a debug message if the current debug level is appropriate for the
+ * severity of the debug message.
+ *
+ * @param _component The component to tag the message with.
+ * @param _level The level of the message.
+ * @param _fmt The format string for the message.
+ */
+#define PRINTD( _component, _level, _fmt, ... ) \
+    do { \
+        if ( _level < *( _component->curr_lvl ) ) { \
+            pc_debug_print( _component->name, "%s(): " _fmt "\n", \
+                            __FUNCTION__, ##__VA_ARGS__ ); \
+        } \
+    } while ( 0 )
+#endif /* DBG_SHOW_LOCATION */
+
+/*!
+ * Print a debug message into the debug ring.
+ *
+ * @param component The name of the component responsible for the message.
+ * @param fmt The format string for the message.
+ * @return Returns the number of bytes written into the ring.
+ */
+ssize_t pc_debug_print( const char *component,
+                        const char *fmt,
+                        ... );
+
+/*!
+ * Dump the debug ring to the console.
+ */
+void debug_dump( void );
+
+/*!
+ * Create an entry for the picoIf log in debugfs.
+ *
+ * @param parent The directory to create the log file in.
+ * @return Returns a dentry pointer to the log file on success, NULL on
+ * failure.
+ */
+struct dentry *
+pc_debug_create_log_file( struct dentry *parent );
+
+/*!
+ * Destroy the debug ring.
+ */
+void
+pc_debug_close( void );
+
+#endif /* __PICOIF_DEBUG_H__ */
diff --git a/drivers/picochip/dma.c b/drivers/picochip/dma.c
new file mode 100644
index 0000000..cf11c1b
--- /dev/null
+++ b/drivers/picochip/dma.c
@@ -0,0 +1,746 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma.c
+ * \brief DMA transport module implementation.
+ *
+ * This file implements Basic DMA transports.
+ *
+ * Two transport methods are provided:
+ *   \li dma1(dl)
+ *   \li dma1(ul)
+ *
+ * The "dl" transport is the main mechanism for loading data into the picoArray
+ * using DMA channels. 
+ * The "ul" transport is for debugging purposesi only, as a transfer from the
+ * picoArray to the host only occurs if the host requests the transfer.
+ * In both methods the DMA engine is used to perform the transfer which calls
+ * the an interrupt handler on exit. This handler will update the FIFO pointers
+ * and wake up any sleeping processes.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/picochip/transports/dma.h>
+#include <linux/picochip/picoif_ioctl.h>
+
+#include "debug.h"
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include "picoif_module.h"
+#include "dma_internal.h"
+#include "dma_fifo_internal.h"
+
+/*!
+ * \brief The basic DMA module.
+ * \extends picoif_module
+ */
+struct dma_module
+{
+    struct picoif_module   mod;            /*!< The generic module. */
+};
+
+/*!
+ * \brief DMA channel parameters (one per DMA channel). 
+ */
+static struct dma_channel
+{
+    struct picoarray        *pa;      /*!< The picoArray running the
+                                       *   transport. */
+    struct picoif_context   *reader;  /*!< The reader of the channel. */
+    unsigned isDownlink;              /*!< Boolean defining DMA direction */      
+    struct pico_resource *chan;       /*!< DMA channel */
+    unsigned channelActive;           /*!< Boolean defining channel status */
+    unsigned xfer_size;               /*!< Size of transfer in bytes */
+    unsigned max_transfer_size;       /*!< Max transfer size in bytes */
+    struct dma_fifo_t *fifo;          /*!< DMA FIFO for this channel */
+    spinlock_t lock;                  /*!< DMA channel lock */
+} 
+dma_channel;
+
+static void
+dma_destructor( struct picoif_module *module );
+
+static struct picoif_context *
+dma_create_trans_instance( struct picoif_module *module,
+                           const char *description,
+                           struct picoif_buf *params );
+
+static void
+dma_close_trans_instance( struct picoif_module *module,
+                          struct picoif_context *ctx );
+
+static ssize_t
+dma_write( struct picoif_module *module,
+           struct picoif_context *ctx,
+           struct picoif_buf *buf,
+           size_t len );
+
+static ssize_t
+dma_read( struct picoif_module *module,
+              struct picoif_context *ctx,
+              struct picoif_buf *buf,
+              size_t len );
+
+static int
+dma_can_write( struct picoif_module *module,
+               struct picoif_context *ctx );
+
+static int
+dma_can_read( struct picoif_module *module,
+              struct picoif_context *ctx );
+
+static ssize_t
+dma_writev( struct picoif_module *module,
+            struct picoif_context *ctx,
+            const struct iovec *vecs,
+            unsigned nr_segs,
+            int from_user );
+
+/*! picoIf module operations for the DMA module. */
+static struct picoif_module_ops dma_ops = {
+    .destructor             = dma_destructor,
+    .create_trans_instance  = dma_create_trans_instance,
+    .close_instance         = dma_close_trans_instance,
+    .write                  = dma_write,
+    .read                   = dma_read,
+    .can_read               = dma_can_read,
+    .can_write              = dma_can_write,
+    .writev                 = dma_writev,
+};
+
+/*! Transport methods for the DMA transport module */
+static const char *dma_tmethods[] = {
+    "dl",
+    "ul",
+};
+
+/*! The DMA transport */
+static struct dma_module dma_mod ={
+    .mod = {
+        .name       = "dma1",
+        .tmethods   = dma_tmethods,
+        .ops        = &dma_ops,
+    },
+};
+
+/*!
+ * Check if the transport can be written to.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return Returns 1 if the transport can be written, 0 otherwise
+ * 0.
+ */
+static int
+dma_can_write( struct picoif_module *module,
+               struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    unsigned fifo_space = dma_fifo_space( channel->fifo );
+    unsigned long flags;
+    int ret = 1;
+
+    spin_lock_irqsave( &channel->lock, flags );
+    if ( !channel->isDownlink && !channel->channelActive )
+    {
+        ret = 1; /* Transfer size requests permitted in the UL */
+        goto out;
+    }
+
+    if ( !fifo_space || channel->channelActive )
+    {
+        ret = 0; /* No space in FIFO or transfer is in progress. */
+        goto out;
+    }
+
+out:
+    spin_unlock_irqrestore( &channel->lock, flags );
+    return ret;
+}
+
+/*!
+ * Check if the transport can be read from.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return Returns 1 if the transport can be read, 0 otherwise.
+ */
+static int
+dma_can_read( struct picoif_module *module,
+              struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    if ( channel->isDownlink )
+        return 0;  /* Cannot read from a downlink */
+
+    return dma_fifo_used( channel->fifo ) ? 1 : 0;
+}
+
+/*!
+ * Handler function for interrupts called by a completed DMA transfer. 
+ *
+ * @param cookie The channel associated with the interrupt source.
+ * @param errno The error number associated with the DMA transfer
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+dma_handler( void *cookie,
+             int errno )
+{
+    struct dma_channel *channel = cookie;
+    struct picoarray *pa = channel->pa;
+    struct scatterlist sgl;
+    int ret = 0;
+    unsigned long flags;
+
+    if ( errno )
+    {
+       PRINTD( COMPONENT_DMA, DBG_ERROR,"DMA transfer generated "
+          "error %d (cookie=0x%p)", errno, cookie );
+       channel->channelActive = 0;
+       return errno;
+    }
+ 
+    spin_lock_irqsave( &channel->lock, flags );
+    channel->channelActive = 0;
+
+    if ( channel->isDownlink )
+    {
+        PRINTD( COMPONENT_DMA, DBG_TRACE,"DL transfer of %d bytes completed",
+            channel->xfer_size );
+
+        /* Update the FIFO ptrs to indicate more data available */
+        dma_fifo_remove_transfer( channel->fifo, channel->xfer_size );
+
+        /* See if there is new data in the FIFO */
+        channel->xfer_size = dma_fifo_used( channel->fifo );
+        if ( channel->xfer_size )
+        {
+            if ( channel->xfer_size > channel->max_transfer_size )
+                channel->xfer_size = channel->max_transfer_size;
+
+            sgl.dma_address = dma_fifo_get_readptr( channel->fifo );
+            sgl.length = channel->xfer_size;
+            channel->channelActive = 1;
+            ret = pa->ops->dma_to_device( pa, channel->chan, &sgl, 
+                channel->xfer_size, dma_handler, channel );
+        } 
+        wake_up_interruptible( &channel->reader->writeq );
+    }
+    else
+    {
+        PRINTD( COMPONENT_DMA, DBG_TRACE,"UL transfer of %d bytes completed",
+            channel->xfer_size );
+
+        /* Add data transferred to FIFO control parameters */
+        dma_fifo_add_transfer( channel->fifo, channel->xfer_size );
+        wake_up_interruptible( &channel->reader->readq );
+    }
+
+    spin_unlock_irqrestore( &channel->lock, flags );
+    return ret;
+}
+
+/*!
+ * Write to the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param buf The data to be written.
+ * @param len The length of data to be written in bytes.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+static ssize_t
+dma_write( struct picoif_module *module,
+           struct picoif_context *ctx,
+           struct picoif_buf *buf,
+           size_t len )
+{
+    struct dma_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+    struct scatterlist sgl;
+    int ret=0;
+    unsigned long flags;
+
+    if ( channel->isDownlink )
+    {
+        if ( len & 0x3 )
+            return -EINVAL;
+        else
+        {
+            ret = dma_fifo_put( channel->fifo, buf, len, 0 );
+            if ( ret < len )
+                ret += dma_fifo_put( channel->fifo, buf, 
+                                      (len-ret), ret );
+
+            if ( !ret )
+                return -EAGAIN;
+        }
+
+        PRINTD( COMPONENT_DMA, DBG_TRACE, "write %u bytes (requested %u bytes)",
+                  ret, len );
+
+        /* Check for space in the FIFO */
+        if ( dma_fifo_space( channel->fifo ) > 0 )
+            wake_up_interruptible( &channel->reader->writeq );
+
+        /* Start a DMA transfer */
+        spin_lock_irqsave( &channel->lock, flags );
+        sgl.length = dma_fifo_used( channel->fifo );
+        if ( sgl.length > channel->max_transfer_size )
+            sgl.length = channel->max_transfer_size;
+
+        if (sgl.length > 0)
+        {
+            if ( !channel->channelActive )
+            {
+                int tmp = 0;
+
+                channel->channelActive = 1;
+                channel->xfer_size = sgl.length;
+                sgl.dma_address = dma_fifo_get_readptr( channel->fifo );
+
+                tmp = pa->ops->dma_to_device( pa, channel->chan, &sgl, 
+                     channel->xfer_size, dma_handler, channel );
+                if ( tmp < 0)
+                    ret = tmp;
+            }
+        }
+        spin_unlock_irqrestore( &channel->lock, flags );
+
+        return ret;
+    }
+    else
+    {
+        uint32_t size = 0;
+    
+        if ( len != sizeof( uint32_t )  )
+            return -EINVAL;
+
+        spin_lock_irqsave( &channel->lock, flags ); 
+        if ( channel->channelActive )
+        {
+            spin_unlock_irqrestore( &channel->lock, flags );
+            return -EAGAIN;
+        }
+ 
+        ret = picoif_buf_copy_from( &size, buf, 0,
+                                      sizeof( uint32_t ) );
+        if ( ret )
+        {
+            spin_unlock_irqrestore( &channel->lock, flags );
+            return ret;
+        }
+
+        /* Start a DMA transfer */
+        sgl.length = dma_fifo_space( channel->fifo ); 
+        if ( size > sgl.length )
+            channel->xfer_size = sgl.length;
+        else
+           channel->xfer_size = size;
+
+        if ( channel->xfer_size > channel->max_transfer_size )
+            channel->xfer_size = channel->max_transfer_size;
+    
+        channel->xfer_size -= dma_fifo_used( channel->fifo );
+        if ( channel->xfer_size ) 
+        {
+            PRINTD( COMPONENT_DMA, DBG_TRACE, "request a transfer of %u bytes)",
+                  channel->xfer_size );
+            sgl.dma_address = dma_fifo_get_writeptr( channel->fifo );
+            ret = ( pa->ops->dma_from_device( pa, channel->chan, &sgl,
+                 channel->xfer_size, dma_handler, channel ));
+            spin_unlock_irqrestore( &channel->lock, flags );
+            if ( !ret )
+                return channel->xfer_size;
+        }
+        return ret;
+     }
+}
+
+/*!
+ * Vectored write to the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param vecs The vectors of data to write into the transport.
+ * @param nr_segs The number of entries in the IO vector.
+ * @param from_user Boolean flag to indicate that the vectors point to
+ * userspace buffers and must be copied across the address spaces.
+ * @return Returns the number of bytes written into the transport on
+ * success, negative on failure.
+ * failure.
+ */
+static ssize_t
+dma_writev( struct picoif_module *module,
+            struct picoif_context *ctx,
+            const struct iovec *vecs,
+            unsigned nr_segs,
+            int from_user )
+{
+    struct dma_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+    struct scatterlist sgl;
+    ssize_t ret=0;
+    unsigned long flags;
+    unsigned seg;
+    ssize_t len = 0;
+
+    PRINTD( COMPONENT_DMA, DBG_TRACE, "received a vector write of %u segments",
+         nr_segs);
+
+    /* Check that the total length of the transfer is a multiple of 4 bytes */
+    for ( seg = 0; seg < nr_segs; ++seg )
+        len += vecs[seg].iov_len;
+
+    if ( len & 0x3 )
+        ret = -EINVAL;
+    else
+    {
+        unsigned bytes_queued = 0;
+
+        spin_lock_irqsave( &channel->lock, flags );
+        for ( seg = 0; seg < nr_segs; ++seg )
+        {
+            struct picoif_buf buf = {
+                .ubuf       = ( char __user * )vecs[ seg ].iov_base,
+                .is_user    = 1,
+            };
+            
+            ret = dma_fifo_put( channel->fifo, &buf, vecs[seg].iov_len, 0 );
+            if ( ret < vecs[seg].iov_len )
+                ret += dma_fifo_put( channel->fifo, &buf, (vecs[seg].iov_len-ret), ret );
+
+            bytes_queued += ret;
+
+            if ( ret < vecs[seg].iov_len )
+                break;
+        }
+        spin_unlock_irqrestore( &channel->lock, flags );
+
+        ret = bytes_queued;
+    }
+
+    if ( !ret )
+        return -EAGAIN;
+
+    PRINTD( COMPONENT_DMA, DBG_TRACE, "vector write %u bytes (requested %u bytes)",
+              ret, len );
+
+    /* Check for space in the FIFO */
+    if ( dma_fifo_space( channel->fifo ) > 0 )
+        wake_up_interruptible( &channel->reader->writeq );
+
+    /* Start a DMA transfer */
+    spin_lock_irqsave( &channel->lock, flags );
+    sgl.length = dma_fifo_used( channel->fifo );
+    if ( sgl.length > channel->max_transfer_size )
+        sgl.length = channel->max_transfer_size;
+
+    if (sgl.length > 0)
+    {
+        if ( !channel->channelActive )
+        {
+            int tmp = 0;
+
+            channel->channelActive = 1;
+            channel->xfer_size = sgl.length;
+            sgl.dma_address = dma_fifo_get_readptr( channel->fifo );
+
+            tmp = pa->ops->dma_to_device( pa, channel->chan, &sgl, 
+                 channel->xfer_size, dma_handler, channel );
+            if ( tmp < 0)
+                ret = tmp;
+        }
+    }
+    spin_unlock_irqrestore( &channel->lock, flags );
+
+    return ret;
+}
+
+/*!
+ * Read from the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the read.
+ * @param buf The buffer to write the data into.
+ * @param len The number of bytes requested to read.
+ * @return Returns the number of bytes read on success, negative on failure.
+ */
+static ssize_t
+dma_read( struct picoif_module *module,
+          struct picoif_context *ctx,
+          struct picoif_buf *buf,
+          size_t len )
+{
+    struct dma_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+    struct scatterlist sgl;
+    int ret = 0;
+    unsigned used_bytes=0;
+    unsigned long flags;
+
+    /* Check that the length is invalid */
+    if ( len & 0x3 )
+        return -EINVAL;
+
+    /* Determine how much data is already in the FIFO */
+    used_bytes = dma_fifo_used( channel->fifo );
+
+    spin_lock_irqsave( &channel->lock, flags );
+    if ( used_bytes < len && ( !channel->channelActive) )
+    {
+        /* Not enough data in the FIFO - request a transfer */
+        sgl.dma_address = dma_fifo_get_writeptr( channel->fifo );
+        sgl.length = dma_fifo_space( channel->fifo ); /* Report the size of
+                the buffer available from the write pointer */
+        channel->channelActive = 1;
+        channel->xfer_size = len - used_bytes;
+
+        if ( channel->xfer_size > channel->max_transfer_size )
+            channel->xfer_size = channel->max_transfer_size;
+
+        ret = pa->ops->dma_from_device( pa, channel->chan,
+            &sgl, channel->xfer_size, dma_handler, channel );
+    }
+    spin_unlock_irqrestore( &channel->lock, flags );
+
+    /* Now return any bytes available */
+    if ( !used_bytes )
+        return -EAGAIN;
+     
+    if ( used_bytes > len )
+        used_bytes = len;
+ 
+    ret = dma_fifo_get( channel->fifo, buf, used_bytes, 0 );
+   
+    PRINTD( COMPONENT_DMA, DBG_TRACE,
+            "read %u bytes (requested %u bytes)", used_bytes, len );
+
+    if ( ret )
+        return ret;
+    else
+        return used_bytes;
+}
+
+/*!
+ * Destructor for the DMA module.
+ *
+ * @param module The module being destroyed.
+ */
+static void
+dma_destructor( struct picoif_module *module )
+{
+}
+
+/*!
+ * Create a and start the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param description The type of transport to create.
+ * @param params Extra parameters for the transport type.
+ * @return Returns the transport context on success, or an ERR_PTR on failure.
+ */
+static struct picoif_context *
+dma_create_trans_instance( struct picoif_module *module,
+                           const char *description,
+                           struct picoif_buf *params )
+{
+    int ret = -ENOMEM;
+    void *private_data = NULL;
+    struct picoif_context *ctx = picoif_new_ctx( module, private_data );
+    struct picoif_dma_params gparams;
+    struct picoarray *pa = NULL;
+    struct dma_channel *channel;
+    struct pico_resource *chan = NULL;
+
+    ret = picoif_buf_copy_from( &gparams, params, 0,
+                                sizeof( gparams ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    pa = picoif_get_device( gparams.dev_num );
+    if ( !pa )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "invalid device number: %u",
+                gparams.dev_num );
+        goto out;
+    }
+
+    /* Check that the DMA channel is not already in use */
+    ret = -EBUSY;
+    chan = pa->ops->get_resource( pa, PICO_RES_DMA_CHANNEL,
+                                             gparams.channel, 1 );
+    if ( !chan )
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR, "invalid DMA channel:%u",
+                gparams.channel );
+        goto out;
+    }
+
+   if ( !ctx )
+       goto out;
+
+    /* Allocate the new channel and initialise the data members. */
+    ret = -ENOMEM;
+    channel = kmalloc( sizeof( dma_channel ), GFP_KERNEL );
+    if (!channel)
+        goto out;
+    ctx->private_data = channel;
+ 
+    ret = dma_fifo_create( &channel->fifo, gparams.buf_size );
+    if (ret)
+        goto bad_fifo_alloc;
+
+    spin_lock_init( &channel->lock );
+
+    channel->reader = ctx;
+    channel->channelActive = 0;
+    channel->pa = pa;
+    channel->chan = chan;
+    channel->max_transfer_size = pa->max_dma_sz;
+
+    if ( !strcmp( description, "dma1(dl)" ) )
+        channel->isDownlink = 1;
+    else if ( !strcmp( description, "dma1(ul)" ) )
+        channel->isDownlink = 0;
+    else
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR, "invalid tmethod \"%s\"",
+                description );
+        ret = -EINVAL;
+        goto bad_description;
+    }
+
+    ret = pa->ops->dma_open( pa, chan, channel->isDownlink );
+    if ( ret ) 
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR, "failed to open DMA channel" );
+        goto bad_description;
+    }
+ 
+    ret = 0; 
+    goto out;
+
+bad_description:
+   dma_fifo_destroy( channel->fifo );
+
+bad_fifo_alloc:
+    kfree( channel );
+
+out:
+    if ( ret )
+    {
+        kfree( ctx );
+        if ( chan )
+            pa->ops->put_resource(  pa, chan );
+    }
+
+    return ret ? ERR_PTR( ret ) : ctx;
+}
+
+/*!
+ * Close an existing transport instance.
+ *
+ * @param mod The module handling the transport.
+ * @param ctx The context that is being closed.
+ */
+static void
+dma_close_trans_instance( struct picoif_module *mod,
+                          struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+    (void)pa->ops->dma_close( pa, channel->chan );
+
+    pa->ops->put_resource( pa, channel->chan );
+    dma_fifo_destroy( channel->fifo );
+
+    if ( channel )
+    {
+        kfree( channel );
+        channel = NULL;
+    }
+
+    if ( ctx )
+    {
+        kfree( ctx );
+        ctx = NULL;
+    }
+}
+
+/* Kernel API and Public functions */
+struct picoif_context *
+picoif_dma_open_dl( unsigned dev_num,
+                    int dma_chan,
+                    size_t buf_size )
+{
+    struct picoif_dma_params dma_params = {
+        .dev_num    = dev_num,
+        .channel    = dma_chan,
+        .buf_size   = buf_size,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &dma_params,
+        .is_user    = 0,
+    };
+
+    struct picoif_context *ctx =
+        dma_create_trans_instance( &dma_mod.mod,
+                                       "dma1(dl)", &buf );
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_dma_open_dl );
+
+struct picoif_context *
+picoif_dma_open_ul( unsigned dev_num,
+                    int dma_chan,
+                    size_t buf_size )
+{
+    struct picoif_dma_params dma_params = {
+        .dev_num    = dev_num,
+        .channel    = dma_chan,
+        .buf_size   = buf_size,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &dma_params,
+        .is_user    = 0,
+    };
+    struct picoif_context *ctx =
+        dma_create_trans_instance( &dma_mod.mod,
+                                       "dma1(ul)", &buf );
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_dma_open_ul );
+
+int
+dma_init( void )
+{
+    return picoif_register_module( &dma_mod.mod );
+}
+
+
diff --git a/drivers/picochip/dma_fifo.c b/drivers/picochip/dma_fifo.c
new file mode 100644
index 0000000..e567a66
--- /dev/null
+++ b/drivers/picochip/dma_fifo.c
@@ -0,0 +1,317 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma_fifo.c
+ * \brief Main file for the common DMA FIFO functions
+ *
+ * This file implements the DMA FIFO managing for all transports concerned with
+ * the picoArray.
+ */
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+
+#include "picoif_module.h"
+#include "dma_fifo_internal.h"
+
+/*! The maximum number of bytes that can be copied to user in a single transfer */
+#define DMA_MAX_TRANSFER_SIZE ( 4096 )
+
+/*!
+ * \brief DMA FIFO parameters (one per DMA channel).
+ */
+struct dma_fifo_t
+{
+    dma_addr_t physaddr;          /*!< Physical base address of FIFO */
+    unsigned char *buf;           /*!< Virtual base address  of FIFO */
+    unsigned bufsize;             /*!< FIFO size in bytes */
+    unsigned inptr;               /*!< FIFO input offset */
+    unsigned outptr;              /*!< FIFO output offset */
+    unsigned used;                /*!< FIFO bytes in use */
+    spinlock_t lock;              /*!< FIFO access control */
+};
+
+__must_check int
+dma_fifo_create( struct dma_fifo_t **fifo,
+                 size_t size )
+{
+    *fifo  = kmalloc( sizeof( struct dma_fifo_t ), GFP_KERNEL );
+    if ( !(*fifo) )
+        return -ENOMEM;
+ 
+    (*fifo)->buf = dma_alloc_coherent( NULL, size, 
+            &((*fifo)->physaddr), GFP_KERNEL );
+
+    if ( (*fifo)->buf == NULL )
+    {
+        kfree( *fifo );
+        return -ENOMEM;
+    }
+ 
+    (*fifo)->bufsize = size;
+    (*fifo)->inptr = 0;
+    (*fifo)->outptr = 0;
+    (*fifo)->used=0;
+    
+    spin_lock_init( &((*fifo)->lock) );
+
+    return 0;
+}
+
+void
+dma_fifo_destroy( struct dma_fifo_t *fifo )
+{
+    if ( fifo->buf != NULL )
+        dma_free_coherent( NULL, fifo->bufsize, fifo->buf,
+               fifo->physaddr );
+
+   if ( fifo )
+       kfree ( fifo );
+}
+
+__must_check dma_addr_t
+dma_fifo_get_readptr( struct dma_fifo_t *fifo )
+{
+    unsigned long flags;
+    dma_addr_t sg_dma_address;
+
+    spin_lock_irqsave( &fifo->lock, flags );
+    sg_dma_address = fifo->physaddr +fifo->outptr;
+    spin_unlock_irqrestore( &fifo->lock, flags );
+    return sg_dma_address;
+}
+
+__must_check dma_addr_t
+dma_fifo_get_writeptr( struct dma_fifo_t *fifo )
+{
+    unsigned long flags;
+    dma_addr_t sg_dma_address;
+
+    spin_lock_irqsave( &fifo->lock, flags );
+    sg_dma_address = fifo->physaddr +fifo->inptr;
+    spin_unlock_irqrestore( &fifo->lock, flags );
+    return sg_dma_address;
+}
+
+__must_check unsigned
+dma_fifo_used( struct dma_fifo_t *fifo )
+{
+    unsigned long flags;
+    unsigned available=0;
+
+    spin_lock_irqsave( &fifo->lock, flags );
+
+    /* Determine how many bytes are available in the FIFO for retrieval */
+    if ( fifo->inptr == fifo->outptr )
+    {
+        if ( fifo->used == 0 )
+            available = 0; /* Nothing to receive */
+        else
+            available = fifo->bufsize - fifo->outptr;
+    }
+    else if ( fifo->inptr > fifo->outptr )
+    {
+        /* Write pointer has not wrapped */
+        available = fifo->inptr -fifo->outptr;
+    }
+    else
+    {
+        /* Write pointer has wrapped */
+        available = fifo->bufsize -fifo->outptr;
+    }
+
+    spin_unlock_irqrestore( &fifo->lock, flags );
+
+    return available;
+}
+
+__must_check int
+dma_fifo_space( struct dma_fifo_t *fifo )
+{
+    int available;
+    unsigned long flags;
+
+    spin_lock_irqsave( &fifo->lock, flags );
+
+    if ( fifo->inptr == fifo->outptr )
+    {
+        if ( fifo->used == 0 )
+            available = fifo->bufsize - fifo->inptr;
+        else
+            available = 0;
+    }
+    else if ( fifo->inptr > fifo->outptr )
+        available = fifo->bufsize - fifo->inptr;
+    else
+        available = fifo->outptr - fifo->inptr;
+
+    spin_unlock_irqrestore( &fifo->lock, flags );
+
+    return available;
+}
+
+__must_check unsigned
+dma_fifo_get( struct dma_fifo_t *fifo,
+              struct picoif_buf *buf,
+              size_t size,
+              unsigned offset)
+{
+    unsigned ret=0;
+    unsigned long flags;
+    unsigned available=0;
+
+    spin_lock_irqsave( &fifo->lock, flags );
+
+    /* Determine how many bytes are available in the FIFO for retrieval */
+    if ( fifo->inptr == fifo->outptr )
+    {
+        if ( fifo->used == 0 )
+            available = 0; /* Nothing to receive */
+        else
+            available = fifo->bufsize - fifo->outptr;
+    }
+    else if ( fifo->inptr > fifo->outptr )
+    {
+        /* Write pointer has not wrapped */
+        available = fifo->inptr -fifo->outptr;
+    }
+    else
+    {
+        /* Write pointer has wrapped */
+        available = fifo->bufsize -fifo->outptr;
+    }
+
+    if ( size > available )
+        ret = available;
+    else
+        ret = size;
+
+    spin_unlock_irqrestore( &fifo->lock, flags );
+
+    /* Copy data to userspace */
+    if ( ret > 0 )
+    {
+        unsigned bytes_so_far=0;
+        unsigned transferSize=0;
+        unsigned i;
+
+        for(i = 0; i < ((ret -1)/DMA_MAX_TRANSFER_SIZE)+1; i++)
+        { 
+            transferSize = ret-bytes_so_far;
+            if ( transferSize >= DMA_MAX_TRANSFER_SIZE )
+                transferSize = DMA_MAX_TRANSFER_SIZE;
+
+            if (picoif_buf_copy_to( buf, 
+                   (fifo->buf +fifo->outptr +bytes_so_far), 
+                   offset, transferSize) < 0 )
+                break;
+            bytes_so_far += transferSize;
+            offset += transferSize;
+        }
+
+        ret = bytes_so_far;
+    }
+
+    spin_lock_irqsave( &fifo->lock, flags );
+    fifo->outptr += ret;
+    fifo->outptr %= fifo->bufsize;
+    fifo->used -= ret;
+    spin_unlock_irqrestore( &fifo->lock, flags );
+
+    return ret;
+}
+
+__must_check unsigned
+dma_fifo_put( struct dma_fifo_t *fifo,
+              struct picoif_buf *buf,
+              size_t size,
+              unsigned offset )
+{
+    unsigned ret=0;
+    unsigned available=0;
+    unsigned long flags;
+    unsigned char *dest=NULL;
+
+    spin_lock_irqsave( &fifo->lock, flags );
+
+    /* Determine the number of free bytes */
+    if ( fifo->inptr == fifo->outptr )
+    {
+        if (fifo->used == 0)
+            available = fifo->bufsize -fifo->inptr;
+        else
+            available = 0;
+    }
+    else if (fifo->inptr > fifo->outptr)
+        available = fifo->bufsize - fifo->inptr;
+    else
+        available = fifo->outptr -fifo->inptr;
+
+    if ( size > available )
+        ret = available;
+    else
+        ret = size;
+
+    if ( ret == 0 )
+    {
+        spin_unlock_irqrestore( &fifo->lock, flags );
+        return ret;
+    }
+
+    dest = fifo->buf + fifo->inptr;
+    spin_unlock_irqrestore( &fifo->lock, flags );
+
+    if ( ret > 0 )
+        picoif_buf_copy_from( dest, buf, offset, ret );
+
+    spin_lock_irqsave( &fifo->lock, flags );
+    fifo->inptr += ret;
+    fifo->inptr %= fifo->bufsize;
+    fifo->used += ret;
+
+    spin_unlock_irqrestore( &fifo->lock, flags );
+
+    return ret;
+}
+
+void
+dma_fifo_add_transfer( struct dma_fifo_t *fifo,
+                       size_t size )
+{
+    unsigned long flags;
+
+    spin_lock_irqsave( &fifo->lock, flags );
+    fifo->used += size;
+    fifo->inptr += size;
+    fifo->inptr %= fifo->bufsize;
+    spin_unlock_irqrestore( &fifo->lock, flags );
+}
+
+void
+dma_fifo_remove_transfer( struct dma_fifo_t *fifo,
+                          size_t size )
+{
+    unsigned long flags;
+
+    spin_lock_irqsave( &fifo->lock, flags );
+    fifo->used -= size;
+    fifo->outptr += size;
+    fifo->outptr %= fifo->bufsize;
+    spin_unlock_irqrestore( &fifo->lock, flags );
+}
+
diff --git a/drivers/picochip/dma_fifo_internal.h b/drivers/picochip/dma_fifo_internal.h
new file mode 100644
index 0000000..4bb78a6
--- /dev/null
+++ b/drivers/picochip/dma_fifo_internal.h
@@ -0,0 +1,140 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma_fifo_internal.h
+ * \brief Common DMA FIFO managing functions
+ *
+ * This file contains common functions for managing the DMA FIFOs.
+ */
+
+#ifndef __PICOIF_DMA_FIFO_INTERNAL__
+#define __PICOIF_DMA_FIFO_INTERNAL__
+
+struct dma_fifo_t;
+
+/*!
+ * Create and initialise the DMA FIFO.
+ *
+ * @param fifo The FIFO structure to initialise
+ * @param size The  size (in bytes) of the FIFO to allocate
+ * @return Returns 0 on success, or ENOMEM if the allocation fails
+ */
+int
+dma_fifo_create( struct dma_fifo_t **fifo,
+                 size_t size );
+
+/*!
+ * Free the DMA FIFO.
+ *
+ * @param fifo The FIFO structure to destroy
+ */
+void
+dma_fifo_destroy( struct dma_fifo_t *fifo );
+
+/*!
+ * Determine the start address of the FIFO read pointer
+ * 
+ * @param fifo The FIFO structure
+ * @return The physical address of the first byte to read
+*/ 
+dma_addr_t
+dma_fifo_get_readptr( struct dma_fifo_t *fifo );
+
+/*!
+ * Determine the start address of the write pointer
+ *
+ * @param fifo The FIFO structure
+ * @return The physical address of the first byte to write
+*/
+dma_addr_t
+dma_fifo_get_writeptr( struct dma_fifo_t *fifo );
+
+/*!
+ * Determine the number of bytes for reading in the DMA FIFO without taking
+ * wrapping into account.
+ *
+ * @param fifo The FIFO structure
+ * @return The number filled bytes to the end of the buffer or the write
+ *         pointer which ever occurs first
+ */
+unsigned
+dma_fifo_used( struct dma_fifo_t *fifo );
+
+/*!
+ * Determine how many bytes are free for writing in the FIFO
+ *
+ * @param fifo The FIFO structure
+ * @return The number free bytes to the end of the buffer or the read
+ *         pointer which ever occurs first
+ */
+int
+dma_fifo_space( struct dma_fifo_t *fifo );
+
+/*
+ * Read up to the specified number of bytes from the FIFO
+ *
+ * @param fifo The FIFO structure
+ * @param buf The buffer to write the data into
+ * @param size The number of bytes to write
+ * @param offset The offset to apply to the buf
+ * @return 0 on success, negative if the buffer copy fails
+ */
+unsigned
+dma_fifo_get( struct dma_fifo_t *fifo,
+              struct picoif_buf *buf,
+              size_t size,
+              unsigned offset );
+
+/*!
+ * Put the specified number of bytes into the FIFO
+ *
+ * @param fifo The FIFO structure
+ * @param buf The buffer to write the data into
+ * @param size The number of bytes to write
+ * @param offset The offset to apply to the buf
+ * @return 0 on success, negative if the buffer copy fails
+ *
+ */
+unsigned
+dma_fifo_put( struct dma_fifo_t *fifo,
+              struct picoif_buf *buf,
+              size_t size,
+              unsigned offset );
+
+/*!
+ * Add the specified number of bytes into the FIFO transfered by the DMA
+ * engine
+ *
+ * @param fifo The FIFO structure
+ * @param size The number of bytes to add
+ *
+ */
+void
+dma_fifo_add_transfer( struct dma_fifo_t *fifo,
+                       size_t size );
+
+/*!
+ * Remove the specified number of bytes from the FIFO transfered by the DMA
+ * engine
+ *
+ * @param fifo The FIFO structure
+ * @param size The number of bytes to remove
+ *
+ */
+void
+dma_fifo_remove_transfer( struct dma_fifo_t *fifo,
+                          size_t size );
+
+#endif /* !__PICOIF_DMA_FIFO_INTERNAL__ */
diff --git a/drivers/picochip/dma_internal.h b/drivers/picochip/dma_internal.h
new file mode 100644
index 0000000..1ec0bae
--- /dev/null
+++ b/drivers/picochip/dma_internal.h
@@ -0,0 +1,34 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma_internal.h
+ * \brief Initialisation function for DMA transport.
+ *
+ * Internal DMA transport function definitions
+ *
+ */
+
+#ifndef __PICOIF_DMA_INTERNAL_H__
+#define __PICOIF_DMA_INTERNAL_H__
+
+/*!
+ * Initialise the DMA transport.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+dma_init( void );
+
+#endif /* !__PICOIF_DMA_INTERNAL_H__ */
diff --git a/drivers/picochip/fpga_cpe20x_main.c b/drivers/picochip/fpga_cpe20x_main.c
new file mode 100644
index 0000000..4c85150
--- /dev/null
+++ b/drivers/picochip/fpga_cpe20x_main.c
@@ -0,0 +1,743 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file fpga_cpe20x_main.c
+ * \brief SPI connected FPGA device driver
+ *
+ * CPLD access functions
+ *
+ */
+
+/*****************************************************************************
+ * Includes
+ *****************************************************************************/
+
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/picochip/fpga_cpe20x.h>
+#include <mach/reset.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <asm/mach-types.h>
+
+#include "cpld_cpe20x.h"
+
+/*****************************************************************************
+ * Magic numbers
+ *****************************************************************************/
+
+/* definition of success */
+#define SUCCESS     (0)
+
+/* name by which the module is known */
+#define MODNAME     "fpga_cpe20x"
+
+/* our major number for the device node */
+#define FPGA_MAJOR   (248)
+
+/* our minor number for the device node */
+#define FPGA_MINOR   (0)
+
+/* device name by which we are known under /proc/devices, /sys, etc */
+#define FPGA_DEVNAME "cpld"
+
+/* SPI bits_per_word */
+#define FPGA_SPI_ACCESS_WIDTH 16
+
+/* define ENABLE_TEST to enable testing of FPGA access by writing and
+ * reading back the contents of the test register during probe.
+ */
+#define ENABLE_TEST
+
+/*****************************************************************************
+ * Macros
+ *****************************************************************************/
+
+/*
+ * Debugging macros.
+ */
+
+#define PRINTD(lvl, format, ...)  \
+    do \
+    { \
+        if(debug>=lvl) \
+        { \
+            printk(KERN_INFO PREFIX format, ##__VA_ARGS__);\
+        }\
+    } while(0)
+
+#define PRINTE(format, ...) \
+    printk(KERN_ERR __FILE__ ":%d:" format, __LINE__, ##__VA_ARGS__)
+
+/*****************************************************************************
+ * Data structure & types
+ *****************************************************************************/
+
+/* A parameter to switch in the test code */
+static int regtest = 0;
+module_param(regtest, int, S_IRUGO);
+MODULE_PARM_DESC(regtest,
+    "Set to '1' or '0' to 'enable' or 'disable' the fpga register test");
+
+/* Driver state data */
+struct fpga
+{
+    struct spi_device   *spi;
+    struct fpga_platform_data *pdata;
+};
+
+/* private device structure for each open device instance */
+typedef struct cpld_dev
+{
+    int minor;
+}
+cpld_dev_t;
+
+/*****************************************************************************
+ * Private function prototypes
+ *****************************************************************************/
+
+/* file operations */
+static int
+fpga_fops_open(struct inode *inode,
+               struct file *filp);
+
+static int
+fpga_fops_release(struct inode *inode,
+                  struct file *filp);
+
+static ssize_t
+fpga_fops_read(struct file *filp,
+               char __user *buf,
+               size_t bufsize,
+               loff_t *offset);
+
+static ssize_t
+fpga_fops_write(struct file *filp,
+                const char __user *buf,
+                size_t bufsize,
+                loff_t *offset);
+
+static int
+fpga_fops_ioctl(struct inode *inode,
+                struct file *filp,
+                unsigned int cmd,
+                unsigned long arg);
+
+/*****************************************************************************
+ * Global variables & module parameters
+ *****************************************************************************/
+
+static struct file_operations fpga_fops =
+{
+    .owner      = THIS_MODULE,
+    .open       = fpga_fops_open,
+    .release    = fpga_fops_release,
+    .read       = fpga_fops_read,
+    .write      = fpga_fops_write,
+    .ioctl      = fpga_fops_ioctl,
+};
+
+static struct miscdevice miscdev =
+{
+    .minor  = MISC_DYNAMIC_MINOR,
+    .name   = "fpga",
+    .fops   = &fpga_fops,
+};
+
+/*****************************************************************************
+ * Private function declarations
+ *****************************************************************************/
+
+/* find_fpga is used with bus_for_each_dev to find the SPI connected device
+ * that has a particular FPGA ID.
+ */
+static int
+find_fpga(struct device *device,
+          void *data)
+{
+    struct fpga *fpga;
+
+    struct spi_device *sdev = to_spi_device(device);
+
+    unsigned int fpga_device_id = *(unsigned int *)data;
+
+    if (!strcmp(sdev->modalias, MODNAME))
+    {
+        fpga = dev_get_drvdata(&sdev->dev);
+
+        if (fpga->pdata->fpga_device_id == fpga_device_id)
+        {
+            return (int)fpga;
+        }
+    }
+    return 0;
+}
+
+/* Return a handle to the FPGA device that has the device ID, or null
+ * if not found. The handle returned should be used with the read and
+ * write functions.
+ */
+void
+*fpga_get_handle(unsigned int fpga_device_id)
+{
+    return (struct fpga *)bus_for_each_dev(
+                &spi_bus_type, NULL, &fpga_device_id, find_fpga);
+}
+
+
+/* Read one of the FPGA registers by assembling an SPI transfer sequence
+ * that does the read.
+ *
+ * From spi_sync, used to do the SPI transfer:
+ *
+ * This call may only be used from a context that may sleep.  The sleep
+ * is non-interruptible, and has no timeout.
+ */
+static u16 read_reg(struct spi_device *spi, unsigned int reg_addr)
+{
+    struct spi_message msg;
+    struct spi_transfer xaddr, xdata;
+    u16 addr_cmd, reg;
+    int err;
+
+    /* Reset local structures */
+    memset(&xaddr, 0, sizeof(struct spi_transfer));
+    memset(&xdata, 0, sizeof(struct spi_transfer));
+
+    /* Setup a transfer to read the device ID from the FPGA and check it
+     * against out platform data.
+     */
+    spi_message_init(&msg);
+
+    /* Transmit the register address and command */
+    addr_cmd =
+        ((reg_addr << FPGA_SPI_ADDR_SHIFT) & FPGA_SPI_ADDR_MASK) |
+        FPGA_SPI_CMD_R_NW;
+    xaddr.tx_buf = &addr_cmd;
+    xaddr.len = 2;     /* Two bytes */
+
+    /* Set the next transfer to receive the register contents */
+    xdata.rx_buf = &reg;
+    xdata.len = 2;     /* Two bytes */
+
+    spi_message_add_tail(&xaddr, &msg);
+    spi_message_add_tail(&xdata, &msg);
+
+    /* Do the register read. Will wait for completion */
+    err = spi_sync(spi, &msg);
+    if (err != 0)
+    {
+        printk(KERN_DEBUG "FPGA read failed\n");
+        return 0;
+    }
+
+    return reg;
+}
+
+/* Write one of the FPGA registers by assembling an SPI transfer sequence
+ * that does the write.
+ *
+ * From spi_sync, used to do the SPI transfer:
+ *
+ * This call may only be used from a context that may sleep.  The sleep
+ * is non-interruptible, and has no timeout.
+ */
+static void
+ write_reg(struct spi_device *spi,
+           unsigned int reg_addr, u16 value)
+{
+    struct spi_message msg;
+    struct spi_transfer xaddr, xdata;
+    u16 addr_cmd;
+    int err;
+
+    /* Reset local structures */
+    memset(&xaddr, 0, sizeof(struct spi_transfer));
+    memset(&xdata, 0, sizeof(struct spi_transfer));
+
+    /* Setup a transfer to read the device ID from the FPGA and check it
+     * against out platform data.
+     */
+    spi_message_init(&msg);
+
+    /* Transmit the register address and command */
+    addr_cmd = (reg_addr << FPGA_SPI_ADDR_SHIFT) & FPGA_SPI_ADDR_MASK;
+    xaddr.tx_buf = &addr_cmd;
+    xaddr.len = 2;     /* Two bytes */
+
+    /* Set the next transfer to transmit the register contents */
+    xdata.tx_buf = &value;
+    xdata.len = 2;     /* Two bytes */
+
+    spi_message_add_tail(&xaddr, &msg);
+    spi_message_add_tail(&xdata, &msg);
+
+    /* Do the register write. Will wait for completion */
+    err = spi_sync(spi, &msg);
+    if (err != 0)
+    {
+        printk(KERN_DEBUG "FPGA write failed\n");
+    }
+}
+
+#ifdef ENABLE_TEST
+/* Test functionality that reads all the registers and prints them out. Also
+ * writes the test register and checks that it reads the same value back.
+ */
+static void
+test_fpga(struct spi_device *spi,
+          u16 id_reg)
+{
+    int i;
+    char opstr[100];
+    char *p;
+    u16 reg;
+
+    /* read/write the test register */
+    for (i = 0; i < 16; ++i)
+    {
+        write_reg(spi, FPGA_TEST_REG, (1 << i));
+        reg = read_reg(spi, FPGA_TEST_REG);
+        if ((1 << i) != reg)
+        {
+            printk("FPGA ID 0x%04x read/write test failed, wrote 0x%04x, "
+                   "read 0x%04x. Aborting test.\n", id_reg, (1 << i), reg);
+            return;
+        }
+    }
+
+    memset(opstr, 0, 100);
+
+    /* Read registers 0 to 80 */
+    printk("FPGA ID 0x%04x Registers:\n", id_reg);
+    for (i = 0; i <= 80; ++i)
+    {
+        if (i % 8 == 0)
+        {
+            if (i > 0)
+            {
+                printk("%s\n", opstr);
+                memset(opstr, 0, 100);
+            }
+            p = opstr;
+            p += sprintf(p, "0x%02x:", i);
+        }
+
+        reg = read_reg(spi, i);
+        p += sprintf(p, " 0x%04x", reg);
+    }
+}
+#endif
+
+/* API function to read an FPGA register using above function */
+u16 fpga_read_reg(void *handle, unsigned int reg_addr)
+{
+    struct fpga *fpga = (struct fpga *)handle;
+
+    return read_reg(fpga->spi, reg_addr);
+}
+
+/* API function to write an FPGA register using above function */
+void
+fpga_write_reg(void *handle,
+               unsigned int reg_addr,
+               u16 value)
+{
+    struct fpga *fpga = (struct fpga *)handle;
+
+    write_reg(fpga->spi, reg_addr, value);
+}
+
+/* A function that we pass to the kernel so that it can do a hard reset */
+static void
+fpga_board_reset(char mode, void *cookie)
+{
+    struct fpga *fpga = (struct fpga *)cookie;
+    unsigned i;
+
+    /* RESET the board!! */
+    for ( i = 0; i < 10; ++i )
+    {
+        if (machine_is_pc72052_i10_revb())
+        {
+            write_reg(fpga->spi, FPGA_PICOARRAY_RESET_REG, 0);
+        }
+        else if (machine_is_pc7802())
+        {
+            write_reg(fpga->spi, FPGA_PICOARRAY_RESET_REG, 1);
+        }
+        else
+        {
+            /* Do Nothing */
+        }
+    }
+
+    /* We shouldn't get here. If we do then the FPGA has failed to reset the
+     * board. There is nothing we can do so lets make the failure known to the
+     * wider world. */
+    printk( KERN_EMERG "fpga reset failed after 10 attempts\n" );
+    BUG();
+}
+
+/* Probe function for the FPGA driver. This checks the device ID in the
+ * FPGA device with the platform data and succeeds the probe if there
+ * is a match. If no FPGA device is present, the SPI driver will read zero
+ * for all registers and the device ID match will fail (providing we do
+ * not use device ID zero!).
+ */
+static int
+fpga_probe(struct spi_device *spi)
+{
+    struct fpga_platform_data *pdata = spi->dev.platform_data;
+    struct fpga *fpga;
+    u16 id_reg;
+    int err = 0;
+
+    /* Set the SPI access width for our device */
+    spi->bits_per_word = FPGA_SPI_ACCESS_WIDTH;
+
+    /* Set the SPI mode */
+    spi->mode = SPI_MODE_2;
+
+    /* Set the SPI mode for this device */
+    spi_setup(spi);
+
+    /* Read the FPGA Device ID register */
+    id_reg = read_reg(spi, FPGA_TYPE_ID_REG);
+
+    /* Test the FPGA register access */
+#ifdef ENABLE_TEST
+    if (regtest)
+    {
+        test_fpga(spi, id_reg);
+    }
+#endif
+
+    /* check the device id */
+    if (pdata->fpga_device_id !=
+            (id_reg & FPGA_DEVICE_ID_MASK) >> FPGA_DEVICE_ID_SHIFT)
+    {
+        /* Mismatch. Fail probe */
+        err = -ENODEV;
+        /* Indicate to the driver not finding the device */
+        pdata->fpga_device_id = ~(pdata->fpga_device_id);
+    }
+
+    /* Allocate our local context */
+    fpga = kzalloc(sizeof(struct fpga), GFP_KERNEL);
+    if (!fpga)
+    {
+        err = -ENOMEM;
+        goto err_exit;
+    }
+
+    /* Set the device state context */
+    fpga->spi = spi;
+    fpga->pdata = pdata;
+
+    /* Associate our local context with the device */
+    dev_set_drvdata(&spi->dev, fpga);
+
+    if (err == 0)
+    {
+        printk("Found " MODNAME " device id %u\n", pdata->fpga_device_id);
+
+        /* Register a reset handler. The FPGA is able to reset the board
+        * and we need to tell the kernel.
+        */
+        register_reset_handler(fpga_board_reset, fpga);
+
+        return 0;
+    }
+
+ err_exit:
+    return err;
+}
+
+/* Remove the FPGA device */
+static int
+fpga_remove(struct spi_device *spi)
+{
+    struct fpga *fpga = dev_get_drvdata(&spi->dev);
+
+    /* De-register the reset handler */
+    deregister_reset_handler(fpga_board_reset, fpga);
+
+    /* Free out context */
+    kfree(fpga);
+
+    printk("Unregistered " MODNAME " device\n");
+    return 0;
+}
+
+/* Driver declaration structure for this FPGA driver */
+static struct spi_driver fpga_driver =
+{
+    .driver =
+    {
+        .name   = MODNAME,
+        .bus    = &spi_bus_type,
+        .owner  = THIS_MODULE,
+    },
+    .probe      = fpga_probe,
+    .remove     = fpga_remove,
+};
+
+/* Module initialisation, declare the FPGA driver */
+static int
+__init fpga_module_init(void)
+{
+    int returnCode;
+
+    if (misc_register(&miscdev))
+        return -EFAULT;
+
+    /* Register the driver in spi land */
+    returnCode = spi_register_driver(&fpga_driver);
+
+    printk(KERN_INFO "%s: fpga device driver " __DATE__ " "
+          __TIME__ "\n", MODNAME);
+
+    return returnCode;
+}
+
+/* Module exit, remove the FPGA driver */
+static void
+__exit fpga_module_exit(void)
+{
+    misc_deregister(&miscdev);
+
+    spi_unregister_driver(&fpga_driver);
+
+    printk(KERN_INFO "%s: fpga device device driver module removed\n", MODNAME);
+}
+
+/*****************************************************************************
+ * Character device file operations (fops) functions.
+ *****************************************************************************/
+
+static int
+fpga_fops_open(struct inode *inode,
+               struct file *filp)
+{
+    int ret = SUCCESS;
+
+    cpld_dev_t *dev;
+
+    dev = (cpld_dev_t *)kzalloc(sizeof(cpld_dev_t), GFP_KERNEL);
+    if (!dev)
+    {
+        ret = (-ENOMEM);
+    }
+    else
+    {
+        dev->minor = iminor(inode);
+        filp->private_data = dev;
+    }
+
+    return ret;
+}
+
+static int
+fpga_fops_release(struct inode *inode,
+                  struct file *filp)
+{
+    int ret = SUCCESS;
+
+    cpld_dev_t *dev = filp->private_data;
+
+    kfree(dev);
+
+    return ret;
+}
+
+/*
+ * fops read method - currently unimplemented
+ */
+static ssize_t
+fpga_fops_read(struct file *filp,
+               char __user *buf,
+               size_t bufsize,
+               loff_t *offset)
+{
+    int ret = SUCCESS;
+    return ret;
+}
+
+/*
+ * fops write method - currently unimplemented
+ */
+static ssize_t
+fpga_fops_write(struct file *filp,
+                const char __user *buf,
+                size_t bufsize,
+                loff_t *offset)
+{
+    int ret = SUCCESS;
+
+    return ret;
+}
+
+/*
+ * Currently, ioctl() is the only method we support.
+ */
+static int
+fpga_fops_ioctl(struct inode *inode,
+                struct file *filp,
+                unsigned int cmd,
+                unsigned long arg)
+{
+    int ret = SUCCESS;
+    struct fpga *fpgaHandle;
+
+    cpld_reg_param_t params;
+
+    /* Check that the requested command is in range */
+    if (_IOC_TYPE(cmd) != PICO_CPLD_IOC_MAGIC)
+    {
+        return -ENOTTY;
+    }
+
+    if (_IOC_NR(cmd) > PICO_CPLD_IOC_MAXNUM)
+    {
+        return -ENOTTY;
+    }
+
+    switch (cmd)
+    {
+        case PICO_CPLD_IOCWRITEREG :
+        {
+            if (copy_from_user(&params, (const void __user *)arg,
+                               sizeof(params)))
+            {
+                ret = -EFAULT;
+                break;
+            }
+
+            if (params.device >= PICO_CPLD_MAX_NUM_DEV)
+            {
+                PRINTE("invalid device %d\n", params.device);
+                ret = -ENODEV;
+                break;
+            }
+
+            /* In user space the AD_FPGA is designated as device '0'
+               in fpga driver land the AD_FPGA is device '2' */
+            /* In user space the RC_FPGA is designated as device '1'
+               in fpga driver land the RC_FPGA is device '1' */
+            /* Therefore some translation is required...*/
+            if (params.device == 0)
+            {
+                /* The user wants to access the AD_FPGA */
+                params.device = 2;
+            }
+
+            if (params.reg >= PICO_CPLD_REG_NREGS)
+            {
+                PRINTE("invalid register %d\n", params.reg);
+                ret = -EINVAL;
+                break;
+            }
+
+            /* obtain a handle for the specified device */
+            fpgaHandle = fpga_get_handle((unsigned int)params.device);
+            if (!fpgaHandle)
+            {
+                ret = -ENODEV;
+                break;
+            }
+            /* do the write */
+            fpga_write_reg(fpgaHandle, (unsigned int)params.reg, params.data);
+            break;
+        }
+
+        case PICO_CPLD_IOCREADREG :
+        {
+            if (copy_from_user(&params, (const void __user *)arg,
+                               sizeof(params)))
+            {
+                ret = -EFAULT;
+                break;
+            }
+
+            if (params.device >= PICO_CPLD_MAX_NUM_DEV)
+            {
+                PRINTE("invalid device %d\n", params.device);
+                ret = -ENODEV;
+                break;
+            }
+
+            /* In user space the AD_FPGA is designated as device '0'
+               in fpga driver land the AD_FPGA is device '2' */
+            /* In user space the RC_FPGA is designated as device '1'
+               in fpga driver land the RC_FPGA is device '1' */
+            /* Therefore some translation is required...*/
+            if (params.device == 0)
+            {
+                /* The user wants to access the AD_FPGA */
+                params.device = 2;
+            }
+
+            if (params.reg >= PICO_CPLD_REG_NREGS)
+            {
+                PRINTE("invalid register %d\n", params.reg);
+                ret = -EINVAL;
+                break;
+            }
+
+            /* obtain a handle for the specified device */
+            fpgaHandle = fpga_get_handle((unsigned int)params.device);
+            if (!fpgaHandle)
+            {
+                ret = -ENODEV;
+                break;
+            }
+            /* do the read */
+            params.data = fpga_read_reg(fpgaHandle, params.reg);
+
+            if (copy_to_user((void __user *)arg, &params, sizeof(params)))
+            {
+                ret = -EFAULT;
+            }
+            break;
+        }
+
+        default :
+        {
+            PRINTE("invalid ioctl command 0x%08X\n", cmd);
+            return -ENOTTY;
+        }
+    }
+
+    return ret;
+}
+
+/*
+ * Things we need to make known to the world at large.
+ */
+module_init(fpga_module_init);
+module_exit(fpga_module_exit);
+EXPORT_SYMBOL(fpga_get_handle);
+EXPORT_SYMBOL(fpga_read_reg);
+EXPORT_SYMBOL(fpga_write_reg);
+
+MODULE_AUTHOR("picoChip");
+MODULE_DESCRIPTION("picoChip FPGA Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/picochip/gpr_interrupt.c b/drivers/picochip/gpr_interrupt.c
new file mode 100644
index 0000000..d4e97bc
--- /dev/null
+++ b/drivers/picochip/gpr_interrupt.c
@@ -0,0 +1,535 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file gpr_interrupt.c
+ * \brief GPR interrupt transport module implementation.
+ *
+ * This file implements a GPR based transport mechanism that signals to the
+ * application an interrupt has been generated via a GPR and optionally
+ * records the values of the register at interrupt time.
+ *
+ * The two transport methods provided are:
+ *  \li gpr_interrupt(with_values)
+ *  \li gpr_interrupt(without_values)
+ * The "with_values" variant samples the GPR at interrupt time and maintains a
+ * queue of all of the values at interrupt time. When the transport is read,
+ * an array of the values is returned to the user where each value is 32 bits
+ * and the values are consumed. The "without_values" variant does not record
+ * the value of the GPR at interrupt time (although it does read it to clear
+ * the interrupt). Instead, this method maintains a count of the interrupts
+ * raised and when read, returns the number of interrupts raised encoded in
+ * the first 4 bytes of the buffer and the count is set to 0.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/picochip/transports/gpr_interrupt.h>
+#include <linux/picochip/picoif_ioctl.h>
+
+#include "debug.h"
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include "picoif_module.h"
+#include "gpr_interrupt_internal.h"
+
+/*!
+ * \brief Stores the value of a GPR at interrupt time. This is dynamically
+ * allocated so that we don't need static FIFOs.
+ */
+struct gpr_int_value
+{
+    u32                 value;  /*!< The value of the GPR when the interrupt
+                                 *  was raised. */
+    struct list_head    list;   /*!< The list storing the values. */
+};
+
+/*!
+ * \brief GPR interrupt channel. Readable transport that returns the values of
+ * the GPR at each interrupt.
+ */
+struct gpr_int_channel
+{
+    int                     record_values;  /*!< Boolean flag for whether GPR
+                                             *   values should be recorded or
+                                             *   just an interrupt count. */
+    u32                     irq_count;      /*!< Number of interrupts raised. */
+    struct pico_resource    *irq;           /*!< The IRQ used for the
+                                             *   transport. */
+    struct pico_resource    *gpr;           /*!< The GPR used for the
+                                             *   transport. */
+    struct picoarray        *pa;            /*!< The picoArray running the
+                                             *   transport. */
+    struct list_head        values;         /*!< The list storing the values. */
+    spinlock_t              lock;           /*!< IRQ lock. */
+    struct picoif_context   *reader;        /*!< The reader of the channel. */
+};
+
+/*!
+ * \brief The gpr interrupt module.
+ * \extends picoif_module
+ */
+struct gpr_int_module
+{
+    struct picoif_module   mod;            /*!< The generic module. */
+    struct kmem_cache      *value_cache;   /*!< The kmem_cache for GPR values
+                                            *   when IRQs are raised. */
+};
+
+static void
+gpr_int_destructor( struct picoif_module *module );
+
+static struct picoif_context *
+gpr_int_create_trans_instance( struct picoif_module *module,
+                               const char *description,
+                               struct picoif_buf *params );
+
+static void
+gpr_int_close_trans_instance( struct picoif_module *module,
+                              struct picoif_context *ctx );
+
+static ssize_t
+gpr_int_write( struct picoif_module *module,
+               struct picoif_context *ctx,
+               struct picoif_buf *buf,
+               size_t len );
+
+static ssize_t
+gpr_int_read( struct picoif_module *module,
+              struct picoif_context *ctx,
+              struct picoif_buf *buf,
+              size_t len );
+
+static int
+gpr_int_can_write( struct picoif_module *module,
+                   struct picoif_context *ctx );
+
+static int
+gpr_int_can_read( struct picoif_module *module,
+                  struct picoif_context *ctx );
+
+/*! picoIf module operations for the GPR interrupt module. */
+static struct picoif_module_ops gpr_int_ops = {
+    .destructor             = gpr_int_destructor,
+    .create_trans_instance  = gpr_int_create_trans_instance,
+    .close_instance         = gpr_int_close_trans_instance,
+    .write                  = gpr_int_write,
+    .read                   = gpr_int_read,
+    .can_read               = gpr_int_can_read,
+    .can_write              = gpr_int_can_write,
+};
+
+/*! Transport methods for the GPR interrupt module. */
+static const char *gpr_int_tmethods[] = {
+    "with_values",
+    "without_values",
+};
+
+/*! The GPR interrupt transport module. */
+static struct gpr_int_module gpr_int_mod ={
+    .mod = {
+        .name       = "gpr_interrupt",
+        .tmethods   = gpr_int_tmethods,
+        .ops        = &gpr_int_ops,
+    },
+};
+
+/*!
+ * Write to the GPR interrupt transport. This is an invalid operation.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param buf The data to be written.
+ * @param len The length of data to be written in bytes.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+static ssize_t
+gpr_int_write( struct picoif_module *module,
+               struct picoif_context *ctx,
+               struct picoif_buf *buf,
+               size_t len )
+{
+    return -EINVAL;
+}
+
+/*!
+ * Check if the transport can be written to.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return GPR interrupt transports can not be written and will always return
+ * 0.
+ */
+static int
+gpr_int_can_write( struct picoif_module *module,
+                   struct picoif_context *ctx )
+{
+    return 0;
+}
+
+/*!
+ * Check if the transport can be read from.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return Returns 1 if the transport can be read, 0 otherwise.
+ */
+static int
+gpr_int_can_read( struct picoif_module *module,
+                  struct picoif_context *ctx )
+{
+    struct gpr_int_channel *channel = ctx->private_data;
+    return ( channel->irq_count > 0 );
+}
+
+/*!
+ * Read from the GPR interrupt transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the read.
+ * @param buf The buffer to write the data into.
+ * @param len The number of bytes requested to read.
+ * @return Returns the number of bytes read on success, negative on failure.
+ */
+static ssize_t
+gpr_int_read( struct picoif_module *module,
+              struct picoif_context *ctx,
+              struct picoif_buf *buf,
+              size_t len )
+{
+    struct gpr_int_channel *channel = ctx->private_data;
+    struct list_head *pos;
+    struct list_head *tmp;
+    const unsigned max_values =
+        channel->record_values ? len / sizeof( u32 ) : 0xFFFFFFFF;
+    unsigned i = 0;
+    struct gpr_int_value *val;
+    int ret = -EAGAIN;
+    ssize_t nbytes = 0;
+    unsigned long flags;
+    struct list_head list;
+
+    if ( len < 4 )
+        goto out;
+
+    INIT_LIST_HEAD( &list );
+
+    PRINTD( COMPONENT_GPR_INT, DBG_TRACE, "read %u bytes", len );
+
+    if ( channel->record_values )
+    {
+        spin_lock_irqsave( &channel->lock, flags );
+        list_for_each_safe( pos, tmp, &channel->values )
+        {
+            if ( max_values == i++ )
+                break;
+
+            /* Move the list entry into the copy list. */
+            list_del( pos );
+            list_add_tail( pos, &list );
+            --channel->irq_count;
+        }
+        spin_unlock_irqrestore( &channel->lock, flags );
+
+        list_for_each_safe( pos, tmp, &list )
+        {
+            val = container_of( pos, struct gpr_int_value, list );
+            ret = picoif_buf_copy_to( buf, &val->value, nbytes,
+                                      sizeof( val->value ) );
+            if ( ret )
+                goto out;
+
+            nbytes += sizeof( u32 );
+
+            kmem_cache_free( gpr_int_mod.value_cache, val );
+        }
+    }
+    else
+    {
+        u32 irq_count;
+        spin_lock_irqsave( &channel->lock, flags );
+        irq_count = channel->irq_count;
+        channel->irq_count = 0;
+        spin_unlock_irqrestore( &channel->lock, flags );
+
+        ret = picoif_buf_copy_to( buf, &irq_count, 0, sizeof( irq_count ));
+        if ( ret )
+            goto out;
+
+        if ( irq_count == 0 )
+            nbytes = -EAGAIN;
+        else
+            nbytes = sizeof( irq_count );
+    }
+
+    ret = nbytes;
+
+out:
+    return ret;
+}
+
+/*!
+ * Destructor for the gpr interrupt module.
+ *
+ * @param module The module being destroyed.
+ */
+static void
+gpr_int_destructor( struct picoif_module *module )
+{
+    kmem_cache_destroy( gpr_int_mod.value_cache );
+}
+
+/*!
+ * Handler function for interrupts raised by the GPRs in the picoArray. This
+ * is passed to the add_irq_handler method of the picoArray and is called when
+ * the interrupt is raised and must also clear the interrupt itself. This
+ * function will acknowledge the interrupt, and if we are recording values,
+ * will record the value to pass to the application when read.
+ *
+ * @param irq The irq resource that raised the interrupt.
+ * @param cookie The channel associated with the interrupt source.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+gpr_int_handler( struct pico_resource *irq,
+                 void *cookie )
+{
+    struct gpr_int_channel *channel = cookie;
+    struct picoarray *pa = channel->pa;
+    u32 val;
+
+    /* Read the register value. This clears the interrupt at the same time. */
+    int ret = pa->ops->register_read( pa, channel->gpr, &val );
+    ++channel->irq_count;
+
+    if ( channel->record_values )
+    {
+        struct gpr_int_value *gpr_val =
+            kmem_cache_alloc( gpr_int_mod.value_cache, GFP_ATOMIC );
+        ret = -ENOMEM;
+        if ( !gpr_val )
+            goto out;
+
+        gpr_val->value = val;
+        list_add_tail( &gpr_val->list, &channel->values );
+        ret = 0;
+    }
+
+out:
+    wake_up_interruptible( &channel->reader->readq );
+    return ret;
+}
+
+/*!
+ * Create a new GPR interrupt transport instance.
+ *
+ * @param module The module managing the transport.
+ * @param description The type of transport to create.
+ * @param params Extra parameters for the transport type.
+ * @return Returns the transport context on success, or an ERR_PTR on failure.
+ */
+static struct picoif_context *
+gpr_int_create_trans_instance( struct picoif_module *module,
+                               const char *description,
+                               struct picoif_buf *params )
+{
+    int ret = -ENOMEM;
+    void *private_data = NULL;
+    struct picoif_context *ctx = picoif_new_ctx( module, private_data );
+    struct picoif_gpr_int_params gparams;
+    struct picoarray *pa = NULL;
+    struct pico_resource *irq = NULL;
+    struct pico_resource *gpr = NULL;
+    struct gpr_int_channel *channel;
+    enum picoarray_device_type dev_type;
+
+    ret = picoif_buf_copy_from( &gparams, params, 0,
+                                sizeof( gparams ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    pa = picoif_get_device( gparams.dev_num );
+    if ( !pa )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "invalid device number: %u",
+                gparams.dev_num );
+        goto out;
+    }
+
+    dev_type = pa->ops->get_device_type( pa );
+    if ( !( PICOARRAY_PC202 == dev_type || PICOARRAY_PC302 == dev_type ) )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN,
+                "device not supported for this transport" );
+        goto out;
+    }
+
+    ret = -EBUSY;
+    /* Request exclusive access to the IRQ resource. */
+    irq = pa->ops->get_resource( pa, PICO_RES_IRQ, gparams.irq_num, 1 );
+    if ( !irq )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "unabled to get irq: %u",
+                gparams.irq_num );
+        goto out;
+    }
+
+    /* Request exclusive access to the GPR resource. */
+    gpr = pa->ops->get_resource( pa, PICO_RES_GPR, irq->metadata, 1 );
+    if ( !gpr )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "unable to get gpr: %u",
+                irq->metadata );
+        goto out;
+    }
+
+    if ( !ctx )
+        goto out;
+
+    /* Allocate the new channel and initialise the data members. */
+    ret = -ENOMEM;
+    channel = kmalloc( sizeof( *channel ), GFP_KERNEL );
+    channel->reader = ctx;
+    ctx->private_data = channel;
+    if ( !ctx->private_data )
+        goto out;
+
+    INIT_LIST_HEAD( &channel->values );
+
+    /* Request the handler function for when the interrupt is raised. */
+    channel->irq            = irq;
+    channel->gpr            = gpr;
+    channel->pa             = pa;
+    channel->irq_count      = 0;
+    if ( !strcmp( description, "gpr_interrupt(with_values)" ) )
+        channel->record_values = 1;
+    else if ( !strcmp( description, "gpr_interrupt(without_values)" ) )
+        channel->record_values = 0;
+    else
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "invalid tmethod \"%s\"",
+                description );
+        ret = -EINVAL;
+        goto bad_description;
+    }
+
+    ret = pa->ops->add_irq_handler( pa, channel->irq, gpr_int_handler,
+                                    channel );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN,
+                "failed to register interrupt handler" );
+        goto handler_reg_failed;
+    }
+
+    ret = 0;
+    goto out;
+
+bad_description:
+handler_reg_failed:
+    kfree( channel );
+
+out:
+    if ( ret )
+    {
+        kfree( ctx );
+        if ( irq )
+            pa->ops->put_resource( pa, irq );
+        if ( gpr )
+            pa->ops->put_resource( pa, gpr );
+    }
+
+    return ret ? ERR_PTR( ret ) : ctx;
+}
+
+/*!
+ * Close an existing transport instance. If this instance is the last one
+ * using the channel, then destroy the channel to make sure we don't leak
+ * memory.
+ *
+ * @param mod The module handling the transport.
+ * @param ctx The context that is being closed.
+ */
+static void
+gpr_int_close_trans_instance( struct picoif_module *mod,
+                              struct picoif_context *ctx )
+{
+    struct gpr_int_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+
+    pa->ops->remove_irq_handler( pa, channel->irq );
+    pa->ops->put_resource( pa, channel->irq );
+    pa->ops->put_resource( pa, channel->gpr );
+    kfree( ctx );
+}
+
+struct picoif_context *
+picoif_gpr_irq_ul( unsigned dev_num,
+                   int irq_num )
+{
+    struct picoif_gpr_int_params gpr_params = {
+        .dev_num    = dev_num,
+        .irq_num    = irq_num,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &gpr_params,
+        .is_user    = 0,
+    };
+    struct picoif_context *ctx =
+        gpr_int_create_trans_instance( &gpr_int_mod.mod,
+                                       "gpr_interrupt(without_values)", &buf );
+
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_gpr_irq_ul );
+
+struct picoif_context *
+picoif_gpr_irq_ul_with_values( unsigned dev_num,
+                               int irq_num )
+{
+    struct picoif_gpr_int_params gpr_params = {
+        .dev_num    = dev_num,
+        .irq_num    = irq_num,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &gpr_params,
+        .is_user    = 0,
+    };
+    struct picoif_context *ctx =
+        gpr_int_create_trans_instance( &gpr_int_mod.mod,
+                                       "gpr_interrupt(with_values)", &buf );
+
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_gpr_irq_ul_with_values );
+
+int
+gpr_interrupt_init( void )
+{
+    gpr_int_mod.value_cache =
+        kmem_cache_create( "picoif_gpr_int",
+                           sizeof( struct gpr_int_value ), 0, 0, NULL );
+    if ( !gpr_int_mod.value_cache )
+        return -ENOMEM;
+
+    return picoif_register_module( &gpr_int_mod.mod );
+}
diff --git a/drivers/picochip/gpr_interrupt_internal.h b/drivers/picochip/gpr_interrupt_internal.h
new file mode 100644
index 0000000..cea98c6
--- /dev/null
+++ b/drivers/picochip/gpr_interrupt_internal.h
@@ -0,0 +1,34 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file gpr_interrupt_internal.h
+ * \brief Initialisation function for GPR interrupt transport.
+ *
+ * Internal GPR interrupt transport functions
+ *
+ */
+
+#ifndef __PICOIF_GPR_INTERRUPT_INTERNAL_H__
+#define __PICOIF_GPR_INTERRUPT_INTERNAL_H__
+
+/*!
+ * Initialise the GPR interrupt transport.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+gpr_interrupt_init( void );
+
+#endif /* !__PICOIF_GPR_INTERRUPT_INTERNAL_H__ */
diff --git a/drivers/picochip/hwif.c b/drivers/picochip/hwif.c
new file mode 100644
index 0000000..8bff2a0
--- /dev/null
+++ b/drivers/picochip/hwif.c
@@ -0,0 +1,921 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file hwif.c
+ * \brief HwIF transport module implementation.
+ *
+ * This file implements the HwIF DMA transport.
+ *
+ * Two transport methods are provided:
+ *   \li hwif(ul)
+ *   \li hwif(int)
+ *
+ * hwif(ul) supports uplink DMA transfers, and hwif(int) supports the 
+ * forwarding of interrupts from the picoArray to host that have no data
+ * associated with them.
+ *
+ * This transport creates one context per device which will permit a maximum of
+ * thirty one DMA channels or interrupts to be configured assuming that the
+ * picoArray device can support this number. Each instance of the transport
+ * requires a interrupt number between 0 and 31 to be assigned which must
+ * match the interrupt bit set in the ITS register by the picoArray interface
+ * code. One GPR is required per context for clearing all the interrupts.
+ *
+ * There is only limited checking that can be performed for consistency 
+ * between the picoArray interface code and the application code.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+
+#include "debug.h"
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include "picoif_module.h"
+#include "hwif_internal.h"
+#include "dma_fifo_internal.h"
+#include <linux/picochip/transports/hwif.h>
+#include <linux/picochip/picoif_ioctl.h>
+
+/*! The maximum number of interrupts that the transport supports. */
+#define HWIF_MAX_INTERRUPT_NUM ( 31 )
+
+/*! The maximum number of devices that the driver supports. */
+#define HWIF_MAX_DEVICES       ( 8 )
+
+/*!
+ * \brief The context parameters used on each device
+ */
+struct hwif_ctx_params
+{
+    uint32_t interrupts_set;         /*!< The active interrupts on this device */
+    int int_clear_gpr;               /*!< The interrupt clear GPR */
+    struct pico_resource *int_clear; /*!< The int clear GPR resource */
+    struct pico_resource *its;       /*!< The ITS resource */
+    struct pico_resource *itm;       /*!< The ITM resource */
+    struct pico_resource *irq;       /*!< The procif IRQ resource */
+    struct picoarray *pa;            /*!< The picoArray running the context */
+    struct dma_channel *channel[HWIF_MAX_INTERRUPT_NUM];
+                                     /*!< DMA channels attached to this context */
+    spinlock_t lock;                 /*!< Context parameter lock */
+};
+
+/*!
+ * \brief The basic HwIF module.
+ * \extends picoif_module
+ */
+struct hwif_module
+{
+    struct picoif_module mod;        /*!< The generic module. */
+    struct hwif_ctx_params params[HWIF_MAX_DEVICES];
+                                     /*!< Common parameters this transport */
+};
+
+/*!
+ * \brief DMA channel parameters (one per DMA channel). 
+ */
+static struct dma_channel
+{
+    struct picoif_context *reader;    /*!< The reader of the transport. */
+    unsigned activeChannel;           /*!< Boolean to determine if the DMA
+                                       *   channel is active */
+    unsigned isPureInterrupt;         /*!< Boolean to determine if the
+                                       *   transport is a pure interrupt or
+                                       *   carrying data */
+    unsigned interruptNumber;         /*!< Interrupt number for the channel */
+    struct pico_resource *chan;       /*!< Physical DMA channel */
+    uint32_t irqCount;                /*!< Number of interrupts raised since
+                                       *   last read (for pure interrupts only) */
+    unsigned xferSize;                /*!< Size of transfer in bytes */
+    unsigned bytesSent;               /*!< Bytes sent so far */
+    unsigned totalBytes;              /*!< Total bytes */
+    unsigned maxTransferSize;         /*!< Max transfer size in bytes */
+    struct dma_fifo_t *fifo;          /*!< DMA FIFO */
+    spinlock_t lock;                  /*!< DMA parameter lock */
+    struct pico_resource *status;     /*!< The DMA status GPR resource */
+    struct pico_resource *count;      /*!< The DMA count GPR resource */
+    struct hwif_ctx_params *hwifCtx;  /*!< Pointer to the context parameters used
+                                       *   in this channel */
+}
+dma_channel;
+
+static void
+hwif_destructor( struct picoif_module *module );
+
+static struct picoif_context *
+hwif_create_trans_instance( struct picoif_module *module,
+                            const char *description,
+                            struct picoif_buf *params );
+
+static void
+hwif_close_trans_instance( struct picoif_module *module,
+                           struct picoif_context *ctx );
+
+static ssize_t
+hwif_write( struct picoif_module *module,
+            struct picoif_context *ctx,
+            struct picoif_buf *buf,
+            size_t len );
+
+static ssize_t
+hwif_read( struct picoif_module *module,
+           struct picoif_context *ctx,
+           struct picoif_buf *buf,
+           size_t len );
+
+static int
+hwif_can_write( struct picoif_module *module,
+                struct picoif_context *ctx );
+
+static int
+hwif_can_read( struct picoif_module *module,
+               struct picoif_context *ctx );
+
+static int
+hwif_queue_transfer( struct dma_channel *channel );
+
+/*! picoIf module operations for the DMA module. */
+static struct picoif_module_ops hwif_ops = {
+    .destructor             = hwif_destructor,
+    .create_trans_instance  = hwif_create_trans_instance,
+    .close_instance         = hwif_close_trans_instance,
+    .write                  = hwif_write,
+    .read                   = hwif_read,
+    .can_read               = hwif_can_read,
+    .can_write              = hwif_can_write,
+};
+
+/*! Transport methods for the DMA transport module */
+static const char *hwif_tmethods[] = {
+    "ul",
+};
+
+/*! The HwIF transport */
+static struct hwif_module hwif_mod ={
+    .mod = {
+        .name       = "hwif",
+        .tmethods   = hwif_tmethods,
+        .ops        = &hwif_ops,
+    },
+};
+
+/*!
+ * Check if the transport can be written to.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return HwiF2 transports cannot be written and will always return 0
+ */
+static int
+hwif_can_write( struct picoif_module *module,
+                struct picoif_context *ctx )
+{
+    return 0;
+}
+
+/*!
+ * Check if the transport can be read from.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return Returns 1 if the transport can be read (and has data ready),
+ * 0 otherwise.
+ */
+static int
+hwif_can_read( struct picoif_module *module,
+               struct picoif_context *ctx )
+{
+    int ret = 0;
+    struct dma_channel *channel = ctx->private_data;
+
+    if ( channel->isPureInterrupt )
+        return ( channel->irqCount > 0 );
+    else
+    {
+        unsigned long flags;
+        unsigned bytes_to_read = dma_fifo_used( channel->fifo );
+
+        if ( bytes_to_read )
+            return 1;
+
+        /* Start any queued transfers for this channel */
+        spin_lock_irqsave( &channel->lock, flags );
+        ret = hwif_queue_transfer(channel );
+        spin_unlock_irqrestore( &channel->lock, flags );
+        return 0;
+    }
+}
+
+/*!
+ * Handler function for interrupts generated by a completed HwIF transfer. 
+ *
+ * @param cookie The channel associated with the interrupt source.
+ * @param errno The error number associated with the DMA transfer
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+hwif_dma_handler( void *cookie,
+                  int errno )
+{
+    struct dma_channel *channel = cookie;
+    int ret = 0;
+    unsigned long flags;
+
+    if ( errno )
+    {
+        PRINTD( COMPONENT_HWIF, DBG_ERROR,"DMA transfer completed with "
+            "error %d (cookie=0x%p)", errno, cookie );
+        return errno;
+    }
+    else
+    {
+        PRINTD( COMPONENT_HWIF, DBG_TRACE,"tranfer of %u bytes completed",
+            channel->xferSize );
+    }
+
+    spin_lock_irqsave( &channel->lock, flags );
+
+    /* Add data transferred to FIFO control parameters */
+    dma_fifo_add_transfer( channel->fifo, channel->xferSize );
+    channel->bytesSent += channel->xferSize;
+    channel->activeChannel = 0;
+
+    if ( channel->bytesSent == channel->totalBytes )
+    {
+        wake_up_interruptible( &channel->reader->readq );
+        channel->totalBytes = 0;
+        channel->bytesSent = 0;
+        channel->xferSize = 0;
+    }
+
+    ret = hwif_queue_transfer( channel );
+
+    spin_unlock_irqrestore( &channel->lock, flags );
+
+    return ret;
+}
+
+/*!
+ * Write to the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param buf The data to be written.
+ * @param len The length of data to be written in bytes.
+ * @return Returns EINVAL as a write is not permitted for this transport
+ */
+static ssize_t
+hwif_write( struct picoif_module *module,
+            struct picoif_context *ctx,
+            struct picoif_buf *buf,
+            size_t len )
+{
+    return -EINVAL;
+}
+
+/*!
+ * Read from the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the read.
+ * @param buf The buffer to write the data into.
+ * @param len The number of bytes requested to read.
+ * @return Returns the number of bytes read on success, negative on failure.
+ */
+static ssize_t
+hwif_read( struct picoif_module *module,
+           struct picoif_context *ctx,
+           struct picoif_buf *buf,
+           size_t len )
+{
+    struct dma_channel *channel = ctx->private_data;
+    int ret = 0;
+
+    if ( channel->isPureInterrupt )
+    {
+        unsigned long flags;
+
+        spin_lock_irqsave( &channel->lock, flags );
+        if ( ( len < sizeof( channel->irqCount ) ) ||
+                                        ( !channel->irqCount ) )
+        {
+            ret = -EAGAIN;
+        }
+        else
+        {
+            PRINTD( COMPONENT_HWIF, DBG_TRACE, "read %u bytes,irq count=%d",
+                 len, channel->irqCount );
+
+            ret = picoif_buf_copy_to( buf, &channel->irqCount, 0,
+                                  sizeof( channel->irqCount ) );
+            channel->irqCount = 0;
+            if ( !ret )
+            {         
+                ret = sizeof( channel->irqCount );
+            }
+        }
+
+        spin_unlock_irqrestore( &channel->lock, flags );
+        return ret;
+    }
+    else
+    {
+        unsigned used_bytes=0;
+        unsigned long flags;
+
+        /* Check that the length is invalid */
+        if ( len & 0x3 )
+            return -EINVAL;
+
+        /* Determine how much data is already in the FIFO */
+        used_bytes = dma_fifo_get( channel->fifo, buf, len, 0 );
+        if ( used_bytes < len )
+           used_bytes += dma_fifo_get( channel->fifo, buf, (len-used_bytes),
+                                used_bytes ); 
+
+        /* Start any queued transfers for this channel */
+        spin_lock_irqsave( &channel->lock, flags );
+        ret = hwif_queue_transfer(channel );
+        spin_unlock_irqrestore( &channel->lock, flags );
+        
+        if ( !used_bytes )
+            return -EAGAIN;
+
+        PRINTD( COMPONENT_HWIF, DBG_TRACE,
+                "read %u bytes (requested %u bytes)", used_bytes, len );
+
+        if ( ret )
+            return ret;
+        else
+            return used_bytes;
+    }
+}
+
+/*!
+ * Destructor for the DMA module.
+ *
+ * @param module The module being destroyed.
+ */
+static void
+hwif_destructor( struct picoif_module *module )
+{
+}
+
+/*!
+ * Handler function for processing interrupts raised by the procIF. This function
+ * is passed to the add_irq_handler() method of the picoArray and is called when the
+ * prociIF IRQ is asserted. This function will acknowledge the interrupt, and start a
+ * DMA transfer of the required size.
+ *
+ * @param irq The irq resource that raised the interrupt.
+ * @param cookie The context associated with the the interrupt.
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+hwif_int_handler( struct pico_resource *irq,
+                    void *cookie )
+{
+    struct hwif_ctx_params *params = cookie;
+    struct picoarray *pa = params->pa;
+    int ret = 0;
+    unsigned i=0;
+    unsigned long flags;
+    uint32_t its=0;
+
+    /* Determine cause of interrupt. Make a local copy of ITS.
+     */
+    ret = pa->ops->register_read( pa, params->its, &its );
+    if ( ret )
+    {
+        return ret;
+    }
+
+    if ( !its )
+    {
+        return 0;
+    }
+
+    /* Clear interrupt */
+    ret = pa->ops->register_write( pa, params->its, 0 );
+    if ( ret )
+    {
+        return ret;
+    }
+
+    /* Scan through pure interrupts */
+    spin_lock_irqsave( &params->lock, flags );
+    for( i=0; i < HWIF_MAX_INTERRUPT_NUM; i++ )
+    {
+        if ( its & ( 1 << i ) )
+        {
+            if ( params->interrupts_set & ( 1 << i ) )
+            {
+                if ( params->channel[i]->isPureInterrupt )
+                {
+                    /* Clear interrupt */
+                    ret = pa->ops->register_write( pa, params->int_clear, ( 1 << i ) );
+
+                    PRINTD( COMPONENT_HWIF, DBG_TRACE,
+                       "pure int:%d ITS:0x%08x", i, its );
+
+                    spin_lock_irqsave( &params->channel[i]->lock, flags );
+                    ++params->channel[i]->irqCount;
+                    wake_up_interruptible( &params->channel[i]->reader->readq );
+                    spin_unlock_irqrestore( &params->channel[i]->lock, flags );
+
+                }
+                else
+                {
+                    /* Clear interrupt */
+                    ret = pa->ops->register_write( pa, params->int_clear, ( 1 << i ) );
+
+                    PRINTD( COMPONENT_HWIF, DBG_TRACE,
+                       "data int:%d ITS:0x%08x", i, its );
+
+                    spin_lock_irqsave( &params->channel[i]->lock, flags );
+                    params->channel[i]->irqCount = 1;
+                    ret = hwif_queue_transfer( params->channel[i] );
+                    spin_unlock_irqrestore( &params->channel[i]->lock, flags );
+          
+                }
+            }
+            else
+                PRINTD( COMPONENT_HWIF, DBG_WARN, "int:%d ITS:0x%08x no "
+                        "handler for DMA channel", i, its );
+        }
+    }
+
+    spin_unlock_irqrestore( &params->lock, flags );
+    return 0;
+}
+
+/*!
+ * Function that manages the queuing of packets for DMA transfer. This function
+ * will add the data (if provided) to the tail of a queue, and if there is no
+ * transfer in progress, extract the nexttransfer from the head of the queue.
+ *
+ * @param channel The DMA channel handle
+ * @return Returns zero on success, non-zero on failure.
+ */
+__must_check static int
+hwif_queue_transfer( struct dma_channel *channel )
+{
+    unsigned maxsize=0;
+    uint32_t size=0;
+    int ret = 0;
+    struct picoarray *pa = channel->hwifCtx->pa;
+
+    if ( channel->activeChannel )
+    {
+        return 0;
+    }
+
+    if ( !channel->totalBytes && channel->irqCount )
+    {
+        uint32_t old_size = 1; /* Number that should never occur */
+        unsigned loop = 10000;
+    
+        /* Read the status GPR for 2 identical values */
+        while(loop > 0)
+        {
+            ret = pa->ops->register_read( pa, channel->status, &size );
+            if ( ret )
+            {
+                size = 0;
+                break;
+            }
+            
+            if ( size == old_size )
+                break;
+
+            old_size = size;
+            loop--;
+        }
+
+        if ( !loop )
+        {
+            PRINTD( COMPONENT_HWIF, DBG_ERROR,
+                "failed to read a consistent value for status register");
+        }
+        else
+        {
+            if ( size > channel->maxTransferSize )
+            {
+                PRINTD(COMPONENT_HWIF, DBG_WARN,
+                    "Transfer size exceeds buffer size or max allowed by DMA. "
+                    " Will truncate");
+                size = channel->maxTransferSize;
+            }
+            else
+            {
+                PRINTD(COMPONENT_HWIF, DBG_TRACE,
+                                     "GPR status read, value=0%u", size);
+            }
+            channel->totalBytes = size;
+        }
+    }
+
+    size = channel->totalBytes-channel->bytesSent;
+    maxsize = dma_fifo_space( channel->fifo );
+    if ( size > maxsize )
+       size = maxsize;
+
+    if ( size > 0 )
+    {
+        struct scatterlist sgl;
+        sgl.dma_address = dma_fifo_get_writeptr( channel->fifo );
+        sgl.length = dma_fifo_space( channel->fifo ); /* Report the size of
+                the buffer available from the write pointer */
+
+        channel->xferSize = size;
+        channel->activeChannel = 1;
+
+        /* Report how much data we are going to accept */
+        ret = pa->ops->register_write( pa, channel->count, size );
+        if ( ret )
+            PRINTD( COMPONENT_HWIF, DBG_ERROR,
+                "Failure to request bytes to receive Sent=%u "
+                "Transfered=%u Total=%u bytes",
+                channel->bytesSent, size, channel->totalBytes ); 
+
+        ret = pa->ops->dma_from_device( pa, channel->chan, &sgl, size,
+                    hwif_dma_handler, channel );
+        if ( ret )
+        {
+            PRINTD( COMPONENT_HWIF, DBG_ERROR,
+                "Failure to begin transfer Sent=%u Transfered=%u Total=%u bytes",
+                channel->bytesSent, size, channel->totalBytes );
+        }
+        else 
+        {
+            PRINTD( COMPONENT_HWIF, DBG_TRACE,
+                "Sent=%u Transfered=%u Total=%u bytes", channel->bytesSent, 
+            size, channel->totalBytes );
+        }
+    }
+    else if ( !maxsize )
+         PRINTD( COMPONENT_HWIF, DBG_WARN,
+            "FIFO full on channel int number %",channel->interruptNumber );
+
+    return ret;
+}
+
+/*!
+ * Create a and start the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param description The type of transport to create.
+ * @param params Extra parameters for the transport type.
+ * @return Returns the transport context on success, or an ERR_PTR on failure.
+ */
+static struct picoif_context *
+hwif_create_trans_instance( struct picoif_module *module,
+                             const char *description,
+                             struct picoif_buf *params )
+{
+    int ret = -ENOMEM;
+    void *private_data = NULL;
+    struct picoif_context *ctx = picoif_new_ctx( module, private_data );
+    struct picoif_hwif_params gparams;
+    struct picoarray *pa = NULL;
+    struct dma_channel *channel;
+    struct pico_resource *chan = NULL;
+    enum picoarray_device_type dev_type;
+    struct pico_resource *irq = NULL;
+    struct pico_resource *status = NULL;
+    struct pico_resource *count = NULL;
+    unsigned long flags;
+
+    ret = picoif_buf_copy_from( &gparams, params, 0,
+                                sizeof( gparams ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    pa = picoif_get_device( gparams.dev_num );
+    if ( !pa )
+    {
+        PRINTD( COMPONENT_HWIF, DBG_WARN, "invalid device number: %u",
+                gparams.dev_num );
+        goto out;
+    }
+
+    dev_type = pa->ops->get_device_type( pa );
+    if ( !( PICOARRAY_PC202 == dev_type || PICOARRAY_PC203 == dev_type ) )
+    {
+        PRINTD( COMPONENT_HWIF, DBG_WARN,
+                "device not supported for this transport" );
+        goto out;
+    }
+
+    if ( !strcmp( description, "hwif(ul)" ) )
+    {
+        /* Check that the DMA channel is not already in use */
+        ret = -EBUSY;
+        chan = pa->ops->get_resource( pa, PICO_RES_DMA_CHANNEL,
+                                             gparams.channel, 1 );
+        if ( !chan )
+        {
+            PRINTD( COMPONENT_HWIF, DBG_ERROR, "invalid DMA channel:%u",
+                gparams.channel );
+            goto out;
+        }
+
+        /* Get the status and count GPR resources */
+        status = pa->ops->get_resource( pa, PICO_RES_GPR, gparams.status_gpr, 1 );
+        if ( !status )
+        {
+            PRINTD( COMPONENT_HWIF, DBG_WARN, "unable to get DMA status gpr: %u",
+                gparams.status_gpr );
+            goto out;
+        }
+ 
+        count = pa->ops->get_resource( pa, PICO_RES_GPR, gparams.count_gpr, 1 );
+        if ( !count )
+        {
+            PRINTD( COMPONENT_HWIF, DBG_WARN, "unable to get DMA count gpr: %u",
+                gparams.count_gpr );
+            goto out;
+        }
+    }
+
+    /* Check that the interrupt number is valid */
+    if (gparams.dev_num >= HWIF_MAX_INTERRUPT_NUM)
+        goto out;
+
+    /* If this is the first transport on the device, set the context
+       parameters */
+    if ( !hwif_mod.params[gparams.dev_num].interrupts_set )
+    {
+        struct pico_resource *int_clear = pa->ops->get_resource( pa,
+            PICO_RES_GPR, gparams.int_clear_gpr, 1 );
+        struct pico_resource *its = NULL;
+        struct pico_resource *itm = NULL;
+
+        (void)pa->ops->get_procif_resource( pa, &its, &itm, &irq );
+
+        ret = -EBUSY;
+        if (( !int_clear ) || ( !its ) || ( !itm ) || ( !irq ))
+        {
+            if ( !int_clear)
+                PRINTD( COMPONENT_HWIF, DBG_WARN, "unable to get int clear "
+                    "gpr: %u", gparams.int_clear_gpr );
+            else
+                pa->ops->put_resource( pa, int_clear );
+
+            if ( !its)
+                PRINTD( COMPONENT_HWIF, DBG_WARN, "unable to get ITS gpr" );
+
+            if ( !itm)
+                PRINTD( COMPONENT_HWIF, DBG_WARN, "unable to get ITM gpr" );
+
+            if ( !irq)
+                PRINTD( COMPONENT_HWIF, DBG_WARN, "unable to procIF irq" );
+
+            pa->ops->put_procif_resource( pa, its, itm, irq );
+
+            goto out;
+        }
+
+        hwif_mod.params[gparams.dev_num].interrupts_set |= (1 << gparams.int_num);
+        hwif_mod.params[gparams.dev_num].int_clear_gpr = gparams.int_clear_gpr;
+        hwif_mod.params[gparams.dev_num].int_clear = int_clear;
+        hwif_mod.params[gparams.dev_num].its = its;
+        hwif_mod.params[gparams.dev_num].itm = itm;
+        hwif_mod.params[gparams.dev_num].irq = irq;
+        hwif_mod.params[gparams.dev_num].pa = pa;
+
+        spin_lock_init( &hwif_mod.params[gparams.dev_num].lock );
+
+    }
+    else
+    { /* Check that the common parameters are consistent */
+        if (( gparams.int_clear_gpr !=
+                          hwif_mod.params[gparams.dev_num].int_clear_gpr ) ||
+            ( hwif_mod.params[gparams.dev_num].interrupts_set &
+                                                        (1 << gparams.int_num) ))
+            goto out;
+
+        hwif_mod.params[gparams.dev_num].interrupts_set |= (1 << gparams.int_num); 
+    }
+
+    if ( !ctx )
+        goto out;
+
+    /* Allocate the new channel and initialise the data members. */
+    ret = -ENOMEM;
+    channel = kmalloc( sizeof( dma_channel ), GFP_KERNEL );
+    if (!channel)
+        goto out;
+    ctx->private_data = channel;
+
+    if ( !strcmp( description, "hwif(ul)" ) )
+    { 
+        ret = dma_fifo_create( &channel->fifo, gparams.buf_size );
+        if (ret)
+            goto bad_fifo_alloc;
+    }
+
+    channel->reader = ctx;
+    channel->hwifCtx = &hwif_mod.params[gparams.dev_num]; 
+    channel->interruptNumber = gparams.int_num;
+    if ( pa->max_dma_sz < gparams.buf_size )
+        channel->maxTransferSize = pa->max_dma_sz;
+    else
+        channel->maxTransferSize = gparams.buf_size;
+    channel->chan = chan;
+    channel->xferSize = 0;
+    channel->bytesSent = 0;
+    channel->totalBytes = 0;
+    channel->activeChannel = 0;
+    channel->status = status;
+    channel->count = count;
+    channel->irqCount = 0;
+ 
+    hwif_mod.params[gparams.dev_num].channel[gparams.int_num] = channel;
+
+    spin_lock_init( &channel->lock );
+
+    if ( !strcmp( description, "hwif(ul)" ) )
+    {
+        channel->isPureInterrupt = 0;
+        ret = pa->ops->dma_open( pa, chan, 0);
+        if ( ret )
+        {
+            PRINTD( COMPONENT_HWIF, DBG_ERROR, "failed to open DMA channel" );
+            goto bad_description;
+        }
+    }
+    else if ( !strcmp( description, "hwif(int)" ) )
+    {
+        channel->fifo = NULL;
+        channel->isPureInterrupt = 1;
+    }
+    else
+    {
+        PRINTD( COMPONENT_HWIF, DBG_ERROR, "invalid tmethod \"%s\"",
+                description );
+        ret = -EINVAL;
+        goto bad_description;
+    }
+
+    if ( irq )
+    {
+        ret = pa->ops->add_irq_handler( pa, irq, hwif_int_handler,
+                                        channel->hwifCtx );
+        if ( ret )
+        {
+            PRINTD( COMPONENT_HWIF, DBG_ERROR,
+                "failed to register interrupt handler" );
+            goto handler_reg_failed;
+        }
+    }
+
+    /* Enable interrupt */
+    spin_lock_irqsave( &channel->hwifCtx->lock, flags );
+    ret = pa->ops->register_write( pa, channel->hwifCtx->itm,
+                     channel->hwifCtx->interrupts_set );
+    spin_unlock_irqrestore( &channel->hwifCtx->lock, flags );
+
+    ret = 0;
+    goto out;
+
+bad_description:
+handler_reg_failed:
+   if ( channel->fifo )
+       dma_fifo_destroy( channel->fifo );
+
+bad_fifo_alloc:
+    kfree( channel );
+
+out:
+    if ( ret )
+    {
+        kfree( ctx );
+
+        if ( chan )
+            pa->ops->put_resource(  pa, chan );
+
+        if ( status )
+            pa->ops->put_resource(  pa, status );
+
+        if ( count )
+            pa->ops->put_resource(  pa, count );
+    }
+
+    return ret ? ERR_PTR( ret ) : ctx;
+}
+
+/*!
+ * Close an existing transport instance.
+ *
+ * @param mod The module handling the transport.
+ * @param ctx The context that is being closed.
+ */
+static void
+hwif_close_trans_instance( struct picoif_module *mod,
+                          struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->hwifCtx->pa;
+    unsigned long flags;
+    unsigned interrupt_bit = ((uint32_t)1) << channel->interruptNumber;
+    struct hwif_ctx_params *params = channel->hwifCtx;
+    int ret = 0;
+
+    if ( !channel->isPureInterrupt )
+        ret = pa->ops->dma_close( pa, channel->chan );
+
+    if ( channel->chan )
+        pa->ops->put_resource( pa, channel->chan );
+
+    if ( channel->fifo )
+        dma_fifo_destroy( channel->fifo );
+
+    params->interrupts_set &= ( !interrupt_bit );
+
+    if ( !params->interrupts_set )
+    {
+        pa->ops->put_resource( pa, params->int_clear );
+        pa->ops->put_procif_resource( pa, params->its, params->itm,
+                      params->irq );
+    }
+
+    if ( channel->status )
+        pa->ops->put_resource( pa, channel->status );
+
+    if ( channel->count )
+        pa->ops->put_resource( pa, channel->count );
+
+    /* Disable interrupt */
+    spin_lock_irqsave( &params->lock, flags );
+    ret = pa->ops->register_write( pa, params->itm, params->interrupts_set );
+    spin_unlock_irqrestore( &params->lock, flags );
+ 
+    params->channel[channel->interruptNumber] = NULL;
+    if ( channel )
+        kfree( channel );
+
+    if ( ctx )
+        kfree( ctx );
+}
+
+/* Kernel API and Public functions */
+struct picoif_context *
+picoif_hwif_dmaul_open( const picoif_hwif_t hwif_context,
+                         unsigned interrupt_number,
+                         int dma_channel,
+                         int dma_status_gpr,
+                         int dma_count_gpr,
+                         size_t buffer_size )
+{
+    struct picoif_hwif_params hwif_params = {
+        .dev_num        = hwif_context->dev_num,
+        .int_num        = interrupt_number,
+        .channel        = dma_channel,
+        .status_gpr     = dma_status_gpr,
+        .count_gpr      = dma_count_gpr,
+        .buf_size       = buffer_size,
+        .int_clear_gpr = hwif_context->int_clear_gpr,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &hwif_params,
+        .is_user    = 0,
+    };
+    struct picoif_context *ctx =
+        hwif_create_trans_instance( &hwif_mod.mod,
+                                       "hwif(ul)", &buf );
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_hwif_dmaul_open );
+
+int
+hwif_init( void )
+{
+    memset(hwif_mod.params, sizeof ( hwif_mod.params ), 0 );
+
+    return picoif_register_module( &hwif_mod.mod );
+}
+
+
diff --git a/drivers/picochip/hwif2.c b/drivers/picochip/hwif2.c
new file mode 100644
index 0000000..96b328e
--- /dev/null
+++ b/drivers/picochip/hwif2.c
@@ -0,0 +1,734 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file hwif2.c
+ * \brief HwIF2 transport module implementation.
+ *
+ * This file implements the HwIF2 DMA transport.
+ *
+ * One transport method is provided:
+ *   \li hwif2(ul)
+ *
+ * This transport creates one context per device which will permit a maximum of
+ * eight DMA channels to be configured assuming that the picoArray device can
+ * support this number. Each DMA channel requires a interrupt number between 0
+ * and 7 to be assigned which must match the interrupt generated in the picoArray
+ * interface code. Two GPRs are required per context for handling the handshaking
+ * between picoArray and host. 
+ *
+ * There is only limited checking that can be performed for consistancy 
+ * between the picoArray interface code and the application code.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+
+#include "debug.h"
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include "picoif_module.h"
+#include "hwif2_internal.h"
+#include "dma_fifo_internal.h"
+#include <linux/picochip/transports/hwif2.h>
+#include <linux/picochip/picoif_ioctl.h>
+
+/*! The maximum number of interrupts that the transport supports. */
+#define HWIF2_MAX_INTERRUPT_NUM ( 8 )
+
+/*! The maximum number of devices that the driver supports. */
+#define HWIF2_MAX_DEVICES       ( 8 )
+
+/*!
+ * \brief The context parameters used on each device
+ */
+struct hwif2_ctx_params
+{
+    unsigned interrupts_set;         /*!< The active interrupts on this device */
+    int its_gpr;                     /*!< The picoArray to host handshaking GPR */
+    int itm_gpr;                     /*!< The host to picoArray handshaking GPR */
+    struct pico_resource *its;       /*!< ITS resource */
+    struct pico_resource *itm;       /*!< ITM resource */
+    struct pico_resource *irq;       /*!< IRQ resource */
+    struct picoarray *pa;            /*!< The picoArray running the context */
+    struct dma_channel *channel[HWIF2_MAX_INTERRUPT_NUM];
+                                     /*!< DMA channels attached to this context */
+};
+
+/*!
+ * \brief The basic HwIF2 module.
+ * \extends picoif_module
+ */
+struct hwif2_module
+{
+    struct picoif_module mod;        /*!< The generic module. */
+    struct hwif2_ctx_params params[HWIF2_MAX_DEVICES];
+                                     /*!< Common parameters this transport */
+};
+
+/*!
+ * \brief DMA channel parameters (one per DMA channel). 
+ */
+static struct dma_channel
+{
+    struct picoif_context   *reader;  /*!< The reader of the channel. */
+    struct pico_resource *chan;       /*!< DMA channel */
+    unsigned interruptNumber;         /*!< Interrupt number for the channel */
+    unsigned maxTransferSize;         /*!< Max transfer size in bytes */
+    unsigned intCount;                /*!< Number of interrupts queued */
+    unsigned activeChannel;           /*!< Boolean to determine if the channel 
+                                       *   is active */
+    unsigned xferSize;                /*!< Size of transfer in bytes */
+    unsigned bytesSent;               /*!< Bytes sent so far */
+    unsigned totalBytes;              /*!< Total bytes */
+    unsigned queuedBytes;             /*!< Bytes queued for transfer */
+    struct dma_fifo_t *fifo;          /*!< DMA FIFO */
+    spinlock_t lock;                  /*!< DMA parameter lock */    
+    struct hwif2_ctx_params *hwif2Ctx;/*!< Pointer to the context parameters used
+                                       *   in this channel */
+} 
+dma_channel;
+
+static void
+hwif2_destructor( struct picoif_module *module );
+
+static struct picoif_context *
+hwif2_create_trans_instance( struct picoif_module *module,
+                             const char *description,
+                             struct picoif_buf *params );
+
+static void
+hwif2_close_trans_instance( struct picoif_module *module,
+                            struct picoif_context *ctx );
+
+static ssize_t
+hwif2_write( struct picoif_module *module,
+             struct picoif_context *ctx,
+             struct picoif_buf *buf,
+             size_t len );
+
+static ssize_t
+hwif2_read( struct picoif_module *module,
+            struct picoif_context *ctx,
+            struct picoif_buf *buf,
+            size_t len );
+
+static int
+hwif2_can_write( struct picoif_module *module,
+                 struct picoif_context *ctx );
+
+static int
+hwif2_can_read( struct picoif_module *module,
+                struct picoif_context *ctx );
+
+static int
+hwif2_queue_transfer( struct dma_channel *channel,
+                      unsigned size );
+
+/*! picoIf module operations for the DMA module. */
+static struct picoif_module_ops hwif2_ops = {
+    .destructor             = hwif2_destructor,
+    .create_trans_instance  = hwif2_create_trans_instance,
+    .close_instance         = hwif2_close_trans_instance,
+    .write                  = hwif2_write,
+    .read                   = hwif2_read,
+    .can_read               = hwif2_can_read,
+    .can_write              = hwif2_can_write,
+};
+
+/*! Transport methods for the DMA transport module */
+static const char *hwif2_tmethods[] = {
+    "ul",
+};
+
+/*! The HwIF2 transport */
+static struct hwif2_module hwif2_mod ={
+    .mod = {
+        .name       = "hwif2",
+        .tmethods   = hwif2_tmethods,
+        .ops        = &hwif2_ops,
+    },
+};
+
+/*!
+ * Check if the transport can be written to.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return HwiF2 transports cannot be written and will always return 0
+ */
+static int
+hwif2_can_write( struct picoif_module *module,
+                 struct picoif_context *ctx )
+{
+    return 0;
+}
+
+/*!
+ * Check if the transport can be read from.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return Returns 1 if the transport can be read (and has data ready),
+ * 0 otherwise.
+ */
+static int
+hwif2_can_read( struct picoif_module *module,
+              struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    unsigned bytes_to_read = dma_fifo_used( channel->fifo );
+    int ret = 0;
+
+    if ( bytes_to_read )
+        return 1;
+
+    /* Start any queued transfers for this channel */
+    ret = hwif2_queue_transfer(channel, 0 );
+
+    return 0;
+}
+
+/*!
+ * Handler function for interrupts generated by a completed HwIF2 transfer. 
+ *
+ * @param cookie The channel associated with the interrupt source.
+ * @param errno The error number associated with the DMA transfer
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+hwif2_dma_handler( void *cookie,
+                   int errno )
+{
+    struct dma_channel *channel = cookie;
+    int ret = 0;
+    unsigned long flags;
+
+    if ( errno )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_ERROR, "DMA transfer terminating "
+            "with error %d (Cooke=0x%p)", errno, cookie );
+        return errno;
+    }
+
+    PRINTD( COMPONENT_HWIF2, DBG_TRACE,"transfer of %d bytes completed",
+            channel->xferSize );
+
+    /* Add data transferred to FIFO control parameters */
+    dma_fifo_add_transfer( channel->fifo, channel->xferSize );
+    spin_lock_irqsave( &channel->lock, flags );
+    channel->bytesSent += channel->xferSize;
+    channel->activeChannel = 0;
+    wake_up_interruptible( &channel->reader->readq );
+
+    if ( channel->bytesSent == channel->totalBytes )
+    {
+        channel->totalBytes = 0;
+        channel->bytesSent = 0;
+        channel->xferSize = 0;
+    }
+
+    spin_unlock_irqrestore( &channel->lock, flags );
+    ret = hwif2_queue_transfer( channel, 0 );
+
+    return ret;
+}
+
+/*!
+ * Write to the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param buf The data to be written.
+ * @param len The length of data to be written in bytes.
+ * @return Returns EINVAL as a write is not permitted for this transport
+ */
+static ssize_t
+hwif2_write( struct picoif_module *module,
+             struct picoif_context *ctx,
+             struct picoif_buf *buf,
+             size_t len )
+{
+    return -EINVAL;
+}
+
+/*!
+ * Read from the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the read.
+ * @param buf The buffer to write the data into.
+ * @param len The number of bytes requested to read.
+ * @return Returns the number of bytes read on success, negative on failure.
+ */
+static ssize_t
+hwif2_read( struct picoif_module *module,
+            struct picoif_context *ctx,
+            struct picoif_buf *buf,
+            size_t len )
+{
+    struct dma_channel *channel = ctx->private_data;
+    unsigned used_bytes=0;
+    int ret = 0;
+
+    /* Check that the length is invalid */
+    if ( len & 0x3 )
+        return -EINVAL;
+
+    /* Determine how much data is already in the FIFO */
+    used_bytes = dma_fifo_get( channel->fifo, buf, len, 0 );
+    if ( used_bytes < len )
+       used_bytes += dma_fifo_get( channel->fifo, buf, (len-used_bytes),
+                                used_bytes ); 
+
+    if ( !used_bytes )
+        return -EAGAIN;
+
+    PRINTD( COMPONENT_HWIF2, DBG_TRACE,
+            "read %u bytes (requested %u bytes)", used_bytes, len );
+
+    if ( ret )
+        return ret;
+    else
+        return used_bytes;
+}
+
+/*!
+ * Destructor for the DMA module.
+ *
+ * @param module The module being destroyed.
+ */
+static void
+hwif2_destructor( struct picoif_module *module )
+{
+}
+
+/*!
+ * Handler function for processing interrupts raised by the GPRs associated with
+ * this transport only. This function is passed to the add_irq_handler() method
+ * of the picoArray and is called when the specific GPR interrupt is raised.
+ * This function will acknowledge the interrupt, and start a DMA transfer
+ * of the required size.
+ *
+ * @param irq The irq resource that raised the interrupt.
+ * @param cookie The context associated with the GPR raising the interrupt.
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+hwif2_int_handler( struct pico_resource *irq,
+                   void *cookie )
+{
+    struct hwif2_ctx_params *params = cookie;
+    struct picoarray *pa = params->pa;
+    int ret = 0;
+    uint32_t its=0;
+    uint32_t itm=0;
+    unsigned size=0;
+    unsigned i=0;
+
+    /* Determine the cause of the interrupt */
+    ret = pa->ops->register_read( pa, params->its, &its );
+
+    if ( !its )
+        return 0;
+
+    /* swap ITM bits 8 & 9 and acknowledge interrupt */
+    itm = its & 0x00000300;
+    itm ^= 0x00000300;
+    ret = pa->ops->register_write( pa, params->itm, itm );
+
+    /* For HwIF2 uplink size (in words) is stored in bits 30:16 of GPR */
+    size = ((its >> 16) & 0x7fff) * 4;
+    if ( size == 0 )
+        return -EAGAIN;
+
+    /* Now determine the DMA channel that caused the interrupt */
+    its = its & 0xFF; /* Bits 0:7 carry interrupt number */
+
+    /* Scan through the active DMA channels to search for the appropriate
+       channel to activate */
+    for( i=0; i < HWIF2_MAX_INTERRUPT_NUM; i++ )
+    {
+        if ((params->interrupts_set & (1 << i)) & its)
+        {
+            ret = hwif2_queue_transfer( params->channel[i], size );
+            return ret;
+        }
+    }
+
+    PRINTD( COMPONENT_HWIF2, DBG_WARN,
+                "no DMA channel defined for interrupt %d",its);
+    return 0;
+}
+
+
+/*!
+ * Function that manages the queuing of packets for DMA transfer. This function
+ * will add the data (if provided) to the tail of a queue, and if there is no
+ * transfer in progress, extract the nexttransfer from the head of the queue.
+ *
+ * @param channel The DMA channel handle
+ * @param size The size of the transfer to add to the list
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+hwif2_queue_transfer( struct dma_channel *channel,
+                      unsigned size )
+{
+    unsigned maxsize=0;
+    int ret = 0;
+    struct picoarray *pa = channel->hwif2Ctx->pa;
+    unsigned long flags;
+
+    spin_lock_irqsave( &channel->lock, flags );
+
+    if ( size )
+    {
+        channel->queuedBytes += size;
+        channel->intCount++;
+
+        PRINTD( COMPONENT_HWIF2, DBG_TRACE,
+                "Transfer queued %d bytes", size );
+    }
+
+    if ( channel->activeChannel )
+    {
+        spin_unlock_irqrestore( &channel->lock, flags );
+        return 0;
+    }
+
+    if ( channel->totalBytes == 0 )
+    {
+      channel->totalBytes = channel->queuedBytes;
+      channel->queuedBytes = 0;
+    }
+
+    size = channel->totalBytes-channel->bytesSent;
+    if (size > channel->maxTransferSize )
+    {
+        PRINTD(COMPONENT_HWIF2, DBG_WARN,
+            "Transfer exceeds FIFO size or max allowed by DMA. Will truncate");
+        size = channel->maxTransferSize;
+    }
+
+    maxsize = dma_fifo_space( channel->fifo );
+    if ( size > maxsize )
+       size = maxsize;
+
+    if ( size > 0 )
+    {
+        struct scatterlist sgl;
+        sgl.dma_address = dma_fifo_get_writeptr( channel->fifo );
+        sgl.length = dma_fifo_space( channel->fifo ); /* Report the size of
+                the buffer available from the write pointer */
+        channel->xferSize = size;
+        if ( channel->xferSize > 0 )
+        {
+            PRINTD( COMPONENT_HWIF2, DBG_TRACE,
+                "Sent=%d Transfered=%d Total=%d bytes", channel->bytesSent, 
+                size, channel->totalBytes );
+
+            channel->activeChannel = 1;
+            ret = pa->ops->dma_from_device( pa, channel->chan, &sgl, size,
+                    hwif2_dma_handler, channel );
+        }
+    }
+
+    spin_unlock_irqrestore( &channel->lock, flags );
+
+    return ret;
+}
+
+/*!
+ * Create a and start the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param description The type of transport to create.
+ * @param params Extra parameters for the transport type.
+ * @return Returns the transport context on success, or an ERR_PTR on failure.
+ */
+static struct picoif_context *
+hwif2_create_trans_instance( struct picoif_module *module,
+                             const char *description,
+                             struct picoif_buf *params )
+{
+    int ret = -ENOMEM;
+    void *private_data = NULL;
+    struct picoif_context *ctx = picoif_new_ctx( module, private_data );
+    struct picoif_hwif2_params gparams;
+    struct picoarray *pa = NULL;
+    struct dma_channel *channel;
+    struct pico_resource *chan = NULL;
+    enum picoarray_device_type dev_type;
+    struct pico_resource *its_irq = NULL;
+
+    ret = picoif_buf_copy_from( &gparams, params, 0,
+                                sizeof( gparams ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    pa = picoif_get_device( gparams.dev_num );
+    if ( !pa )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_WARN, "invalid device number: %u",
+                gparams.dev_num );
+        goto out;
+    }
+
+    dev_type = pa->ops->get_device_type( pa );
+    if ( !( PICOARRAY_PC202 == dev_type || PICOARRAY_PC302 == dev_type ) )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_WARN,
+                "device not supported for this transport" );
+        goto out;
+    }
+
+    /* Check that the DMA channel is not already in use */
+    ret = -EBUSY;
+    chan = pa->ops->get_resource( pa, PICO_RES_DMA_CHANNEL,
+                                             gparams.channel, 1 );
+    if ( !chan )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_ERROR, "invalid DMA channel:%u",
+                gparams.channel );
+        goto out;
+    }
+
+    /* Check that the interrupt number is valid */
+    if (gparams.dev_num >= HWIF2_MAX_INTERRUPT_NUM)
+        goto out;
+
+    /* If this is the first transport on the device, set the context
+       parameters */
+    if ( !hwif2_mod.params[gparams.dev_num].interrupts_set )
+    {
+        struct pico_resource *its_gpr = pa->ops->get_resource( pa,
+            PICO_RES_GPR, gparams.its_gpr, 1 );
+        struct pico_resource *itm_gpr = pa->ops->get_resource( pa,
+            PICO_RES_GPR, gparams.itm_gpr, 1 );
+
+        its_irq = pa->ops->get_resource( pa, PICO_RES_IRQ, 
+                its_gpr->metadata, 1 );
+
+        ret = -EBUSY;
+        if (( !its_gpr ) || ( !itm_gpr ) || ( !its_irq ))
+        {
+            if ( !its_gpr )
+                PRINTD( COMPONENT_HWIF2, DBG_WARN, "unable to get its gpr: %u",
+                        gparams.its_gpr );
+            else
+                pa->ops->put_resource( pa, its_gpr );
+                
+            if ( !itm_gpr )
+                PRINTD( COMPONENT_HWIF2, DBG_WARN, "unable to get itm gpr: %u",
+                        gparams.itm_gpr );
+            else
+                pa->ops->put_resource( pa, itm_gpr );
+
+            if ( !its_irq )
+                PRINTD( COMPONENT_HWIF2, DBG_WARN, "unable to get irq: %u",
+                        gparams.its_gpr );
+            else
+                pa->ops->put_resource( pa, its_irq );
+             
+            goto out;
+        }
+
+        hwif2_mod.params[gparams.dev_num].interrupts_set |= (1 << gparams.int_num);
+        hwif2_mod.params[gparams.dev_num].its_gpr = gparams.its_gpr;
+        hwif2_mod.params[gparams.dev_num].itm_gpr = gparams.itm_gpr;
+        hwif2_mod.params[gparams.dev_num].its = its_gpr;
+        hwif2_mod.params[gparams.dev_num].itm = itm_gpr;
+        hwif2_mod.params[gparams.dev_num].irq = its_irq;
+        hwif2_mod.params[gparams.dev_num].pa = pa;
+    }
+    else
+    { /* Check that the common parameters are consistant */
+        if (( gparams.its_gpr != hwif2_mod.params[gparams.dev_num].its_gpr ) ||
+            ( gparams.itm_gpr != hwif2_mod.params[gparams.dev_num].itm_gpr ) ||
+            ( hwif2_mod.params[gparams.dev_num].interrupts_set &
+                                                        (1 << gparams.int_num) ))
+            goto out;
+
+        hwif2_mod.params[gparams.dev_num].interrupts_set |= (1 << gparams.int_num); 
+    }
+
+    if ( !ctx )
+        goto out;
+
+    /* Allocate the new channel and initialise the data members. */
+    ret = -ENOMEM;
+    channel = kmalloc( sizeof( dma_channel ), GFP_KERNEL );
+    if (!channel)
+        goto out;
+    ctx->private_data = channel;
+ 
+    ret = dma_fifo_create( &channel->fifo, gparams.buf_size );
+    if (ret)
+        goto bad_fifo_alloc;
+
+    channel->reader = ctx;
+    channel->hwif2Ctx = &hwif2_mod.params[gparams.dev_num]; 
+    channel->interruptNumber = gparams.int_num;
+    if ( gparams.buf_size > pa->max_dma_sz )
+        channel->maxTransferSize = pa->max_dma_sz;
+    else
+        channel->maxTransferSize = gparams.buf_size;
+    channel->chan = chan;
+    channel->intCount = 0;
+    channel->xferSize = 0;
+    channel->bytesSent = 0;
+    channel->totalBytes = 0;
+    channel->activeChannel = 0;
+    channel->queuedBytes = 0;
+    hwif2_mod.params[gparams.dev_num].channel[gparams.int_num] = channel;
+
+    spin_lock_init( &channel->lock );
+
+    if ( strcmp( description, "hwif2(ul)" ) )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_ERROR, "invalid tmethod \"%s\"",
+                description );
+        ret = -EINVAL;
+        goto bad_description;
+    }
+
+    ret = pa->ops->dma_open( pa, chan, 0 );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_ERROR, "failed to open DMA channel" );
+        goto bad_description;
+    }
+
+    if ( its_irq )
+    {
+        ret = pa->ops->add_irq_handler( pa, its_irq, hwif2_int_handler,
+                                    channel->hwif2Ctx );
+        if ( ret )
+        {
+            PRINTD( COMPONENT_HWIF2, DBG_ERROR,
+                "failed to register interrupt handler" );
+            goto handler_reg_failed;
+        }
+    }
+
+    ret = 0;
+    goto out;
+
+bad_description:
+handler_reg_failed:
+   dma_fifo_destroy( channel->fifo );
+
+bad_fifo_alloc:
+    kfree( channel );
+
+out:
+    if ( ret )
+    {
+        kfree( ctx );
+        if ( chan )
+            pa->ops->put_resource(  pa, chan );
+    }
+
+    return ret ? ERR_PTR( ret ) : ctx;
+}
+
+/*!
+ * Close an existing transport instance.
+ *
+ * @param mod The module handling the transport.
+ * @param ctx The context that is being closed.
+ */
+static void
+hwif2_close_trans_instance( struct picoif_module *mod,
+                          struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->hwif2Ctx->pa;
+    unsigned interrupt_bit = ((uint32_t)1) << channel->interruptNumber;
+    struct hwif2_ctx_params *params = channel->hwif2Ctx;
+    (void)pa->ops->dma_close( pa, channel->chan );
+
+    PRINTD( COMPONENT_HWIF2, DBG_TRACE, "close transport instance" );
+
+    pa->ops->put_resource( pa, channel->chan );
+    dma_fifo_destroy( channel->fifo );
+
+    params->interrupts_set &= ( !interrupt_bit );
+    params->channel[channel->interruptNumber] = NULL;
+
+    if ( !params->interrupts_set )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_TRACE,
+                "no further hwif users for device %u", pa->dev_num );
+        pa->ops->remove_irq_handler( pa, params->irq );
+        pa->ops->put_resource( pa, params->its );
+        pa->ops->put_resource( pa, params->itm );
+        pa->ops->put_resource( pa, params->irq );
+    }
+
+    if ( channel )
+        kfree( channel );
+
+    if ( ctx )
+        kfree( ctx );
+
+    PRINTD( COMPONENT_HWIF2, DBG_TRACE, "transport instance closed" );
+}
+
+/* Kernel API and Public functions */
+struct picoif_context *
+picoif_hwif2_dmaul_open( const picoif_hwif2_t hwif2_context,
+                         unsigned interrupt_number,
+                         int dma_channel,
+                         size_t buffer_size )
+{
+    struct picoif_hwif2_params hwif2_params = {
+        .dev_num    = hwif2_context->dev_num,
+        .int_num    = interrupt_number,
+        .channel    = dma_channel,
+        .buf_size   = buffer_size,
+        .its_gpr    = hwif2_context->its_gpr,
+        .itm_gpr    = hwif2_context->itm_gpr,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &hwif2_params,
+        .is_user    = 0,
+    };
+    struct picoif_context *ctx =
+        hwif2_create_trans_instance( &hwif2_mod.mod,
+                                       "hwif2(ul)", &buf );
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_hwif2_dmaul_open );
+
+int
+hwif2_init( void )
+{
+    memset(hwif2_mod.params, sizeof ( hwif2_mod.params ), 0 );
+
+    return picoif_register_module( &hwif2_mod.mod );
+}
+
+
diff --git a/drivers/picochip/hwif2_internal.h b/drivers/picochip/hwif2_internal.h
new file mode 100644
index 0000000..38a3eb1
--- /dev/null
+++ b/drivers/picochip/hwif2_internal.h
@@ -0,0 +1,33 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file hwif2_internal.h
+ * \brief Initialisation function for HwIF2 transport.
+ *
+ * Internal HwIF2 transport function definitions
+ */
+
+#ifndef __PICOIF_HWIF2_INTERNAL_H__
+#define __PICOIF_HWIF2_INTERNAL_H__
+
+/*!
+ * Initialise the HwIF2 transport.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+hwif2_init( void );
+
+#endif /* !__PICOIF_HWIF2_INTERNAL_H__ */
diff --git a/drivers/picochip/hwif_internal.h b/drivers/picochip/hwif_internal.h
new file mode 100644
index 0000000..9cd93d7
--- /dev/null
+++ b/drivers/picochip/hwif_internal.h
@@ -0,0 +1,33 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file hwif_internal.h
+ * \brief Initialisation function for HwIF transport.
+ *
+ * Internal HwIF function definitions
+ */
+
+#ifndef __PICOIF_HWIF_INTERNAL_H__
+#define __PICOIF_HWIF_INTERNAL_H__
+
+/*!
+ * Initialise the HwI2 transport.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+hwif_init( void );
+
+#endif /* !__PICOIF_HWIF_INTERNAL_H__ */
diff --git a/drivers/picochip/pc202.c b/drivers/picochip/pc202.c
new file mode 100644
index 0000000..70f0298
--- /dev/null
+++ b/drivers/picochip/pc202.c
@@ -0,0 +1,1793 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file pc202.c
+ * \brief PC202 device implementation.
+ *
+ * This file implements the PC202 support of picoIf. All implementation in
+ * this file is private and should not be accessed directly by users and only
+ * provides the necessary basic services with which transports can be built
+ * upon and devices configured.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include <linux/picochip/devices/pc202.h>
+#include "picoarray.h"
+#include "resource.h"
+#include "picoif_internal.h"
+#include "procif.h"
+#include "debug.h"
+#include "soft_reset.h"
+#include "utilities_internal.h"
+#include "procif.h"
+
+/*! The offset of the data register for a virtual port in the AHB2Pico. */
+#define AHB2PICO_VP_DATA            ( 0x08 )
+
+/*! The address of the AHB2Pico interrupt status register. This is an offset
+ * from the AHB2Pico base address. */
+#define AHB2PICO_INT_STATUS_OFFSET  ( 0x01E0 )
+
+/*! The number of virtual ports in the AHB2Pico. */
+#define AHB2PICO_NUM_VPS           ( 32 )
+
+/*! The CAEID of the procif. */
+#define PC202_PROCIF_CAEID          ( 0x48 )
+/*! The offset in the procif for the operation request register. */
+#define PC202_PROCIF_OP_REQ_OFFSET  ( 0x4018 )
+/*! The offset in the procif for the operation status register. */
+#define PC202_PROCIF_OP_STATUS_OFFSET  ( 0x401c )
+/*! The offset of the start request bit in the operation request register. */
+#define PC202_PROCIF_OP_REQ_START   ( 1 << 1 )
+/*! The offset of the sync request bit in the operation request register. */
+#define PC202_PROCIF_OP_REQ_SYNC    ( 1 << 0 )
+
+/*! The offset of a virtual port config register from the virtual port
+ *  register base. */
+#define AHB2PICO_VP_CONFIG_OFFSET   ( 0x00 )
+/*! The offset of a virtual port status register from the virtual port
+ *  register base. */
+#define AHB2PICO_VP_STATUS_OFFSET   ( 0x04 )
+/*! The offset of a virtual port data register from the virtual port
+ *  register base. */
+#define AHB2PICO_VP_DATA_OFFSET     ( 0x08 )
+/*! The spacing of virtual ports in the AHB2Pico. */
+#define AHB2PICO_VP_SPACING         ( 0x10 )
+
+/*! The number of DMACs in the system */
+#define PICO_NUM_DMACS              ( 0x02)
+
+/*! The FIFO size for the DMA tasklet */
+#define DMA_FIFO_SIZE               ( 9 )
+
+/*! DMA burst size in words */
+#define PC202_DMA_BURST_SIZE        ( 1 )
+
+/*! The maximum number of transactions per transfer */
+#define DMAH_CHX_MAX_BLK_SIZE       ( 4095 )
+
+/*! Determine the msize and max transfer size that is permitted */
+#if ((PC202_DMA_BURST_SIZE == 1) || (PC202_DMA_BURST_SIZE == 2))
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = MS_1_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 4)
+#elif (PC202_DMA_BURST_SIZE == 4)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = MS_4_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 8)
+#elif (PC202_DMA_BURST_SIZE == 8)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = MS_8_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 16)
+#elif (PC202_DMA_BURST_SIZE == 16)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = MS_16_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 32)
+#elif (PC202_DMA_BURST_SIZE == 32)   
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = MS_32_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 64)
+#else
+    #error
+#endif
+
+/*!
+ * Determine if a GPR port is enabled
+ *
+ * @param _sr The value of the status register for the VP.
+ * @return Returns non-zero if the VP is enabled, zero otherwise.
+ */
+#define IS_PORT_ENABLED( _sr ) ( _sr & 0x1 )
+
+/*!
+ *  Determine if a GPR port is configured as a receive port
+ *
+ *  @param _sr The value of the status register for the VP.
+ *  @return Returns non-zero if the VP is configured as a receive port
+ *  (pA->ARM), zero otherwise.
+ */
+#define IS_PORT_A_RECEIVE( _sr ) ( _sr & 0x2 )
+
+/*!
+ *  Determine if a GPR port is configured as a non blocking port
+ *
+ *  @param _sr The value of the status register for the VP.
+ *  @return Returns non-zero if the VP is configured as non-blocking, zero
+ *  otherwise.
+ */
+#define IS_PORT_NONBLOCKING( _sr ) ( _sr & 0x4 )
+
+/*!
+ *  Determine if a GPR port is ready to give or receive data
+ *
+ *  @param _sr The value of the status register for the VP.
+ *  @return Returns non-zero if the VP can accept data, zero otherwise.
+ */
+#define IS_PORT_READY_FOR_DATA( _sr ) ( _sr & 0x8 )
+
+/*! The number of registered PC202s in the system. Until this reaches zero, we
+ * can't unregister the platform driver. */
+static unsigned num_pc202s;
+
+static void
+pc202_destroy( struct picoarray *pa );
+
+/*!
+ * \brief PC202 IRQ handler.
+ *
+ * This structure defines an IRQ handler for PC202 devices and is an internal
+ * structure that could be reused for other device types.
+ */
+struct pc202_irq_handler
+{
+    /*! The position in the list of handlers for an interrupt source. */
+    struct list_head        list;
+
+    /*! The IRQ that this handles. */
+    struct pico_resource    *irq;
+
+    /*! A cookie to pass to the callback function when the interrupt is
+     * raised. */
+    void                    *cookie;
+
+    /*! The callback function to call when the interrupt is raised. */
+    int                     ( *callback )( struct pico_resource *irq,
+                                           void *cookie );
+};
+
+/*!
+ * \brief PC202 DMA tasklet FIFO parameters.
+ *
+ * This structure defines a small FIFO used by a tasklet for DMA transfers
+ */
+struct pc202_dma_fifo_params
+{
+    /*!< DMA channel */
+    struct pc202_dma_channel *dma;
+
+    /*!< Error number associated with the transfer */
+    int errno;
+};
+
+/*!
+ * \brief PC202 DMA tasklet structure.
+ *
+ * This structure defines a small FIFO used by a tasklet for DMA transfers
+ */
+struct pc202_dma_fifo
+{
+    /*!< FIFO read pointer */
+    unsigned                readPtr;
+
+    /*!< FIFO write pointer */
+    unsigned                writePtr;
+
+    /*!< FIFO parameters */
+    struct pc202_dma_fifo_params fifo[DMA_FIFO_SIZE];
+};
+
+/*!
+ * \brief PC202 DMA handler
+ *
+ * This structure defines a DMA handler for PC202 devices and is an internal
+ * strucutre that might be reused for other device types that uses the Synopsys
+ * DMAC. There will be one instance of this structure per DMA channel in the
+ * system.
+ */
+struct pc202_dma_channel
+{
+    /*! Structure holding the current transfer details */
+    firecracker_dma_xfr_t xfr;
+
+    /*! Definition of the hardware handshaking interface set for this channel */
+    firecracker_dma_handshake_t hs;
+
+    /*! Identification of the DMAC connected to this channel */
+    firecracker_dma_t dmac;
+
+    /*! Scatter / gather list for this channel */
+    firecracker_dma_list_t sgl;
+
+    /*! picoArray DMA channel number */
+    unsigned channel;
+
+    /*! Channel status (1 for active and 0 for waiting */
+    int stateActive;
+
+    /*! Physical address for the picoArray DMA channel */
+    dma_addr_t pico_addr;
+
+    /*! Call back function to execute when the interrupt is raised */
+    int ( *handler )( void *cookie,
+                      int errno );
+
+    /*! User data to be supplied to the callback function */
+    void *cookie;
+
+    /*! Pointer to parent structure */
+    struct pc202 *dev;
+};
+
+/*!
+ * \brief Private representation of a PC202 device.
+ *
+ * This describes all private data required in the PC202 implementation of
+ * this driver.
+ *
+ * \extends picoarray
+ */
+struct pc202
+{
+    /*! The picoArray base class. */
+    struct picoarray            pa;
+
+    /*! The physical address of the procif registers. */
+    dma_addr_t                  reg_base_phys;
+
+    /*! The length of the procif registers in bytes. */
+    size_t                      reg_base_len;
+
+    /*! The virtually mapped address of the procif registers. */
+    void __iomem                *reg_base;
+
+    /*! The physical address of the AHB2Pico registers. */
+    dma_addr_t                  ahb_base_phys;
+
+    /*! The length of the AHB2Pico registers in bytes. */
+    size_t                      ahb_base_len;
+
+    /*! The virtually mappped address of the AHB2Pico registers. */
+    void __iomem                *ahb_base;
+
+    /*! The physical address of the CCR register. */
+    dma_addr_t                  ccr_base_phys;
+
+    /*! The length of the CCR register in bytes. */
+    size_t                      ccr_base_len;
+
+    /*! The virtually mappped address of the CCR register. */
+    void __iomem                *ccr_base;
+
+    /*! The procif IRQ number. */
+    unsigned                    procif_irq;
+
+    /*! The AHB2Pico IRQ number. The AHB2Pico supports a number of interrupt
+     * sources, but these are all raised through a single IRQ line. */
+    unsigned                    ahb2pico_irq;
+
+    /*! The handlers registered for the procif IRQ. */
+    struct pc202_irq_handler    procif_irq_handlers;
+
+    /*! The handlers registered for the AHB2Pico IRQ. */
+    struct pc202_irq_handler    ahb2pico_irq_handlers;
+
+    /*! The DMAC 1 IRQ number. */
+    unsigned                    dma1_irq;
+
+    /*! The DMAC2 IRQ number. */
+    unsigned                    dma2_irq;
+
+    /*! DMA channel data */
+    struct pc202_dma_channel    dma_channel[PICO_NUM_DMA_CHANNELS];
+
+    /*! DMA tasklet FIFO */
+    struct pc202_dma_fifo       dma_fifo;
+
+    /*! DMA tasklet structure */
+    struct tasklet_struct       dma_tasklet;
+};
+
+/*!
+ * Get the PC202 structure given a picoArray base class.
+ *
+ * @param pa The base class pointer.
+ * @return Returns a pointer to the PC202 structure on success, NULL on
+ * failure.
+ */
+static inline struct pc202 *
+to_pc202( struct picoarray *pa )
+{
+    return pa ? container_of( pa, struct pc202, pa ) : NULL;
+}
+
+/*!
+ * Write the value of an AHB2Pico register.
+ *
+ * @param dev The PC202 owning the AHB2Pico.
+ * @param offset The offset of the register in bytes.
+ * @param value The value of the register to write.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_ahb2pico_reg_write( struct pc202 *dev,
+                          unsigned offset,
+                          u32 value )
+{
+    PRINTD( COMPONENT_PC202, DBG_TRACE, "pA[%u] ahb2pico, %04x:=%08x",
+            dev->pa.dev_num, offset, value );
+    picoif_out32( value, dev->ahb_base + offset );
+    return 0;
+}
+
+/*!
+ * Read the value of an AHB2Pico register.
+ *
+ * @param dev The PC202 owning the AHB2Pico.
+ * @param offset The offset of the register in bytes.
+ * @param[out] value Pointer to the address to store the register value in.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_ahb2pico_reg_read( struct pc202 *dev,
+                         unsigned offset,
+                         u32 *value )
+{
+    *value = picoif_in32( dev->ahb_base + offset );
+    return 0;
+}
+
+/*!
+ * Read a number of 16 bit words from the PC202 procif.
+ *
+ * @param pa The device to read from.
+ * @param caeid The CAEID of the AE to read from.
+ * @param address The start address in the AE to begin reading from.
+ * @param count The number of 16 bit words to read.
+ * @param[out] data The buffer to store the data in.
+ * @return Returns the number of words read on success, negative on failure.
+ */
+static int
+pc202_config_read( struct picoarray *pa,
+                   u16 caeid,
+                   u16 address,
+                   u16 count,
+                   u16 *data )
+{
+    struct pc202 *dev = to_pc202( pa );
+
+    PRINTD( COMPONENT_PC202, DBG_TRACE,
+            "pa[%u]: config read %u words %04x@%04x", pa->dev_num,
+            count, caeid, address );
+
+    return procif_config_read( dev->reg_base, caeid, address, data, count );
+}
+
+/*!
+ * Write a number of 16 bit words to the PC202 procif.
+ *
+ * @param pa The device to write to.
+ * @param caeid The CAEID of the AE to write to.
+ * @param address The start address in the AE to begin writing to.
+ * @param count The number of 16 bit words to write.
+ * @param[in] data The buffer to write from.
+ * @return Returns the number of words written on success, negative on failure.
+ */
+static int
+pc202_config_write( struct picoarray *pa,
+                    u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *data )
+{
+    struct pc202 *dev = to_pc202( pa );
+
+    PRINTD( COMPONENT_PC202, DBG_TRACE,
+            "pa[%u]: config write %u words %04x@%04x", pa->dev_num,
+            count, caeid, address );
+
+    return procif_config_write( dev->reg_base, caeid, address, data, count );
+}
+
+/*!
+ * Sync the PC202 device.
+ *
+ * @param pa The device to sync.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_sync( struct picoarray *pa )
+{
+    u16 val;
+
+    /* Read the current operation status register value. */
+    int ret = pa->ops->config_read( pa, PC202_PROCIF_CAEID,
+                                    PC202_PROCIF_OP_STATUS_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    /* If we are running, don't try and sync. */
+    ret = 0;
+    if ( val & PC202_PROCIF_OP_REQ_START )
+        goto out;
+
+    /* Read the current operation request register value. */
+    ret = pa->ops->config_read( pa, PC202_PROCIF_CAEID,
+                                    PC202_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    /* Set the sync request bit. */
+    val |= PC202_PROCIF_OP_REQ_SYNC;
+    ret = pa->ops->config_write( pa, PC202_PROCIF_CAEID,
+                                 PC202_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Start the PC202 device running.
+ *
+ * @param pa The device to start.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_start( struct picoarray *pa )
+{
+    u16 val;
+    int ret = pa->ops->config_read( pa, PC202_PROCIF_CAEID,
+                                    PC202_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+    val |= PC202_PROCIF_OP_REQ_START;
+    ret = pa->ops->config_write( pa, PC202_PROCIF_CAEID,
+                                 PC202_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Stop the PC202 device running.
+ *
+ * @param pa The device to stop.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_stop( struct picoarray *pa )
+{
+    u16 val;
+    int ret = pa->ops->config_read( pa, PC202_PROCIF_CAEID,
+                                    PC202_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+    val &= ~PC202_PROCIF_OP_REQ_START;
+    ret = pa->ops->config_write( pa, PC202_PROCIF_CAEID,
+                                 PC202_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Reset the PC202. This performs a soft reset that returns the picoArray to
+ * be as close as possible to the hardware reset state without affecting the
+ * ARM subsystem.
+ *
+ * @param pa The device being reset.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_reset( struct picoarray *pa )
+{
+    struct pc202 *dev = to_pc202( pa );
+    unsigned long flags;
+
+    PRINTD( COMPONENT_PC202, DBG_TRACE, "pa[%u]: reset", pa->dev_num );
+
+    spin_lock_irqsave( &pa->lock, flags );
+    picoArraySoftReset( dev->reg_base, dev->ahb_base );
+    spin_unlock_irqrestore( &pa->lock, flags );
+
+    return 0;
+}
+
+/*!
+ * Read a GPR (general purpose register) in the PC202.
+ *
+ * @param pa The device being read from.
+ * @param reg The register to read.
+ * @param[out] value The address to store the register value in.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_register_read( struct picoarray *pa,
+                     struct pico_resource *reg,
+                     u32 *value )
+{
+    struct pc202 *dev = to_pc202( pa );
+    int ret = -EINVAL;
+
+    if ( !reg || PICO_RES_GPR != reg->type )
+        goto out;
+
+    if ( reg->value < PC202_GPR_PROCIF_0 ||
+         reg->value > PC202_GPR_AHB2PICO_23 )
+        goto out;
+
+    if ( reg->value >= PC202_GPR_PROCIF_0 &&
+         reg->value <= PC202_GPR_ITS )
+    {
+        procif_reg_read( dev->reg_base, reg->offset, value );
+
+        ret = 0;
+    }
+    else
+    {
+        u32 status;
+        pc202_ahb2pico_reg_read( dev, reg->offset + AHB2PICO_VP_STATUS_OFFSET,
+                                 &status );
+        ret = -EAGAIN;
+        /* For non-blocking GPR's, we only check if they are enabled and
+         * receive GPR's. If they are blocking GPRs then we need to check that
+         * there is some data to read. */
+        if ( !IS_PORT_ENABLED( status ) ||
+             !IS_PORT_A_RECEIVE( status ) ||
+             ( !IS_PORT_NONBLOCKING( status ) &&
+               !IS_PORT_READY_FOR_DATA( status ) ) )
+            goto out;
+        pc202_ahb2pico_reg_read( dev, reg->offset + AHB2PICO_VP_DATA,
+                                 value );
+        ret = 0;
+    }
+
+out:
+    return ret;
+}
+
+/*!
+ * Write a GPR (general purpose register) in the PC202.
+ *
+ * @param pa The device being written to.
+ * @param reg The register to write.
+ * @param value The value to write to the register.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_register_write( struct picoarray *pa,
+                      struct pico_resource *reg,
+                      u32 value )
+{
+    struct pc202 *dev = to_pc202( pa );
+    int ret = -EINVAL;
+
+    if ( !reg || PICO_RES_GPR != reg->type )
+    {
+        goto out;
+    }
+
+    if ( reg->value < PC202_GPR_PROCIF_0 ||
+         reg->value > PC202_GPR_AHB2PICO_23 )
+    {
+        goto out;
+    }
+
+    if ( reg->value >= PC202_GPR_PROCIF_0 &&
+         reg->value <= PC202_GPR_ITS )
+    {
+        procif_reg_write( dev->reg_base, reg->offset, value );
+        ret = 0;
+    }
+    else
+    {
+        u32 status;
+        pc202_ahb2pico_reg_read( dev, reg->offset + AHB2PICO_VP_STATUS_OFFSET,
+                                 &status );
+        ret = -EAGAIN;
+        /* For non-blocking GPR's, we only check if they are enabled and
+         * send GPR's. If they are blocking GPRs then we need to check that
+         * there is some space to accept the value. */
+        if ( !IS_PORT_ENABLED( status ) ||
+             IS_PORT_A_RECEIVE( status ) ||
+             ( !IS_PORT_NONBLOCKING( status ) &&
+               !IS_PORT_READY_FOR_DATA( status ) ) )
+            goto out;
+        pc202_ahb2pico_reg_write( dev, reg->offset + AHB2PICO_VP_DATA,
+                                  value );
+        ret = 0;
+    }
+
+out:
+    return ret;
+}
+
+/*!
+ * Load the picoArray specified with the array of data
+ *
+ * @param pa The device being written to.
+ * @param data The virtual address of the buffer to write
+ * @param sgl The scatter gather list of the source data.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_pa_load( struct picoarray *pa,
+               u32 *data,
+               struct scatterlist *sgl )
+{
+    struct pc202 *dev = to_pc202( pa );
+    unsigned i;
+    int ret = 0;
+
+    PRINTD( COMPONENT_PC202, DBG_TRACE, "pa[%u]: config reg "
+            "write %u words", pa->dev_num, sgl->length );
+
+    for( i=0; i < sgl->length ; i++)
+    {
+        ret = procif_reg_write( dev->reg_base,
+                           PROCIF_REG_CFG_WR_OFFSET, data[i] );
+        /* Do not need to check return value, it is always true */
+    }
+ 
+    return i;
+
+}
+
+/*! The resources for a PC202 device. */
+static struct pico_resource pc202_resources[] = {
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC202_DMA_PROCIF_0, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC202_DMA_PROCIF_1, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC202_DMA_PROCIF_2, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC202_DMA_PROCIF_3, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC202_DMA_AHB2PICO_0, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC202_DMA_AHB2PICO_1, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC202_DMA_AHB2PICO_2, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC202_DMA_AHB2PICO_3, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_0, .offset = 0x0, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_1, .offset = 0x4, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_2, .offset = 0x8, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_3, .offset = 0xc, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_4, .offset = 0x10, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_5, .offset = 0x14, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_6, .offset = 0x18, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_7, .offset = 0x1c, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_8, .offset = 0x20, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_9, .offset = 0x24, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_10, .offset = 0x28, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_11, .offset = 0x2c, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_12, .offset = 0x30, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_13, .offset = 0x34, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_14, .offset = 0x38, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_15, .offset = 0x3c, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_16, .offset = 0x40, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_17, .offset = 0x44, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_18, .offset = 0x48, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_19, .offset = 0x4c, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_20, .offset = 0x54, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_21, .offset = 0x5c, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_22, .offset = 0x64, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_PROCIF_23, .offset = 0x6c, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_ITM, .offset = 0x70, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_ITS, .offset = 0x74, },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_0, .metadata = PC202_IRQ_AHB2PICO_0, .offset = 0x40 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_1, .metadata = PC202_IRQ_AHB2PICO_1, .offset = 0x50 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_2, .metadata = PC202_IRQ_AHB2PICO_2, .offset = 0x60 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_3, .metadata = PC202_IRQ_AHB2PICO_3, .offset = 0x70 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_4, .metadata = PC202_IRQ_AHB2PICO_4, .offset = 0x80 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_5, .metadata = PC202_IRQ_AHB2PICO_5, .offset = 0x90 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_6, .metadata = PC202_IRQ_AHB2PICO_6, .offset = 0xa0 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_7, .metadata = PC202_IRQ_AHB2PICO_7, .offset = 0xb0 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_8, .metadata = PC202_IRQ_AHB2PICO_8, .offset = 0xc0 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_9, .metadata = PC202_IRQ_AHB2PICO_9, .offset = 0xd0 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_10, .metadata = PC202_IRQ_AHB2PICO_10, .offset = 0xe0 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_11, .metadata = PC202_IRQ_AHB2PICO_11, .offset = 0xf0 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_12, .metadata = PC202_IRQ_AHB2PICO_12, .offset = 0x100 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_13, .metadata = PC202_IRQ_AHB2PICO_13, .offset = 0x110 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_14, .metadata = PC202_IRQ_AHB2PICO_14, .offset = 0x120 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_15, .metadata = PC202_IRQ_AHB2PICO_15, .offset = 0x130 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_16, .metadata = PC202_IRQ_AHB2PICO_16, .offset = 0x140 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_17, .metadata = PC202_IRQ_AHB2PICO_17, .offset = 0x150 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_18, .metadata = PC202_IRQ_AHB2PICO_18, .offset = 0x160 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_19, .metadata = PC202_IRQ_AHB2PICO_19, .offset = 0x170 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_20, .metadata = PC202_IRQ_AHB2PICO_20, .offset = 0x180 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_21, .metadata = PC202_IRQ_AHB2PICO_21, .offset = 0x190 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_22, .metadata = PC202_IRQ_AHB2PICO_22, .offset = 0x1a0 },
+    { .type = PICO_RES_GPR, .value = PC202_GPR_AHB2PICO_23, .metadata = PC202_IRQ_AHB2PICO_23, .offset = 0x1b0 },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_0, .metadata = PC202_GPR_AHB2PICO_0, .offset = 4, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_1, .metadata = PC202_GPR_AHB2PICO_1, .offset = 5, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_2, .metadata = PC202_GPR_AHB2PICO_2, .offset = 6, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_3, .metadata = PC202_GPR_AHB2PICO_3, .offset = 7, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_4, .metadata = PC202_GPR_AHB2PICO_4, .offset = 8, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_5, .metadata = PC202_GPR_AHB2PICO_5, .offset = 9, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_6, .metadata = PC202_GPR_AHB2PICO_6, .offset = 10, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_7, .metadata = PC202_GPR_AHB2PICO_7, .offset = 11, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_8, .metadata = PC202_GPR_AHB2PICO_8, .offset = 12, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_9, .metadata = PC202_GPR_AHB2PICO_9, .offset = 13, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_10, .metadata = PC202_GPR_AHB2PICO_10, .offset = 14, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_11, .metadata = PC202_GPR_AHB2PICO_11, .offset = 15, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_12, .metadata = PC202_GPR_AHB2PICO_12, .offset = 16, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_13, .metadata = PC202_GPR_AHB2PICO_13, .offset = 17, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_14, .metadata = PC202_GPR_AHB2PICO_14, .offset = 18, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_15, .metadata = PC202_GPR_AHB2PICO_15, .offset = 19, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_16, .metadata = PC202_GPR_AHB2PICO_16, .offset = 20, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_17, .metadata = PC202_GPR_AHB2PICO_17, .offset = 21, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_18, .metadata = PC202_GPR_AHB2PICO_18, .offset = 22, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_19, .metadata = PC202_GPR_AHB2PICO_19, .offset = 23, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_20, .metadata = PC202_GPR_AHB2PICO_20, .offset = 24, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_21, .metadata = PC202_GPR_AHB2PICO_21, .offset = 25, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_22, .metadata = PC202_GPR_AHB2PICO_22, .offset = 26, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_AHB2PICO_23, .metadata = PC202_GPR_AHB2PICO_23, .offset = 27, },
+    { .type = PICO_RES_IRQ, .value = PC202_IRQ_PROCIF },
+    { .type = 0, .value = 0 }, /* Sentinel value. Do not remove and keep this
+                                * at the end. */
+};
+
+/*! The offset in the AHB2Pico for GPR virtual ports. */
+#define AHB2PICO_GPR_VP_START       ( 0x40 )
+
+/*! The position of the interrupt enable bit in a virtual port config
+ *  register. */
+#define AHB2PICO_INT_EN             ( 1 << 0 )
+
+/*!
+ * Add an IRQ handler to the PC202 for a given interrupt source.
+ *
+ * @param pa The device to register the interrupt handler with.
+ * @param irq The IRQ to attach the handler to.
+ * @param callback The callback function to call when the interrupt is
+ * raised.
+ * @param cookie The cookie to pass to the callback function. This may be NULL
+ * if it is not required.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_add_irq_handler( struct picoarray *pa,
+                       struct pico_resource *irq,
+                       int ( *callback )( struct pico_resource *irq,
+                                          void *cookie ),
+                       void *cookie )
+{
+    struct pc202_irq_handler *handler = NULL;
+    struct pc202 *dev = to_pc202( pa );
+    int ret = -ENOMEM;
+    unsigned long flags;
+
+    if ( irq->type != PICO_RES_IRQ || !irq->exclusive || !callback )
+        return -EINVAL;
+
+    spin_lock_irqsave( &pa->lock, flags );
+
+    handler = kmalloc( sizeof( *handler ), GFP_KERNEL );
+    if ( !handler )
+        goto out;
+
+    handler->callback   = callback;
+    handler->cookie     = cookie;
+    handler->irq        = irq;
+
+    /* If this is an AHB2Pico IRQ, then lets enable the interrupt. */
+    if ( PC202_IRQ_PROCIF != irq->value )
+    {
+        unsigned gpr_num = irq->value - PC202_IRQ_AHB2PICO_0;
+        unsigned offset =
+            AHB2PICO_GPR_VP_START + ( gpr_num * AHB2PICO_VP_SPACING );
+        u32 val;
+
+        /* Read the status register. */
+        pc202_ahb2pico_reg_read( dev, offset + AHB2PICO_VP_STATUS_OFFSET,
+                                 &val );
+        /* If the port is non-blocking then fail as we will receive constant
+         * interrupts. We also only support receive GPRs for interrupt
+         * generation. */
+        if ( !IS_PORT_A_RECEIVE( val ) || IS_PORT_NONBLOCKING( val ) )
+        {
+            PRINTD( COMPONENT_PC202, DBG_WARN,
+                    "cannot enable IRQ: AHB2Pico VP is not"
+                    " configured as blocking receive" );
+            ret = -EIO;
+            goto out;
+        }
+
+        pc202_ahb2pico_reg_read( dev, offset, &val );
+        val |= AHB2PICO_INT_EN;
+        pc202_ahb2pico_reg_write( dev, offset, val );
+    }
+
+    list_add( &handler->list, irq->value == PC202_IRQ_PROCIF ?
+              &dev->procif_irq_handlers.list :
+              &dev->ahb2pico_irq_handlers.list );
+
+    ret = 0;
+out:
+    if ( ret && handler )
+        kfree( handler );
+
+    spin_unlock_irqrestore( &pa->lock, flags );
+    return ret;
+}
+
+/*!
+ * Remove an IRQ handler from a PC202 interrupt source.
+ *
+ * @param pa The PC202 to remove the handler from.
+ * @param irq The IRQ to remove the handler for.
+ */
+static void
+pc202_remove_irq_handler( struct picoarray *pa,
+                          struct pico_resource *irq )
+{
+    struct list_head *pos;
+    struct list_head *tmp;
+    struct pc202 *dev = to_pc202( pa );
+    int found = 0;
+    struct pc202_irq_handler *handler;
+    unsigned long flags;
+
+    /* Protect against interrupts being raised whilst we remove the handler.
+     */
+    spin_lock_irqsave( &pa->lock, flags );
+
+    /* If this is an AHB2Pico IRQ, then lets disable the interrupt. */
+    if ( PC202_IRQ_PROCIF != irq->value )
+    {
+        unsigned gpr_num = irq->value - PC202_IRQ_AHB2PICO_0;
+        unsigned offset =
+            AHB2PICO_GPR_VP_START + ( gpr_num * AHB2PICO_VP_SPACING );
+        u32 val;
+        pc202_ahb2pico_reg_read( dev, offset, &val );
+        val &= ~AHB2PICO_INT_EN;
+        pc202_ahb2pico_reg_write( dev, offset, val );
+    }
+
+    list_for_each_safe( pos, tmp, &dev->procif_irq_handlers.list )
+    {
+        handler = container_of( pos, struct pc202_irq_handler, list );
+        if ( handler->irq == irq )
+        {
+            list_del( pos );
+            found = 1;
+            break;
+        }
+    }
+
+    if ( found )
+        goto out;
+
+    list_for_each_safe( pos, tmp, &dev->ahb2pico_irq_handlers.list )
+    {
+        handler = container_of( pos, struct pc202_irq_handler, list );
+        if ( handler->irq == irq )
+        {
+            list_del( pos );
+            found = 1;
+            break;
+        }
+    }
+out:
+    spin_unlock_irqrestore( &pa->lock, flags );
+}
+
+/*!
+ * PC202 AHB2Pico ISR. This ISR will be called when the AHB2Pico generates an
+ * interrupt and checks all of the AHB2Pico interrupt sources for raised
+ * interrupts and calls the appropriate handler if there is one registered. If
+ * there is no interrupt handler for the IRQ source then that source is
+ * disabled.
+ *
+ * @param irq The irq that has been raised.
+ * @param dev The PC202 device that has raised the interrupt.
+ * @return Returns IRQ_HANDLED on success.
+ */
+static irqreturn_t
+pc202_ahb2pico_irq( int irq,
+                    void *dev )
+{
+    struct pc202 *pc202dev = dev;
+    struct list_head *pos;
+    struct pc202_irq_handler *handler;
+    int ret;
+    u32 int_status;
+    unsigned i;
+    unsigned handled;
+
+    pc202_ahb2pico_reg_read( pc202dev, AHB2PICO_INT_STATUS_OFFSET,
+                             &int_status );
+    for ( i = 0; i < AHB2PICO_NUM_VPS; ++i )
+    {
+        if ( int_status & ( 1 << i ) )
+        {
+            handled = 0;
+            list_for_each( pos, &pc202dev->ahb2pico_irq_handlers.list )
+            {
+                handler = container_of( pos, struct pc202_irq_handler, list );
+                if ( ( handler->irq->offset ) == i  && handler->callback )
+                {
+                    ret = handler->callback( handler->irq, handler->cookie );
+                    if ( !ret )
+                    {
+                        handled = 1;
+                        break;
+                    }
+                }
+            }
+            if ( !handled )
+            {
+                PRINTD( COMPONENT_PC202, DBG_WARN,
+                        "no interrupt handler for AHB2Pico VP %u", i );
+                /* Disable the interrupt generation for this GPR - there
+                 * is no handler installed. The configuration registers
+                 * are 0x10 bytes apart starting from 0x40. */
+                pc202_ahb2pico_reg_write( pc202dev, 
+                        ( i * AHB2PICO_VP_SPACING ) + AHB2PICO_GPR_VP_START,
+                        0 );
+            }
+        }
+    }
+
+    return IRQ_HANDLED;
+}
+
+/*!
+ * PC202 procif ISR. This ISR will be called when the procif generates an
+ * interrupts and calls the appropriate handler if there is one registered. If
+ * there is no interrupt handler then the ITM register is cleared to prevent
+ * further interrupts from being raised.
+ *
+ * @param irq The irq that has been raised.
+ * @param dev The PC202 device that has raised the interrupt.
+ * @return Returns IRQ_HANDLED on success.
+ */
+static irqreturn_t
+pc202_procif_irq( int irq,
+                  void *dev )
+{
+    struct pc202 *pc202dev = dev;
+    struct list_head *pos;
+    struct pc202_irq_handler *handler;
+    int ret;
+    int handled = 0;
+
+    list_for_each( pos, &pc202dev->procif_irq_handlers.list )
+    {
+        handler = container_of( pos, struct pc202_irq_handler, list );
+        if ( handler->callback )
+        {
+            ret = handler->callback( handler->irq, handler->cookie );
+            if ( ret )
+                break;
+            handled = 1;
+        }
+    }
+
+    /* Mask out the interrupt to prevent it from occuring again. */
+    if ( !handled )
+        procif_reg_write( pc202dev->reg_base, PC202_PROCIF_ITM_OFFSET,
+                          0 );
+
+    return IRQ_HANDLED;
+}
+
+/*!
+ * PC202 DMA tasklet. This function will execute the appropriate DMA handler
+ * at a time chosen by the host.  The DMA software will not permit more that one 
+ * transfer to be queued for each DMA chhanel. Thus the FIFO which is common to
+ * all DMA channels need not be large (one for each DMA channel plus 1 spare entry).
+ * As a tasklet cannot be called when it is already running, this function must 
+ * iterated around the FIFO until it is empty. 
+ *
+ * @param fifoP An unsigned long conmtaining the address of the DMA FIFO
+ */
+static void
+pc202_dma_do_tasklet(unsigned long fifoP)
+{
+    struct pc202_dma_fifo *dma_fifo = (struct pc202_dma_fifo *)fifoP;
+
+    while( dma_fifo->readPtr != dma_fifo->writePtr )
+    {
+        PRINTD( COMPONENT_PC202, DBG_TRACE,
+                "calling handle 0x%p error=%d (Read ptr=%d, write ptr=%d)",
+                dma_fifo->fifo[dma_fifo->readPtr].dma->handler,
+                 dma_fifo->fifo[dma_fifo->readPtr].errno,
+                dma_fifo->readPtr, dma_fifo->writePtr );
+
+        dma_fifo->fifo[dma_fifo->readPtr].dma->handler(
+              dma_fifo->fifo[dma_fifo->readPtr].dma->cookie,
+              dma_fifo->fifo[dma_fifo->readPtr].errno );
+        dma_fifo->readPtr++;
+        dma_fifo->readPtr %= DMA_FIFO_SIZE;
+    }
+}
+
+/*!
+ * \brief PC202 DMA channel mappings
+ *
+ * This structure defines the DMAC and DMA channel numbers for each of the
+ * picoArray DMA channels. This structure is internal and specific to the
+ * PC202.
+ */
+struct pc202_dma_mapping
+{
+    unsigned dmac;
+    unsigned chan;
+};
+
+/*!
+ * \brief Initialise the DMAC and DMA channel mappings
+ *
+ * @param dma Pointer to the global DMA structure for the PC202 device
+ * @return Returns 0 on succes, negatice number on error.
+ *
+ */
+__must_check static int
+pc202_dma_init( struct pc202 *dev )
+{
+    unsigned i;
+    firecracker_dma_t dmac[PICO_NUM_DMACS];
+    struct pc202_dma_mapping dma_mapping[PICO_NUM_DMA_CHANNELS] = {
+        { 0, 1 },
+        { 1, 1 },
+        { 0, 3 },
+        { 1, 3 },
+        { 0, 0 },
+        { 1, 0 },
+        { 0, 2 },
+        { 1, 2 },
+    };
+   
+    for(i = 0; i < PICO_NUM_DMACS ; i++)
+    {
+       dmac[i] = firecracker_dma_get_dmac_handle( i );
+       if (dmac[i] == NULL)
+            return -ENOMEM; 
+    }
+
+    /* Assign the DMAC number and channel to the picoArray DMA channel */
+    for (i = 0; i < PICO_NUM_DMA_CHANNELS; i++)
+    {
+        dev->dma_channel[i].hs.interface = dma_mapping[i].chan;
+        dev->dma_channel[i].dmac = dmac[ dma_mapping[i].dmac ];
+        dev->dma_channel[i].hs.active_low = 0; /* PC20x DREQs are active high */
+        dev->dma_channel[i].stateActive = 0;
+        dev->dma_channel[i].xfr = NULL;
+        dev->dma_channel[i].dev = dev;
+        dev->dma_channel[i].channel = i;
+    }
+
+    tasklet_init( &dev->dma_tasklet, pc202_dma_do_tasklet,
+                                                  (unsigned long)&dev->dma_fifo);
+
+    return 0;
+}
+
+/*!
+ * PC202 DMA ISR. This ISR will be called when the DMAC generates an
+ * interrupt and calls the appropriate handler if there is one registered. 
+ *
+ * @param irq The irq that has been raised.
+ * @param dev The PC202 device that has raised the interrupt.
+ * @return Returns IRQ_HANDLED on success.
+ */
+static irqreturn_t
+pc202_dma_irq( int irq,
+               void *dev )
+{
+    firecracker_dma_t dmac = dev;
+    struct pc202_dma_channel *dma;
+    firecracker_dma_xfr_t xfr;
+    dma_int_type_t int_type = INT_ALL;
+
+    /* retrieve the transfer handle and our private data (dma) */
+    xfr = firecracker_dma_int_get_xfr(dmac, &int_type, (void **)&dma);
+
+    if (xfr == NULL)
+    {
+        PRINTD( COMPONENT_PC202, DBG_ERROR, "dma %d: got NULL xfr",
+                  dma->channel);
+        return IRQ_NONE;
+    }
+
+    /* Reset the interrupt we are servicing */
+    firecracker_dma_clear_int(xfr, int_type);
+
+    if (dma == NULL)
+    {
+        PRINTD( COMPONENT_PC202, DBG_ERROR, "invalid DMA interrupt, irq = %d",
+              irq);
+        return IRQ_NONE;
+    }
+
+    /* call the handler function */
+    dma->stateActive = 0;
+    if ( dma->handler )
+    {
+       unsigned tmp = dma->dev->dma_fifo.writePtr +1;
+
+       tmp %= DMA_FIFO_SIZE;
+       if ( tmp == dma->dev->dma_fifo.readPtr )
+           PRINTD( COMPONENT_PC202, DBG_ERROR, "dma tasklet full" );
+       else
+       {
+           dma->dev->dma_fifo.fifo[dma->dev->dma_fifo.writePtr].dma = dma;
+
+           if ( INT_ERROR & int_type )
+               dma->dev->dma_fifo.fifo[dma->dev->dma_fifo.writePtr].errno = -EIO;
+           else
+               dma->dev->dma_fifo.fifo[dma->dev->dma_fifo.writePtr].errno = 0;
+
+           PRINTD( COMPONENT_PC202, DBG_TRACE,
+                   "queueing DMA handler call error=%d (cookie=0x%p) "
+                   "(read ptr=%d, write ptr=%d)",
+                   dma->dev->dma_fifo.fifo[dma->dev->dma_fifo.writePtr].errno,
+                   dma->dev->dma_fifo.fifo[dma->dev->dma_fifo.writePtr].dma->cookie,
+                   dma->dev->dma_fifo.readPtr, dma->dev->dma_fifo.writePtr );
+
+           dma->dev->dma_fifo.writePtr = tmp;
+           tasklet_schedule( &dma->dev->dma_tasklet );
+       }
+    }
+    else
+        PRINTD( COMPONENT_PC202, DBG_ERROR,
+              "no interrupt handler for DMA channel %u", dma->channel );
+
+    return IRQ_HANDLED;
+}
+
+/*!
+ * DMA a scatter gather list of memory from a kernel mapped scatterlist
+ * into a picoArray DMA channel. After the DMA transfer has completed, the
+ * callback function will be called with the cookie as the parameter. The
+ * caller of this function is responsible for mapping and unmapping the
+ * buffers to be transferred into a DMA capable region.
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to use as a destination.
+ * @param sgl The scatter gather list of the source data.
+ * @param nbytes The number of bytes in the scatter gather list.
+ * @param callback The callback function to be called when the transfer
+ * has completed. The parameter errno will be set to the status of the DMA
+ * operation where 0 == success, negative == failure.
+ * @param cookie The cookie to pass to the callback function.
+ */
+static int
+pc202_dma_to_device( struct picoarray *pa,
+                     struct pico_resource *dma_channel,
+                     struct scatterlist *sgl,
+                     size_t nbytes,
+                     int ( *callback )( void *cookie,
+                                        int errno ),
+                     void *cookie )
+{
+    int ret = 0;
+    struct pc202 *dev = to_pc202( pa );
+    struct pc202_dma_channel *dma = &dev->dma_channel[dma_channel->value];
+    dma_addr_t src = sg_dma_address( sgl );
+    firecracker_dma_endpoint_t src_ep;
+    firecracker_dma_endpoint_t dst_ep;
+
+    if ( dma->stateActive )
+      return -EAGAIN;
+
+    PRINTD( COMPONENT_PC202, DBG_TRACE, "DMA transfer Chan %d, Bytes %d",
+          dma_channel->value, nbytes );
+
+    /* make a single SGL entry */
+    firecracker_dma_list_clear( dma->sgl );
+
+    src_ep.dma_addr = src;
+    src_ep.ahb_master_select = AHB_MASTER1;
+    src_ep.periph_not_mem = 0;
+    src_ep.flow_controller = 0;
+    src_ep.enable_sg = 0;
+    src_ep.addr_inc = INCREMENT;
+    src_ep.tr_width = TR_WIDTH32;
+    src_ep.msize = MS_AUTO;
+    src_ep.auto_reload = 0;
+
+    dst_ep.dma_addr = dma->pico_addr;
+    if ( dma_channel->value >= PC202_DMA_AHB2PICO_0 )
+        dst_ep.ahb_master_select = AHB_MASTER2;
+    else
+        dst_ep.ahb_master_select = AHB_MASTER4;
+
+    dst_ep.periph_not_mem = 1;
+    dst_ep.flow_controller = 0;
+    dst_ep.enable_sg = 0;
+    dst_ep.addr_inc = NO_CHANGE;
+    dst_ep.tr_width = TR_WIDTH32;
+    SET_PICOARRAY_MSIZE(dst_ep);
+    dst_ep.auto_reload = 0;
+
+    if ( dma->xfr != NULL )
+        firecracker_dma_release( dma->xfr );
+
+    dma->xfr = firecracker_dma_setup_direct_xfr( dma->dmac,
+                &src_ep, &dst_ep, NULL, &(dma->hs), nbytes,
+                PROTCTL_1, dma );
+    if ( dma->xfr == NULL )
+    {
+        PRINTD( COMPONENT_PC202, DBG_ERROR, "error setting up list xfr "
+               "for channel %d", dma_channel->value );
+        return -EINVAL;
+    }
+
+    firecracker_dma_enable_int( dma->xfr, INT_ERROR | INT_TRANSFER );
+
+    dma->handler = callback;
+    dma->cookie = cookie;
+    dma->stateActive = 1;
+    ret = firecracker_dma_start( dma->xfr );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_PC202, DBG_ERROR, "error starting xfr, "
+              "ret=%d", -ret );
+        return -ret;
+    }
+
+    return ret;
+}
+
+/*!
+ * DMA a scatter gather list of memory from a picoArray DMA channel. After
+ * the DMA transfer has completed, the callback function will be called
+ * with the cookie as the parameter. The caller of this function is
+ * responsible for mapping and unmapping the buffers to be transferred
+ * into a DMA capable region.
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to use as a source.
+ * @param sgl The scatter gather list of the destination buffer.
+ * @param nbytes The number of bytes to transfer.
+ * @param callback The callback function to be called when the transfer
+ * has completed. The parameter errno will be set to the status of the DMA
+ * operation where 0 == success, negative == failure.
+ * @param cookie The cookie to pass to the callback function.
+ * @return 0 for success and non-zeo for error
+ */
+static int
+pc202_dma_from_device( struct picoarray *pa,
+                       struct pico_resource *dma_channel,
+                       struct scatterlist *sgl,
+                       size_t nbytes,
+                       int ( *callback )( void *cookie,
+                                          int errno ),
+                       void *cookie )
+{
+    int ret = 0;
+    struct pc202 *dev = to_pc202( pa );
+    struct pc202_dma_channel *dma = &dev->dma_channel[dma_channel->value];
+    dma_addr_t src = sg_dma_address( sgl );
+    firecracker_dma_endpoint_t src_ep;
+    firecracker_dma_endpoint_t dst_ep;
+
+    if ( dma->stateActive )
+        return -EAGAIN;
+
+    PRINTD( COMPONENT_PC202, DBG_TRACE, "chan %d, bytes %u",
+               dma_channel->value, nbytes );
+
+    /* make a single SGL entry */
+    firecracker_dma_list_clear(dma->sgl);
+
+    src_ep.dma_addr = dma->pico_addr;
+    if ( dma_channel->value >= PC202_DMA_AHB2PICO_0 )
+        src_ep.ahb_master_select = AHB_MASTER2;
+    else
+        src_ep.ahb_master_select = AHB_MASTER4;
+    src_ep.periph_not_mem = 1;
+    src_ep.flow_controller = 0;
+    src_ep.enable_sg = 0;
+    src_ep.addr_inc = NO_CHANGE;
+    src_ep.tr_width = TR_WIDTH32;
+    SET_PICOARRAY_MSIZE(src_ep);
+    src_ep.auto_reload = 0;
+
+    dst_ep.dma_addr = src;
+    dst_ep.ahb_master_select = AHB_MASTER1;
+    dst_ep.periph_not_mem = 0;
+    dst_ep.flow_controller = 0;
+    dst_ep.enable_sg = 0;
+    dst_ep.addr_inc = INCREMENT;
+    dst_ep.tr_width = TR_WIDTH32;
+    dst_ep.msize = MS_AUTO;
+    dst_ep.auto_reload = 0;
+
+    if ( dma->xfr != NULL )
+        firecracker_dma_release( dma->xfr );
+
+    dma->xfr = firecracker_dma_setup_direct_xfr( dma->dmac,
+                &src_ep, &dst_ep, &(dma->hs), NULL, nbytes,
+                PROTCTL_1, dma);
+    if ( dma->xfr == NULL )
+    {
+        PRINTD( COMPONENT_PC202, DBG_ERROR, "error setting up list xfr");
+        return -EINVAL;
+    }
+
+    firecracker_dma_enable_int( dma->xfr, INT_ERROR | INT_TRANSFER );
+
+    dma->stateActive = 1;
+    dma->handler = callback;
+    dma->cookie = cookie;
+    ret = firecracker_dma_start( dma->xfr );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_PC202, DBG_ERROR,"error starting xfr, ret=%d",
+             -ret );
+        return -ret;
+    }
+
+    return ret;
+}
+
+/*!
+ * Open and enable the specified DMA channel
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to open
+ * @param is_downlink 1 if the channel is a downlink, 0 for an uplink
+ * @return 0 on success, a negative number on failure
+ */
+__must_check static int
+pc202_dma_open( struct picoarray *pa,
+                struct pico_resource *dma_channel,
+                int is_downlink )
+{
+    struct pc202 *pc202dev = to_pc202( pa );
+    struct pc202_dma_channel *dma = 
+                                &pc202dev->dma_channel[dma_channel->value];
+
+    if ( dma_channel->value >=  PC202_DMA_AHB2PICO_0 )
+    {
+        PRINTD( COMPONENT_PC202, DBG_TRACE,
+              "AHB2PICO pa_dma %d  => cpu_dma %d",
+              ( dma_channel->value-PC202_DMA_AHB2PICO_0 ), 
+              dma_channel->value);
+
+        dma->pico_addr = (dma_addr_t)pc202dev->ahb_base_phys 
+            +((dma_channel->value-PC202_DMA_AHB2PICO_0)*AHB2PICO_VP_SPACING)
+            +AHB2PICO_VP_DATA_OFFSET;
+
+        /* Set the DMAC Enable bit (bit1) in the DMA config register */
+        (void)pc202_ahb2pico_reg_write( pc202dev, 
+                ((dma_channel->value-PC202_DMA_AHB2PICO_0)*AHB2PICO_VP_SPACING)
+                +AHB2PICO_VP_CONFIG_OFFSET, (0x02 + (PC202_DMA_BURST_SIZE << 2)));
+    }
+    else
+    {
+        /* ProcIF interface - Set the channels phyiscal address and use the
+           DMA shadow register. Register offset is calculated by counting
+           the register order as follows:
+              GPR0 -> GPR19, DMA0, GPR20, DMA1, GPR21, DMA2, GPR22, DMA3
+           Each register occupies a long word, therefore the offsets to apply
+           are:
+              DMA Channel 0 -> 80
+              DMA Channel 1 -> 88
+              DMA Channel 2 -> 96
+              DMA Channel 3 -> 108
+           channel->value lies in the range PC202_DMA_PROCIF_0 to
+               PC202_DMA_PROCIF_3 as an enumaration list */
+        dma->pico_addr = (dma_addr_t)pc202dev->reg_base_phys +
+          ( 2 * (10+(dma_channel->value-PC202_DMA_PROCIF_0)) * sizeof(uint32_t));
+    }
+
+    dma->sgl = firecracker_dma_list_create( dma->dmac, 1 );
+    if ( dma->sgl == NULL )
+    {
+        PRINTD( COMPONENT_PC202, DBG_ERROR, "dma %d: cannot allocate "
+           "scatter gather list", dma_channel->value);
+        return -EINVAL;
+    }
+
+    /* Initialise parameters that need to be reset */
+    dma->xfr = NULL;
+    dma->stateActive=0;
+    dma->handler=NULL;
+    dma->cookie=NULL;
+
+    return 0;
+}
+
+/*!
+ * Close and disable the specified DMA channel
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to close
+ * @return 0 in all cases
+ */
+static int
+pc202_dma_close( struct picoarray *pa,
+                 struct pico_resource *dma_channel )
+{
+    int ret = 0;
+    struct pc202 *pc202dev = to_pc202( pa );
+    struct pc202_dma_channel *dma =
+                                &pc202dev->dma_channel[dma_channel->value];
+
+    if ( dma->xfr )
+    {
+        if ( dma->stateActive )
+        {
+            ret = firecracker_dma_abort( dma->xfr );
+            if ( ret )
+                PRINTD( COMPONENT_PC202, DBG_WARN, "DMA abort failed, "
+                "return code=%d", ret );
+
+            PRINTD( COMPONENT_PC202, DBG_WARN, "dma %d: stopped while dma "
+                "in progress", dma_channel->value);
+        }
+
+        /* Disable all interrupts for this channel */
+        firecracker_dma_disable_int( dma->xfr, INT_ALL );
+
+        /* Reset all interrupts for this channel */
+        firecracker_dma_clear_int(dma->xfr, INT_ALL );
+
+        firecracker_dma_release( dma->xfr );
+    }
+
+    if ( dma->sgl )
+    {
+        ret = firecracker_dma_list_destroy( dma->sgl );
+        if (ret)
+            PRINTD( COMPONENT_PC202, DBG_WARN, "DMA list_destroy failed "
+                "return code = %d", ret );
+    }
+
+    dma->stateActive = 0;
+    return 0;
+}
+
+/*!
+ * Get the device type of a PC202.
+ *
+ * @param pa The device to query.
+ * @return Always returns PICOARRAY_PC202.
+ */
+static enum picoarray_device_type
+pc202_get_device_type( struct picoarray *pa )
+{
+    return PICOARRAY_PC202;
+}
+
+/*!
+ * Get the ITM, ITS and procIF IRQ resources.
+ * This function will return the pointers to the resources requested on success or NULL
+ * if the resource is already allocated.
+ *
+ * @param pa The device to take to DMA the data.
+ * @param its The ITS resource or NULL on failure
+ * @param itm The ITM resource or NULL on failure
+ * @param procif_irq The IRQ resource or NULL on failure
+ * 
+ * @return 0 on success, non-zero on failure
+ */
+static int
+pc202_get_procif_resource( struct picoarray *pa,
+                           struct pico_resource **its,
+                           struct pico_resource **itm,
+                           struct pico_resource **procif_irq )
+{
+    *its = generic_get_resource( pa, PICO_RES_GPR, PC202_GPR_ITS, 1 );
+    *itm = generic_get_resource( pa, PICO_RES_GPR, PC202_GPR_ITM, 1 );
+    *procif_irq = generic_get_resource( pa, PICO_RES_IRQ, PC202_IRQ_PROCIF, 1 );
+
+    return ( (!(*its)) || (!(*itm)) || (!(*procif_irq)) );
+}
+
+/*!
+ * Put the ITM, ITS and procIF IRQ resources.
+ * This function will free any non NULL resources specified
+ *
+ * @param pa The device to take to DMA the data.
+ * @param its The ITS resource
+ * @param itm The ITM resource
+ * @param procif_irq The IRQ resource
+ */
+static void
+pc202_put_procif_resource( struct picoarray *pa,
+                           struct pico_resource *its,
+                           struct pico_resource *itm,
+                           struct pico_resource *procif_irq )
+{
+    if ( its )
+        generic_put_resource( pa, its );
+
+    if ( itm )
+        generic_put_resource( pa, itm );
+
+    if ( procif_irq )
+        generic_put_resource( pa, procif_irq );
+}
+
+/*! Operations for the PC202 devices. */
+static struct picoarray_ops pc202_ops = {
+    .sync                = pc202_sync,
+    .start               = pc202_start,
+    .stop                = pc202_stop,
+    .get_device_type     = pc202_get_device_type,
+    .config_read         = pc202_config_read,
+    .config_write        = pc202_config_write,
+    .register_read       = pc202_register_read,
+    .register_write      = pc202_register_write,
+    .reset               = pc202_reset,
+    .get_resource        = generic_get_resource,
+    .get_procif_resource = pc202_get_procif_resource,
+    .put_resource        = generic_put_resource,
+    .put_procif_resource = pc202_put_procif_resource,
+    .destructor          = pc202_destroy,
+    .add_irq_handler     = pc202_add_irq_handler,
+    .remove_irq_handler  = pc202_remove_irq_handler,
+    .dma_to_device       = pc202_dma_to_device,
+    .dma_from_device     = pc202_dma_from_device,
+    .dma_open            = pc202_dma_open,
+    .dma_close           = pc202_dma_close,
+    .pa_load             = pc202_pa_load,
+};
+
+/*!
+ * Probe method for the PC202 platform driver. This function creates a new
+ * PC202 instance and is responsible for allocating all of the resources
+ * required.
+ *
+ * @param pdev The platform device that has been probed.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_probe( struct platform_device *pdev )
+{
+    struct resource *res;
+    int ret;
+    uint32_t chip_control;
+    struct pc202 *newdev = kmalloc( sizeof( *newdev ), GFP_KERNEL );
+
+    if ( !newdev )
+        return -ENOMEM;
+
+    ret = -ENOMEM;
+    newdev->pa.resources = kmalloc( sizeof( pc202_resources ), GFP_KERNEL );
+    if ( !newdev->pa.resources )
+        goto out;
+    memcpy( newdev->pa.resources, pc202_resources, sizeof( pc202_resources ) );
+
+    newdev->pa.dev_num = pdev->id;
+    newdev->pa.ops = &pc202_ops;
+    newdev->pa.features = PICOARRAY_HAS_DMA | PICOARRAY_HAS_DMA_LOAD;
+    newdev->pa.max_dma_sz = PICOARRAY_MAX_TRANSFER;
+    spin_lock_init( &newdev->pa.lock );
+
+    ret = -EINVAL;
+    /* Get the procif IRQ. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_IRQ, "procif_irq" );
+    if ( !res )
+        goto out;
+    newdev->procif_irq = res->start;
+
+    ret = -EINVAL;
+    /* Get the DMA1 IRQ. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_IRQ, "dma1_irq" );
+    if ( !res )
+        goto out;
+    newdev->dma1_irq = res->start;
+
+    ret = -EINVAL;
+    /* Get the DMA2 IRQ. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_IRQ, "dma2_irq" );
+    if ( !res )
+        goto out;
+    newdev->dma2_irq = res->start;
+
+    /* Get the IRQ for AHB2Pico GPRs. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_IRQ, "gpr_irq" );
+    if ( !res )
+        goto out;
+    newdev->ahb2pico_irq = res->start;
+
+    /* Get the register base address for the procif. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM, "procif" );
+    if ( !res )
+        goto out;
+    newdev->reg_base_phys = res->start;
+    newdev->reg_base_len = ( res->end - res->start ) + 1;
+
+    /* Get the register base address for the AHB2Pico. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM,
+                                        "ahb2pico_axi2pico" );
+    if ( !res )
+        goto out;
+    newdev->ahb_base_phys = res->start;
+    newdev->ahb_base_len = ( res->end - res->start ) + 1;
+
+    /* Get the Chip Control Register */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM, "ccr_base");
+    if ( !res )
+        goto out;
+    newdev->ccr_base_phys = res->start;
+    newdev->ccr_base_len = ( res->end - res->start ) + 1;
+
+    /* Map the resources. */
+    newdev->reg_base = request_and_map( "procif", newdev->reg_base_phys,
+                                        newdev->reg_base_len );
+    if ( !newdev->reg_base )
+        goto out;
+
+    newdev->ahb_base = request_and_map( "ahb2pico", newdev->ahb_base_phys,
+                                        newdev->ahb_base_len );
+    if ( !newdev->ahb_base )
+        goto ahb_map_failed;
+
+    newdev->ccr_base = request_and_map( "ccr_base", newdev->ccr_base_phys,
+                                        newdev->ccr_base_len );
+    if ( !newdev->ccr_base )
+        goto ccr_map_failed;
+
+    /* Initialise the DMAC structures */
+    ret = pc202_dma_init( newdev );
+    if ( ret )
+        goto dma_init_failed;
+
+    /* Clear CCR bits 3 & 4 to set DREQ mux for procIf instead of EBI */
+    chip_control = picoif_in32(newdev->ccr_base);
+    chip_control &= ~(0x00000018);
+    picoif_out32(chip_control,newdev->ccr_base);
+
+    ret = request_irq( newdev->procif_irq, pc202_procif_irq, IRQF_DISABLED,
+                       pdev->name, newdev );
+    if ( ret )
+        goto procif_irq_failed;
+
+    ret = request_irq( newdev->ahb2pico_irq, pc202_ahb2pico_irq, IRQF_DISABLED,
+                       pdev->name, newdev );
+    if ( ret )
+        goto ahb2pico_irq_failed;
+
+    ret = request_irq( newdev->dma1_irq, pc202_dma_irq, IRQF_DISABLED,
+                       pdev->name, firecracker_dma_get_dmac_handle( 0 ) );
+    if ( ret )
+        goto dma1_irq_failed;
+
+    ret = request_irq( newdev->dma2_irq, pc202_dma_irq, IRQF_DISABLED,
+                       pdev->name, firecracker_dma_get_dmac_handle( 1 ) );
+    if ( ret )
+        goto dma2_irq_failed;
+
+    /* Initialise the interrupt handler lists. */
+    INIT_LIST_HEAD( &newdev->procif_irq_handlers.list );
+    INIT_LIST_HEAD( &newdev->ahb2pico_irq_handlers.list );
+
+    newdev->dma_fifo.readPtr = newdev->dma_fifo.writePtr = 0;
+
+    ret = picoif_register_dev( &newdev->pa );
+    goto out;
+
+dma2_irq_failed:
+    free_irq( newdev->dma1_irq, firecracker_dma_get_dmac_handle( 0 ) );
+
+dma1_irq_failed:
+    free_irq( newdev->ahb2pico_irq, newdev );
+
+ahb2pico_irq_failed:
+    free_irq( newdev->procif_irq, newdev );
+
+dma_init_failed:
+procif_irq_failed:
+    unmap_and_release( newdev->ccr_base_phys, newdev->ccr_base_len,
+                       newdev->ccr_base );
+
+ccr_map_failed:
+    unmap_and_release( newdev->ahb_base_phys, newdev->ahb_base_len,
+                       newdev->ahb_base );
+
+ahb_map_failed:
+    unmap_and_release( newdev->reg_base_phys, newdev->reg_base_len,
+                       newdev->reg_base );
+out:
+    if ( ret && newdev->pa.resources )
+        kfree( newdev->pa.resources );
+
+    if ( ret )
+        kfree( newdev );
+    else
+        ++num_pc202s;
+
+    return ret;
+}
+
+/*!
+ * Remove method for the PC202 platform driver. This method is called when the
+ * platform driver is removed and must release all resources the driver has
+ * been using.
+ *
+ * @param pdev The platform device being remove.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc202_remove( struct platform_device *pdev )
+{
+    struct picoarray *pa = picoif_get_device( pdev->id );
+    struct pc202 *pc202dev = to_pc202( pa );
+    int ret = 0;
+
+    free_irq( pc202dev->dma1_irq, firecracker_dma_get_dmac_handle( 0 ) );
+    free_irq( pc202dev->dma2_irq, firecracker_dma_get_dmac_handle( 1 ) );
+    free_irq( pc202dev->procif_irq, pc202dev );
+    free_irq( pc202dev->ahb2pico_irq, pc202dev );
+    unmap_and_release( pc202dev->ahb_base_phys, pc202dev->ahb_base_len,
+                       pc202dev->ahb_base );
+    unmap_and_release( pc202dev->reg_base_phys, pc202dev->reg_base_len,
+                       pc202dev->reg_base );
+    unmap_and_release( pc202dev->ccr_base_phys, pc202dev->ccr_base_len,
+                       pc202dev->ccr_base );
+
+    kfree( pc202dev->pa.resources );
+    kfree( pc202dev );
+
+    return ret;
+}
+
+/*! The PC202 platform driver.
+ *  \todo Change the name to PC202 specific rather than generic picoArray.
+ */
+static struct platform_driver pc202_driver = {
+    .probe      = pc202_probe,
+    .remove     = pc202_remove,
+    .driver     = {
+        .name   = "picoArray",
+    },
+};
+
+int
+pc202_init( void )
+{
+    return platform_driver_register( &pc202_driver );
+}
+
+/*!
+ * Destructor to be called when a PC202 is removed from picoif. This
+ * function must decrement the number of PC202s registered, and when this
+ * reaches zero, remove the platform driver.
+ *
+ * @param pa The device being removed.
+ */
+static void
+pc202_destroy( struct picoarray *pa )
+{
+    PRINTD( COMPONENT_PC202, DBG_TRACE, "pA[%u]: destructor called",
+            pa->dev_num );
+
+    /* If we have no more pc202s, then remove the driver. */
+    if ( 0 == --num_pc202s )
+        platform_driver_unregister( &pc202_driver );
+}
diff --git a/drivers/picochip/pc203.c b/drivers/picochip/pc203.c
new file mode 100644
index 0000000..8e4af10
--- /dev/null
+++ b/drivers/picochip/pc203.c
@@ -0,0 +1,1072 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file pc203.c
+ * \brief PC203 device implementation.
+ *
+ * This file implements the PC203 support of picoIf. All implementation in
+ * this file is private and should not be accessed directly by users and only
+ * provides the necessary basic services with which transports can be built
+ * upon and devices configured.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/dmaengine.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <asm/io.h>
+#include <asm/cpld_hdp102.h>
+
+#include <linux/picochip/devices/pc203.h>
+#include "picoarray.h"
+#include "resource.h"
+#include "picoif_internal.h"
+#include "procif.h"
+#include "debug.h"
+#include "utilities_internal.h"
+
+#include "../dma/fsldma.h"
+
+/*! The offset of the ITM register in the procif. */
+#define PC203_PROCIF_ITM_OFFSET     ( 0x70 )
+/*! The position of the memif reset bit in the chip control register. */
+#define PC203_MEMIF_SOFT_RESET      ( 1 << 29 )
+/*! The offset of the chip control register in the procif decode region 2. */
+#define CHIP_CONTROL_OFFSET         ( 0x1F )
+
+/*! The CAEID of the procif. */
+#define PC203_PROCIF_CAEID          ( 0x48 )
+/*! The offset in the procif for the operation request register. */
+#define PC203_PROCIF_OP_REQ_OFFSET  ( 0x4018 )
+/*! The offset in the procif for the operation status register. */
+#define PC203_PROCIF_OP_STATUS_OFFSET  ( 0x401c )
+/*! The offset of the start request bit in the operation request register. */
+#define PC203_PROCIF_OP_REQ_START   ( 1 << 1 )
+/*! The offset of the sync request bit in the operation request register. */
+#define PC203_PROCIF_OP_REQ_SYNC    ( 1 << 0 )
+
+/*! Downlinks transfer blocks of 128bytes. DMASrc generics must be
+    lowWaterMark=>32, transferLen=>32, DREQMode=>3 */
+#define PC203_DOWNLINK_SIZE         128
+/*! Uplinks transfer blocks of 32bytes. DMASink generics must be
+ *  lowWaterMark=>8, transferLen=>8, DREQMode=>3 */
+#define PC203_UPLINK_SIZE           32
+
+/*! The max transfer size that is permitted */
+#define PICOARRAY_MAX_TRANSFER      ( 0xFFFFFFFC )
+
+/*! The number of registered PC203s in the system. Until this reaches zero, we
+ * can't unregister the platform driver. */
+static unsigned num_pc203s;
+
+static void
+pc203_destroy( struct picoarray *pa );
+
+/*!
+ * \brief PC203 IRQ handler.
+ *
+ * This structure defines an IRQ handler for PC203 devices and is an internal
+ * structure that could be reused for other device types.
+ */
+struct pc203_irq_handler
+{
+    /*! The position in the list of handlers for an interrupt source. */
+    struct list_head        list;
+
+    /*! The IRQ that this handles. */
+    struct pico_resource    *irq;
+
+    /*! A cookie to pass to the callback function when the interrupt is
+     * raised. */
+    void                    *cookie;
+
+    /*! The callback function to call when the interrupt is raised. */
+    int                     ( *callback )( struct pico_resource *irq,
+                                           void *cookie );
+};
+
+/*!
+ * DMA Engine can only pass one parameter to a callback function but the
+ * callback function from dma.c needs two. Use this structure to translate
+ * between the two callback definitions
+ */
+struct pc203_dma_cb_param {
+    int ( *callback )( void *cookie,
+                      int errno );
+    void *cookie;
+    int chanid;
+};
+
+/*!
+ * \brief Private representation of a PC203 device.
+ *
+ * This describes all private data required in the PC203 implementation of
+ * this driver.
+ *
+ * \extends picoarray
+ */
+struct pc203
+{
+    /*! The picoArray base class. */
+    struct picoarray            pa;
+
+    /*! The physical address of the procif registers. */
+    dma_addr_t                  reg_base_phys;
+
+    /*! The length of the procif registers in bytes. */
+    size_t                      reg_base_len;
+
+    /*! The virtually mapped address of the procif registers. */
+    void __iomem                *reg_base;
+
+    /*! The physical address of the chip control register. */
+    dma_addr_t                  ccr_base_phys;
+
+    /*! The length of the chip control register in bytes. */
+    size_t                      ccr_base_len;
+
+    /*! The physical address of the ProcIf DMA registers. */
+    dma_addr_t                  dma_base_phys;
+
+    /*! The length of the ProcIf DMA registers in bytes. */
+    size_t                      dma_base_len;
+
+    /*! The virtually mapped address of the chip control register. */
+    void __iomem                *ccr_base;
+
+    /*! The procif IRQ number. */
+    unsigned                    procif_irq;
+
+    /*! The handlers registered for the procif IRQ. */
+    struct pc203_irq_handler    procif_irq_handlers;
+
+    /*! The DMA engine channel */
+    struct dma_chan             *dma_chan[PICO_NUM_DMA_CHANNELS];
+
+    /*! The callback parameters, one per DMA channel */
+    struct pc203_dma_cb_param   callback[PICO_NUM_DMA_CHANNELS];
+};
+
+/*!
+ * Get the PC203 structure given a picoArray base class.
+ *
+ * @param pa The base class pointer.
+ * @return Returns a pointer to the PC203 structure on success, NULL on
+ * failure.
+ */
+static inline struct pc203 *
+to_pc203( struct picoarray *pa )
+{
+    return pa ? container_of( pa, struct pc203, pa ) : NULL;
+}
+
+/*!
+ * Read a number of 16 bit words from the PC203 procif.
+ *
+ * @param pa The device to read from.
+ * @param caeid The CAEID of the AE to read from.
+ * @param address The start address in the AE to begin reading from.
+ * @param count The number of 16 bit words to read.
+ * @param[out] data The buffer to store the data in.
+ * @return Returns the number of words read on success, negative on failure.
+ */
+static int
+pc203_config_read( struct picoarray *pa,
+                   u16 caeid,
+                   u16 address,
+                   u16 count,
+                   u16 *data )
+{
+    struct pc203 *dev = to_pc203( pa );
+
+    PRINTD( COMPONENT_PC203, DBG_TRACE,
+            "pa[%u]: config read %u words %04x@%04x", pa->dev_num,
+            count, caeid, address );
+
+    return procif_config_read( dev->reg_base, caeid, address, data, count );
+}
+
+/*!
+ * Write a number of 16 bit words to the PC203 procif.
+ *
+ * @param pa The device to write to.
+ * @param caeid The CAEID of the AE to write to.
+ * @param address The start address in the AE to begin writing to.
+ * @param count The number of 16 bit words to write.
+ * @param[in] data The buffer to write from.
+ * @return Returns the number of words written on success, negative on failure.
+ */
+static int
+pc203_config_write( struct picoarray *pa,
+                    u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *data )
+{
+    struct pc203 *dev = to_pc203( pa );
+
+    PRINTD( COMPONENT_PC203, DBG_TRACE,
+            "pa[%u]: config write %u words %04x@%04x", pa->dev_num,
+            count, caeid, address );
+
+    return procif_config_write( dev->reg_base, caeid, address, data, count );
+}
+
+/*!
+ * Sync the PC203 device.
+ *
+ * @param pa The device to sync.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_sync( struct picoarray *pa )
+{
+    u16 val;
+
+    /* Read the current operation status register value. */
+    int ret = pa->ops->config_read( pa, PC203_PROCIF_CAEID,
+                                    PC203_PROCIF_OP_STATUS_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    /* If we are running, don't try and sync. */
+    ret = 0;
+    if ( val & PC203_PROCIF_OP_REQ_START )
+        goto out;
+
+    /* Read the current operation request register value. */
+    ret = pa->ops->config_read( pa, PC203_PROCIF_CAEID,
+                                    PC203_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    /* Set the sync request bit. */
+    val |= PC203_PROCIF_OP_REQ_SYNC;
+    ret = pa->ops->config_write( pa, PC203_PROCIF_CAEID,
+                                 PC203_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Start the PC203 device running.
+ *
+ * @param pa The device to start.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_start( struct picoarray *pa )
+{
+    u16 val;
+    int ret = pa->ops->config_read( pa, PC203_PROCIF_CAEID,
+                                    PC203_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+    val |= PC203_PROCIF_OP_REQ_START;
+    ret = pa->ops->config_write( pa, PC203_PROCIF_CAEID,
+                                 PC203_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Stop the PC203 device running.
+ *
+ * @param pa The device to stop.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_stop( struct picoarray *pa )
+{
+    u16 val;
+    int ret = pa->ops->config_read( pa, PC203_PROCIF_CAEID,
+                                    PC203_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+    val &= ~PC203_PROCIF_OP_REQ_START;
+    ret = pa->ops->config_write( pa, PC203_PROCIF_CAEID,
+                                 PC203_PROCIF_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Reset the PC203. This performs a soft reset that returns the picoArray to
+ * be as close as possible to the hardware reset state without affecting the
+ * ARM subsystem.
+ *
+ * @param pa The device being reset.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_reset( struct picoarray *pa )
+{
+    struct pc203 *dev = to_pc203( pa );
+    unsigned long flags;
+
+    spin_lock_irqsave( &pa->lock, flags );
+
+    /* Assert the reset line. */
+    cpld_pico_reset_assert( pa->dev_num );
+    /* Wait for 2ms then deassert the reset line. */
+    udelay( 2000 );
+    cpld_pico_reset_deassert( pa->dev_num );
+
+    /* Reset the memif. */
+    picoif_out32( PC203_MEMIF_SOFT_RESET, dev->ccr_base + CHIP_CONTROL_OFFSET );
+
+    spin_unlock_irqrestore( &pa->lock, flags );
+
+    return 0;
+}
+
+/*!
+ * Read a GPR (general purpose register) in the PC203.
+ *
+ * @param pa The device being read from.
+ * @param reg The register to read.
+ * @param[out] value The address to store the register value in.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_register_read( struct picoarray *pa,
+                     struct pico_resource *reg,
+                     u32 *value )
+{
+    struct pc203 *dev = to_pc203( pa );
+
+    if ( !reg || PICO_RES_GPR != reg->type )
+        return -EINVAL;
+
+    if ( reg->value < PC203_GPR_PROCIF_0 ||
+         reg->value >= PICO_NUM_GPRS )
+        return -EINVAL;
+
+    procif_reg_read( dev->reg_base, reg->offset, value );
+
+    return 0;
+}
+
+/*!
+ * Write a GPR (general purpose register) in the PC203.
+ *
+ * @param pa The device being written to.
+ * @param reg The register to write.
+ * @param value The value to write to the register.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_register_write( struct picoarray *pa,
+                      struct pico_resource *reg,
+                      u32 value )
+{
+    struct pc203 *dev = to_pc203( pa );
+
+    if ( !reg || PICO_RES_GPR != reg->type )
+        return -EINVAL;
+
+    if ( reg->value < PC203_GPR_PROCIF_0 ||
+         reg->value >= PICO_NUM_GPRS )
+        return -EINVAL;
+
+    procif_reg_write( dev->reg_base, reg->offset, value );
+
+    return 0;
+}
+
+/*! The resources for a PC203 device.
+ *
+ * The pA ProcIf DMA channels are memory mapped into the 8560 through CS3:
+ *          pA0: 0xc000_0000
+ *          pA1: 0xc004_0000
+ *          pA2: 0xc008_0000
+ *          pA3: 0xc00c_0000
+ * Each pA has four DMA channels in decode region 1 which are selected by
+ * up_adhi[1:0]. These pins are connected to laddr[14:15] so the FIFOs are
+ * mapped to offsets:
+ *          DMA0: 0x0_0000
+ *          DMA1: 0x1_0000
+ *          DMA2: 0x2_0000
+ *          DMA3: 0x3_0000
+ * The read/write pointers are managed by the ProcIf so the 8560 DMA should
+ * always read from the same device address (i.e. no incrementing)
+ */
+static struct pico_resource pc203_resources[] = {
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC203_DMA_PROCIF_0, .offset = 0x00000, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC203_DMA_PROCIF_1, .offset = 0x10000, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC203_DMA_PROCIF_2, .offset = 0x20000, },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC203_DMA_PROCIF_3, .offset = 0x30000, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_0, .offset = 0x0, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_1, .offset = 0x4, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_2, .offset = 0x8, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_3, .offset = 0xc, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_4, .offset = 0x10, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_5, .offset = 0x14, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_6, .offset = 0x18, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_7, .offset = 0x1c, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_8, .offset = 0x20, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_9, .offset = 0x24, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_10, .offset = 0x28, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_11, .offset = 0x2c, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_12, .offset = 0x30, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_13, .offset = 0x34, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_14, .offset = 0x38, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_15, .offset = 0x3c, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_16, .offset = 0x40, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_17, .offset = 0x44, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_18, .offset = 0x48, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_19, .offset = 0x4c, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_20, .offset = 0x54, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_21, .offset = 0x5c, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_22, .offset = 0x64, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_PROCIF_23, .offset = 0x6c, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_ITM, .offset = 0x70, },
+    { .type = PICO_RES_GPR, .value = PC203_GPR_ITS, .offset = 0x74, },
+    { .type = 0, .value = 0 }, /* Sentinel value. Do not remove and keep this
+                                * at the end. */
+};
+
+/*!
+ * Add an IRQ handler to the PC203 for a given interrupt source.
+ *
+ * @param pa The device to register the interrupt handler with.
+ * @param irq The IRQ to attach the handler to.
+ * @param callback The callback function to call when the interrupt is
+ * raised.
+ * @param cookie The cookie to pass to the callback function. This may be NULL
+ * if it is not required.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_add_irq_handler( struct picoarray *pa,
+                       struct pico_resource *irq,
+                       int ( *callback )( struct pico_resource *irq,
+                                          void *cookie ),
+                       void *cookie )
+{
+    struct pc203_irq_handler *handler;
+    struct pc203 *dev = to_pc203( pa );
+    int ret = -ENOMEM;
+    unsigned long flags;
+
+    if ( irq->type != PICO_RES_IRQ || !irq->exclusive || !callback )
+        return -EINVAL;
+
+    handler = kmalloc( sizeof( *handler ), GFP_KERNEL );
+    if ( !handler )
+        goto out;
+
+    handler->callback   = callback;
+    handler->cookie     = cookie;
+    handler->irq        = irq;
+
+    spin_lock_irqsave( &pa->lock, flags );
+    list_add( &handler->list, &dev->procif_irq_handlers.list );
+    spin_unlock_irqrestore( &pa->lock, flags );
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Remove an IRQ handler from a PC203 interrupt source.
+ *
+ * @param pa The PC203 to remove the handler from.
+ * @param irq The IRQ to remove the handler for.
+ */
+static void
+pc203_remove_irq_handler( struct picoarray *pa,
+                          struct pico_resource *irq )
+{
+    struct list_head *pos;
+    struct list_head *tmp;
+    struct pc203 *dev = to_pc203( pa );
+    int found = 0;
+    struct pc203_irq_handler *handler;
+    unsigned long flags;
+
+    /* Protect against interrupts being raised whilst we remove the handler. */
+    spin_lock_irqsave( &pa->lock, flags );
+
+    list_for_each_safe( pos, tmp, &dev->procif_irq_handlers.list )
+    {
+        handler = container_of( pos, struct pc203_irq_handler, list );
+        if ( handler->irq == irq )
+        {
+            list_del( pos );
+            found = 1;
+            break;
+        }
+    }
+
+    spin_unlock_irqrestore( &pa->lock, flags );
+}
+
+/*!
+ * PC203 procif ISR. This ISR will be called when the procif generates an
+ * interrupts and calls the appropriate handler if there is one registered. If
+ * there is no interrupt handler then the ITM register is cleared to prevent
+ * further interrupts from being raised.
+ *
+ * @param irq The irq that has been raised.
+ * @param dev The PC203 device that has raised the interrupt.
+ * @return Returns IRQ_HANDLED on success.
+ */
+static irqreturn_t
+pc203_procif_irq( int irq,
+                  void *dev )
+{
+    struct pc203 *pc203dev = dev;
+    struct list_head *pos;
+    struct pc203_irq_handler *handler;
+    int ret;
+    int handled = 0;
+
+    list_for_each( pos, &pc203dev->procif_irq_handlers.list )
+    {
+        handler = container_of( pos, struct pc203_irq_handler, list );
+        if ( handler->callback )
+        {
+            ret = handler->callback( handler->irq, handler->cookie );
+            if ( ret )
+                break;
+            handled = 1;
+        }
+    }
+
+    /* Mask out the interrupt to prevent it from occuring again. */
+    if ( !handled )
+        procif_reg_write( pc203dev->reg_base, PC203_PROCIF_ITM_OFFSET, 0 );
+
+    return IRQ_HANDLED;
+}
+
+/*!
+ * DMA callback, call the actuall callback passed to dma_to_device
+ *
+ * @param cookie A pointer to a pc203_dma_cp_param struct
+ */
+void pc203_dma_callback( void *cb_param )
+{
+    struct pc203_dma_cb_param *cookie = (struct pc203_dma_cb_param*)cb_param;
+    cookie->callback( cookie->cookie, 0 );
+}
+
+/*!
+ * DMA a scatter gather list of memory from a kernel mapped scatterlist
+ * into a picoArray DMA channel. After the DMA transfer has completed, the
+ * callback function will be called with the cookie as the parameter. The
+ * caller of this function is responsible for mapping and unmapping the
+ * buffers to be transferred into a DMA capable region.
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_chan The DMA channel to use as a destination.
+ * @param sgl The scatter gather list of the source data.
+ * @param nbytes The number of bytes in the scatter gather list.
+ * @param callback The callback function to be called when the transfer
+ * has completed. The parameter errno will be set to the status of the DMA
+ * operation where 0 == success, negative == failure.
+ * @param cookie The cookie to pass to the callback function.
+ */
+static int
+pc203_dma_memcpy( struct picoarray *pa,
+                  struct pico_resource *dma_channel,
+                  dma_addr_t src,
+                  dma_addr_t dst,
+                  size_t nbytes,
+                  int ( *callback )( void *cookie,
+                                    int errno ),
+                  void *cookie )
+{
+    struct pc203 *pc203dev = to_pc203( pa );
+    struct dma_async_tx_descriptor *tx;
+    struct dma_chan *chan = pc203dev->dma_chan[dma_channel->value];
+
+    tx = chan->device->device_prep_dma_memcpy( chan, dst, src,
+                                               nbytes, DMA_PREP_INTERRUPT);
+    if (!tx)
+        return -ENOMEM;
+
+    pc203dev->callback[dma_channel->value].callback = callback;
+    pc203dev->callback[dma_channel->value].cookie = cookie;
+    pc203dev->callback[dma_channel->value].chanid = dma_channel->value;
+
+    tx->callback = pc203_dma_callback;
+    tx->callback_param = &pc203dev->callback[dma_channel->value];
+    tx->parent = NULL;
+    tx->tx_submit( tx );
+
+    /* Send the DMA to the hardware */
+    dma_async_issue_pending( chan );
+    cpld_dma_reset(dma_channel->value);
+
+    return 0;
+}
+
+/*!
+ * Copy data from the scatter gather list into the pA. The callback function
+ * will be called after the transfer is complete.
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_chan The DMA channel to use as a destination.
+ * @param sgl The scatter gather list of the source data.
+ * @param nbytes The number of bytes in the scatter gather list.
+ * @param callback The callback function to be called when the transfer
+ * has completed. The parameter errno will be set to the status of the DMA
+ * operation where 0 == success, negative == failure.
+ * @param cookie The cookie to pass to the callback function.
+ */
+static int
+pc203_dma_to_device( struct picoarray *pa,
+                     struct pico_resource *dma_chan,
+                     struct scatterlist *sgl,
+                     size_t nbytes,
+                     int ( *callback )( void *cookie,
+                                        int errno ),
+                     void *cookie )
+{
+    struct pc203 *pc203dev = to_pc203( pa );
+
+    dma_addr_t src = sg_dma_address( sgl );
+    dma_addr_t dst = pc203dev->dma_base_phys + dma_chan->offset;
+
+    return pc203_dma_memcpy( pa, dma_chan, src, dst, nbytes, callback, cookie );
+}
+
+/*!
+ * Copy data from the pA into the scatter gather list. The callback function
+ * will be called after the transfer is complete.
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_chan The DMA channel to use as a source.
+ * @param sgl The scatter gather list of the destination buffer.
+ * @param nbytes The number of bytes to transfer.
+ * @param callback The callback function to be called when the transfer
+ * has completed. The parameter errno will be set to the status of the DMA
+ * operation where 0 == success, negative == failure.
+ * @param cookie The cookie to pass to the callback function.
+ */
+static int
+pc203_dma_from_device( struct picoarray *pa,
+                         struct pico_resource *dma_chan,
+                         struct scatterlist *sgl,
+                         size_t nbytes,
+                         int ( *callback )( void *cookie,
+                                            int errno ),
+                         void *cookie )
+{
+    struct pc203 *pc203dev = to_pc203( pa );
+
+    dma_addr_t src = pc203dev->dma_base_phys + dma_chan->offset;
+    dma_addr_t dst = sg_dma_address( sgl );
+
+    return pc203_dma_memcpy( pa, dma_chan, src, dst, nbytes, callback, cookie );
+}
+
+/*!
+ * Choose the specific DMA channel, this will get called once for each
+ * DMA channel until we return true. see `dma_filter_fn` in dmaengine.h for
+ * details.
+ */
+static bool filter(struct dma_chan *chan, void *param)
+{
+    struct pico_resource *dma_channel = (struct pico_resource*)param;
+
+    /* Take the channel that was asked for by pc203_dma_open() */
+    if ( chan->chan_id == dma_channel->value )
+        return true;
+    return false;
+}
+
+/*!
+ * Open and enable the specified DMA channel
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to open
+ * @param is_downlink 1 if the channel is a downlink, 0 for uplink
+ * @return 0 on success, a negative number on failure
+ */
+__must_check static int
+pc203_dma_open( struct picoarray *pa,
+                struct pico_resource *dma_channel,
+                int is_downlink )
+{
+    dma_cap_mask_t mask;
+    struct pc203 *pc203dev = to_pc203( pa );
+    struct fsl_dma_chan *fsl_chan;
+    struct dma_chan *chan;
+
+    dma_cap_zero( mask );
+    dma_cap_set( DMA_MEMCPY, mask );
+    dma_cap_set( DMA_PRIVATE, mask );
+    chan = dma_request_channel( mask, filter, dma_channel );
+    if ( !chan )
+    {
+        PRINTD( COMPONENT_PC203, DBG_ERROR,
+                "Could not open DMA%d",
+                dma_channel->value );
+        return -ENODEV;
+    }
+
+    pc203dev->dma_chan[dma_channel->value] = chan;
+
+    /* Setup the channel as either an uplink or a downlink, this is fsldma
+       driver specific and can't be done through the DMA Engine API. */
+    fsl_chan = to_fsl_chan( pc203dev->dma_chan[dma_channel->value] );
+    fsl_chan->set_dest_loop_size( fsl_chan, 4 );
+    fsl_chan->toggle_ext_start( fsl_chan, 1 );
+    if ( is_downlink )
+        fsl_chan->toggle_ext_pause( fsl_chan, PC203_DOWNLINK_SIZE );
+    else
+        fsl_chan->toggle_ext_pause( fsl_chan, PC203_UPLINK_SIZE );
+
+    /* Setup the CPLD to fix the DMA lines */
+    cpld_dma_enable( dma_channel->value );
+
+    return 0;
+}
+
+/*!
+ * Close and disable the specified DMA channel
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to close
+ * @return 0 in all cases
+ */
+static int
+pc203_dma_close( struct picoarray *pa,
+                 struct pico_resource *dma_channel )
+{
+    struct pc203 *pc203dev = to_pc203( pa );
+
+    cpld_dma_disable(dma_channel->value);
+
+    dma_release_channel( pc203dev->dma_chan[dma_channel->value] );
+    pc203dev->dma_chan[dma_channel->value] = NULL;
+
+    return 0;
+}
+
+/*!
+ * Get the device type of a PC203.
+ *
+ * @param pa The device to query.
+ * @return Always returns PICOARRAY_PC203.
+ */
+static enum picoarray_device_type
+pc203_get_device_type( struct picoarray *pa )
+{
+    return PICOARRAY_PC203;
+}
+
+/*!
+ * Get the ITM, ITS and procIF IRQ resources.
+ * This function will return the pointers to the resources requested on
+ * success or NULL if the resource is already allocated.
+ *
+ * @param pa The device to take to DMA the data.
+ * @param its The ITS resource or NULL on failure
+ * @param itm The ITM resource or NULL on failure
+ * @param procif_irq The IRQ resource or NULL on failure
+ *
+ * @return 0 on success, non-zero on failure
+ */
+static int
+pc203_get_procif_resource( struct picoarray *pa,
+                           struct pico_resource **its,
+                           struct pico_resource **itm,
+                           struct pico_resource **procif_irq )
+{
+    *its = generic_get_resource( pa, PICO_RES_GPR, PC203_GPR_ITS, 1 );
+    *itm = generic_get_resource( pa, PICO_RES_GPR, PC203_GPR_ITM, 1 );
+    *procif_irq = generic_get_resource( pa, PICO_RES_IRQ, PC203_IRQ_PROCIF, 1 );
+
+    return ( (!(*its)) || (!(*itm)) || (!(*procif_irq)) );
+}
+
+/*!
+ * Put the ITM, ITS and procIF IRQ resources.
+ * This function will free any non NULL resources specified
+ *
+ * @param pa The device to take to DMA the data.
+ * @param its The ITS resource
+ * @param itm The ITM resource
+ * @param procif_irq The IRQ resource
+ */
+static void
+pc203_put_procif_resource( struct picoarray *pa,
+                           struct pico_resource *its,
+                           struct pico_resource *itm,
+                           struct pico_resource *procif_irq )
+{
+    if ( its )
+        generic_put_resource( pa, its );
+
+    if ( itm )
+        generic_put_resource( pa, itm );
+
+    if ( procif_irq )
+        generic_put_resource( pa, procif_irq );
+}
+
+/*!
+ * Load the picoArray specified with the array of data
+ *
+ * @param pa The device being written to.
+ * @param data The virtual address of the buffer to write
+ * @param sgl The scatter gather list of the source data.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_pa_load( struct picoarray *pa,
+               u32 *data,
+               struct scatterlist *sgl )
+{
+    struct pc203 *dev = to_pc203( pa );
+    unsigned i;
+    int ret = 0;
+
+    PRINTD( COMPONENT_PC203, DBG_TRACE, "pa[%u]: config reg "
+            "write %u words", pa->dev_num, sgl->length );
+
+    for( i=0; i < sgl->length ; i++)
+    {
+        ret = procif_reg_write( dev->reg_base,
+                                PROCIF_REG_CFG_WR_OFFSET, data[i] );
+        /* Do not need to check return value, it is always true */
+    }
+
+    return i;
+}
+
+/*! Operations for the PC203 devices. */
+static struct picoarray_ops pc203_ops = {
+    .sync                   = pc203_sync,
+    .start                  = pc203_start,
+    .stop                   = pc203_stop,
+    .get_device_type        = pc203_get_device_type,
+    .config_read            = pc203_config_read,
+    .config_write           = pc203_config_write,
+    .register_read          = pc203_register_read,
+    .register_write         = pc203_register_write,
+    .reset                  = pc203_reset,
+    .get_resource           = generic_get_resource,
+    .get_procif_resource    = pc203_get_procif_resource,
+    .put_resource           = generic_put_resource,
+    .put_procif_resource    = pc203_put_procif_resource,
+    .destructor             = pc203_destroy,
+    .add_irq_handler        = pc203_add_irq_handler,
+    .remove_irq_handler     = pc203_remove_irq_handler,
+    .dma_to_device          = pc203_dma_to_device,
+    .dma_from_device        = pc203_dma_from_device,
+    .dma_open               = pc203_dma_open,
+    .dma_close              = pc203_dma_close,
+    .pa_load                = pc203_pa_load,
+};
+
+static int pc203_probe( struct platform_device *pdev );
+static int pc203_remove( struct platform_device *pdev );
+
+/*! The PC203 platform driver.
+ *  \todo Change the name to PC203 specific rather than generic picoArray.
+ */
+static struct platform_driver pc203_driver = {
+    .probe      = pc203_probe,
+    .remove     = pc203_remove,
+    .driver     = {
+        .name   = "picoArray",
+    },
+};
+
+/*!
+ * Probe method for the PC203 platform driver. This function creates a new
+ * PC203 instance and is responsible for allocating all of the resources
+ * required.
+ *
+ * @param pdev The platform device that has been probed.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_probe( struct platform_device *pdev )
+{
+    struct resource *res;
+    int ret;
+    struct pc203 *newdev = kmalloc( sizeof( *newdev ), GFP_KERNEL );
+
+    if ( !newdev )
+        return -ENOMEM;
+
+    ret = -ENOMEM;
+    newdev->pa.resources = kmalloc( sizeof( pc203_resources ), GFP_KERNEL );
+    if ( !newdev->pa.resources )
+        goto out;
+    memcpy( newdev->pa.resources, pc203_resources, sizeof( pc203_resources ) );
+
+    newdev->pa.dev_num = pdev->id;
+    newdev->pa.ops = &pc203_ops;
+    newdev->pa.features = PICOARRAY_HAS_DMA;
+    newdev->pa.max_dma_sz = PICOARRAY_MAX_TRANSFER;
+    spin_lock_init( &newdev->pa.lock );
+
+    ret = -EINVAL;
+    /* Get the procif IRQ. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_IRQ, "procif_irq" );
+    if ( !res )
+        goto out;
+    newdev->procif_irq = res->start;
+
+    /* Get the register base address for the procif. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM, "procif" );
+    if ( !res )
+        goto out;
+    newdev->reg_base_phys = res->start;
+    newdev->reg_base_len = ( res->end - res->start ) + 1;
+
+    /* Get the register base address for the chip control register. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM,
+                                        "ccr_base" );
+    if ( !res )
+        goto out;
+    newdev->ccr_base_phys = res->start;
+    newdev->ccr_base_len = ( res->end - res->start ) + 1;
+
+    /* Get the base address of the memory-mapped pA DMA channel */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM, "dma_base" );
+    if ( !res )
+        goto out;
+    newdev->dma_base_phys = res->start;
+    newdev->dma_base_len = ( res->end - res->start ) + 1;
+
+    /* Map the resources. */
+    newdev->reg_base = request_and_map( "procif", newdev->reg_base_phys,
+                                        newdev->reg_base_len );
+    if ( !newdev->reg_base )
+        goto out;
+
+    newdev->ccr_base = request_and_map( "ccr", newdev->ccr_base_phys,
+                                        newdev->ccr_base_len );
+    if ( !newdev->ccr_base )
+        goto ccr_map_failed;
+
+    ret = request_irq( newdev->procif_irq, pc203_procif_irq, IRQF_DISABLED,
+                       pdev->name, newdev );
+    if ( ret )
+        goto procif_irq_failed;
+
+    /* Register our interest in DMA channels */
+    dmaengine_get();
+
+    /* Initialise the interrupt handler lists. */
+    INIT_LIST_HEAD( &newdev->procif_irq_handlers.list );
+
+    ret = picoif_register_dev( &newdev->pa );
+    goto out;
+
+procif_irq_failed:
+    unmap_and_release( newdev->ccr_base_phys, newdev->ccr_base_len,
+                       newdev->ccr_base );
+
+ccr_map_failed:
+    unmap_and_release( newdev->reg_base_phys, newdev->reg_base_len,
+                       newdev->reg_base );
+out:
+    if ( ret && newdev->pa.resources )
+        kfree( newdev->pa.resources );
+
+    if ( ret )
+    {
+        platform_driver_unregister( &pc203_driver );
+        kfree( newdev );
+    }
+    else
+        ++num_pc203s;
+
+    if ( !ret )
+    {
+        PRINTD( COMPONENT_PC203, DBG_TRACE, "PC203 device %d registered",
+                newdev->pa.dev_num );
+    }
+    return ret;
+}
+
+/*!
+ * Remove method for the PC203 platform driver. This method is called when the
+ * platform driver is removed and must release all resources the driver has
+ * been using.
+ *
+ * @param pdev The platform device being remove.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc203_remove( struct platform_device *pdev )
+{
+    struct picoarray *pa = picoif_get_device( pdev->id );
+    struct pc203 *pc203dev = to_pc203( pa );
+    int ret = 0;
+
+    free_irq( pc203dev->procif_irq, pc203dev );
+    unmap_and_release( pc203dev->ccr_base_phys, pc203dev->ccr_base_len,
+                       pc203dev->ccr_base );
+    unmap_and_release( pc203dev->reg_base_phys, pc203dev->reg_base_len,
+                       pc203dev->reg_base );
+
+    kfree( pc203dev->pa.resources );
+    kfree( pc203dev );
+
+    /* Release our interest in DMA channels */
+    dmaengine_put();
+
+    return ret;
+}
+
+int
+pc203_init( void )
+{
+    return platform_driver_register( &pc203_driver );
+}
+
+/*!
+ * Destructor to be called when a PC203 is removed from picoif. This
+ * function must decrement the number of PC203s registered, and when this
+ * reaches zero, remove the platform driver.
+ *
+ * @param pa The device being removed.
+ */
+static void
+pc203_destroy( struct picoarray *pa )
+{
+    PRINTD( COMPONENT_PC203, DBG_TRACE, "pA[%u]: destructor called",
+            pa->dev_num );
+
+    /* If we have no more pc203s, then remove the driver. */
+    if ( 0 == --num_pc203s )
+        platform_driver_unregister( &pc203_driver );
+}
diff --git a/drivers/picochip/pc302.c b/drivers/picochip/pc302.c
new file mode 100644
index 0000000..bedd421
--- /dev/null
+++ b/drivers/picochip/pc302.c
@@ -0,0 +1,1633 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file pc302.c
+ * \brief PC302 device implementation.
+ *
+ * This file implements the PC302 support of picoIf. All implementation in
+ * this file is private and should not be accessed directly by users and only
+ * provides the necessary basic services with which transports can be built
+ * upon and devices configured.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/jiffies.h>
+#include <asm/io.h>
+#include <mach/pc302/axi2cfg.h>
+#include <mach/pc302/pc302.h>
+#include <mach/pc302_dmac.h>
+
+#include <linux/picochip/devices/pc302.h>
+
+#include "picoarray.h"
+#include "resource.h"
+#include "picoif_internal.h"
+#include "axi2cfg.h"
+#include "debug.h"
+#include "soft_reset.h"
+#include "utilities_internal.h"
+#include "axi2cfg.h"
+
+/*! The address of the AXI2Pico interrupt status register. This is an offset
+ * from the AXI2Pico base address. */
+#define AXI2PICO_INT_STATUS_OFFSET  ( 0x0200 )
+
+/*! The number of virtual ports in the AXI2Pico. */
+#define AXI2PICO_NUM_VPS           ( 32 )
+
+/*! The spacing of virtual ports in the AXI2Pico. */
+#define AXI2PICO_VP_SPACING         ( 0x10 )
+
+/*! The offset of a virtual port config register from the virtual port
+ *  register base. */
+#define AXI2PICO_VP_CONFIG_OFFSET   ( 0x00 )
+
+/*! The offset of a virtual port status register from the virtual port
+ *  register base. */
+#define AXI2PICO_VP_STATUS_OFFSET   ( 0x04 )
+
+/*! The offset of the data register for a virtual port in the AXI2Pico. */
+#define AXI2PICO_VP_DATA_OFFSET     ( 0x08 )
+
+/*! The CAEID of the procif. */
+#define PC302_AXI2CFG_CAEID          ( 0x48 )
+
+/*! The CAEID of the AXI2Pico. */
+#define PC302_AXI2PICO_CAEID	     ( 0xa8 )
+
+/*! The CAEID of the Frac-N. */
+#define PC302_FRACN_CAEID            ( 0x0578 )
+
+/*! The offset in the procif for the operation request register. */
+#define PC302_AXI2CFG_OP_REQ_OFFSET  ( 0x4018 )
+/*! The offset in the procif for the operation status register. */
+#define PC302_PROCIF_OP_STATUS_OFFSET  ( 0x401c )
+/*! The offset of the start request bit in the operation request register. */
+#define PC302_AXI2CFG_OP_REQ_START   ( 1 << 1 )
+
+/*! The position of the interrupt enable bit in a virtual port config
+ *  register. */
+#define AXI2PICO_INT_EN             ( 1 << 0 )
+
+/*! The offset in an AE for the sleep register. */
+#define SLEEP_REG_OFFSET	    ( 0xA060 )
+
+/*! Timeout for DMA load of picoArray */
+#define TIMEOUT_10MS                ( HZ / 100 )
+
+/*! DMA burst size in words */
+#define PC302_DMA_BURST_SIZE        ( 1 )
+
+/*! The maximum number of transactions per transfer */
+#define DMAH_CHX_MAX_BLK_SIZE       ( 4095 )
+
+/*! Determine the msize and max transfer size that is permitted */
+#if ((PC302_DMA_BURST_SIZE == 1) || (PC302_DMA_BURST_SIZE == 2))
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC302_DMA_MS_1_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 4)
+#elif (PC302_DMA_BURST_SIZE == 4)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC302_DMA_MS_4_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 8)
+#elif (PC302_DMA_BURST_SIZE == 8)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC302_DMA_MS_8_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 16)
+#elif (PC302_DMA_BURST_SIZE == 16)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC302_DMA_MS_16_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 32)
+#elif (PC302_DMA_BURST_SIZE == 32)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC302_DMA_MS_32_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 64)
+#else
+    #error
+#endif
+
+/*!
+ * Determine if a GPR port is enabled
+ */
+#define IS_PORT_ENABLED(status_reg) (status_reg & 0x1)
+
+/*!
+ *  Determine if a GPR port is configured as a receive port
+ */
+#define IS_PORT_A_RECEIVE(status_reg) (status_reg & 0x2)
+
+/*!
+ *  Determine if a GPR port is configured as a non blocking port
+ */
+#define IS_PORT_NONBLOCKING(status_reg) (status_reg & 0x4)
+
+/*!
+ *  Determine if a GPR port is ready to give or receive data
+ */
+#define IS_PORT_READY_FOR_DATA(status_reg) (status_reg & 0x8)
+
+/*! The number of registered PC302s in the system. Until this reaches zero, we
+ * can't unregister the platform driver. */
+static unsigned num_pc302s;
+
+static void
+pc302_destroy( struct picoarray *pa );
+
+/*!
+ * \brief PC302 IRQ handler.
+ *
+ * This structure defines an IRQ handler for PC302 devices and is an internal
+ * structure that could be reused for other device types.
+ */
+struct pc302_irq_handler
+{
+    /*! The position in the list of handlers for an interrupt source. */
+    struct list_head        list;
+
+    /*! The IRQ that this handles. */
+    struct pico_resource    *irq;
+
+    /*! A cookie to pass to the callback function when the interrupt is
+     * raised. */
+    void                    *cookie;
+
+    /*! The callback function to call when the interrupt is raised. */
+    int                     ( *callback )( struct pico_resource *irq,
+                                           void *cookie );
+};
+
+/*!
+ * \brief PC302 DMA handler
+ *
+ * This structure defines a DMA handler for PC302 devices and is an internal
+ * strucutre that might be reused for other device types that uses the Synopsys
+ * DMAC. There will be one instance of this structure per DMA channel in the
+ * system.
+ */
+struct pc302_dma_channel
+{
+    /*! Structure holding the current transfer details */
+    pc302_dma_xfr_t xfr;
+
+    /*! Definition of the hardware handshaking interface set for this channel */
+    pc302_dma_handshake_t hs;
+
+    /*! Identification of the DMAC connected to this channel */
+    pc302_dma_t dmac;
+
+    /*! Scatter / gather list for this channel */
+    pc302_dma_list_t sgl;
+
+    /*! DMA source master */
+    pc302_master_t srcMaster;
+
+    /*! DMA destination master */
+    pc302_master_t dstMaster;
+
+    /*! picoArray DMA channel number */
+    unsigned channel;
+
+    /*! Channel status (1 for active and 0 for waiting) */
+    int stateActive;
+
+    /*! Physical address for the picoArray DMA channel */
+    dma_addr_t pico_addr;
+
+    /*! The callback function to call when the DMA transfer is completed. */
+    int ( *callback )( void *cookie,
+                       int errno );
+
+    /*! User data */
+    void *cookie;
+};
+
+/*!
+ * \brief Private representation of a PC302 device.
+ *
+ * This describes all private data required in the PC302 implementation of
+ * this driver.
+ *
+ * \extends picoarray
+ */
+struct pc302
+{
+    /*! The picoArray base class. */
+    struct picoarray            pa;
+
+    /*! The physical address of the lower axi2cfg registers. */
+    dma_addr_t                  axi2cfg1_base_phys;
+
+    /*! The length of the lowe axi2cfg registers in bytes. */
+    size_t                      axi2cfg1_base_len;
+
+    /*! The virtually mapped address of the lower axi2cfg registers. */
+    void __iomem                *axi2cfg1_base;
+
+    /*! The physical address of the upper axi2cfg registers. */
+    dma_addr_t                  axi2cfg2_base_phys;
+
+    /*! The length of the upper axi2cfg registers in bytes. */
+    size_t                      axi2cfg2_base_len;
+
+    /*! The virtually mapped address of the upper axi2cfg registers. */
+    void __iomem                *axi2cfg2_base;
+
+    /*! The physical address of the AXI2Pico registers. */
+    dma_addr_t                  axi2pico_base_phys;
+
+    /*! The length of the AXI2Pico registers in bytes. */
+    size_t                      axi2pico_base_len;
+
+    /*! The virtually mappped address of the AXI2Pico registers. */
+    void __iomem                *axi2pico_base;
+
+    /*! The AXI2Pico IRQ number. The AXI2Pico supports a number of interrupt
+     * sources, but these are all raised through a single IRQ line. */
+    unsigned                    gpr_irq;
+
+    /*! The handlers registered for the AXI2Pico IRQ. */
+    struct pc302_irq_handler    axi2pico_irq_handlers;
+
+    /*! DMA channel data */
+    struct pc302_dma_channel    dma_channel[PICO_NUM_DMA_CHANNELS];
+};
+
+/*!
+ * Get the PC302 structure given a picoArray base class.
+ *
+ * @param pa The base class pointer.
+ * @return Returns a pointer to the PC302 structure on success, NULL on
+ * failure.
+ */
+static inline struct pc302 *
+to_pc302( struct picoarray *pa )
+{
+    return pa ? container_of( pa, struct pc302, pa ) : NULL;
+}
+
+/*!
+ * Write the value of an AXI2Pico register.
+ *
+ * @param dev The PC302 owning the AXI2Pico.
+ * @param offset The offset of the register in bytes.
+ * @param value The value of the register to write.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_axi2pico_reg_write( struct pc302 *dev,
+                          unsigned offset,
+                          u32 value )
+{
+    PRINTD( COMPONENT_PC302, DBG_TRACE, "pA[%u] axi2pico, %04x:=%08x",
+            dev->pa.dev_num, offset, value );
+    picoif_out32( value, dev->axi2pico_base + offset );
+    return 0;
+}
+
+/*!
+ * Read the value of an AXI2Pico register.
+ *
+ * @param dev The PC302 owning the AXI2Pico.
+ * @param offset The offset of the register in bytes.
+ * @param[out] value Pointer to the address to store the register value in.
+ */
+static void
+pc302_axi2pico_reg_read( struct pc302 *dev,
+                         unsigned offset,
+                         u32 *value )
+{
+    *value = picoif_in32( dev->axi2pico_base + offset );
+}
+
+/*!
+ * Read a number of 16 bit words from the PC302 axi2cfg.
+ *
+ * @param pa The device to read from.
+ * @param caeid The CAEID of the AE to read from.
+ * @param address The start address in the AE to begin reading from.
+ * @param count The number of 16 bit words to read.
+ * @param[out] data The buffer to store the data in.
+ * @return Returns the number of words read on success, negative on failure.
+ */
+static int
+pc302_config_read( struct picoarray *pa,
+                   u16 caeid,
+                   u16 address,
+                   u16 count,
+                   u16 *data )
+{
+    struct pc302 *dev = to_pc302( pa );
+
+    PRINTD( COMPONENT_PC302, DBG_TRACE,
+            "pa[%u]: config read %u words %04x@%04x", pa->dev_num,
+            count, caeid, address );
+
+    return axi2cfg_config_read( dev->axi2cfg2_base, caeid, address, data, count );
+}
+
+/*!
+ * Write a number of 16 bit words to the PC302 axi2cfg.
+ *
+ * @param pa The device to write to.
+ * @param caeid The CAEID of the AE to write to.
+ * @param address The start address in the AE to begin writing to.
+ * @param count The number of 16 bit words to write.
+ * @param[in] data The buffer to write from.
+ * @return Returns the number of words written on success, negative on failure.
+ */
+static int
+pc302_config_write( struct picoarray *pa,
+                    u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *data )
+{
+    struct pc302 *dev = to_pc302( pa );
+
+    PRINTD( COMPONENT_PC302, DBG_TRACE,
+            "pa[%u]: config write %u words %04x@%04x", pa->dev_num,
+            count, caeid, address );
+
+    return axi2cfg_config_write( dev->axi2cfg2_base, caeid, address, data, count );
+}
+
+/*!
+ * Sync the PC302 device. PC302 requires no synchronisation as it is a single
+ * device so do nothing.
+ *
+ * @param pa The device to sync.
+ * @return Always returns zero.
+ */
+static int
+pc302_sync( struct picoarray *pa )
+{
+    return 0;
+}
+
+/*!
+ * Start the PC302 device running.
+ *
+ * @param pa The device to start.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_start( struct picoarray *pa )
+{
+    u16 val;
+    int ret = pa->ops->config_read( pa, PC302_AXI2CFG_CAEID,
+                                    PC302_AXI2CFG_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+    val |= PC302_AXI2CFG_OP_REQ_START;
+    ret = pa->ops->config_write( pa, PC302_AXI2CFG_CAEID,
+                                 PC302_AXI2CFG_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Stop the PC302 device running.
+ *
+ * @param pa The device to stop.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_stop( struct picoarray *pa )
+{
+    u16 val;
+    int ret = pa->ops->config_read( pa, PC302_AXI2CFG_CAEID,
+                                    PC302_AXI2CFG_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+    val &= ~PC302_AXI2CFG_OP_REQ_START;
+    ret = pa->ops->config_write( pa, PC302_AXI2CFG_CAEID,
+                                 PC302_AXI2CFG_OP_REQ_OFFSET, 1, &val );
+    if ( 1 != ret )
+        goto out;
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*! The CAEID of the MemIf. */
+#define PC302_MEMIF_CAEID           ( 0x88 )
+/*! The address of the FIFO status lower register. */
+#define PC302_MEMIF_FIFO_STAT_LOW   ( 0x0080 )
+
+/*! The CAEID of the PAI */
+#define PC302_PAI_CAEID             ( 0x0578 )
+/*! The address of the pai_io_ctrl register. */
+#define PC302_PAI_IO_CTRL_REG       ( 0x0009 )
+
+/*!
+ * Reset the PC302. This performs a soft reset that returns the picoArray to
+ * be as close as possible to the hardware reset state without affecting the
+ * ARM subsystem.
+ *
+ * @param pa The device being reset.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_reset( struct picoarray *pa )
+{
+    int ret;
+    unsigned long flags;
+    u16 val;
+    u16 io_ctrl_value;
+
+    u16 buf_vals[ 0x14 ] = {
+                            0xf0, 0, 0xf0, 0, 0xf0, 0, 0xf0, 0, 0xf0, 0,
+                            0xf0, 0, 0xf0, 0, 0xf0, 0, 0xf0, 0, 0xf0, 0,
+                           };
+    u16 error_vals[ 4 ] = { 0, 0, 0, 0, };
+
+    PRINTD( COMPONENT_PC302, DBG_TRACE, "pa[%u]: reset", pa->dev_num );
+
+    spin_lock_irqsave( &pa->lock, flags );
+    ret = pa->ops->config_write( pa, PC302_MEMIF_CAEID, 0, 0x14, buf_vals );
+    if ( 0x14 != ret )
+        goto out;
+
+    ret = pa->ops->config_write( pa, PC302_MEMIF_CAEID,
+                                 PC302_MEMIF_FIFO_STAT_LOW, 4, error_vals );
+    if ( 4 != ret )
+        goto out;
+
+    /* Save the PAI io_ctrl register value */
+    ret = pa->ops->config_read( pa, PC302_PAI_CAEID,
+                                PC302_PAI_IO_CTRL_REG, 1,
+                                &io_ctrl_value );
+    if ( 1 != ret )
+        goto out;
+
+    syscfg_update( AXI2CFG_SYS_CONFIG_PA_RST_MASK,
+                   AXI2CFG_SYS_CONFIG_PA_RST_MASK);
+
+    /* Wait for the reset to clear. */
+    while ( syscfg_read() & AXI2CFG_SYS_CONFIG_PA_RST_MASK )
+        cpu_relax();
+
+    /* Wake the AXI2Pico and the Frac-N back up. We need to do this so that the
+     * GPIO driver and Frac-N drivers can keep running without losing access to
+     * their blocks. */
+    val = 0;
+    ret =  pa->ops->config_write( pa, PC302_AXI2PICO_CAEID,
+				  SLEEP_REG_OFFSET, 1, &val );
+    if ( 1 != ret)
+        goto out;
+
+    ret = pa->ops->config_write( pa, PC302_FRACN_CAEID,
+				 SLEEP_REG_OFFSET, 1, &val );
+    if ( 1 != ret)
+        goto out;
+
+    /* Wake up the PAI up so we can restore the io_ctrl register
+     * back to what it was prior to the reset happening. */
+    ret = pa->ops->config_write( pa, PC302_PAI_CAEID,
+                                 SLEEP_REG_OFFSET, 1, &val );
+    if ( 1 != ret)
+        goto out;
+
+    /* Restore the PAI io_ctrl register value */
+    ret = pa->ops->config_write( pa, PC302_PAI_CAEID,
+                                 PC302_PAI_IO_CTRL_REG, 1,
+                                 &io_ctrl_value );
+    if ( 1 != ret)
+        goto out;
+
+    ret = 0;
+
+out:
+    spin_unlock_irqrestore( &pa->lock, flags );
+    return ret;
+}
+
+/*!
+ * Read a GPR (general purpose register) in the PC302.
+ *
+ * @param pa The device being read from.
+ * @param reg The register to read.
+ * @param[out] value The address to store the register value in.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_register_read( struct picoarray *pa,
+                     struct pico_resource *reg,
+                     u32 *value )
+{
+    struct pc302 *dev = to_pc302( pa );
+    u32 gprStatus = 0;
+
+    if ( !reg || PICO_RES_GPR != reg->type )
+        return -EINVAL;
+
+    if ( reg->value < PC302_GPR_AXI2PICO_0 ||
+         reg->value > PC302_GPR_AXI2PICO_23 )
+        return -EINVAL;
+
+    pc302_axi2pico_reg_read( dev, reg->offset + AXI2PICO_VP_STATUS_OFFSET,
+                             &gprStatus );
+    if ((!IS_PORT_ENABLED(gprStatus)) ||
+        (!IS_PORT_A_RECEIVE(gprStatus)) ||
+        (!IS_PORT_READY_FOR_DATA(gprStatus)))
+      return -EINVAL;
+
+    pc302_axi2pico_reg_read( dev, reg->offset + AXI2PICO_VP_DATA_OFFSET,
+                             value );
+
+    return 0;
+}
+
+/*!
+ * Write a GPR (general purpose register) in the PC302.
+ *
+ * @param pa The device being written to.
+ * @param reg The register to write.
+ * @param value The value to write to the register.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_register_write( struct picoarray *pa,
+                      struct pico_resource *reg,
+                      u32 value )
+{
+    struct pc302 *dev = to_pc302( pa );
+    u32 gprStatus = 0;
+
+    if ( !reg || PICO_RES_GPR != reg->type )
+        return -EINVAL;
+
+    if ( reg->value < PC302_GPR_AXI2PICO_0 ||
+         reg->value > PC302_GPR_AXI2PICO_23 )
+        return -EINVAL;
+
+    pc302_axi2pico_reg_read( dev, reg->offset + AXI2PICO_VP_STATUS_OFFSET,
+          &gprStatus );
+    if ((!IS_PORT_ENABLED(gprStatus)) ||
+        (IS_PORT_A_RECEIVE(gprStatus)) ||
+        (!IS_PORT_READY_FOR_DATA(gprStatus)))
+      return -EINVAL;
+
+    pc302_axi2pico_reg_write( dev, reg->offset + AXI2PICO_VP_DATA_OFFSET,
+                              value );
+
+    return 0;
+}
+
+/*!
+ * Load the picoArray specified with the array of data
+ *
+ * @param pa The device being written to.
+ * @param data The virtual address of the buffer to write
+ * @param sgl The scatter gather list of the source data.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_pa_load( struct picoarray *pa,
+               u32 *data,
+               struct scatterlist *sgl  )
+{
+    struct pc302 *dev = to_pc302( pa );
+    int ret = 0;
+    pc302_dma_endpoint_t src_ep;
+    pc302_dma_endpoint_t dst_ep;
+    pc302_dma_t dma=NULL;
+    pc302_dma_xfr_t dma_xfr=NULL;
+    unsigned long timeout_jiffies = 0;
+    u32 tmp = 0;
+
+    /* Purge the configuration read and write ports */
+    ret = axi2cfg_reg_write( dev->axi2cfg1_base, AXI2CFG_REG_PURGE_CFG,
+           ( AXI2CFG_PURGE_CFG_RD_PORT_IDX | AXI2CFG_PURGE_CFG_WR_PORT_IDX ));
+
+    /* Poll purge configuration register to determine when the purge has
+       completed */
+    timeout_jiffies = jiffies + TIMEOUT_10MS;
+    while (1)
+    {
+        ret = axi2cfg_reg_read( dev->axi2cfg1_base,
+                AXI2CFG_REG_PURGE_CFG, &tmp );
+        if (!(tmp & AXI2CFG_PURGE_CFG_WR_PRGSS_PORT_IDX))
+            break;
+
+        /* Check for time out */
+        if (time_after(jiffies, timeout_jiffies))
+        {
+            PRINTD( COMPONENT_PC302, DBG_WARN,
+                "Timed out waiting for DMA configuration purge to complete");
+            ret = -EIO;
+            goto out;
+        }
+        cpu_relax();
+    }
+
+    /* Enable DMAC interface */
+    ret =  axi2cfg_reg_write( dev->axi2cfg1_base, AXI2CFG_REG_DMAC1_CFG,
+        (AXI2CFG_DMAC1_CONFIG_DMA_WRITE_IDX | AXI2CFG_DMAC1_CONFIG_ENABLE_IDX));
+
+    /* Get the DMAC handle for a DMAC 2 which is the only DMAC that connects
+       to the AXI2CFG bus */
+    dma = pc302_dma_get_dma_handle(1);
+    if (dma == NULL)
+    {
+        ret = -ENOMEM;
+        goto out;
+    }
+
+    PRINTD( COMPONENT_PC302, DBG_TRACE, "src=%08X, cnt=%d", sg_dma_address( sgl ),
+          sgl->length );
+
+    /* Set up the source endpoint, source can be master 1, 2 or 3, but pick
+     * 1 as we shouldn't be too busy at this point. The AXI2Cfg is fixed to
+     * master 4 so we have to use that. The AXI2Cfg doesn't require any
+     * hardware flow control for writing so treat it like a non-incrementing
+     * block of memory. */
+    src_ep.dma_addr = sg_dma_address( sgl );
+    src_ep.master = PC302_DMA_MASTER1;
+    src_ep.periph_not_mem = 0;
+    src_ep.flow_controller = 0;
+    src_ep.enable_sg = 0;
+    src_ep.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    if ( sgl->length % 2)
+        src_ep.tr_width = PC302_DMA_TR_WIDTH32;
+    else
+        src_ep.tr_width = PC302_DMA_TR_WIDTH64;
+    src_ep.auto_reload = 0;
+    src_ep.msize = PC302_DMA_MS_AUTO;
+
+    dst_ep.dma_addr = dev->axi2cfg2_base_phys + AXI2CFG_REG_CFG_WR;
+    dst_ep.master = PC302_DMA_MASTER4;
+    dst_ep.periph_not_mem = 0;
+    dst_ep.flow_controller = 0;
+    dst_ep.enable_sg = 0;
+    dst_ep.addr_inc = PC302_DMA_ADDR_NO_CHANGE;
+    dst_ep.tr_width = PC302_DMA_TR_WIDTH32;
+    dst_ep.msize = PC302_DMA_MS_AUTO;
+    dst_ep.auto_reload = 0;
+
+    dma_xfr = pc302_dma_setup_direct_xfr( dma, &src_ep, &dst_ep, NULL, NULL,
+                                          sgl->length * sizeof( u32 ),
+                                          PC302_DMA_PROTCTL_1, NULL, NULL );
+    if (dma_xfr == NULL)
+    {
+        PRINTD( COMPONENT_PC302, DBG_WARN, "NULL xfr" );
+        return -EIO;
+    }
+
+    /* Clear interrupts for this channel */
+    pc302_dma_clear_int(dma_xfr,PC302_DMA_INT_TRANSFER);
+
+    ret = pc302_dma_start(dma_xfr);
+    if (ret)
+    {
+        PRINTD( COMPONENT_PC302, DBG_WARN, "error starting xfr" );
+        goto dma_start_failed;
+    }
+
+    /* Poll status register to determine when the transfer has completed */
+    timeout_jiffies = jiffies + TIMEOUT_10MS;
+    while (1)
+    {
+        if (pc302_dma_get_raw_status(dma_xfr,PC302_DMA_INT_TRANSFER))
+            break;
+
+        /* Check for time out */
+        if (time_after(jiffies, timeout_jiffies))
+        {
+            PRINTD( COMPONENT_PC302, DBG_WARN,
+                    "Timed out waiting for DMA Load to complete");
+            ret = -EIO;
+            break;
+        }
+
+        cpu_relax();
+    }
+
+dma_start_failed:
+    ret = pc302_dma_release(dma_xfr);
+    if ( ret )
+        PRINTD( COMPONENT_PC302, DBG_WARN, "DMA release failed, "
+            "return code = %d", ret );
+
+out:
+    /* Permit ARM access to configuration port, disable DMAC interface */
+    ( void )axi2cfg_reg_write( dev->axi2cfg1_base, AXI2CFG_REG_DMAC1_CFG,
+                               0x00000 );
+
+    if ( !ret )
+        return sgl->length;
+
+    return ret;
+}
+
+/*! The resources for a PC302 device. */
+static struct pico_resource pc302_resources[] = {
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC302_DMA_AXI2PICO_0, .offset = 0x00 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC302_DMA_AXI2PICO_1, .offset = 0x10 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC302_DMA_AXI2PICO_2, .offset = 0x20 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC302_DMA_AXI2PICO_3, .offset = 0x30 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC302_DMA_AXI2PICO_4, .offset = 0x40 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC302_DMA_AXI2PICO_5, .offset = 0x50 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC302_DMA_AXI2PICO_6, .offset = 0x60 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC302_DMA_AXI2PICO_7, .offset = 0x70 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_0, .metadata = PC302_IRQ_AXI2PICO_0, .offset = 0x80 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_1, .metadata = PC302_IRQ_AXI2PICO_1, .offset = 0x90 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_2, .metadata = PC302_IRQ_AXI2PICO_2, .offset = 0xa0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_3, .metadata = PC302_IRQ_AXI2PICO_3, .offset = 0xb0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_4, .metadata = PC302_IRQ_AXI2PICO_4, .offset = 0xc0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_5, .metadata = PC302_IRQ_AXI2PICO_5, .offset = 0xd0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_6, .metadata = PC302_IRQ_AXI2PICO_6, .offset = 0xe0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_7, .metadata = PC302_IRQ_AXI2PICO_7, .offset = 0xf0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_8, .metadata = PC302_IRQ_AXI2PICO_8, .offset = 0x100 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_9, .metadata = PC302_IRQ_AXI2PICO_9, .offset = 0x110 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_10, .metadata = PC302_IRQ_AXI2PICO_10, .offset = 0x120 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_11, .metadata = PC302_IRQ_AXI2PICO_11, .offset = 0x130 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_12, .metadata = PC302_IRQ_AXI2PICO_12, .offset = 0x140 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_13, .metadata = PC302_IRQ_AXI2PICO_13, .offset = 0x150 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_14, .metadata = PC302_IRQ_AXI2PICO_14, .offset = 0x160 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_15, .metadata = PC302_IRQ_AXI2PICO_15, .offset = 0x170 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_16, .metadata = PC302_IRQ_AXI2PICO_16, .offset = 0x180 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_17, .metadata = PC302_IRQ_AXI2PICO_17, .offset = 0x190 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_18, .metadata = PC302_IRQ_AXI2PICO_18, .offset = 0x1a0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_19, .metadata = PC302_IRQ_AXI2PICO_19, .offset = 0x1b0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_20, .metadata = PC302_IRQ_AXI2PICO_20, .offset = 0x1c0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_21, .metadata = PC302_IRQ_AXI2PICO_21, .offset = 0x1d0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_22, .metadata = PC302_IRQ_AXI2PICO_22, .offset = 0x1e0 },
+    { .type = PICO_RES_GPR, .value = PC302_GPR_AXI2PICO_23, .metadata = PC302_IRQ_AXI2PICO_23, .offset = 0x1f0 },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_0, .metadata = PC302_GPR_AXI2PICO_0, .offset = 8, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_1, .metadata = PC302_GPR_AXI2PICO_1, .offset = 9, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_2, .metadata = PC302_GPR_AXI2PICO_2, .offset = 10, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_3, .metadata = PC302_GPR_AXI2PICO_3, .offset = 11, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_4, .metadata = PC302_GPR_AXI2PICO_4, .offset = 12, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_5, .metadata = PC302_GPR_AXI2PICO_5, .offset = 13, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_6, .metadata = PC302_GPR_AXI2PICO_6, .offset = 14, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_7, .metadata = PC302_GPR_AXI2PICO_7, .offset = 15, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_8, .metadata = PC302_GPR_AXI2PICO_8, .offset = 16, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_9, .metadata = PC302_GPR_AXI2PICO_9, .offset = 17, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_10, .metadata = PC302_GPR_AXI2PICO_10, .offset = 18, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_11, .metadata = PC302_GPR_AXI2PICO_11, .offset = 19, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_12, .metadata = PC302_GPR_AXI2PICO_12, .offset = 20, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_13, .metadata = PC302_GPR_AXI2PICO_13, .offset = 21, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_14, .metadata = PC302_GPR_AXI2PICO_14, .offset = 22, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_15, .metadata = PC302_GPR_AXI2PICO_15, .offset = 23, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_16, .metadata = PC302_GPR_AXI2PICO_16, .offset = 24, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_17, .metadata = PC302_GPR_AXI2PICO_17, .offset = 25, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_18, .metadata = PC302_GPR_AXI2PICO_18, .offset = 26, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_19, .metadata = PC302_GPR_AXI2PICO_19, .offset = 27, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_20, .metadata = PC302_GPR_AXI2PICO_20, .offset = 28, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_21, .metadata = PC302_GPR_AXI2PICO_21, .offset = 29, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_22, .metadata = PC302_GPR_AXI2PICO_22, .offset = 30, },
+    { .type = PICO_RES_IRQ, .value = PC302_IRQ_AXI2PICO_23, .metadata = PC302_GPR_AXI2PICO_23, .offset = 31, },
+    { .type = 0, .value = 0 }, /* Sentinel value. Do not remove and keep this
+                                * at the end. */
+};
+
+/*! The offset in the AXI2Pico for GPR virtual ports. */
+#define AXI2PICO_GPR_VP_START       ( 0x80 )
+
+/*!
+ * Add an IRQ handler to the PC302 for a given interrupt source.
+ *
+ * @param pa The device to register the interrupt handler with.
+ * @param irq The IRQ to attach the handler to.
+ * @param callback The callback function to call when the interrupt is
+ * raised.
+ * @param cookie The cookie to pass to the callback function. This may be NULL
+ * if it is not required.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_add_irq_handler( struct picoarray *pa,
+                       struct pico_resource *irq,
+                       int ( *callback )( struct pico_resource *irq,
+                                          void *cookie ),
+                       void *cookie )
+{
+    struct pc302_irq_handler *handler;
+    struct pc302 *dev = to_pc302( pa );
+    int ret;
+    unsigned gpr_num = irq->value - PC302_IRQ_AXI2PICO_0;
+    unsigned offset =
+            AXI2PICO_GPR_VP_START + ( gpr_num * AXI2PICO_VP_SPACING );
+    u32 val = 0;
+    unsigned long flags;
+
+    if ( irq->type != PICO_RES_IRQ || !irq->exclusive || !callback )
+        return -EINVAL;
+
+    spin_lock_irqsave( &pa->lock, flags );
+
+    /* Need to check that the port is bocking before enabling interrupts */
+    pc302_axi2pico_reg_read( dev, offset + AXI2PICO_VP_STATUS_OFFSET,
+                             &val);
+
+    /* If the port is non-blocking then fail as we will receive constant
+     * interrupts. We also only support receive GPRs for interrupt
+     * generation. */
+    if ( !IS_PORT_A_RECEIVE( val ) || IS_PORT_NONBLOCKING( val ) )
+    {
+        PRINTD( COMPONENT_PC302, DBG_WARN,
+                "cannot enable IRQ: AXI2Pico VP is not"
+                " configured as blocking receive" );
+        PRINTD( COMPONENT_PC302, DBG_WARN,"offset=%d",offset);
+        ret = -EIO;
+        goto out;
+    }
+
+    ret = -ENOMEM;
+    handler = kmalloc( sizeof( *handler ), GFP_KERNEL );
+    if ( !handler )
+        goto out;
+
+    handler->callback   = callback;
+    handler->cookie     = cookie;
+    handler->irq        = irq;
+
+    list_add( &handler->list, &dev->axi2pico_irq_handlers.list );
+
+    /* Enable the interrupt. */
+    pc302_axi2pico_reg_read( dev, offset + AXI2PICO_VP_CONFIG_OFFSET, &val );
+    val |= AXI2PICO_INT_EN;
+    pc302_axi2pico_reg_write( dev, offset + AXI2PICO_VP_CONFIG_OFFSET, val );
+
+    ret = 0;
+out:
+
+    spin_unlock_irqrestore( &pa->lock, flags );
+    return ret;
+}
+
+
+/*!
+ * Remove an IRQ handler from a PC302 interrupt source.
+ *
+ * @param pa The PC302 to remove the handler from.
+ * @param irq The IRQ to remove the handler for.
+ */
+static void
+pc302_remove_irq_handler( struct picoarray *pa,
+                          struct pico_resource *irq )
+{
+    struct list_head *pos;
+    struct list_head *tmp;
+    struct pc302 *dev = to_pc302( pa );
+    struct pc302_irq_handler *handler;
+    unsigned long flags;
+    unsigned gpr_num = irq->value - PC302_IRQ_AXI2PICO_0;
+    unsigned offset =
+            AXI2PICO_GPR_VP_START + ( gpr_num * AXI2PICO_VP_SPACING );
+    u32 val= 0;
+
+    /* Protect against interrupts being raised whilst we remove the handler.
+     */
+    spin_lock_irqsave( &pa->lock, flags );
+
+    /* Disable the interrupt. */
+    pc302_axi2pico_reg_read( dev, offset + AXI2PICO_VP_CONFIG_OFFSET, &val );
+    val &= ~AXI2PICO_INT_EN;
+    pc302_axi2pico_reg_write( dev, offset + AXI2PICO_VP_CONFIG_OFFSET, val );
+
+    list_for_each_safe( pos, tmp, &dev->axi2pico_irq_handlers.list )
+    {
+        handler = container_of( pos, struct pc302_irq_handler, list );
+        if ( handler->irq == irq )
+        {
+            list_del( pos );
+            break;
+        }
+    }
+
+    spin_unlock_irqrestore( &pa->lock, flags );
+}
+
+/*!
+ * PC302 AXI2Pico ISR. This ISR will be called when the AXI2Pico generates an
+ * interrupt and checks all of the AXI2Pico interrupt sources for raised
+ * interrupts and calls the appropriate handler if there is one registered. If
+ * there is no interrupt handler for the IRQ source then that source is
+ * disabled.
+ *
+ * @param irq The irq that has been raised.
+ * @param dev The PC302 device that has raised the interrupt.
+ * @return Returns IRQ_HANDLED on success.
+ */
+static irqreturn_t
+pc302_axi2pico_irq( int irq,
+                    void *dev )
+{
+    struct pc302 *pc302dev = dev;
+    struct list_head *pos;
+    struct pc302_irq_handler *handler;
+    int ret;
+    u32 int_status;
+    unsigned i;
+    unsigned handled;
+
+    pc302_axi2pico_reg_read( pc302dev, AXI2PICO_INT_STATUS_OFFSET,
+                             &int_status );
+    for ( i = 0; i < AXI2PICO_NUM_VPS; ++i )
+    {
+        if ( int_status & ( 1 << i ) )
+        {
+            handled = 0;
+            list_for_each( pos, &pc302dev->axi2pico_irq_handlers.list )
+            {
+                handler = container_of( pos, struct pc302_irq_handler, list );
+                if ( ( handler->irq->offset ) == i  && handler->callback )
+                {
+                    ret = handler->callback( handler->irq, handler->cookie );
+                    if ( !ret )
+                    {
+                        handled = 1;
+                        break;
+                    }
+                }
+            }
+            if ( !handled )
+            {
+                PRINTD( COMPONENT_PC302, DBG_WARN,
+                        "no interrupt handler for AXI2Pico VP %u", i );
+                /* Disable the interrupt generation for this GPR - there
+                 * is no handler installed. */
+                pc302_axi2pico_reg_write( pc302dev,
+                       ( i * AXI2PICO_VP_SPACING ) + AXI2PICO_GPR_VP_START,
+                        0 );
+            }
+        }
+    }
+
+    return IRQ_HANDLED;
+}
+
+/*!
+ * \brief PC302 DMA channel mappings
+ *
+ * This structure defines the DMAC and DMA channel numbers for each of the
+ * picoArray DMA channels. This structure is internal and specific to the
+ * PC302.
+ */
+struct pc302_dma_mapping
+{
+    pc302_master_t srcMaster;
+    pc302_master_t dstMaster;
+};
+
+/*!
+ * \brief Initialise the DMAC and DMA channel mappings
+ *
+ * @param dma Pointer to the global DMA structure for the PC302 device
+ */
+static void
+pc302_dma_init( struct pc302_dma_channel *dma )
+{
+    unsigned i;
+    pc302_dma_t dmac = pc302_dma_get_dma_handle( 0 );
+    /* Make a slightly random mapping to attempt to distribute traffic over
+     * a number of masters for efficiency. */
+    struct pc302_dma_mapping dma_mapping[PICO_NUM_DMA_CHANNELS] = {
+        { PC302_DMA_MASTER1, PC302_DMA_MASTER2},
+        { PC302_DMA_MASTER3, PC302_DMA_MASTER4},
+        { PC302_DMA_MASTER2, PC302_DMA_MASTER1},
+        { PC302_DMA_MASTER4, PC302_DMA_MASTER3},
+        { PC302_DMA_MASTER1, PC302_DMA_MASTER2},
+        { PC302_DMA_MASTER3, PC302_DMA_MASTER4},
+        { PC302_DMA_MASTER2, PC302_DMA_MASTER1},
+        { PC302_DMA_MASTER4, PC302_DMA_MASTER3},
+    };
+
+    /* Assign the DMAC number and channel to the picoArray DMA channel */
+    for (i = 0; i < PICO_NUM_DMA_CHANNELS; i++)
+    {
+        dma[i].srcMaster = dma_mapping[i].srcMaster;
+        dma[i].dstMaster = dma_mapping[i].dstMaster;
+        dma[i].hs.hwInterface = i;
+        dma[i].dmac = dmac;
+        dma[i].hs.active_low = 0; /* PC302 DREQs are active high */
+        dma[i].stateActive = 0;
+        dma[i].xfr = NULL;
+    }
+}
+
+/*!
+ * Open and enable the specified DMA channel
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to open
+ * @param is_downlink 1 if the channel is an downlink, 0 for an uplink
+ * @return 0 on success, a negative number on failure
+ */
+__must_check static int
+pc302_dma_open( struct picoarray *pa,
+                struct pico_resource *dma_channel,
+                int is_downlink )
+{
+    struct pc302 *pc302dev = to_pc302( pa );
+    struct pc302_dma_channel *dma =
+        &pc302dev->dma_channel[dma_channel->value];
+    u32 gprStatus = 0;
+
+    PRINTD( COMPONENT_PC302, DBG_TRACE,
+            "pa_dma %d  => cpu_dma %d",
+            ( dma_channel->value-PC302_DMA_AXI2PICO_0 ),
+            dma_channel->value);
+
+    dma->pico_addr = (dma_addr_t)pc302dev->axi2pico_base_phys
+        + ((dma_channel->value - PC302_DMA_AXI2PICO_0) * AXI2PICO_VP_SPACING)
+        + AXI2PICO_VP_DATA_OFFSET;
+
+    if ( ( dma_channel->value < PC302_DMA_AXI2PICO_0 ) ||
+         ( dma_channel->value > PC302_DMA_AXI2PICO_7 ) )
+        return -EINVAL;
+
+    pc302_axi2pico_reg_read( pc302dev, dma_channel->offset
+              + AXI2PICO_VP_STATUS_OFFSET, &gprStatus );
+
+    if ( !IS_PORT_ENABLED(gprStatus) )
+    {
+        PRINTD( COMPONENT_PC302, DBG_ERROR, "dma %d: is not enabled",
+           dma_channel->value);
+        return -EINVAL;
+    }
+
+    /* Set the DMAC Enable bit (bit1) in the DMA config register */
+    if ( IS_PORT_A_RECEIVE(gprStatus) )
+       /* Enable the UL DMA channel by setting bit 1, and set the
+           watermark to 1 x the burst size on bits 2 to 8.  */
+       (void)pc302_axi2pico_reg_write( pc302dev,
+           ((dma_channel->value - PC302_DMA_AXI2PICO_0) * AXI2PICO_VP_SPACING)
+           + AXI2PICO_VP_CONFIG_OFFSET, 0x02 + (PC302_DMA_BURST_SIZE << 2));
+    else
+        /* Enable the DL DMA channel by setting bit 1, and set the watermark
+           to 2 x the burst size on bits 2 to 8 */
+        (void)pc302_axi2pico_reg_write( pc302dev,
+         ((dma_channel->value-PC302_DMA_AXI2PICO_0)*AXI2PICO_VP_SPACING)
+         +AXI2PICO_VP_CONFIG_OFFSET, 0x02 + ((2*PC302_DMA_BURST_SIZE) << 2));
+
+    dma->sgl = pc302_dma_list_create( dma->dmac, 1 );
+    if ( dma->sgl == NULL )
+    {
+        PRINTD( COMPONENT_PC302, DBG_ERROR, "dma %d: cannot allocate "
+           "scatter gather list", dma_channel->value);
+        return -EINVAL;
+    }
+
+    /* Initialise all variables that may become set */
+    dma->xfr = NULL;
+    dma->channel = dma_channel->value - PC302_DMA_AXI2PICO_0;
+    dma->stateActive = 0;
+    dma->callback = NULL;
+    dma->cookie = NULL;
+
+    return 0;
+}
+
+/*!
+ * Close and disable the specified DMA channel
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to close
+ * @return 0 in all cases
+ */
+static int
+pc302_dma_close( struct picoarray *pa,
+                 struct pico_resource *dma_channel )
+{
+    int ret = 0;
+    struct pc302 *pc302dev = to_pc302( pa );
+    struct pc302_dma_channel *dma =
+        &pc302dev->dma_channel[dma_channel->value];
+
+    if ( dma->xfr )
+    {
+        if ( dma->stateActive )
+        {
+            ret = pc302_dma_abort( dma->xfr );
+            if ( ret )
+                PRINTD( COMPONENT_PC302, DBG_WARN, "DMA abort failed, "
+                "return code=%d", ret );
+
+            PRINTD( COMPONENT_PC302, DBG_WARN, "dma %d: stopped while dma "
+                "in progress", dma_channel->value);
+        }
+
+        /* Disable all interrupts for this channel */
+        ret = pc302_dma_disable_int( dma->xfr, PC302_DMA_INT_ALL );
+        if ( ret )
+            PRINTD( COMPONENT_PC302, DBG_WARN, "disable interrupt failed "
+                "return code=%d", ret );
+
+        /* Reset all interrupts for this channel */
+        pc302_dma_clear_int(dma->xfr, PC302_DMA_INT_ALL );
+
+        ret = pc302_dma_release( dma->xfr );
+        if (ret )
+            PRINTD( COMPONENT_PC302, DBG_WARN, "DMA_release failed "
+                "return code = %d", ret );
+    }
+
+    if ( dma->sgl )
+    {
+        ret = pc302_dma_list_destroy( dma->sgl );
+        if (ret)
+            PRINTD( COMPONENT_PC302, DBG_WARN, "DMA list_destroy failed "
+                    "return code = %d", ret );
+    }
+
+    dma->stateActive = 0;
+    return 0;
+}
+
+/*!
+ * DMA handler function. This function simply resets the channel active flag
+ * and passes the cookie onto the handler specified in the pc302_to_device
+ * and pc302_from_device functions.
+ *
+ * @param cookie The cookie to pass to the callback function.
+ * @param errno The status of the DMA operation
+ * @return 0 on success, non-zero on failure
+ */
+static int
+pc302_dma_handler( void *cookie,
+                   int errno )
+{
+    struct pc302_dma_channel *dma = (struct pc302_dma_channel *)cookie;
+
+    if ( errno & PC302_DMA_INT_ERROR)
+        errno = -EIO;
+    else
+        errno = 0;
+
+    dma->stateActive = 0;
+    return dma->callback(dma->cookie, errno);
+}
+
+/*!
+ * DMA a scatter gather list of memory from a kernel mapped scatterlist
+ * into a picoArray DMA channel. After the DMA transfer has completed, the
+ * callback function will be called with the cookie as the parameter. The
+ * caller of this function is responsible for mapping and unmapping the
+ * buffers to be transferred into a DMA capable region.
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to use as a destination.
+ * @param sgl The scatter gather list of the source data.
+ * @param nbytes The number of bytes in the scatter gather list.
+ * @param callback The callback function to be called when the transfer
+ * has completed. The parameter errno will be set to the status of the DMA
+ * operation where 0 == success, negative == failure.
+ * @param cookie The cookie to pass to the callback function.
+ * @return 0 on success, non-zero on failure
+ */
+static int
+pc302_dma_to_device( struct picoarray *pa,
+                     struct pico_resource *dma_channel,
+                     struct scatterlist *sgl,
+                     size_t nbytes,
+                     int ( *callback )( void *cookie,
+                                        int errno ),
+                     void *cookie )
+{
+    int ret = 0;
+    struct pc302 *dev = to_pc302( pa );
+    struct pc302_dma_channel *dma = &dev->dma_channel[dma_channel->value];
+    pc302_dma_endpoint_t src_ep;
+    pc302_dma_endpoint_t dst_ep;
+
+    if ( dma->stateActive )
+      return -EAGAIN;
+
+    PRINTD( COMPONENT_PC302, DBG_TRACE, "DMA transfer Chan %d, Bytes %d",
+          dma_channel->value, nbytes );
+
+    /* make a single SGL entry */
+    ret = pc302_dma_list_clear( dma->sgl );
+
+    src_ep.msize = PC302_DMA_MS_AUTO;
+#if (PC302_DMA_BURST_SIZE == 1)
+    src_ep.tr_width = PC302_DMA_TR_WIDTH32;
+#else
+    src_ep.tr_width = PC302_DMA_TR_WIDTH64;
+#endif
+    src_ep.dma_addr = sg_dma_address( sgl );
+    src_ep.master = dma->srcMaster;
+    src_ep.periph_not_mem = 0;
+    src_ep.flow_controller = 0;
+    src_ep.enable_sg = 0;
+    src_ep.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    src_ep.auto_reload = 0;
+
+    SET_PICOARRAY_MSIZE(dst_ep);
+    dst_ep.tr_width = PC302_DMA_TR_WIDTH32;
+    dst_ep.dma_addr = dma->pico_addr;
+    dst_ep.master = dma->dstMaster;
+    dst_ep.periph_not_mem = 1;
+    dst_ep.flow_controller = 0;
+    dst_ep.enable_sg = 0;
+    dst_ep.addr_inc = PC302_DMA_ADDR_NO_CHANGE;
+    dst_ep.auto_reload = 0;
+
+    if ( dma->xfr != NULL )
+    {
+        ret = pc302_dma_release(dma->xfr);
+        if ( ret )
+             PRINTD( COMPONENT_PC302, DBG_ERROR, "failed to release previous xfr, "
+                     " ret = %d", ret );
+    }
+
+    dma->xfr = pc302_dma_setup_direct_xfr( dma->dmac, &src_ep,
+            &dst_ep, NULL, &(dma->hs), nbytes, PC302_DMA_PROTCTL_1,
+            pc302_dma_handler, dma );
+    if ( dma->xfr == NULL )
+    {
+        PRINTD( COMPONENT_PC302, DBG_ERROR, "error setting up list xfr "
+               "for channel %d", dma_channel->value );
+        return -EINVAL;
+    }
+
+    ret = pc302_dma_enable_int(dma->xfr,
+               PC302_DMA_INT_ERROR | PC302_DMA_INT_TRANSFER);
+    if ( ret )
+    {
+        PRINTD( COMPONENT_PC302, DBG_ERROR, "failed to enable interrupts, "
+            "ret=%d", ret );
+    }
+
+    dma->stateActive = 1;
+    dma->callback = callback;
+    dma->cookie = cookie;
+
+    ret = pc302_dma_start( dma->xfr );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_PC302, DBG_ERROR, "error starting xfr, "
+              "ret=%d", ret );
+    }
+
+    return ret;
+}
+
+/*!
+ * DMA a scatter gather list of memory from a picoArray DMA channel. After
+ * the DMA transfer has completed, the callback function will be called
+ * with the cookie as the parameter. The caller of this function is
+ * responsible for mapping and unmapping the buffers to be transferred
+ * into a DMA capable region.
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to use as a source.
+ * @param sgl The scatter gather list of the destination buffer.
+ * @param nbytes The number of bytes to transfer.
+ * @param callback The callback function to be called when the transfer
+ * has completed. The parameter errno will be set to the status of the DMA
+ * operation where 0 == success, negative == failure.
+ * @param cookie The cookie to pass to the callback function.
+ * @return 0 on success, non-zero on failure
+ */
+static int
+pc302_dma_from_device( struct picoarray *pa,
+                         struct pico_resource *dma_channel,
+                         struct scatterlist *sgl,
+                         size_t nbytes,
+                         int ( *callback )( void *cookie,
+                                            int errno ),
+                         void *cookie )
+{
+    int ret = 0;
+    struct pc302 *dev = to_pc302( pa );
+    struct pc302_dma_channel *dma = &dev->dma_channel[dma_channel->value];
+    pc302_dma_endpoint_t src_ep;
+    pc302_dma_endpoint_t dst_ep;
+
+    if ( dma->stateActive )
+        return -EAGAIN;
+
+    PRINTD( COMPONENT_PC302, DBG_TRACE, "chan %d, bytes %d",
+               dma_channel->value, nbytes );
+
+    /* make a single SGL entry */
+    ret = pc302_dma_list_clear(dma->sgl);
+
+    SET_PICOARRAY_MSIZE(src_ep);
+    src_ep.tr_width = PC302_DMA_TR_WIDTH32;
+    src_ep.dma_addr = dma->pico_addr;
+    src_ep.master = dma->srcMaster;
+    src_ep.periph_not_mem = 1;
+    src_ep.flow_controller = 0;
+    src_ep.enable_sg = 0;
+    src_ep.addr_inc = PC302_DMA_ADDR_NO_CHANGE;
+    src_ep.auto_reload = 0;
+
+    dst_ep.msize = PC302_DMA_MS_AUTO;
+#if (PC302_DMA_BURST_SIZE == 1)
+    dst_ep.tr_width = PC302_DMA_TR_WIDTH32;
+#else
+    dst_ep.tr_width = PC302_DMA_TR_WIDTH64;
+#endif
+    dst_ep.dma_addr = sg_dma_address( sgl );
+    dst_ep.master = dma->dstMaster;
+    dst_ep.periph_not_mem = 0;
+    dst_ep.flow_controller = 0;
+    dst_ep.enable_sg = 0;
+    dst_ep.addr_inc = PC302_DMA_ADDR_INCREMENT;
+    dst_ep.auto_reload = 0;
+
+    if ( dma->xfr != NULL )
+        ret = pc302_dma_release( dma->xfr );
+
+    dma->xfr = pc302_dma_setup_direct_xfr( dma->dmac,
+                &src_ep, &dst_ep, &(dma->hs), NULL, nbytes,
+                PC302_DMA_PROTCTL_1, pc302_dma_handler, dma );
+    if ( dma->xfr == NULL )
+    {
+        PRINTD( COMPONENT_PC302, DBG_ERROR, "error setting up list xfr");
+        return -EINVAL;
+    }
+
+    ret = pc302_dma_enable_int( dma->xfr,
+                              PC302_DMA_INT_ERROR | PC302_DMA_INT_TRANSFER );
+    if ( ret )
+    {
+      PRINTD( COMPONENT_PC302, DBG_WARN, "DMA enable interrupts failed "
+          "return code = %d", ret );
+    }
+
+    dma->stateActive = 1;
+    dma->callback = callback;
+    dma->cookie = cookie;
+    ret = pc302_dma_start( dma->xfr );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_PC302, DBG_ERROR, "error starting xfr, ret=%d",
+                ret );
+    }
+
+    return ret;
+}
+
+/*!
+ * Get the device type of a PC302.
+ *
+ * @param pa The device to query.
+ * @return Always returns PICOARRAY_PC302.
+ */
+static enum picoarray_device_type
+pc302_get_device_type( struct picoarray *pa )
+{
+    return PICOARRAY_PC302;
+}
+
+/*!
+ * Get the ITM, ITS and procIF IRQ resources.
+ * This function will return an error as the PC302 has no procIF interface
+ *
+ * @param pa The device to take to DMA the data.
+ * @param its The ITS resource or NULL on failure
+ * @param itm The ITM resource or NULL on failure
+ * @param procif_irq The IRQ resource or NULL on failure
+ *
+ * @return EINVAL in all situations
+ */
+static int
+pc302_get_procif_resource( struct picoarray *pa,
+                           struct pico_resource **its,
+                           struct pico_resource **itm,
+                           struct pico_resource **procif_irq )
+{
+    return -EINVAL;
+}
+
+/*!
+ * Put the ITM, ITS and procIF IRQ resources.
+ * This function is not relevant to the PC302 as it has no procIF interface.
+ *
+ * @param pa The device to take to DMA the data.
+ * @param its The ITS resource
+ * @param itm The ITM resource
+ * @param procif_irq The IRQ resource
+ */
+static void
+pc302_put_procif_resource( struct picoarray *pa,
+                           struct pico_resource *its,
+                           struct pico_resource *itm,
+                           struct pico_resource *procif_irq )
+{
+}
+
+/*! Operations for the PC302 devices. */
+static struct picoarray_ops pc302_ops = {
+    .sync                = pc302_sync,
+    .start               = pc302_start,
+    .stop                = pc302_stop,
+    .get_device_type     = pc302_get_device_type,
+    .config_read         = pc302_config_read,
+    .config_write        = pc302_config_write,
+    .register_read       = pc302_register_read,
+    .register_write      = pc302_register_write,
+    .reset               = pc302_reset,
+    .get_resource        = generic_get_resource,
+    .get_procif_resource = pc302_get_procif_resource,
+    .put_resource        = generic_put_resource,
+    .put_procif_resource = pc302_put_procif_resource,
+    .destructor          = pc302_destroy,
+    .add_irq_handler     = pc302_add_irq_handler,
+    .remove_irq_handler  = pc302_remove_irq_handler,
+    .dma_to_device       = pc302_dma_to_device,
+    .dma_from_device     = pc302_dma_from_device,
+    .dma_open            = pc302_dma_open,
+    .dma_close           = pc302_dma_close,
+    .pa_load             = pc302_pa_load,
+};
+
+/*!
+ * Probe method for the PC302 platform driver. This function creates a new
+ * PC302 instance and is responsible for allocating all of the resources
+ * required.
+ *
+ * @param pdev The platform device that has been probed.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_probe( struct platform_device *pdev )
+{
+    struct resource *res;
+    int ret;
+    struct pc302 *newdev = kmalloc( sizeof( *newdev ), GFP_KERNEL );
+
+    if ( !newdev )
+        return -ENOMEM;
+
+    ret = -ENOMEM;
+    newdev->pa.resources = kmalloc( sizeof( pc302_resources ), GFP_KERNEL );
+    if ( !newdev->pa.resources )
+        goto out;
+    memcpy( newdev->pa.resources, pc302_resources, sizeof( pc302_resources ) );
+
+    newdev->pa.dev_num = pdev->id;
+    newdev->pa.ops = &pc302_ops;
+    newdev->pa.features = PICOARRAY_HAS_DMA_LOAD | PICOARRAY_HAS_DMA;
+    newdev->pa.max_dma_sz = PICOARRAY_MAX_TRANSFER;
+    spin_lock_init( &newdev->pa.lock );
+
+    ret = -EINVAL;
+
+    /* Get the IRQ for AXI2Pico GPRs. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_IRQ, "gpr_irq" );
+    if ( !res )
+        goto out;
+    newdev->gpr_irq = res->start;
+
+    /* Get the register base address for the lower AXI2CFG registers */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM, "procif" );
+    if ( !res )
+        goto out;
+    newdev->axi2cfg1_base_phys = res->start;
+    newdev->axi2cfg1_base_len = ( res->end - res->start ) + 1;
+
+    /* Get the register base address for the upper AXi2CFG registers */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM,
+                                        "procif2" );
+    if ( !res )
+        goto out;
+    newdev->axi2cfg2_base_phys = res->start;
+    newdev->axi2cfg2_base_len = ( res->end - res->start ) + 1;
+
+    /* Get the register base address for the AXI2Pico. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM,
+                                        "ahb2pico_axi2pico" );
+    if ( !res )
+        goto out;
+    newdev->axi2pico_base_phys = res->start;
+    newdev->axi2pico_base_len = ( res->end - res->start ) + 1;
+
+    /* Map the resources. */
+    newdev->axi2cfg1_base = request_and_map( "axi2cfg1", newdev->axi2cfg1_base_phys,
+                                        newdev->axi2cfg1_base_len );
+    if ( !newdev->axi2cfg1_base )
+        goto out;
+
+    newdev->axi2cfg2_base = request_and_map( "axi2cfg2", newdev->axi2cfg2_base_phys,
+                                        newdev->axi2cfg2_base_len );
+    if ( !newdev->axi2cfg2_base )
+        goto axi2cfg2_map_failed;
+
+    newdev->axi2pico_base = request_and_map( "axi2pico", newdev->axi2pico_base_phys,
+                                        newdev->axi2pico_base_len );
+    if ( !newdev->axi2pico_base )
+        goto ahb2pico_map_failed;
+
+    ret = request_irq( newdev->gpr_irq, pc302_axi2pico_irq, IRQF_DISABLED,
+                       pdev->name, newdev );
+    if ( ret )
+        goto axi2pico_irq_failed;
+
+    /* Initialise the interrupt handler lists. */
+    INIT_LIST_HEAD( &newdev->axi2pico_irq_handlers.list );
+
+    /* Initialise the DMA channel structure */
+    pc302_dma_init( newdev->dma_channel );
+
+    ret = picoif_register_dev( &newdev->pa );
+    goto out;
+
+axi2pico_irq_failed:
+    unmap_and_release( newdev->axi2pico_base_phys, newdev->axi2pico_base_len,
+                       newdev->axi2pico_base );
+
+ahb2pico_map_failed:
+    unmap_and_release( newdev->axi2cfg2_base_phys, newdev->axi2cfg2_base_len,
+                       newdev->axi2cfg2_base );
+
+axi2cfg2_map_failed:
+    unmap_and_release( newdev->axi2cfg1_base_phys, newdev->axi2cfg1_base_len,
+                       newdev->axi2cfg1_base );
+out:
+    if ( ret && newdev->pa.resources )
+        kfree( newdev->pa.resources );
+
+    if ( ret )
+        kfree( newdev );
+    else
+        ++num_pc302s;
+
+    return ret;
+}
+
+/*!
+ * Remove method for the PC302 platform driver. This method is called when the
+ * platform driver is removed and must release all resources the driver has
+ * been using.
+ *
+ * @param pdev The platform device being remove.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc302_remove( struct platform_device *pdev )
+{
+    struct picoarray *pa = picoif_get_device( pdev->id );
+    struct pc302 *pc302dev = to_pc302( pa );
+    int ret = 0;
+
+    free_irq( pc302dev->gpr_irq, pc302dev );
+    unmap_and_release( pc302dev->axi2cfg1_base_phys, pc302dev->axi2cfg1_base_len,
+                       pc302dev->axi2cfg1_base );
+    unmap_and_release( pc302dev->axi2cfg2_base_phys, pc302dev->axi2cfg2_base_len,
+                       pc302dev->axi2cfg2_base );
+    unmap_and_release( pc302dev->axi2pico_base_phys, pc302dev->axi2pico_base_len,
+                       pc302dev->axi2pico_base );
+
+    kfree( pc302dev );
+
+    return ret;
+}
+
+/*! The PC302 platform driver.
+ *  \todo Change the name to PC302 specific rather than generic picoArray.
+ */
+static struct platform_driver pc302_driver = {
+    .probe      = pc302_probe,
+    .remove     = pc302_remove,
+    .driver     = {
+        .name   = "picoArray",
+    },
+};
+
+int
+pc302_init( void )
+{
+    return platform_driver_register( &pc302_driver );
+}
+
+/*!
+ * Destructor to be called when a PC302 is removed from picoif. This
+ * function must decrement the number of PC302s registered, and when this
+ * reaches zero, remove the platform driver.
+ *
+ * @param pa The device being removed.
+ */
+static void
+pc302_destroy( struct picoarray *pa )
+{
+    PRINTD( COMPONENT_PC302, DBG_TRACE, "pA[%u]: destructor called",
+            pa->dev_num );
+
+    /* If we have no more pc302s, then remove the driver. */
+    if ( 0 == --num_pc302s )
+        platform_driver_unregister( &pc302_driver );
+}
diff --git a/drivers/picochip/picoarray.h b/drivers/picochip/picoarray.h
new file mode 100644
index 0000000..d23f0ea
--- /dev/null
+++ b/drivers/picochip/picoarray.h
@@ -0,0 +1,523 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoarray.h
+ * \brief picoArray device and resource definition.
+ *
+ * This file defines a base class for a picoArray and a resource type used for
+ * accessing picoArray resources. This base class should not be instantiated
+ * directly but inherited from to create specific device types (using the
+ * container_of()) macro.
+ */
+
+/*!
+ * \page paAbstraction picoArray Class Hierarchy
+ *
+ * \section introduction Introduction
+ *
+ * Each type of picoArray is implemented as a class derived from the picoarray
+ * base class and must contain the methods in picoarray_ops. The picoarray
+ * structure consists of 3 main components:
+ *  \li Resources
+ *  \li Operations
+ *  \li Common members
+ *
+ * The resources describe the DMA channels, GPRs and interrupt sources that
+ * the picoArray has. Users should never directly access these resources -
+ * they should use the get_resource and put_resource methods of the
+ * picoarray_ops to get and release the resources. Using these resources,
+ * upper layers such as transport methods can hold exclusive access to a
+ * resource and prevent conflicts between transport instances and methods and
+ * also prevent other user applications from disrupting a transport service.
+ * Consider the HwIf transport as an example. There are several GPRs used for
+ * signalling the amount of data available to transfer, the amount of data the
+ * host processor has queued for transfer and for clearing interrupts. If a
+ * user application did a register write to the count GPR, then the reference
+ * design would lose synchronisation with the application and data
+ * loss/corruption could occur. By adding these resources and locks, if the
+ * transport needs exclusive access, then this is guaranteed by the resources.
+ *
+ * The operations define a set of primitive operations that effectively export
+ * the basic services that the picoArray can provide. For some device types,
+ * some services may be unavailable in which case the operations should still
+ * be implemented but always return an error. These services include
+ * primitives such as configuration bus access, GPR access, IRQ registration
+ * and DMA to/from device methods. As an example use of these services, a DMA
+ * transport module would be responsible for managing the data that needs to
+ * be transferred to/from the picoArray and when a transfer needs to take
+ * place, the module will call the dma_to_device() or dma_from_device()
+ * operation in the relevant picoArray.
+ *
+ * The common members include the logical device number, spin locks for
+ * concurrent access and pointers to the resources and operations. These
+ * common members should contain no device specific information.
+ *
+ * \section new_devices Adding new devices
+ *
+ * To add a new device type, an implementation file for the device should be
+ * created, for example pc202.c. This file contains the derived structure -
+ * pc202, and has the picoarray structure embedded in it. The PC202 methods
+ * are also defined, and these can get a pc202 pointer from a pointer to the
+ * embedded picoarray structure with the container_of() macro:
+ *
+ * \code
+ *  struct picoarray *pa;
+ *  struct pc202 *pc202dev = container_of( pa, struct pc202, pa );
+ * \endcode
+ *
+ * This file also needs to define the resources that the device has and must
+ * provide init() and destructor functions that are used to register the
+ * device with picoIf and remove the driver when picoIf is unloaded.
+ */
+#ifndef __PICOIF_PICOARRAY_H__
+#define __PICOIF_PICOARRAY_H__
+
+#include <linux/types.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+struct picoarray;
+
+/*!
+ * picoArray device types.
+ */
+enum picoarray_device_type
+{
+    PICOARRAY_PC202,
+    PICOARRAY_PC203,
+    PICOARRAY_PC302,
+};
+
+/*!
+ * \brief Enumeration for picoArray resource types.
+ *
+ * This defines resource types for picoArray resources that may be requested
+ * by functions. Each device type should have a corresponding enumeration for
+ * each type that lists all resources the device has.
+ */
+enum pico_resource_type
+{
+    PICO_RES_DMA_CHANNEL = 1,  /*!< DMA channel. */
+    PICO_RES_GPR,              /*!< General purpose register (GPR). */
+    PICO_RES_IRQ,              /*!< IRQ source. */
+};
+
+/*!
+ * \brief A resource descriptor describing a picoArray resource.
+ *
+ * This structure defines a resource for a picoArray and should not be
+ * accessed directly.
+ */
+struct pico_resource
+{
+    enum pico_resource_type type;       /*!< The resource type. */
+
+    unsigned                value;      /*!< The resource ID/value. */
+
+    int                     exclusive;  /*!< Boolean flag to indicate the
+                                         *  resource is exclusively held. */
+
+    atomic_t                ref_count;  /*!< The reference count of the
+                                         *  resource. */
+
+    unsigned                offset;     /*!< For GPRs and DMA channels, this is
+                                         *  the offset. For interrupts this
+                                         *  fields usage is dependent on the
+                                         *  IRQ type. */
+
+    int                     metadata;   /*!< Metadata for the resource. For GPR
+                                         * interrupts, this may be the GPR that
+                                         * the interrupt is tied to. */
+};
+
+/*!
+ * \brief Operations common to all picoArray devices.
+ *
+ * This structure defines a set of operations that all picoArrays should
+ * support. These functions are used for configuration and transport but only
+ * provide primitive services. More complicated transports should use these
+ * functions to implement a higher level transport module.
+ */
+struct picoarray_ops
+{
+    /*!
+     * Get the picoArray device type.
+     *
+     * @return Returns the picoArray device type.
+     */
+    enum picoarray_device_type ( *get_device_type )( struct picoarray *pa );
+
+    /*!
+     * Reset the device.
+     *
+     * @param pa The device to reset.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *reset )( struct picoarray *pa );
+
+    /*!
+     * Start the device.
+     *
+     * @param pa The device to start.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *start )( struct picoarray *pa );
+
+    /*!
+     * Sync the device.
+     *
+     * @param pa The device to sync.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *sync )( struct picoarray *pa );
+
+    /*!
+     * Stop the device.
+     *
+     * @param pa The device to stop.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *stop )( struct picoarray *pa );
+
+    /*!
+     * Perform a read from the configuration bus.
+     *
+     * @param pa The device to read from.
+     * @param caeid The CAEID of the AE to read from.
+     * @param address The address from within the AE to begin reading from.
+     * @param count The number of 16-bit words to read.
+     * @param data Pointer to the buffer to write the words read into.
+     * @return Returns the number of 16-bit words read on success, negative on
+     * failure.
+     */
+    int ( *config_read )( struct picoarray *pa,
+                          u16 caeid,
+                          u16 address,
+                          u16 count,
+                          u16 *data );
+
+    /*!
+     * Perform a write to the configuration bus.
+     *
+     * @param pa The device to write to.
+     * @param caeid The CAEID of the AE to write to.
+     * @param address The address from within the AE to begin writing from.
+     * @param count The number of 16-bit words to write.
+     * @param data Pointer to the buffer of words to write.
+     * @return Returns the number of 16-bit words written on success, negative
+     * on failure.
+     */
+    int ( *config_write )( struct picoarray *pa,
+                           u16 caeid,
+                           u16 address,
+                           u16 count,
+                           u16 *data );
+
+    /*!
+     * Perform multiple write to the configuration bus write register.
+     *
+     * @param pa The device to write to.
+     * @param data Pointer to the buffer of words to write.
+     * @param sgl The scatter gather list of the source data.
+     * @return Returns the number of 32-bit words written on success, negative
+     * on failure.
+     */
+    int ( *pa_load )( struct picoarray *pa,
+                      u32 *data,
+                      struct scatterlist *sgl );
+
+    /*!
+     * DMA a scatter gather list of memory from a kernel mapped scatterlist
+     * into a picoArray DMA channel. After the DMA transfer has completed, the
+     * callback function will be called with the cookie as the parameter. The
+     * caller of this function is responsible for mapping and unmapping the
+     * buffers to be transferred into a DMA capable region.
+     *
+     * @param pa The picoArray to DMA the data.
+     * @param dma_channel The DMA channel to use as a destination.
+     * @param sgl The scatter gather list of the source data.
+     * @param nbytes The number of bytes in the scatter gather list.
+     * @param callback The callback function to be called when the transfer
+     * has completed. The parameter errno will be set to the status of the DMA
+     * operation where 0 == success, negative == failure.
+     * @param cookie The cookie to pass to the callback function.
+     * @return Returns the number of bytes queued for transfer on success,
+     * negative on failure. Note that it is possible that the number of bytes
+     * queued may not be the same as nbytes if the device does not support
+     * scatter gather operations.
+     */
+    int ( *dma_to_device )( struct picoarray *pa,
+                            struct pico_resource *dma_channel,
+                            struct scatterlist *sgl,
+                            size_t nbytes,
+                            int ( *callback )( void *cookie,
+                                               int errno ),
+                            void *cookie );
+
+    /*!
+     * DMA a scatter gather list of memory from a picoArray DMA channel. After
+     * the DMA transfer has completed, the callback function will be called
+     * with the cookie as the parameter. The caller of this function is
+     * responsible for mapping and unmapping the buffers to be transferred
+     * into a DMA capable region.
+     *
+     * @param pa The picoArray to DMA the data.
+     * @param dma_channel The DMA channel to use as a source.
+     * @param sgl The scatter gather list of the destination buffer.
+     * @param nbytes The number of bytes to transfer.
+     * @param callback The callback function to be called when the transfer
+     * has completed. The parameter errno will be set to the status of the DMA
+     * operation where 0 == success, negative == failure.
+     * @param cookie The cookie to pass to the callback function.
+     * @return Returns the number of bytes queued for transfer on success,
+     * negative on failure. Note that it is possible that the number of bytes
+     * queued may not be the same as nbytes if the device does not support
+     * scatter gather operations.
+     */
+    int ( *dma_from_device )( struct picoarray *pa,
+                              struct pico_resource *dma_channel,
+                              struct scatterlist *sgl,
+                              size_t nbytes,
+                              int ( *callback )( void *cookie,
+                                                 int errno ),
+                              void *cookie );
+
+    /*!
+     * Open and enables a DMA channel
+     *
+     * @param pa The picoArray to DMA the data.
+     * @param dma_channel The DMA channel to use as a source.
+     * @param is_downlink 1 if the DMA channel is a downlink, 0 otherwise.
+     * @return Returns 0 on success, negative on failure.
+     */
+    int ( *dma_open )( struct picoarray *pa,
+                       struct pico_resource *dma_channel,
+                       int is_downlink );
+
+    /*!
+     * Closes and disables a DMA channel
+     *
+     * @param pa The picoArray to DMA the data.
+     * @param dma_channel The DMA channel to use as a source.
+     * @return Returns 0 on success, negative on failure.
+     */
+    int ( *dma_close )( struct picoarray *pa,
+                        struct pico_resource *dma_channel );
+
+    /*!
+     * Read the value of a general purpose register (GPR). The register is
+     * referenced by the resource which must be retrieved with get_resource.
+     * If the register is being used exclusively by a transport and the
+     * get_resource fails, the register cannot be read.
+     *
+     * @param pa The device to read from.
+     * @param reg The register to read.
+     * @param value Pointer to the address the value should be stored in.
+     * @return Returns the resource on success, NULL on failure.
+     */
+     int ( *register_read )( struct picoarray *pa,
+                             struct pico_resource *reg,
+                             u32 *value );
+
+    /*!
+     * Write the value of a general purpose register (GPR). The register is
+     * referenced by the resource which must be retrieved with get_resource.
+     * If the register is being used exclusively by a transport and the
+     * get_resource fails, the register cannot be read.
+     *
+     * @param pa The device to write to.
+     * @param reg The register to write.
+     * @param value The value of the register to write.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *register_write )( struct picoarray *pa,
+                             struct pico_resource *reg,
+                             u32 value );
+
+    /*!
+     * Add a new IRQ handler. There must only be 1 IRQ handler for each
+     * interrupt source so the resource must have the exclusive flag set. The
+     * callback will be called when the interrupt is raised and must the
+     * interrupt must be cleared by the callback. The callback will be called
+     * in interrupt context and so should run as quickly as possible and may
+     * not sleep. If more processing is required, this should be deferred to a
+     * tasklet or work queue.
+     *
+     * @param pa The device to register the handler for.
+     * @param irq The IRQ source to handle.
+     * @param callback The callback function to call when the IRQ is raised.
+     * @param cookie A cookie to pass to the callback function.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *add_irq_handler )( struct picoarray *pa,
+                              struct pico_resource *irq,
+                              int ( *callback )( struct pico_resource *irq,
+                                                 void *cookie ),
+                              void *cookie );
+
+    /*!
+     * Remove an interrupt handler from the device.
+     *
+     * @param pa The device to remove the interrupt handler from.
+     * @param irq The interrupt source to remove the handler for.
+     */
+    void ( *remove_irq_handler )( struct picoarray *pa,
+                                  struct pico_resource *irq );
+
+    /*!
+     * Get a resource from the device. This will increment the reference count
+     * of the resource, and if it exclusive access is requested, the exclusive
+     * flag will be set and further attempts to get the resource will fail
+     * until the reference count has been decremented back to zero.
+     *
+     * @param pa The device to get the resource from.
+     * @param resource_type The type of resource being requested.
+     * @param resource_id The ID of the resource being requested.
+     * @param exclusive Boolean flag indicating whether exclusive access is
+     * required.
+     * @return Returns a pointer to the resource on success, NULL on failure.
+     */
+    struct pico_resource * ( *get_resource )( struct picoarray *pa,
+                                        enum pico_resource_type resource_type,
+                                        unsigned resource_id,
+                                        int exclusive );
+
+    /*!
+     * Decrement the reference count of a resource. If the resource is held
+     * exclusively and the reference count is zero after decrementing, it will
+     * become available to other users.
+     *
+     * @param pa The device the resource belongs to.
+     * @param resource The resource to put.
+     */
+    void ( *put_resource )( struct picoarray *pa,
+                            struct pico_resource *resource );
+
+    /*!
+     * Destructor for the device. This function is called when the module
+     * releases the devices and should be used for any cleanup needed.
+     *
+     * @param pa The device to destroy.
+     */
+    void ( *destructor )( struct picoarray *pa );
+
+    /*!
+     * Get the ITM, ITS and procIF IRQ resources.
+     * This function will return the pointers to the resources requested on success
+     * or NULL if the resource is already allocated.
+     *
+     * @param pa The device to take to DMA the data.
+     * @param its The ITS resource or NULL on failure
+     * @param itm The ITM resource or NULL on failure
+     * @param procif_irq The IRQ resource or NULL on failure
+     *
+     * @return 0 on success, non-zero on failure
+     */
+    int ( *get_procif_resource )( struct picoarray *pa,
+                                  struct pico_resource **its,
+                                  struct pico_resource **itm,
+                                  struct pico_resource **procif_irq );
+    
+    /*!
+     * Put the ITM, ITS and procIF IRQ resources.
+     * This function will free any non NULL resources specified
+     *
+     * @param pa The device to take to DMA the data.
+     * @param its The ITS resource
+     * @param itm The ITM resource
+     * @param procif_irq The IRQ resource
+     */
+    void ( *put_procif_resource )( struct picoarray *pa,
+                                   struct pico_resource *its,
+                                   struct pico_resource *itm,
+                                   struct pico_resource *procif_irq );
+};
+
+/*!
+ * \brief Base class for picoArray structures.
+ *
+ * This is an abstract base class for picoArray structures and there should
+ * never be any standalone instances of this structure - they should be
+ * contained in device specific structures to inherit from this using
+ * container_of() macros.
+ */
+struct picoarray
+{
+    unsigned                dev_num;    /*!< The logical device number of the
+                                         *   picoArray. */
+
+    struct picoarray_ops    *ops;       /*!< Methods for the device. */
+
+    struct pico_resource    *resources; /*!< Resources that the device has.
+                                         *   This is an array of resources and
+                                         *   should be terminated with a 0
+                                         *   filled entry. */
+
+    spinlock_t              lock;       /*!< Concurrency lock. This is used
+                                         *   for protecting resources and
+                                         *   hardware interlocks. */
+
+    unsigned long           features;   /*!< Features bitmap. Used to indicate
+                                         *   features that the device supports
+                                         */
+    unsigned long           max_dma_sz; /*!< Maximum DMA transfer length. */
+};
+
+#define PICOARRAY_HAS_DMA_LOAD          ( 1 << 0 )
+#define PICOARRAY_HAS_DMA               ( 1 << 1 )
+
+/*!
+ * Check if a picoArray has a requested feature.
+ *
+ * \param pa The picoArray to query.
+ * \param feature The feature to test for.
+ * \return Returns non-zero if the device has the feature, zero otherwise.
+ */
+static inline int
+picoarray_has_feature( const struct picoarray *pa,
+                       unsigned long feature )
+{
+    return pa->features & feature;
+}
+
+/*!
+ * Init function for the PC203 device family. This must be called by
+ * picoif_main to allow the PC203 devices (if any) to be detected.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+pc203_init( void );
+
+/*!
+ * Init function for the PC202 device family. This must be called by
+ * picoif_main to allow the PC202 devices (if any) to be detected.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+pc202_init( void );
+
+/*!
+ * Init function for the PC302 device family. This must be called by
+ * picoif_main to allow the PC302 devices (if any) to be detected.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+pc302_init( void );
+
+#endif /* !__PICOIF_PICOARRAY_H__ */
diff --git a/drivers/picochip/picoif_internal.h b/drivers/picochip/picoif_internal.h
new file mode 100644
index 0000000..168687e
--- /dev/null
+++ b/drivers/picochip/picoif_internal.h
@@ -0,0 +1,184 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif_internal.h
+ * \brief Internal operations for picoIf driver implementation.
+ *
+ * This file defines functions in the picoIf core used for registering
+ * transport modules, and accessing core module services.
+ *
+ * \mainpage
+ *
+ * This document describes the architecture and implementation of the picoIf
+ * Linux kernel driver. This document also describes the kernel API available
+ * to users.
+ *
+ * \section Overview
+ *
+ * picoIf is a library and driver to allow users to configure, control and
+ * communicate with picoArray devices. This documentation describes the driver
+ * implementation and kernel space API but the driver also provides a
+ * userspace interface through POSIX system calls, and debugfs.
+ *
+ * For more details, see:
+ * \li \ref moduleDocs
+ * \li \ref paAbstraction
+ * \li \ref kernelAPI
+ * \li \ref debugging
+ */
+#ifndef __PICOIF_PICOIF_INTERNAL_H__
+#define __PICOIF_PICOIF_INTERNAL_H__
+
+#include <asm/io.h>
+#include "picoarray.h"
+
+struct picoif_module;
+
+/*! Accessor for struct picoif_buf to get the user buffer address. */
+#define ubuf    buf_u.u_buf
+/*! Accessor for struct picoif_buf to get the kernel buffer address. */
+#define kbuf    buf_u.k_buf
+
+/*!
+ * \brief Structure to abstract user/kernel buffer spaces.
+ */
+struct picoif_buf
+{
+    /*! The buffer pointers. u_buf if .is_user = 1, k_buf otherwise. */
+    union
+    {
+        void __user *u_buf;
+        void        *k_buf;
+    } buf_u;
+
+    /*! Boolean flag to indicate the buffer is a userspace buffer. */
+    int             is_user;
+};
+
+/*!
+ * Copy the contents of a struct picoif_buf into a kernel buffer. This is
+ * used to allow functions to work for either userspace or kernel space
+ * interfaces with a simple wrapper around them to create the struct
+ * picoif_buf.
+ *
+ * @param dst The buffer to copy the data into.
+ * @param src The buffer to copy the data from.
+ * @param offset The byte offset in src to begin copying from.
+ * @param nbytes The number of bytes to copy from src to dst.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_buf_copy_from( void *dst,
+                      struct picoif_buf *src,
+                      unsigned offset,
+                      size_t nbytes );
+
+/*!
+ * Copy the contents of a kernel buffer into a struct picoif_buf. This is
+ * used to allow functions to work for either userspace or kernel space
+ * interfaces with a simple wrapper around them to create the struct
+ * picoif_buf.
+ *
+ * @param dst The buffer to copy the data into.
+ * @param src The buffer to copy the data from.
+ * @param offset The byte offset in dst to begin copying to.
+ * @param nbytes The number of bytes to copy from src to dst.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_buf_copy_to( struct picoif_buf *dst,
+                    void *src,
+                    unsigned offset,
+                    size_t nbytes );
+
+/*!
+ * Register a new device with picoif.
+ *
+ * @param pa The new device to register with the module.
+ * @return Returns zero on success, non-zero on failure.
+ */
+int
+picoif_register_dev( struct picoarray *pa );
+
+/*!
+ * Unregister a device from the module.
+ *
+ * @param pa The device to unregister from the module.
+ */
+void
+picoif_unregister_dev( struct picoarray *pa );
+
+/*!
+ * Register a new picoif module with the driver. This module should be
+ * used to provide new transport methods. Modules are unregistered with
+ * picoif_unregister_module().
+ *
+ * @param module The module to register with the driver.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_register_module( struct picoif_module *module );
+
+/*!
+ * Unregister a transport module from the driver.
+ *
+ * @param module The module to unregister.
+ */
+void
+picoif_unregister_module( struct picoif_module *module );
+
+/*!
+ * Get a device given its logical device number.
+ *
+ * @param dev_num The logical device number of the picoArray to get.
+ * @return Returns a pointer to the device on success, NULL on failure.
+ */
+struct picoarray *
+picoif_get_device( unsigned dev_num );
+
+/*!
+ * Perform a 32 bit write to the picoArray taking endianness into account.
+ *
+ * @param value The value to write.
+ * @param addr The virtual IO address to write to.
+ */
+static inline void
+picoif_out32( u32 value,
+              void __iomem *addr )
+{
+#ifdef __LITTLE_ENDIAN
+    iowrite32( value, addr );
+#else /* __LITTLE_ENDIAN */
+    out_be32( addr, value );
+#endif /* __LITTLE_ENDIAN */
+}
+
+/*!
+ * Perform a 32 bit read from the picoArray taking endianness into account.
+ *
+ * @param addr The virtual IO address to read from.
+ * @return Returns the 32 bit value.
+ */
+static inline u32
+picoif_in32( void __iomem *addr )
+{
+#ifdef __LITTLE_ENDIAN
+    return ioread32( addr );
+#else /* __LITTLE_ENDIAN */
+    return in_be32( addr );
+#endif /* __LITTLE_ENDIAN */
+}
+
+#endif /* !__PICOIF_PICOIF_INTERNAL_H__ */
diff --git a/drivers/picochip/picoif_main.c b/drivers/picochip/picoif_main.c
new file mode 100644
index 0000000..5251aac
--- /dev/null
+++ b/drivers/picochip/picoif_main.c
@@ -0,0 +1,1515 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif_main.c
+ * \brief Main file for picoIf kernel driver.
+ *
+ * This file implements the core functionality of the picoIf kernel driver.
+ * This file is responsible for registration of devices and transport modules
+ * and handling all userspace/kernelspace interfaces such as file operations.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/err.h>
+#include <linux/debugfs.h>
+#include <linux/poll.h>
+#include <linux/aio.h>
+#include <asm/uaccess.h>
+#include <linux/dma-mapping.h>
+#include <asm/errno.h>
+
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include <linux/picochip/picoif_ioctl.h>
+#include "picoif_module.h"
+#include "gpr_interrupt_internal.h"
+#include "dma_internal.h"
+#include "hwif_internal.h"
+#include "hwif2_internal.h"
+#include "debug.h"
+#include <linux/picochip/picoif.h>
+
+/*! The maximum number of devices the driver supports. */
+#define PICOIF_MAX_DEVICES ( 8 )
+
+/*! The maximum number of transport modules the driver supports. */
+#define PICOIF_MAX_MODULES ( 8 )
+
+/*! The maximum number of bytes to be transfered between user and
+ *  kernel space in one operation. This number must take into account
+ *  any DMA tranaction limits that exist if DMA is being used */
+#define PICOIF_MAX_TRANSFER_SIZE ( 4096 )
+
+/*!
+ * \brief Structure to store devices in the system and any other data private
+ * to the driver.
+ */
+struct picoif_core_t
+{
+    /*! The devices that the driver interfaces to. */
+    struct picoarray            *devices[ PICOIF_MAX_DEVICES ];
+
+    /*! The miscdevice used for the Linux device registration. */
+    struct miscdevice           miscdev;
+
+    /*! The modules that have been registered with picoIf. */
+    struct picoif_module        *modules[ PICOIF_MAX_MODULES ];
+
+#ifdef CONFIG_DEBUG_FS
+    /*! The entry in /debug for all debugfs files. */
+    struct dentry               *debugfs_dir;
+
+    /*! The entry in /debug/picoif for the debug log. */
+    struct dentry               *debug_log;
+#endif /* CONFIG_DEBUG_FS */
+};
+
+static int
+picoif_open( struct inode *inode,
+             struct file *filp );
+
+static ssize_t
+picoif_write( struct file *filp,
+              const char __user *buf,
+              size_t len,
+              loff_t *loff );
+
+static ssize_t
+picoif_read( struct file *filp,
+             char __user *buf,
+             size_t len,
+             loff_t *loff );
+
+static int
+picoif_ioctl( struct inode *inode,
+              struct file *filp,
+              unsigned int cmd,
+              unsigned long arg );
+
+static int
+picoif_release( struct inode *inode,
+                struct file *filp );
+
+static int
+picoif_mmap( struct file *filp,
+             struct vm_area_struct *vma );
+
+static unsigned int
+picoif_poll( struct file *filp,
+             struct poll_table_struct *pollt );
+
+static ssize_t
+picoif_aio_write( struct kiocb *iocb,
+                  const struct iovec *vecs,
+                  unsigned long nr_segs,
+                  loff_t offset );
+
+static ssize_t
+picoif_aio_read( struct kiocb *iocb,
+                 const struct iovec *vecs,
+                 unsigned long nr_segs,
+                 loff_t offset );
+
+/*!
+ * File operations structure for the driver. All file operations for the
+ * driver and transports will be in this structure and if the operation needs
+ * to be rerouted to a transport module, this will happen in these functions.
+ */
+static struct file_operations picoif_fops = {
+    .owner      = THIS_MODULE,
+    .open       = picoif_open,
+    .release    = picoif_release,
+    .write      = picoif_write,
+    .read       = picoif_read,
+    .ioctl      = picoif_ioctl,
+    .mmap       = picoif_mmap,
+    .poll       = picoif_poll,
+    .aio_read   = picoif_aio_read,
+    .aio_write  = picoif_aio_write,
+};
+
+/*!
+ * The miscdevice for the driver.
+ */
+static struct picoif_core_t picoif_core = {
+    .miscdev    =  {
+        .fops   = &picoif_fops,
+        .name   = "picoif",
+        .minor  = MISC_DYNAMIC_MINOR,
+    },
+};
+
+int
+picoif_buf_copy_from( void *dst,
+                      struct picoif_buf *src,
+                      unsigned offset,
+                      size_t nbytes )
+{
+    if ( src->is_user )
+        return copy_from_user( dst, src->ubuf + offset, nbytes );
+
+    return memcpy( dst, src->kbuf + offset, nbytes ) ? 0 : 1;
+}
+
+int
+picoif_buf_copy_to( struct picoif_buf *dst,
+                    void *src,
+                    unsigned offset,
+                    size_t nbytes )
+{
+    if ( dst->is_user )
+        return copy_to_user( dst->ubuf + offset, src, nbytes );
+
+    return memcpy( dst->kbuf + offset, src, nbytes ) ? 0 : 1;
+}
+
+/*!
+ * Open a new instance of the driver. At open, the file descriptor will be a
+ * generic picoif instance for configuration and to use it as a transport
+ * file descriptor, the NEW_TRANSPORT ioctl() call must be used to associate
+ * it with a transport instance.
+ *
+ * @param inode The inode of the device file.
+ * @param filp The context of the open instance. The private_data member can
+ * be used to store driver information for this context. For non-transport
+ * instances, private_data should be NULL and for transport instances it
+ * should point to a struct picoif_context.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_open( struct inode *inode,
+             struct file *filp )
+{
+    filp->private_data = NULL;
+    return 0;
+}
+
+/*!
+ * Close an instance of the driver. If this descriptor is associated with a
+ * transport, close the transport instance.
+ *
+ * @param inode The inode of the device file.
+ * @param filp The context of the open instance.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_release( struct inode *inode,
+                struct file *filp )
+{
+    struct picoif_context *ctx = filp->private_data;
+
+    /* If this is a transport instance, close it. */
+    if ( ctx )
+        ctx->module->ops->close_instance( ctx->module, ctx );
+
+    return 0;
+}
+
+/*!
+ * Asynchronous write operation for picoIf. We don't actually do any
+ * asynchronous operations, but this is also used for the writev() system call
+ * so we simply complete these operations synchronously.
+ *
+ * @param iocb The IO control buffer for the request.
+ * @param vecs The vector of buffers to write.
+ * @param nr_segs The number of entries in the vecs buffer to write.
+ * @param offset Not used in this driver.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+static ssize_t
+picoif_aio_write( struct kiocb *iocb,
+                  const struct iovec *vecs,
+                  unsigned long nr_segs,
+                  loff_t offset )
+{
+    ssize_t ret = 0;
+    struct picoif_context *ctx = iocb->ki_filp->private_data;
+    if ( !ctx )
+        return -EBADF;
+
+    if ( ctx->module->ops->writev )
+        ret = ctx->module->ops->writev( ctx->module, ctx, vecs, nr_segs, 1 );
+    else
+    {
+        /* If we don't have a writev method for the transport, then emulate it
+         * with a series of normal writes. */
+        unsigned seg;
+        ssize_t total = 0;
+        const struct iovec *vec;
+
+        for ( seg = 0; seg < nr_segs; ++seg )
+        {
+            vec = &vecs[ seg ];
+            ret = picoif_write( iocb->ki_filp, vec->iov_base, vec->iov_len,
+                                &offset );
+            total += ret;
+            if ( ret < vec->iov_len )
+                goto out;
+        }
+
+        ret = ret >= 0 ? total : ret;
+    }
+out:
+    return ret;
+}
+
+/*!
+ * Asynchronous read operation for picoIf. We don't actually do any
+ * asynchronous operations, but this is also used for the readv() system call
+ * so we simply complete these operations synchronously.
+ *
+ * @param iocb The IO control buffer for the request.
+ * @param vecs The vector of buffers to read into.
+ * @param nr_segs The number of entries in the vecs buffer to read.
+ * @param offset Not used in this driver.
+ * @return Returns the number of bytes read on success, negative on
+ * failure.
+ */
+static ssize_t
+picoif_aio_read( struct kiocb *iocb,
+                 const struct iovec *vecs,
+                 unsigned long nr_segs,
+                 loff_t offset )
+{
+    ssize_t ret = 0;
+    struct picoif_context *ctx = iocb->ki_filp->private_data;
+    if ( !ctx )
+        return -EBADF;
+
+    if ( ctx->module->ops->readv )
+        ret = ctx->module->ops->readv( ctx->module, ctx, vecs, nr_segs, 1 );
+    else
+    {
+        unsigned seg;
+        ssize_t total = 0;
+        const struct iovec *vec;
+
+        /* If we don't have a readv method for the transport, then emulate it
+         * with a series of normal reads. */
+        for ( seg = 0; seg < nr_segs; ++seg )
+        {
+            vec = &vecs[ seg ];
+            ret = picoif_read( iocb->ki_filp, vec->iov_base, vec->iov_len,
+                               &offset );
+            total += ret;
+            if ( ret < vec->iov_len )
+                goto out;
+        }
+
+        ret = ret >= 0 ? total : ret;
+    }
+out:
+    return ret;
+}
+
+/*!
+ * Write to the open instance. For non-transport file descriptors this is an
+ * invalid operation. For transport instances, use the context to find the
+ * module that handles the instance and call its write() method.
+ *
+ * @param filp The context of the open instance.
+ * @param buf The data to write into the transport instance.
+ * @param len The number of bytes to write.
+ * @param loff The offset to write into the file. This is ignored in this
+ * driver.
+ * @return Returns the number of bytes written on success, negative on
+ * failure. It is possible that this may successfully return less than len
+ * bytes.
+ */
+static ssize_t
+picoif_write( struct file *filp,
+              const char __user *buf,
+              size_t len,
+              loff_t *loff )
+{
+    struct picoif_context *ctx = filp->private_data;
+    ssize_t ret;
+    struct picoif_buf pbuf = {
+        .ubuf       = ( char __user * )buf,
+        .is_user    = 1,
+    };
+
+    if ( !ctx )
+        return -EBADF;
+
+again:
+    if ( !( filp->f_flags & O_NONBLOCK ) &&
+         wait_event_interruptible( ctx->writeq,
+                                   ctx->module->ops->can_write( ctx->module,
+                                   ctx ) ) )
+    {
+        ret = -ERESTARTSYS;
+        goto out;
+    }
+
+    ret = ctx->module->ops->write( ctx->module, ctx, &pbuf, len );
+
+    /* If the resource is temporarily unavailable and we are a blocking
+     * transport, then do it again until it succeeds. */
+    if ( -EAGAIN == ret && !( filp->f_flags & O_NONBLOCK ) )
+        goto again;
+
+    if ( !ret && ( filp->f_flags & O_NONBLOCK ) )
+        ret = -EAGAIN;
+
+out:
+    return ret;
+}
+
+/*!
+ * Read frm the open instance. For non-transport file descriptors this is an
+ * invalid operation. For transport instances, use the context to find the
+ * module that handles the instance and call its read() method.
+ *
+ * @param filp The context of the open instance.
+ * @param buf The data to read from the transport instance.
+ * @param len The number of bytes to read.
+ * @param loff The offset to read from the file. This is ignored in this
+ * driver.
+ * @return Returns the number of bytes read on success, negative on
+ * failure. It is possible that this may successfully return less than len
+ * bytes.
+ */
+static ssize_t
+picoif_read( struct file *filp,
+             char __user *buf,
+             size_t len,
+             loff_t *loff )
+{
+    struct picoif_context *ctx = filp->private_data;
+    ssize_t ret;
+    struct picoif_buf pbuf = {
+        .ubuf       = buf,
+        .is_user    = 1,
+    };
+
+    if ( !ctx )
+        return -EBADF;
+
+again:
+    if ( !( filp->f_flags & O_NONBLOCK ) &&
+         wait_event_interruptible( ctx->readq,
+                                   ctx->module->ops->can_read( ctx->module,
+                                   ctx ) ) )
+    {
+        ret = -ERESTARTSYS;
+        goto out;
+    }
+
+    ret = ctx->module->ops->read( ctx->module, ctx, &pbuf, len );
+
+    /* If the resource is temporarily unavailable and we are a blocking
+     * transport, then do it again until it succeeds. */
+    if ( -EAGAIN == ret && !( filp->f_flags & O_NONBLOCK ) )
+        goto again;
+
+    if ( !ret && ( filp->f_flags & O_NONBLOCK ) )
+        ret = -EAGAIN;
+
+out:
+    return ret;
+}
+
+/*!
+ * Simple open function for the picoIf mmap() implementation. This is only
+ * used for logging.
+ *
+ * @param vma The vma request is being mapped.
+ */
+static void
+picoif_vma_open( struct vm_area_struct *vma )
+{
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "mmap pa %lx to va %lx",
+            vma->vm_pgoff << PAGE_SHIFT, vma->vm_start );
+}
+
+/*!
+ * Simple close function for the picoIf mmap() implementation. This is only
+ * used for logging.
+ *
+ * @param vma The vma request is being unmapped.
+ */
+static void
+picoif_vma_close( struct vm_area_struct *vma )
+{
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "mmap, close mapping of pa %lx",
+            vma->vm_pgoff << PAGE_SHIFT );
+}
+
+/*!
+ * VM operations for the picoIf mmap implementation. This functions do nothing
+ * special and are only used for logging and debug.
+ */
+static struct vm_operations_struct picoif_vm_ops = {
+    .open   = picoif_vma_open,
+    .close  = picoif_vma_close,
+};
+
+/*!
+ * Map a range of physical memory into the user process. This creates a
+ * mapping from the beginning of the physical memory address (0) + the
+ * requested offset. The user can effectively map the whole physical address
+ * space with this call but we have no way of knowing what the physical memory
+ * setup is at this point and certainly no way of knowing which memory is
+ * shared between the host processor and the picoArray(s). It is in fact
+ * possible that there is no shared memory and that this will only map host
+ * memory, but there is no way for the driver to be able to detect this. For
+ * example, for PC202, this driver may be running on the ARM or an external
+ * host, so there may or may not shared memory.
+ *
+ * This function effectively reimplements a mapping of /dev/mem with the
+ * exception that all memory accesses should be uncached. This is required to
+ * avoid stalls and race conditions when communicating through shared memory.
+ *
+ * @param filp The context of the open instance.
+ * @param vma The VMA for the requested operation.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_mmap( struct file *filp,
+             struct vm_area_struct *vma )
+{
+    size_t size = vma->vm_end - vma->vm_start;
+    int ret;
+
+    /* Ensure that the mapping is non-cached and non-buffered. */
+    vma->vm_page_prot = pgprot_noncached( vma->vm_page_prot );
+
+    ret = -EAGAIN;
+    if ( remap_pfn_range( vma, vma->vm_start, vma->vm_pgoff,
+                          size, vma->vm_page_prot ) )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "remap_pfn_range() failed (%u bytes @0x%08x)", size,
+                vma->vm_start );
+        goto out;
+    }
+
+    vma->vm_ops = &picoif_vm_ops;
+    picoif_vma_open( vma );
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Poll a transport type. It is only valid to poll on a transport file
+ * descriptor. Polling a non-transport file descriptor will return -EINVAL.
+ *
+ * @param filp The file descriptor being polled.
+ * @param pollt The poll table for the request.
+ * @return Returns a mask of the poll events on success, negative on failure.
+ */
+static unsigned int
+picoif_poll( struct file *filp,
+             struct poll_table_struct *pollt )
+{
+    struct picoif_context *ctx = filp->private_data;
+    struct picoif_module *mod;
+    unsigned int ret = 0;
+
+    if ( !ctx )
+        goto out;
+
+    mod = ctx->module;
+
+    poll_wait( filp, &ctx->writeq, pollt );
+    poll_wait( filp, &ctx->readq, pollt );
+
+    if ( mod->ops->can_write( mod, ctx ) )
+        ret |= POLLOUT;
+    if ( mod->ops->can_read( mod, ctx ) )
+        ret |= POLLIN;
+
+out:
+    return ret;
+}
+
+int
+picoif_reset( void )
+{
+    unsigned i;
+    int ret = 0;
+    struct picoarray *pa;
+
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "picoif: reset all devices" );
+
+    /* Reset each device in sequence. */
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        pa = picoif_core.devices[ i ];
+        if ( pa )
+        {
+            PRINTD( COMPONENT_PICOIF, DBG_TRACE, "resetting device %u",
+                    i );
+            ret = pa->ops->reset( pa );
+            if ( ret )
+                break;
+        }
+    }
+
+    return ret;
+}
+EXPORT_SYMBOL( picoif_reset );
+
+int
+picoif_start_all( void )
+{
+    unsigned i;
+    int ret = 0;
+    struct picoarray *pa;
+
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "picoif: start all devices" );
+
+    /* Sync the devices. */
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        pa = picoif_core.devices[ i ];
+        if ( pa )
+        {
+            PRINTD( COMPONENT_PICOIF, DBG_TRACE, "syncing device %u", i );
+            ret = pa->ops->sync( pa );
+            if ( ret )
+                break;
+        }
+    }
+
+    /* Start each device in sequence. The master is the only device we need
+     * to do this with but it is easier and quicker to do all devices rather
+     * than find the master. */
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        pa = picoif_core.devices[ i ];
+        if ( pa )
+        {
+            PRINTD( COMPONENT_PICOIF, DBG_TRACE, "starting device %u", i );
+            ret = pa->ops->start( pa );
+            if ( ret )
+                break;
+        }
+    }
+
+    return ret;
+}
+EXPORT_SYMBOL( picoif_start_all );
+
+int
+picoif_stop_all( void )
+{
+    unsigned i;
+    int ret = 0;
+    struct picoarray *pa;
+
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "picoif: stop all devices" );
+
+    /* Start each device in sequence. The master is the only device we need
+     * to do this with but it is easier and quicker to do all devices rather
+     * than find the master. */
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        pa = picoif_core.devices[ i ];
+        if ( pa )
+        {
+            PRINTD( COMPONENT_PICOIF, DBG_TRACE, "stopping device %u",
+                    i );
+            ret = pa->ops->stop( pa );
+            if ( ret )
+                break;
+        }
+    }
+
+    return ret;
+}
+EXPORT_SYMBOL( picoif_stop_all );
+
+struct picoarray *
+picoif_get_device( unsigned dev_num )
+{
+    if ( dev_num >= PICOIF_MAX_DEVICES )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "picoif: get_device, device out of range (%u)",
+                dev_num );
+        return NULL;
+    }
+
+    return picoif_core.devices[ dev_num ];
+}
+
+int
+picoif_config_read( unsigned dev_num,
+                    u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *buf )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = pa->ops->config_read( pa, caeid, address, count, buf );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_config_read );
+
+int
+picoif_config_write( unsigned dev_num,
+                     u16 caeid,
+                     u16 address,
+                     u16 count,
+                     u16 *buf )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = pa->ops->config_write( pa, caeid, address, count, buf );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_config_write );
+
+int
+picoif_pa_load( unsigned dev_num,
+                u32 *buf,
+                struct scatterlist *sgl )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = pa->ops->pa_load( pa, buf, sgl );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_pa_load );
+
+int
+picoif_register_write( unsigned dev_num,
+                       unsigned reg_id,
+                       u32 value )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    struct pico_resource *reg;
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = -EBUSY;
+    reg = pa->ops->get_resource( pa, PICO_RES_GPR, reg_id, 0 );
+    if ( !reg )
+        goto out;
+
+    ret = pa->ops->register_write( pa, reg, value );
+
+    pa->ops->put_resource( pa, reg );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_register_write );
+
+int
+picoif_register_read( unsigned dev_num,
+                      unsigned reg_id,
+                      u32 *value )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    struct pico_resource *reg;
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = -EBUSY;
+    reg = pa->ops->get_resource( pa, PICO_RES_GPR, reg_id, 0 );
+    if ( !reg )
+        goto out;
+
+    ret = pa->ops->register_read( pa, reg, value );
+
+    pa->ops->put_resource( pa, reg );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_register_read );
+
+/*!
+ * Handle a register read/write request ioctl. This is largely just a wrapper
+ * around picoif_register_{read,write}() and doing the address space
+ * copying.
+ *
+ * @param user_req The request structure containing the register ID, device
+ * number and value.
+ * @param write Boolean to indicate that the operation is a write.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_ioctl_reg_req( struct picoif_reg_req __user *user_req,
+                      int write )
+{
+    struct picoif_reg_req reg_req;
+    int ret;
+
+    ret = copy_from_user( &reg_req, user_req, sizeof( reg_req ) );
+    if ( ret )
+        goto out;
+
+    ret = write ? picoif_register_write( reg_req.dev, reg_req.reg_id,
+                                              reg_req.value ) :
+                  picoif_register_read( reg_req.dev, reg_req.reg_id,
+                                             &reg_req.value );
+
+    if ( !write && !ret )
+    {
+        ret = copy_to_user( user_req, &reg_req, sizeof( reg_req ) );
+        if ( ret )
+            goto out;
+    }
+
+out:
+    return ret;
+}
+
+/*!
+ * Handle a multiple configure register write request ioctl. This 
+ * function will allocate cached/uncached memory depending on whether a DMA
+ * is available, and provide both the virtual and phyiscal addresses to the
+ * device layer so that both DMA and non DMA transfers are supported.
+ *
+ * @param user_req The request structure containing the device number,
+ *  number of writes to make to the configuration write port and the
+ *  values to write.
+ * @param write Boolean to indicate that the operation is a write.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_ioctl_multi_reg_req( struct picoif_multi_reg_req __user *user_req,
+                            int write )
+{
+    struct picoif_multi_reg_req multi_reg_req;
+    int ret;
+    int transfer_count = 0;
+    u32 *bounce = NULL;
+    struct scatterlist sgl;
+    struct picoarray *pa;
+    int do_dma;
+
+    ret = copy_from_user( &multi_reg_req, user_req, sizeof( multi_reg_req ) );
+    if ( ret )
+        goto out;
+
+    if ( !write )
+    {
+        ret = -EINVAL;
+        goto out;
+    }
+
+    pa = picoif_get_device( multi_reg_req.dev );
+    if ( !pa )
+    {
+        ret = -EINVAL;
+        goto out;
+    }
+
+    do_dma = picoarray_has_feature( pa, PICOARRAY_HAS_DMA_LOAD );
+
+    /* Allocate a buffer to perform the read/write to/from to avoid doing each
+     * word with copy_{to,from}_user calls. */
+    ret = -ENOMEM;
+    if ( do_dma )
+        bounce = dma_alloc_coherent( NULL, PICOIF_MAX_TRANSFER_SIZE,
+               &sgl.dma_address, GFP_KERNEL );
+    else
+        bounce = kmalloc( PICOIF_MAX_TRANSFER_SIZE, GFP_KERNEL );
+    if ( !bounce )
+        goto out;
+
+    /* Copy data from userspace */
+    if ( multi_reg_req.count > 0 )
+    {
+        unsigned words_so_far=0;
+        unsigned num_transfers = 
+          ((multi_reg_req.count-1)/(PICOIF_MAX_TRANSFER_SIZE/sizeof( u32 )))+1;
+        unsigned i=0;
+
+        for(i = 0; i < num_transfers; i++)
+        {
+            sgl.length = multi_reg_req.count-words_so_far;
+            if ( sgl.length >= (PICOIF_MAX_TRANSFER_SIZE / sizeof( u32 )))
+                sgl.length = (PICOIF_MAX_TRANSFER_SIZE / sizeof( u32 ));
+
+            ret = copy_from_user( bounce, &multi_reg_req.buf[words_so_far],
+                          sgl.length * sizeof( u32 ));
+            words_so_far += sgl.length;
+
+            if ( ret )
+                goto out;
+
+            ret = picoif_pa_load( multi_reg_req.dev, bounce, &sgl );
+
+            /* If successful, set the number of words read/written and copy
+               the data back if it was a config read. */
+            if ( ret > 0 )
+            { 
+                transfer_count += ret;
+                ret = 0;
+            }
+        }
+    }
+
+    /* Copy the request back containing the number of words written/read. */
+    if ( copy_to_user( user_req, &multi_reg_req, sizeof( multi_reg_req ) ) )
+        ret = -EFAULT;
+
+out:
+    if ( !ret )
+        ret = transfer_count;
+
+    if ( bounce )
+    {
+        if ( do_dma )
+            dma_free_coherent( NULL, PICOIF_MAX_TRANSFER_SIZE, bounce,
+                 sgl.dma_address );
+        else
+            kfree( bounce );
+    }
+
+    return ret;
+}
+
+/*!
+ * Handle a config bus read/write request ioctl. This is largely just a wrapper
+ * around picoif_config_{read,write}() and doing the address space
+ * copying.
+ *
+ * @param user_req The request structure containing the device number, CAEID,
+ * AE address, count and pointer to data buffer.
+ * @param write Boolean to indicate that the operation is a write.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_ioctl_cfg_req( struct picoif_cfg_req __user *user_req,
+                      int write )
+{
+    struct picoif_cfg_req cfg_req;
+    u16 *bounce = NULL;
+    int ret;
+
+    /* Copy the request from userspace. */
+    ret = copy_from_user( &cfg_req, user_req, sizeof( cfg_req ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    if ( cfg_req.count > ( ( 1 << 16 ) - 1 ) )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "config request count exceeds address space size" );
+        goto out;
+    }
+
+    if ( cfg_req.count + cfg_req.ae_addr > ( ( 1 << 16 ) - 1 ) )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "config request start + count exceeds address space size" );
+        goto out;
+    }
+
+    /* Allocate a buffer to perform the read/write to/from to avoid doing each
+     * word with copy_{to,from}_user calls. */
+    ret = -ENOMEM;
+    bounce = kmalloc( cfg_req.count * sizeof( u16 ), GFP_KERNEL );
+    if ( !bounce )
+        goto out;
+
+    if ( write )
+    {
+        ret = copy_from_user( bounce, cfg_req.buf,
+                              cfg_req.count * sizeof( u16 ) );
+        if ( ret )
+            goto out;
+    }
+
+    /* Do the actual read/write. */
+    ret = write ? picoif_config_write( cfg_req.dev, cfg_req.caeid,
+                                       cfg_req.ae_addr, cfg_req.count,
+                                       bounce ) :
+                  picoif_config_read( cfg_req.dev, cfg_req.caeid,
+                                      cfg_req.ae_addr, cfg_req.count,
+                                      bounce );
+
+    /* If successful, set the number of words read/written and copy the data
+     * back if it was a config read. */
+    if ( ret >= 0 )
+    {
+        cfg_req.count = ret;
+        if ( !write )
+        {
+            ret = copy_to_user( cfg_req.buf, bounce,
+                                cfg_req.count * sizeof( u16 ) );
+            if ( ret )
+                goto out;
+        }
+        ret = 0;
+    }
+
+    /* Copy the request back containing the number of words written/read. */
+    if ( copy_to_user( user_req, &cfg_req, sizeof( cfg_req ) ) )
+        ret = -EFAULT;
+
+out:
+    if ( bounce )
+        kfree( bounce );
+    return ret;
+}
+
+
+unsigned
+picoif_num_devices( void )
+{
+    unsigned i;
+    unsigned num_devices = 0;
+
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+        if ( picoif_core.devices[ i ] )
+            ++num_devices;
+
+    return num_devices;
+}
+EXPORT_SYMBOL( picoif_num_devices );
+
+ssize_t
+picoif_transport_generic_read( struct picoif_context *ctx,
+                               u8 *buf,
+                               size_t len )
+{
+    struct picoif_buf pbuf = {
+        .kbuf       = buf,
+        .is_user    = 0,
+    };
+    return ctx->module->ops->read( ctx->module, ctx, &pbuf, len );
+}
+EXPORT_SYMBOL( picoif_transport_generic_read );
+
+ssize_t
+picoif_transport_generic_write( struct picoif_context *ctx,
+                                const u8 *buf,
+                                size_t len )
+{
+    struct picoif_buf pbuf = {
+        .kbuf       = ( void * )buf,
+        .is_user    = 0,
+    };
+    return ctx->module->ops->write( ctx->module, ctx, &pbuf, len );
+}
+EXPORT_SYMBOL( picoif_transport_generic_write );
+
+void
+picoif_transport_generic_close( struct picoif_context *ctx )
+{
+    ctx->module->ops->close_instance( ctx->module, ctx );
+}
+EXPORT_SYMBOL( picoif_transport_generic_close );
+
+/*!
+ * Handle an ioctl request to get the number of devices in the system. This is
+ * just a wrapper around picoif_num_devices() with the address space
+ * copying.
+ *
+ * @param res The destination to write the number of devices to.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_ioctl_num_devices( void __user *res )
+{
+    unsigned num_devices = picoif_num_devices();
+    return copy_to_user( res, &num_devices, sizeof( num_devices ) );
+}
+
+/*!
+ * Get a picoif module by the module name.
+ *
+ * @param name The name of the module.
+ * @return Returns a pointer to the module on success, NULL on failure.
+ */
+static struct picoif_module *
+picoif_get_module( const char *name )
+{
+    unsigned i;
+    struct picoif_module *mod = NULL;
+
+    for ( i = 0; i < PICOIF_MAX_MODULES; ++i )
+        if ( picoif_core.modules[ i ] &&
+             !strcmp( picoif_core.modules[ i ]->name, name ) )
+        {
+            mod = picoif_core.modules[ i ];
+            break;
+        }
+
+    return mod;
+}
+
+/*!
+ * Handle a new transport request. This attempts to open a new transport
+ * described in req and associated it with the file descriptor filp.
+ *
+ * @param filp The file descriptor to be associated with the transport.
+ * @param req The request for the new transport.
+ * @return Returns zero on success, non-zero on failure.
+ */
+static int
+picoif_new_trans( struct file *filp,
+                  void __user *req )
+{
+
+    struct picoif_new_trans_req trans_req;
+    int ret = copy_from_user( &trans_req, req, sizeof( trans_req ) );
+    char module_name[ 32 ];
+    char *p;
+    struct picoif_module *mod;
+    struct picoif_context *ctx;
+    struct picoif_buf tbuf;
+
+    if ( ret )
+        goto out;
+
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "create new transport \"%s\"",
+            trans_req.description );
+
+    ret = -EINVAL;
+    p = strchr( trans_req.description, '(' );
+    if ( !p )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "invalid transport description \"%s\"",
+                trans_req.description );
+        goto out;
+    }
+
+    /* Extract the module name. */
+    strncpy( module_name, trans_req.description,
+             ( p - trans_req.description ) );
+    module_name[ p - trans_req.description ] = '\0';
+
+    mod = picoif_get_module( module_name );
+    if ( !mod )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "module %s not registered", module_name );
+        goto out;
+    }
+
+    tbuf.ubuf = trans_req.params;
+    tbuf.is_user = 1;
+    ctx = mod->ops->create_trans_instance( mod, trans_req.description,
+                                           &tbuf );
+    if ( IS_ERR( ctx ) )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "failed to create transport \"%s\"", trans_req.description );
+        ret = PTR_ERR( ctx );
+        goto out;
+    }
+
+    filp->private_data = ctx;
+
+    ret = 0;
+
+out:
+    return ret;
+}
+
+/*!
+ * Handle an ioctl request for the driver. If this is a transport instance
+ * then the ioctl request should be rerouted to the appropriate transport
+ * module.
+ *
+ * @param inode The inode of the device file.
+ * @param filp The file context for this instance.
+ * @param cmd The ioctl type.
+ * @param arg The argument for the ioctl. This may be casted to the
+ * appropriate type depending on the ioctl type.
+ */
+static int
+picoif_ioctl( struct inode *inode,
+              struct file *filp,
+              unsigned int cmd,
+              unsigned long arg )
+{
+    int ret = -ENOTTY;
+
+    switch ( cmd )
+    {
+        case PICOIF_IOC_RESET:
+            ret = picoif_reset();
+            break;
+
+        case PICOIF_IOC_STARTALL:
+            ret = picoif_start_all();
+            break;
+
+        case PICOIF_IOC_STOPALL:
+            ret = picoif_stop_all();
+            break;
+
+        case PICOIF_IOC_CFG_READ:
+            ret = picoif_ioctl_cfg_req( ( void __user * )arg, 0 );
+            break;
+
+        case PICOIF_IOC_CFG_WRITE:
+            ret = picoif_ioctl_cfg_req( ( void __user * )arg, 1 );
+            break;
+
+        case PICOIF_IOC_REG_READ:
+            ret = picoif_ioctl_reg_req( ( void __user * )arg, 0 );
+            break;
+
+        case PICOIF_IOC_REG_WRITE:
+            ret = picoif_ioctl_reg_req( ( void __user * )arg, 1 );
+            break;
+
+        case PICOIF_IOC_MULTI_CFG_WRITE:
+            ret = picoif_ioctl_multi_reg_req( ( void __user * )arg, 1 );
+            break;
+
+        case PICOIF_IOC_NUMDEV:
+            ret = picoif_ioctl_num_devices( ( void __user * )arg );
+            break;
+
+        case PICOIF_IOC_NEW_TRANS:
+            ret = picoif_new_trans( filp, ( void __user * )arg );
+            break;
+
+        default:
+            PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                    "picoif: invalid ioctl cmd (%u)", cmd );
+            break;
+    }
+
+    return ret;
+}
+
+int
+picoif_register_dev( struct picoarray *pa )
+{
+    int ret = -EINVAL;
+    if ( !pa )
+        goto out;
+
+    /* Check that we have the required methods filled in. */
+    if ( !pa->ops ||
+         !pa->resources ||
+         !pa->ops->get_device_type ||
+         !pa->ops->reset ||
+         !pa->ops->start ||
+         !pa->ops->stop ||
+         !pa->ops->sync ||
+         !pa->ops->dma_to_device ||
+         !pa->ops->dma_from_device ||
+         !pa->ops->config_read ||
+         !pa->ops->config_write ||
+         !pa->ops->register_read ||
+         !pa->ops->register_write ||
+         !pa->ops->reset ||
+         !pa->ops->get_resource ||
+         !pa->ops->get_procif_resource ||
+         !pa->ops->put_resource ||
+         !pa->ops->put_procif_resource ||
+         !pa->ops->add_irq_handler ||
+         !pa->ops->remove_irq_handler ||
+         !pa->ops->destructor ||
+         !pa->ops->pa_load )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_ERROR,
+                "device %u does not have all required fields/methods",
+                pa->dev_num );
+        goto out;
+    }
+
+    ret = -ENOMEM;
+    if ( pa->dev_num >= PICOIF_MAX_DEVICES )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_TRACE,
+                "pA[ %u ]: device number out of range", pa->dev_num );
+        goto out;
+    }
+
+    ret = 0;
+    picoif_core.devices[ pa->dev_num ] = pa;
+
+out:
+    return ret;
+}
+
+void
+picoif_unregister_dev( struct picoarray *pa )
+{
+    if ( !pa )
+        return;
+
+    if ( !picoif_core.devices[ pa->dev_num ] )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "pA[ %u ]: device not registered", pa->dev_num );
+        return;
+    }
+
+    picoif_core.devices[ pa->dev_num ] = NULL;
+}
+
+int
+picoif_register_module( struct picoif_module *module )
+{
+    unsigned i;
+    int ret = -EINVAL;
+
+    if ( !module )
+        goto out;
+
+    if ( !module->name ||
+         !module->ops ||
+         !module->tmethods ||
+         !module->ops->create_trans_instance ||
+         !module->ops->close_instance ||
+         !module->ops->destructor ||
+         !module->ops->write ||
+         !module->ops->read ||
+         !module->ops->can_read ||
+         !module->ops->can_write )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_ERROR,
+                "transport module \"%s\" does not have all required "
+                "fields/methods", module->name ?: "no name" );
+        goto out;
+    }
+
+    ret = -ENOMEM;
+    for ( i = 0; i < PICOIF_MAX_MODULES; ++i )
+        if ( !picoif_core.modules[ i ] )
+        {
+            picoif_core.modules[ i ] = module;
+            ret = 0;
+            break;
+        }
+
+out:
+    return ret;
+}
+
+void
+picoif_unregister_module( struct picoif_module *module )
+{
+    unsigned i;
+
+    if ( !module )
+        goto out;
+
+    for ( i = 0; i < PICOIF_MAX_MODULES; ++i )
+        if ( picoif_core.modules[ i ] == module )
+        {
+            picoif_core.modules[ i ] = NULL;
+            break;
+        }
+
+out:
+    return;
+}
+
+/*!
+ * Remove all registered devices from the core.
+ */
+static void
+picoif_remove_devices( void )
+{
+
+    unsigned i;
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        struct picoarray *pa = picoif_core.devices[ i ];
+        if ( pa )
+            pa->ops->destructor( pa );
+    }
+}
+
+/*!
+ * Remove all registered modules from the core.
+ */
+static void
+picoif_remove_modules( void )
+{
+
+    unsigned i;
+
+    for ( i = 0; i < PICOIF_MAX_MODULES; ++i )
+    {
+        struct picoif_module *module = picoif_core.modules[ i ];
+        if ( module )
+            module->ops->destructor( module );
+    }
+}
+
+/*!
+ * picoif module initialisation. This function registers the misc device
+ * and performs any initialisation necessary to allow users to use the
+ * services provided.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_init( void )
+{
+    int ret = misc_register( &picoif_core.miscdev );
+    if ( ret )
+    {
+        printk( KERN_INFO "failed to register picoif miscdevice\n" );
+        goto out;
+    }
+
+#ifdef CONFIG_DEBUG_FS
+    ret = -ENOMEM;
+    picoif_core.debugfs_dir = debugfs_create_dir( "picoif", NULL );
+    if ( !picoif_core.debugfs_dir )
+    {
+        printk( KERN_INFO "failed to create debugfs entry\n" );
+        goto debugfs_dir_failed;
+    }
+
+    ret = -ENOMEM;
+    picoif_core.debug_log =
+        pc_debug_create_log_file( picoif_core.debugfs_dir );
+    if ( !picoif_core.debug_log )
+    {
+        printk( KERN_INFO "failed to create debugfs log file\n" );
+        goto debugfs_log_failed;
+    }
+#endif /* CONFIG_DEBUG_FS */
+
+#ifdef CONFIG_PICOIF_PC202
+    ret = pc202_init();
+    if ( ret )
+    {
+        printk( KERN_INFO "pc202 registration failed\n" );
+        goto internal_fail;
+    }
+#endif /* CONFIG_PICOIF_PC202 */
+
+#ifdef CONFIG_PICOIF_PC203
+    ret = pc203_init();
+    if ( ret )
+    {
+        printk( KERN_INFO "pc203 registration failed\n" );
+        goto internal_fail;
+    }
+#endif /* CONFIG_PICOIF_PC203 */
+
+#ifdef CONFIG_PICOIF_PC302
+    ret = pc302_init();
+    if ( ret )
+    {
+        printk( KERN_INFO "pc302 registration failed\n" );
+        goto internal_fail;
+    }
+#endif /* CONFIG_PICOIF_PC302 */
+
+    ret = gpr_interrupt_init();
+    if ( ret )
+    {
+        printk( KERN_INFO
+                "gpr interrupt transport module registration failed\n" );
+        goto internal_fail;
+    }
+
+    ret = dma_init();
+    if ( ret )
+    {
+        printk( KERN_INFO
+                "DMA transport module registration failed\n" );
+        goto internal_fail;
+    }
+
+    ret = hwif_init();
+    if ( ret )
+    {
+        printk( KERN_INFO
+                "HwIF transport module registration failed\n" );
+        goto internal_fail;
+    }
+
+    ret = hwif2_init();
+    if ( ret )
+    {
+        printk( KERN_INFO
+                "HwIF2 transport module registration failed\n" );
+        goto internal_fail;
+    }
+
+    ret = 0;
+    goto out;
+
+internal_fail:
+debugfs_log_failed:
+    debugfs_remove_recursive( picoif_core.debugfs_dir );
+debugfs_dir_failed:
+    misc_deregister( &picoif_core.miscdev );
+out:
+    if ( ret )
+    {
+        picoif_remove_devices();
+        picoif_remove_modules();
+        pc_debug_close();
+    }
+    return ret;
+}
+
+/*!
+ * Module exit function for picoif. This function releases any resources
+ * and performs any cleanup necessary.
+ */
+static void
+picoif_exit( void )
+{
+    picoif_remove_devices();
+    picoif_remove_modules();
+
+    misc_deregister( &picoif_core.miscdev );
+
+#ifdef CONFIG_DEBUG_FS
+    debugfs_remove_recursive( picoif_core.debugfs_dir );
+#endif /* CONFIG_DEBUG_FS */
+    pc_debug_close();
+}
+
+module_init( picoif_init );
+module_exit( picoif_exit );
+MODULE_AUTHOR( "Jamie Iles" );
+MODULE_LICENSE( "GPL" );
diff --git a/drivers/picochip/picoif_module.h b/drivers/picochip/picoif_module.h
new file mode 100644
index 0000000..f556612
--- /dev/null
+++ b/drivers/picochip/picoif_module.h
@@ -0,0 +1,328 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif_module.h
+ * \brief picoIf module and context definition.
+ *
+ * This file defines a base class for picoIf modules and should be inherited
+ * from using the container_of() macro to implement new transport modules.
+ *
+ * \page moduleDocs Transport Module Overview
+ *
+ * \section introduction Introduction
+ *
+ * picoIf implements a modular transport system that allows transport modules
+ * to be easily added and removed without breaking the ABI between userspace
+ * and kernelspace. To achieve this, picoIf defines a picoif_module base class
+ * from which transport modules may derive from and create a new transport
+ * family. Transport modules support a transport family - there may be several
+ * methods supported, but they have a common core. For example in some older
+ * SRD's there is the HwIf transport family that uses an IrqMux entity in the
+ * SRD to provide picoArray initiated uplink DMA and also simple interrupts.
+ * Both of these methods would be supported in a single module as it would be
+ * easier to manage the IrqMux in a single place.
+ *
+ * \section newtransports Opening new transports
+ *
+ * Transports are opened with the create_trans() method of the transport
+ * module and this method takes a textual description of the transport and a
+ * pointer to some transport specific parameters. The transport description is
+ * encoded in the form:
+ *
+ * \code
+ * module_name(method)
+ * \endcode
+ *
+ * For example, the GPR interrupt transport module provides two transports:
+ *  \li "gpr_interrupt(with_values)"
+ *  \li "gpr_interrupt(without_values)"
+ * Where the first method samples the GPR at interrupt time and the second
+ * only records a count of the interrupts.
+ *
+ * The transport parameters should be stored in a structure that is available
+ * to userspace and kernelspace and will be copied into the transport module
+ * by the module itself and the values interpreted.
+ *
+ * \section readingAndWriting Reading and writing
+ *
+ * By default, all transports will be opened in blocking mode but may be put
+ * into non-blocking mode at any time. However, the read and write methods for
+ * the transport module must always be non-blocking and return -EAGAIN if the
+ * read/write would block. This makes it easier for kernel API users to
+ * multiplex multiple transport instances and allows the blocking code to be
+ * factored out which is often common across multiple transports.
+ *
+ * The picoif_context structure contains wait queues for both reading and
+ * writing. If the upper layers, such as the kernel API users or the
+ * picoif_write() and picoif_read() functions need to block, then they can
+ * wait on these queues. To simplify the logic for these functions, there are
+ * also can_read() and can_write() methods that return non-zero if the
+ * operation can take place without blocking and are therefore suitable for
+ * use in the wait_event_interruptible macros(). For example, a blocking read
+ * (minus error checking and return values) might look like:
+ *
+ * \code
+ *  struct picoif_context *ctx;
+ *  struct picoif_buf buffer;
+ *  wait_event_interruptible( ctx->readq,
+ *                            ctx->module->ops->can_read( ctx->module, ctx ) );
+ *  ctx->module->ops->read( ctx->module, ctx, &buffer, transfer_len );
+ * \endcode
+ *
+ * \section new_modules Adding new modules
+ *
+ * To add a new transport module, an implementation file for the transport
+ * family should be created, for example dma.c. This file contains the
+ * derived structure - dma, and has the picoif_module structure embedded in it.
+ * The DMA transport methods are also defined, and these can get a dma pointer
+ * from a pointer to the embedded picoif_module structure with the
+ * container_of() macro:
+ *
+ * \code
+ *  struct picoif_module *module;
+ *  struct dma *dma_module =
+ *      container_of( module, struct picoif_module, module );
+ * \endcode
+ *
+ * When a new context is created with the create_trans() method, the transport
+ * code should create any per-instance structure and store this in the
+ * private_data field of the picoif_context structure for use in the read()
+ * and write() methods etc.
+ */
+#ifndef __PICOIF_PICOIF_MODULE_H__
+#define __PICOIF_PICOIF_MODULE_H__
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include "picoif_internal.h"
+#include <linux/picochip/picoif.h>
+
+struct picoif_module;
+
+
+/*!
+ * Create a new picoIf context and initialise it. This should only be called
+ * by the modules when creating new instances and not users.
+ *
+ * @param module The module owning the context.
+ * @param private_data Private data for the module transport instance.
+ * @return Returns a pointer to the new context on success, NULL on failure.
+ */
+static inline struct picoif_context *
+picoif_new_ctx( struct picoif_module *module,
+                void *private_data )
+{
+    struct picoif_context *ctx = kmalloc( sizeof( *ctx ), GFP_KERNEL );
+    if ( !ctx )
+        goto out;
+
+    ctx->module = module;
+    ctx->private_data = private_data;
+
+    init_waitqueue_head( &ctx->readq );
+    init_waitqueue_head( &ctx->writeq );
+
+out:
+    return ctx;
+}
+
+/*!
+ * Free an existing context. This should only be called by modules when
+ * releasing transport instances and not users.
+ *
+ * @param ctx The context to free.
+ */
+static inline void
+picoif_free_ctx( struct picoif_context *ctx )
+{
+    kfree( ctx );
+}
+
+/*!
+ * \brief Operations for the transport module.
+ */
+struct picoif_module_ops
+{
+    /*!
+     * Create a new transport instance. This function should create a new
+     * transport instance and on success, the file descriptor associated with
+     * the this context will only be used for this transport.
+     *
+     * @param module The module to handle the transport.
+     * @param description The name of the module and transport type in the
+     * form "module_name(transport_type)".
+     * @param params Any extra transport specific parameters should be encoded
+     * in this parameter.
+     * @return Returns a pointer to a new context on success, NULL on failure.
+     */
+    struct picoif_context *
+        ( *create_trans_instance )( struct picoif_module *mod,
+                                    const char *description,
+                                    struct picoif_buf *params );
+
+    /*!
+     * Close an open transport instance.
+     *
+     * @param module The module handling the transport.
+     * @param context The transport instance to close.
+     */
+    void ( *close_instance )( struct picoif_module *mod,
+                              struct picoif_context *context );
+
+    /*!
+     * Transport module destructor. This will be called on termination of
+     * picoif and should close all transport instances and free any
+     * resources.
+     *
+     * @param module The module being destroyed.
+     */
+    void ( *destructor )( struct picoif_module *module );
+
+    /*!
+     * Write method for the transport. This is used for writing userspace data
+     * into the transport. This function must be non-blocking and must return
+     * -EAGAIN if there is no space to write any data. If a higher layer
+     *  wishes to block then it can wait on the contexts write queue.
+     *
+     * @param module The module handling the transport.
+     * @param ctx The context that is writing the data.
+     * @param data The data to write.
+     * @param len The length of the data to write in bytes.
+     * @return Returns the number of bytes written on success, negative on
+     * failure.
+     */
+    ssize_t ( *write )( struct picoif_module *module,
+                        struct picoif_context *ctx,
+                        struct picoif_buf *data,
+                        size_t len );
+
+    /*!
+     * Read method for the transport. This is used for reading transport data
+     * into userspace. This function must be non-blocking and must return
+     * -EAGAIN if there is no data to be read. If a higher layer wishes to
+     * block then it can wait on the contexts read queue.
+     *
+     * @param module The module handling the transport.
+     * @param ctx The context that is reading the data.
+     * @param data The buffer to store the data in.
+     * @param len The length of the data to read in bytes.
+     * @return Returns the number of bytes read on success, negative on
+     * failure.
+     */
+    ssize_t ( *read )( struct picoif_module *module,
+                       struct picoif_context *ctx,
+                       struct picoif_buf *data,
+                       size_t len );
+
+    /*!
+     * Vectored write method for the transport. This is used for writing
+     * userspace data into the transport. This function must be non-blocking
+     * and must return -EAGAIN if there is no space to write any data. If a
+     * higher layer wishes to block then then can wait on the contexts write
+     * queue.
+     *
+     * Transports do not need to implement writev if there is no significant
+     * performance improvement by doing so. For example, a transport that
+     * simply reads from a FIFO in memory would gain little speedup, but a
+     * transport that writes into a FIFO before starting a DMA transfer could
+     * reduce the number of DMA transfers by writing the segments in one go.
+     *
+     * @param module The module handling the transport.
+     * @param ctx The context that is writing the data.
+     * @param vecs The vectors of data to write into the transport.
+     * @param nr_segs The number of entries in the IO vector.
+     * @param from_user Boolean flag to indicate that the vectors point to
+     * userspace buffers and must be copied across the address spaces.
+     * @return Returns the number of bytes written into the transport on
+     * success, negative on failure.
+     */
+    ssize_t ( *writev )( struct picoif_module *module,
+                         struct picoif_context *ctx,
+                         const struct iovec *vecs,
+                         unsigned nr_segs,
+                         int from_user );
+
+    /*!
+     * Vectored read method for the transport. This is used for reading data
+     * from the transport into userspace. This function must be non-blocking
+     * and must return -EAGAIN if there is no data to read. If a higher layer
+     * wishes to block then then can wait on the contexts read queue.
+     *
+     * Transports do not need to implement readv if there is no significant
+     * performance improvement by doing so. For example, a transport that
+     * simply reads from a FIFO in memory would gain little speedup, but a
+     * transport that DMAs into a FIFO on demand and then copies into the
+     * buffer could perform the transfers in one go.
+     *
+     * @param module The module handling the transport.
+     * @param ctx The context that is reading the data.
+     * @param vecs The vectors of data to read the transport data into.
+     * @param nr_segs The number of entries in the IO vector.
+     * @param from_user Boolean flag to indicate that the vectors point to
+     * userspace buffers and must be copied across the address spaces.
+     * @return Returns the number of bytes read from the transport on
+     * success, negative on failure.
+     */
+    ssize_t ( *readv )( struct picoif_module *module,
+                        struct picoif_context *ctx,
+                        const struct iovec *vecs,
+                        unsigned nr_segs,
+                        int to_user );
+
+    /*!
+     * Check if a write with the given context will not block.
+     *
+     * @param module The module the context belongs to.
+     * @param ctx The context being queuried.
+     * @return Returns 1 if the write will not block, 0 otherwise.
+     */
+    int ( *can_write )( struct picoif_module *module,
+                        struct picoif_context *ctx );
+
+    /*!
+     * Check if a read with the given context will not block.
+     *
+     * @param module The module the context belongs to.
+     * @param ctx The context being queuried.
+     * @return Returns 1 if the read will not block, 0 otherwise.
+     */
+    int ( *can_read )( struct picoif_module *module,
+                       struct picoif_context *ctx );
+};
+
+/*!
+ * \brief picoif transport module.
+ *
+ * This defines a picoif module used for implementing transport methods.
+ * A transport module may implement several transport methods using a common
+ * base. For example a HwIf module may implement HwIf uplink DMA and IrqMux
+ * interrupts. These should be combined in the same module as they share
+ * resources and implementation.
+ */
+struct picoif_module
+{
+    /*! The name of the module. */
+    const char                 *name;
+
+    /*! The operations for the module. */
+    struct picoif_module_ops   *ops;
+
+    /*! An array of transport method names. */
+    const char                 **tmethods;
+};
+
+#endif /* !__PICOIF_PICOIF_MODULE_H__ */
diff --git a/drivers/picochip/procif.c b/drivers/picochip/procif.c
new file mode 100644
index 0000000..e2da1cc
--- /dev/null
+++ b/drivers/picochip/procif.c
@@ -0,0 +1,182 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file procif.c
+ * \brief ProcIf access functions.
+ *
+ * This file implements functions for using the procif to configure and debug
+ * picoArray systems providing configuration bus access over the procif.
+ */
+
+#include <linux/types.h>
+#include <asm/io.h>
+#include <linux/spinlock.h>
+#include "debug.h"
+#include "procif.h"
+#include "picoif_internal.h"
+
+/* Configuration port write bit positions. */
+#define CAEID_BIT_MASK    ( 1 << 19 )    /*!< Bit 19 - AE ID signal. */
+#define CADDR_BIT_MASK    ( 1 << 18 )    /*!< Bit 18 - AE ADDR signal. */
+#define CREAD_BIT_MASK    ( 1 << 17 )    /*!< Bit 17 - READ data signal. */
+#define CWRITE_BIT_MASK   ( 1 << 16 )    /*!< Bit 16 - WRITE data signal. */
+
+#define RB_FAIL_MASK      ( 1 << 17 )    /*!< Bit 17 - readback failed. */
+#define RB_VALID_MASK     ( 1 << 16 )    /*!< Bit 16 - readback valid. */
+
+#define RETRIES ( 10 )                   /*!< The number of retries for a \
+                                          *   procif config read. */
+
+/*! Spinlock for procif accesses. We could have a spinlock for each procif,
+ *  but these operations are in the slow path and it is easier to have a
+ *  single lock and serialise all config accesses. */
+static spinlock_t procif_lock = SPIN_LOCK_UNLOCKED;
+
+int
+procif_config_read( void __iomem *procif_base,
+                    u16 aeid,
+                    u16 ae_addr,
+                    u16 *buf,
+                    u16 count )
+{
+    u32 val;
+    void __iomem *write_p = procif_base + PROCIF_REG_CFG_WR_OFFSET;
+    void __iomem *read_p = procif_base + PROCIF_REG_CFG_RD_OFFSET;
+    u16 to_read = count;
+    u16 rc;
+    unsigned i;
+    unsigned retries;
+    unsigned long flags;
+
+    PRINTD( COMPONENT_PROCIF, DBG_TRACE, "reading %u words from %04x@%04x",
+            count, aeid, ae_addr );
+
+    spin_lock_irqsave( &procif_lock, flags );
+
+    val = aeid | CAEID_BIT_MASK;
+    picoif_out32( val, write_p );
+    wmb();
+
+    while ( to_read )
+    {
+        /* Output the address to read from. */
+        val = ( ae_addr + ( count - to_read ) ) | CADDR_BIT_MASK;
+        picoif_out32( val, write_p );
+        wmb();
+
+        /* Dispatch the read requests. */
+        rc = ( to_read > 64 ) ? 64 : to_read;
+        val = CREAD_BIT_MASK;
+        for ( i = 0; i < rc; ++i )
+        {
+            picoif_out32( val, write_p );
+            wmb();
+        }
+
+        /* Now read the values. */
+        for ( i = 0; i < rc; ++i )
+        {
+            retries = RETRIES;
+            while ( retries )
+            {
+                val = picoif_in32( read_p );
+                if ( val & ( RB_VALID_MASK | RB_FAIL_MASK ) )
+                    break;
+                --retries;
+                rmb();
+            }
+
+            if ( !retries || ( val & RB_FAIL_MASK ) )
+            {
+                PRINTD( COMPONENT_PROCIF, DBG_ERROR,
+                        "config read %04x@%04x failed", aeid,
+                        ( ae_addr + ( count - to_read ) + i ) );
+                if ( !retries )
+                    PRINTD( COMPONENT_PROCIF, DBG_ERROR, "timed out" );
+
+                break;
+            }
+            else
+                buf[ ( count - to_read ) + i ] = val & 0xFFFF;
+        }
+
+        if ( val & RB_FAIL_MASK )
+            break;
+
+        to_read -= rc;
+    }
+
+    spin_unlock_irqrestore( &procif_lock, flags );
+
+    return !( val & RB_FAIL_MASK ) ? count : -EIO;
+}
+
+int
+procif_config_write( void __iomem *procif_base,
+                     u16 aeid,
+                     u16 ae_addr,
+                     u16 *buf,
+                     u16 count )
+{
+    u32 val;
+    void __iomem *write_p = procif_base + PROCIF_REG_CFG_WR_OFFSET;
+    unsigned i;
+    unsigned long flags;
+
+    PRINTD( COMPONENT_PROCIF, DBG_TRACE, "writing %u words to %04x@%04x",
+            count, aeid, ae_addr );
+
+    spin_lock_irqsave( &procif_lock, flags );
+
+    val = aeid | CAEID_BIT_MASK;
+    picoif_out32( val, write_p );
+    /* Flush the AEID request to comply with the procif protocol. */
+    wmb();
+
+    /* Output the address to read from. */
+    val = ae_addr | CADDR_BIT_MASK;
+    picoif_out32( val, write_p );
+    /* Flush the address request to comply with the procif protocol. */
+    wmb();
+
+    /* Now read the values. */
+    for ( i = 0; i < count; ++i )
+    {
+        val = buf[ i ] | CWRITE_BIT_MASK;
+        picoif_out32( val, write_p );
+    }
+
+    spin_unlock_irqrestore( &procif_lock, flags );
+
+    return i;
+}
+
+int
+procif_reg_write( void __iomem *base,
+                  unsigned offset,
+                  u32 value )
+{
+    picoif_out32( value, base + offset );
+    return 0;
+}
+
+int
+procif_reg_read( void __iomem *base,
+                 unsigned offset,
+                 u32 *value )
+{
+    *value = picoif_in32( base + offset );
+    return 0;
+}
diff --git a/drivers/picochip/procif.h b/drivers/picochip/procif.h
new file mode 100644
index 0000000..34b4f8e
--- /dev/null
+++ b/drivers/picochip/procif.h
@@ -0,0 +1,95 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file procif.h
+ * \brief ProcIf access functions.
+ *
+ * This file provides a set of functions for using the procif in picoArray
+ * devices and should be used to implement the device files for devices that
+ * contain a procif.
+ *
+ */
+
+#ifndef __PICOIF_PROCIF_H__
+#define __PICOIF_PROCIF_H__
+
+/*! Register offset for the config bus read port. */
+#define PROCIF_REG_CFG_RD_OFFSET   ( 0x78 )
+
+/*! Register offset for the config bus write port. */
+#define PROCIF_REG_CFG_WR_OFFSET   ( 0x7C )
+
+/*! The offset of the ITM register in the procif. */
+#define PC202_PROCIF_ITM_OFFSET    ( 0x70 )
+
+/*!
+ * Read a number of 16 bit words from a picoArray procif.
+ *
+ * @param procif_base The base address of the procif.
+ * @param aeid The CAEID of the AE to read from.
+ * @param ae_addr The address to begin reading from within the AE.
+ * @param[out] buf The buffer to store the results in.
+ * @param count The number of 16 bit words to read.
+ * @return Returns the number of words read on success, negative on failure.
+ */
+int procif_config_read( void __iomem *procif_base,
+                        u16 aeid,
+                        u16 ae_addr,
+                        u16 *buf,
+                        u16 count );
+
+/*!
+ * Write a number of 16 bit words to a picoArray procif.
+ *
+ * @param procif_base The base address of the procif.
+ * @param aeid The CAEID of the AE to write to.
+ * @param ae_addr The address to begin writing to within the AE.
+ * @param[in] buf The buffer to read the words from.
+ * @param count The number of 16 bit words to write.
+ * @return Returns the number of words written on success, negative on failure.
+ */
+int procif_config_write( void __iomem *procif_base,
+                         u16 aeid,
+                         u16 ae_addr,
+                         u16 *buf,
+                         u16 count );
+
+/*!
+ * Write a register in the procif.
+ *
+ * @param base The I/O memory base address of the procif.
+ * @param offset The offset of the register in bytes.
+ * @param value The value of the register to write.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+procif_reg_write( void __iomem *base,
+                  unsigned offset,
+                  u32 value );
+
+/*!
+ * Read a register in the procif.
+ *
+ * @param base The I/O memory base address of the procif.
+ * @param offset The offset of the register in bytes.
+ * @param[out] value The address to store the register value in.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+procif_reg_read( void __iomem *base,
+                 unsigned offset,
+                 u32 *value );
+
+#endif /* __PICOIF_PROCIF_H__ */
diff --git a/drivers/picochip/resource.c b/drivers/picochip/resource.c
new file mode 100644
index 0000000..39c5d50
--- /dev/null
+++ b/drivers/picochip/resource.c
@@ -0,0 +1,103 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file resource.c
+ * \brief Generic resource acquisition/release functions.
+ *
+ * This file implements functions for requesting and putting picoArray
+ * resources where no extra behaviour other than getting/releasing the
+ * resource is required. This should be sufficient for almost all devices.
+ */
+
+#include "picoarray.h"
+#include "resource.h"
+
+/*!
+ * Get a resource from a picoArray device. For most devices, this should be
+ * sufficient, but if there are any corner cases for a device, this function
+ * may be overridden.
+ *
+ * @param pa The device to acquire the resource from.
+ * @param type The type of resource to acquire.
+ * @param value The resource ID to acquire.
+ * @param exclusive Boolean flag to indicate that exclusive access is required
+ * to the resource.
+ * @return Returns zero on success, non-zero on failure.
+ */
+struct pico_resource *
+generic_get_resource( struct picoarray *pa,
+                      enum pico_resource_type type,
+                      unsigned value,
+                      int exclusive )
+{
+    struct pico_resource *tmp = pa->resources;
+    int ret = 1;
+    struct pico_resource *resource = NULL;
+
+    spin_lock( &pa->lock );
+
+    /* The end of the array should be marked with all zero's. */
+    while ( tmp->type || tmp->value || tmp->exclusive )
+    {
+        /* This is the resource. */
+        if ( tmp->type == type && tmp->value == value )
+        {
+            if ( exclusive && !tmp->exclusive )
+            {
+                tmp->exclusive = 1;
+                ret = 0;
+            }
+            if ( !exclusive && !tmp->exclusive )
+                ret = 0;
+
+            if ( !ret )
+            {
+                resource = tmp;
+                atomic_inc( &tmp->ref_count );
+                break;
+            }
+        }
+
+        ++tmp;
+    }
+
+    spin_unlock( &pa->lock );
+
+    return resource;
+}
+
+/*!
+ * Decrement the reference count of a resource.
+ *
+ * @param dev The device the resource belongs to.
+ * @param resource The resource to put.
+ */
+void
+generic_put_resource( struct picoarray *dev,
+                      struct pico_resource *resource )
+{
+    spin_lock( &dev->lock );
+
+    if ( 0 == atomic_read( &resource->ref_count ) )
+        goto out;
+
+    if ( resource->exclusive )
+        resource->exclusive = 0;
+
+    atomic_dec( &resource->ref_count );
+
+out:
+    spin_unlock( &dev->lock );
+}
diff --git a/drivers/picochip/resource.h b/drivers/picochip/resource.h
new file mode 100644
index 0000000..a61a345
--- /dev/null
+++ b/drivers/picochip/resource.h
@@ -0,0 +1,37 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file resource.h
+ * \brief Generic resource get and put functions.
+ *
+ * Generic device resource managing functions
+ */
+
+#ifndef __PICOIF_RESOURCE_H__
+#define __PICOIF_RESOURCE_H__
+
+#include "picoarray.h"
+
+struct pico_resource *
+generic_get_resource( struct picoarray *pa,
+                      enum pico_resource_type type,
+                      unsigned value,
+                      int exclusive );
+
+void
+generic_put_resource( struct picoarray *dev,
+                      struct pico_resource *resource );
+
+#endif /* !__PICOIF_RESOURCE_H__ */
diff --git a/drivers/picochip/soft_reset.c b/drivers/picochip/soft_reset.c
new file mode 100644
index 0000000..c8a386a
--- /dev/null
+++ b/drivers/picochip/soft_reset.c
@@ -0,0 +1,638 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2006-2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file soft_reset.h
+ * \brief Perform a software reset of the picoArray on PC202/PC205
+ */
+
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include "soft_reset.h"
+#include "soft_reset_memif.h"
+
+static void __iomem *procif_base;
+static void __iomem *ahb2pico_base;
+
+#define CONFIG_READ_OFFSET                0x78
+#define CONFIG_WRITE_OFFSET               0x7c
+
+#define CAEID_AHB                         0x0008
+#define CAEID_MEMIF                       0x0028
+#define CAEID_PROCIF                      0x0048
+#define PA_CONFIG_WRITE                   0x00010000
+#define PA_CONFIG_READ                    0x00020000
+#define PA_CONFIG_ADDR                    0x00040000
+#define PA_CONFIG_AEID                    0x00080000
+#define PA_CONFIG_VALID                   0x00010000
+#define PA_RUN_STEP_REQUEST_REG           0x4018
+
+#define AHBIF_CONFIG_REG                  0x0
+#define AHBIF_STATUS_REG                  0x4
+#define AHBIF_DATA_REG                    0x8
+
+#define MEMIF_BUFFERS                     6
+#define MEMIF_EMPTY_CAEID                 0x2c28
+#define OTHER_CTRL_CAEID                  0x2088
+
+#define AHB2PICO_VP_DIR_MASK              0x00000002
+#define AHB2PICO_VP_DIR_IS_TX             0x00000000
+#define AHB2PICO_VP_DIR_IS_RX             0x00000002
+#define AHB2PICO_VP_SNGL_MASK             0x00000800
+#define AHB2PICO_VP_STATE_MASK            0x00000008
+#define AHB2PICO_VP_LEVEL_MASK            0x000007f0
+
+#define SDGPIO_BASE 0x9800
+#define SDGPIO_PINS 32
+#define SDGPIO_REG_CONFIG(pin)            (SDGPIO_BASE + (pin * 4))
+#define SDGPIO_REG_AVALUE(pin)            (SDGPIO_BASE + (pin * 4) + 1)
+#define SDGPIO_REG_ARATE(pin)             (SDGPIO_BASE + (pin * 4) + 2)
+#define SDGPIO_REG_GROUP                  (SDGPIO_BASE + 0x86)
+
+#define DMA_REG_THRESHOLD(dma)            (dma * 4 + 1)
+#define DMA_REG_DREQ(dma)                 (dma * 4 + 2)
+#define DMA_REG_POINTER(dma)              (dma * 4 + 3)
+
+static inline void reset_out32(void __iomem *base, u32 offset, u32 value)
+{
+    iowrite32(value, base + offset);
+}
+
+static inline u32 reset_in32(void __iomem *base, u32 offset)
+{
+    return ioread32(base + offset);
+}
+
+/*!
+ * Read data from the config bus
+ *
+ * \param caeid The AEID to select
+ * \param addr The address to start reading from
+ * \param buf[out] The buffer to write the data to
+ * \param len The number of u16 words to read
+ * \return 0 on success, -1 on failure
+ */
+static int config_read_data (u16 caeid, u16 addr, u16 *buf, u16 len)
+{
+    u32 data;
+    int i;
+
+    reset_out32(procif_base, CONFIG_WRITE_OFFSET, PA_CONFIG_AEID | caeid);
+    reset_out32(procif_base, CONFIG_WRITE_OFFSET, PA_CONFIG_ADDR | addr);
+    for (i = 0; i < len; ++i)
+    {
+        reset_out32(procif_base, CONFIG_WRITE_OFFSET, PA_CONFIG_READ);
+        do
+        {
+            data = reset_in32(procif_base, CONFIG_READ_OFFSET);
+        }
+        while (!data);
+
+        if (data & PA_CONFIG_VALID)
+            buf[i] = (u16)(data & 0xffff);
+        else
+            return -1;
+    }
+
+    return 0;
+}
+
+/*!
+ * Read a single word of data from the config bus
+ *
+ * \param caeid The AEID to select
+ * \param addr The address to read
+ * \return The 16-bit data read from the picoArray
+ */
+static u16 config_read_word (u16 caeid, u16 addr)
+{
+    u32 data;
+
+    reset_out32(procif_base, CONFIG_WRITE_OFFSET, PA_CONFIG_AEID | caeid);
+    reset_out32(procif_base, CONFIG_WRITE_OFFSET, PA_CONFIG_ADDR | addr);
+    reset_out32(procif_base, CONFIG_WRITE_OFFSET, PA_CONFIG_READ);
+    do
+    {
+        data = reset_in32(procif_base, CONFIG_READ_OFFSET);
+    }
+    while (!data);
+
+    if (data & PA_CONFIG_VALID)
+        return (u16)(data & 0xffff);
+
+    pr_err("softreset: read failure, caeid: 0x%04x addr 0x%04x\n", caeid, addr);
+    return 0;
+}
+
+/*!
+ * Write a single 16-bit word of data to the config bus
+ *
+ * \param caeid The AEID to select
+ * \param addr The address to write to
+ * \param data The data to write
+ */
+static void config_write_word (u16 caeid, u16 addr, u16 data)
+{
+    reset_out32(procif_base, CONFIG_WRITE_OFFSET, PA_CONFIG_AEID | caeid);
+    reset_out32(procif_base, CONFIG_WRITE_OFFSET, PA_CONFIG_ADDR | addr);
+    reset_out32(procif_base, CONFIG_WRITE_OFFSET, PA_CONFIG_WRITE | data);
+}
+
+/*!
+ * Write a stream of configuration port data into the picoArray
+ *
+ * \param buf A buffer of u32 data items to write into the config port
+ * \param len The number of u32 data items in buf
+ */
+static void config_stream_write (const u32 *buf, u16 len)
+{
+    int i;
+
+    for (i = 0; i < len; ++i)
+        reset_out32(procif_base, CONFIG_WRITE_OFFSET, buf[i]);
+}
+
+/*!
+ * Start the picoArray
+ */
+static void reset_run_system (void)
+{
+    config_write_word (CAEID_PROCIF, PA_RUN_STEP_REQUEST_REG, 2);
+}
+
+/*!
+ * Stop the picoArray
+ */
+static void reset_stop_system (void)
+{
+    config_write_word(CAEID_PROCIF, PA_RUN_STEP_REQUEST_REG, 0);
+}
+
+/*!
+ * Reset just the hardware ports of an AE
+ *
+ * \param caeid The CAEID of the AE to reset
+ */
+static void reset_ae_hwp (u16 caeid)
+{
+    config_write_word(caeid, 0xa065, 2);
+    config_write_word(caeid, 0xa063, 1);
+    udelay(10);
+    config_write_word(caeid, 0xa063, 0);
+    config_write_word(caeid, 0xa065, 3);
+}
+
+/*!
+ * Reset all AEs except for the ProcIf, MemIf and AHB2pico. We can't just reset
+ * these ones because there is no there is no synchronisation between the
+ * domains and it would kill the ARM, so just reset their HWPs. Send them to
+ * sleep after they are reset.
+ */
+static void reset_programmable_aes (void)
+{
+    config_write_word(0xef9f, 0xa063, 1);
+    udelay(10);
+    config_write_word(0xef9f, 0xa063, 0);
+    udelay(10);
+    /* Reset all other HWPs */
+    reset_ae_hwp(CAEID_MEMIF);
+    reset_ae_hwp(CAEID_AHB);
+    reset_ae_hwp(CAEID_PROCIF);
+    /* Put all AEs except the ProcIf to sleep */
+    config_write_word(0xffbf, 0xa060, 1);
+}
+
+/*!
+ * Write data into the ProcIf, decode region 0
+ *
+ * \param regNum The register number to write to (pad_ebi_addr[6:0]/4)
+ * \param value The data to write
+ */
+static void write_procif_data(u8 regNum, u32 value)
+{
+    reset_out32(procif_base, regNum * 4, value);
+}
+
+/*!
+ * Read data from the ProcIf, decode region 0
+ *
+ * \param regNum The register number to read (pad_ebi_addr[6:0]/4)
+ * \return The data in that register
+ */
+static u32 read_procif_data (u8 regNum)
+{
+    return reset_in32(procif_base, regNum * 4);
+}
+
+/*!
+ * Write a value into an AHB2pico GPR or DMA register
+ *
+ * \param vp The VP number of the DMA or GPR
+ * \param offset The offset from the start of the VP registers
+ * \param value The value to write to the register
+ */
+static void set_ahb_vp_register (u8 vp, u8 offset, u32 value)
+{
+    reset_out32(ahb2pico_base, (vp<<4) + offset, value);
+}
+
+/*!
+ * Read a DMA or GPR register from the AHB2pico.
+ *
+ * \param vp The VP of the DMA or GPR to read
+ * \param offset The offset from the start of the VP registers
+ * \return The data from the register
+ */
+static u32 get_ahb_vp_register (u8 vp, u8 offset)
+{
+    return reset_in32(ahb2pico_base, (vp<<4) + offset);
+}
+
+/*!
+ * From the VP (DMAC[0:3], GPR[0:24]) return the HWP instance and signal port
+ * number. This mapping is in section 3 of the ahb2pico specs.
+ *
+ * \param vp The virtual port
+ * \param hwp[out] The HWP instance the VP is on
+ * \param signal[out] The signal port number
+ */
+static void map_vp2hwp (u8 vp, u8 *hwp, u8 *signal)
+{
+    if(vp < 2 ) {
+        *hwp = 0;
+        *signal = vp;
+    } else if(vp < 4) {
+        *hwp = 1;
+        *signal = vp + 11;
+    } else if(vp < 17) {
+        *hwp = 0;
+        *signal = vp - 2;
+    } else {
+        *hwp = 1;
+        *signal = vp - 17;
+    }
+}
+
+/*!
+ * Get the ConfigLow register of a HWP
+ *
+ * \param caeid The CAEID
+ * \param port The HWP number to read the config value of
+ * \param inst The HWP block instance the port is on
+ * \return The 16-bit value of the register
+ */
+static u16 get_hwp_config_low (u16 caeid, u8 port, u8 inst)
+{
+    unsigned int port_address = 0x9000 + (port<< 3) + (inst<< 8);
+
+    return config_read_word(caeid, port_address);
+}
+
+/*!
+ * Set a HWP ConfigLow register
+ *
+ * \param caeid The CAEID
+ * \param port The HWP number to set
+ * \param inst The HWP block instance the port is on
+ * \param value The new value of the ConfigLow register
+ */
+static void set_hwp_config_low (u16 caeid, u8 port, u8 inst, u16 value)
+{
+    unsigned int hwp_address = 0x9000 + (port << 3) + (inst << 8);
+    config_write_word(caeid, hwp_address, value);
+}
+
+/*!
+ * Set a HWP to non-blocking
+ *
+ * \param caeid The CAEID
+ * \param port The HWP number to set
+ * \param inst The HWP block instance the port is on
+ */
+static void set_hwp_nonblocking(u16 caeid, u8 port, u8 inst)
+{
+    u16 config_low = get_hwp_config_low(caeid, port, inst);
+    config_low |= 5; /* Non-blocking, Right bus enabled */
+    set_hwp_config_low(caeid, port, inst, config_low);
+}
+
+/*!
+ * Disable a HWP
+ *
+ * \param caeid The CAEID
+ * \param port The HWP number to disable
+ * \param inst The HWP block instance the port is on
+ */
+static void disable_hwp (u16 caeid, u8 port, u8 inst)
+{
+    u16 config_low = get_hwp_config_low(caeid, port, inst);
+    config_low &= ~(3); /* Clear PortEnable */
+    set_hwp_config_low(caeid, port, inst, config_low);
+}
+
+/*!
+ * Reset the AHB2pico
+ */
+static void reset_ahb2pico (int print_errors)
+{
+    u32 data, fifo_level;
+    u8 vp, pin, hwp, signal;
+
+    /* For each DMA VP check the 'single' bit of the status register and read out
+     * data if it is set. This bit is used rather than the 'state' bit since there
+     * might not be a full block in the DMA.  */
+    for (vp = 0; vp < 4 ; ++vp )
+    {
+        data = get_ahb_vp_register(vp, AHBIF_STATUS_REG);
+        if ((data & AHB2PICO_VP_DIR_MASK) == AHB2PICO_VP_DIR_IS_RX)
+            while (data & AHB2PICO_VP_SNGL_MASK)
+            {
+                (void)get_ahb_vp_register(vp, AHBIF_DATA_REG);
+                data = get_ahb_vp_register(vp, AHBIF_STATUS_REG);
+            }
+    }
+
+    /* For each GPR VP check the 'state' bit of the status register and read out
+     * data if it is set. Don't do number 29 since this is the fuse.  */
+    for (vp = 4; vp < 29 ; ++vp )
+    {
+        data = get_ahb_vp_register(vp, AHBIF_STATUS_REG);
+        if ((data & AHB2PICO_VP_DIR_MASK) == AHB2PICO_VP_DIR_IS_RX)
+            while (data & AHB2PICO_VP_STATE_MASK)
+            {
+                (void)get_ahb_vp_register(vp, AHBIF_DATA_REG);
+                data = get_ahb_vp_register(vp, AHBIF_STATUS_REG);
+            }
+    }
+
+    /* All VPs, whether DMA or GPR can be drained the same way on the pA side.
+     * Read the status register to find out the port direction:
+     *   AHB->pA: set to non-blocking to drain data
+     *   pA->AHB: disable so new new data can get added */
+    for (vp = 0; vp < 29 ; vp++ )
+    {
+        map_vp2hwp(vp, &hwp, &signal);
+        data = get_ahb_vp_register(vp, AHBIF_STATUS_REG);
+        if ((data & AHB2PICO_VP_DIR_MASK) == AHB2PICO_VP_DIR_IS_TX)
+            set_hwp_nonblocking(CAEID_AHB, signal, hwp);
+        else
+            disable_hwp(CAEID_AHB, signal, hwp);
+    }
+
+    /* This runs the currently loaded design for a short while because we can't
+     * just run the AHB2pico. Make sure the currently loaded design can't harm
+     * anything */
+    config_write_word(0xffbf, 0xa060, 1);
+    reset_run_system();
+    reset_stop_system();
+
+    /* Check the DMA FIFO fill levels are correct - all the data has been drained
+     * out. A TX DMA should have space for 64 writes and an RX should contain no
+     * data */
+    for (vp = 0; vp < 4 ; vp++ ) {
+      data = get_ahb_vp_register(vp, AHBIF_STATUS_REG);
+      fifo_level = (data & AHB2PICO_VP_LEVEL_MASK) >> 4;
+      if ((data & AHB2PICO_VP_DIR_MASK) == AHB2PICO_VP_DIR_IS_TX)
+      {
+          if(fifo_level != 64)
+              if (print_errors)
+                  pr_err("softreset: error resetting DMA%d TX FIFO (%d)\n", vp,
+                         fifo_level);
+      }
+      else if (fifo_level != 0)
+      {
+          if (print_errors)
+              pr_err("softreset: error resetting DMA%d RX FIFO (%d)\n", vp,
+                     fifo_level);
+      }
+    }
+
+    reset_ae_hwp(CAEID_AHB);
+
+    /* Set all AHB-side registers to post-reset values */
+    for (vp = 0; vp < 29 ; vp++ )
+        set_ahb_vp_register(vp, AHBIF_CONFIG_REG, 0x00000000);
+
+    /* Reset all of the picoArray controlled SD-GPIO pins to their reset values.
+     * Some pins may be controlled by the ARM and we should leave those alone */
+    for (pin = 0; pin < SDGPIO_PINS; ++pin)
+    {
+        data = config_read_word(CAEID_AHB, SDGPIO_REG_CONFIG(pin));
+        if (!(data & 0x8000))
+            continue; /* Skip if Control Source bit is 0 (config controlled) */
+        config_write_word(CAEID_AHB, SDGPIO_REG_CONFIG(pin), 0x000f);
+        config_write_word(CAEID_AHB, SDGPIO_REG_AVALUE(pin), 0x0000);
+        config_write_word(CAEID_AHB, SDGPIO_REG_ARATE(pin), 0x0000);
+    }
+
+    /* Reset picoBus grouping of pins */
+    config_write_word(CAEID_AHB, SDGPIO_REG_GROUP, 0x0000);
+}
+
+/*!
+ * Reset the MemIf and GprSrc registers. This must be done from inside the
+ * picoArray.
+ */
+static int reset_memif_gpr (void)
+{
+    int buffer, i, ertc_moved = 0;
+    s32 data;
+    u16 activeBuffers = 0, ertc_start[4], ertc_end[4];
+
+    /* Wakeup the MemIf */
+    config_write_word(CAEID_MEMIF, 0xa060, 0);
+
+    /* Determine which MEMIF buffers are in use by the current pA design */
+    for (buffer = 0; buffer < MEMIF_BUFFERS; ++buffer)
+    {
+        data = config_read_word(CAEID_MEMIF, buffer * 0x0004);
+        if ((data & 0x000f) != 0x0000)
+            activeBuffers |= (1 << buffer);
+    }
+
+    /* Reset the HWPs and clear error flags in the ProcIf*/
+    reset_ae_hwp(CAEID_MEMIF);
+    config_write_word(CAEID_PROCIF, 0xa030, 0);
+    config_write_word(CAEID_PROCIF, 0xa031, 0);
+    config_write_word(CAEID_PROCIF, 0xa032, 0);
+
+    /* Load the config file and set r9 to the active buffers */
+    config_stream_write(soft_reset_memif, (sizeof(soft_reset_memif)/4));
+    config_write_word(MEMIF_EMPTY_CAEID, 0xa009, activeBuffers);
+    data = config_read_word(MEMIF_EMPTY_CAEID, 0xa060);
+    if (data != 0)
+        pr_err("softreset: incorrect MEMIF CAEID\n");
+    data = config_read_word(OTHER_CTRL_CAEID, 0xa060);
+    if (data != 1)
+        pr_err("softreset: incorrect MEMIF CAEID\n");
+
+    /* Get the ERTC so we can check it ran, then start it */
+    if (config_read_data(CAEID_PROCIF, 0x4008, ertc_start, 4) == -1)
+        pr_err("softreset: failed to read ERTC\n");
+    reset_run_system();
+
+    /* Give the picoArray some time to get started. Otherwise the operation
+     * status register might not have been updated and we disable the MemIf
+     * buffers while the design is still running. */
+    udelay(10);
+
+    /* wait for the picoArray to stop */
+    do
+    {
+        data = config_read_word(CAEID_PROCIF, 0x401c);
+    }
+    while (data & 2);
+
+    if (config_read_data(CAEID_PROCIF, 0x4008, ertc_end, 4) == -1)
+        pr_err("softreset: failed to read ERTC\n");
+
+    for (i = 0; i < 4; ++i)
+        ertc_moved |= (ertc_start[i] != ertc_end[i]);
+    if (!ertc_moved)
+        pr_err("softreset: picoArray didn't run correctly\n");
+
+    /* Return buffer config registers to their reset value*/
+    for (buffer = 0; buffer < 6; ++buffer)
+    {
+        config_write_word(CAEID_MEMIF, 4 * buffer, 0x0000);
+        config_write_word(CAEID_MEMIF, 1 + 4 * buffer, 0x0000);
+        config_write_word(CAEID_MEMIF, 2 + 4 * buffer, 0x0000);
+    }
+    config_write_word(CAEID_MEMIF, 0x80, 0);
+
+    /* Reset the HWPs */
+    reset_ae_hwp(CAEID_MEMIF);
+
+    return 0;
+}
+
+/*!
+ * Reset the ProcIf. Drain GprSinks, drain DMAs
+ */
+static void reset_procif (void)
+{
+    int gpr, addr, dma, reads;
+
+    /* Configuration bus stuff */
+    config_write_word(CAEID_PROCIF, 0x5020, 0x0000); /*AutoBurstPacing*/
+
+    /* SyncIf stuff */
+    config_write_word(CAEID_PROCIF, 0x4010, 0x0004); /*SyncRetimeOffset*/
+    config_write_word(CAEID_PROCIF, 0x4014, 0x0000); /*DebugMode*/
+    config_write_word(CAEID_PROCIF, 0x4020, 0x0000); /*StartUpOffset*/
+
+    /* Generic AE stuff */
+    config_write_word(CAEID_PROCIF, 0xa062, 0x0000); /*ErrorRegistor*/
+    config_write_word(CAEID_PROCIF, 0xa038, 0x0000); /*ErrorMaskLow*/
+    config_write_word(CAEID_PROCIF, 0xa039, 0x0000); /*ErrorMaskMid*/
+    config_write_word(CAEID_PROCIF, 0xa03A, 0x0000); /*ErrorMaskHigh*/
+    config_write_word(CAEID_PROCIF, 0xa030, 0x0000); /*ErrorFlagsLow*/
+    config_write_word(CAEID_PROCIF, 0xa031, 0x0000); /*ErrorFlagsMid*/
+    config_write_word(CAEID_PROCIF, 0xa032, 0x0000); /*ErrorFlagsHigh*/
+
+    /* IRQ stuff */
+    config_write_word(CAEID_PROCIF, 0x0024, 0x00ff); /*IRQMode&Pulse*/
+
+    /*  Turn each GPR into a blocking input port */
+    for (addr = 0x9000; addr < 0x90d0; addr += 0x8)
+    {
+        if (addr == 0x9068 || 0x9070)
+            continue; /* Skip DMA HWPs */
+        config_write_word(CAEID_PROCIF, addr, 0x0003);
+        config_write_word(CAEID_PROCIF, addr+1, 0x0011);
+    }
+
+    /* Run just the ProcIf */
+    config_write_word(CAEID_PROCIF, 0xa061, 0x0002);
+
+    /* Read out the contents of each GPR (four times) to empty it. Also empty the
+     * ITS register */
+    for (gpr = 0; gpr < 30; gpr++)
+    {
+        if (gpr == 20 || gpr == 22 || gpr == 24 || gpr == 26)
+            continue; /* Skip the DMA registers in decode region 0 */
+        if (gpr == 28)
+            continue; /* Skip the ITM register in decode region 0 */
+        for(reads = 0; reads < 4; reads++)
+            read_procif_data(gpr);
+    }
+
+    /* Set the value of ITM to zero*/
+    write_procif_data(28, 0x00000000);
+
+    /* Stop the ProcIf */
+    config_write_word(CAEID_PROCIF, 0xa061, 0x0000);
+
+    /* DMA stuff */
+    for (dma = 0; dma < 5; ++dma)
+    {
+        config_write_word(CAEID_PROCIF, DMA_REG_DREQ(dma), 0x0000);
+        config_write_word(CAEID_PROCIF, DMA_REG_THRESHOLD(dma), 0x1000);
+        config_write_word(CAEID_PROCIF, DMA_REG_POINTER(dma), 0x0000);
+    }
+    config_write_word(CAEID_PROCIF, 0x0309, 0x0004); /*GlobalDREQSettings*/
+    config_write_word(CAEID_PROCIF, 0xa032, 0x0000); /*ErrorFlagsMid*/
+
+    reset_ae_hwp(CAEID_PROCIF);
+
+    /* External interface registers */
+    config_write_word(CAEID_PROCIF, 0x0028, 0x0000); /*Acc2First*/
+    config_write_word(CAEID_PROCIF, 0x002a, 0x0000); /*Acc2Next*/
+    config_write_word(CAEID_PROCIF, 0x002b, 0x0000); /*ConfigPortMode*/
+
+    /* Fuses */
+    config_write_word(CAEID_PROCIF, 0x0034, 0x0000); /*RowFuse*/
+    config_write_word(CAEID_PROCIF, 0x0035, 0x0000); /*Site3DisableFuse*/
+
+    /* Sleep */
+    config_write_word(CAEID_PROCIF, 0xa060, 0x0001);
+}
+
+/*!
+ * Reset just the picoArray part of firecracker
+ */
+void picoArraySoftReset (void __iomem *procif,
+                         void __iomem *ahb)
+{
+    procif_base = (void __iomem *)procif;
+    ahb2pico_base = (void __iomem *)ahb;
+
+    /* soft reset the AHB2Pico - don't print errors */
+    reset_ahb2pico(0);
+
+    /* soft reset the picoArray without the AHB2Pico - must be done after
+     * AHB2Pico to prevent rogue data getting transfered */
+    reset_programmable_aes();
+
+    /* soft reset the MemIf and GPRs */
+    reset_memif_gpr();
+
+    /* soft reset the AHB2Pico - print errors */
+    reset_ahb2pico(1);
+
+    /* soft reset the PROCIF - do this last so the pA is not run, otherwise
+     * rogue data will end up in the HWPs */
+    reset_procif();
+
+    /* soft reset the picoArray without the AHB2Pico - must be done after
+     * AHB2Pico to prevent rogue data getting transfered */
+    reset_programmable_aes();
+
+    /* Wake the AHB2Pico block - must be done so that the GPIO driver
+     * can keep running without losing access to this block */
+   config_write_word(CAEID_AHB, 0xa060, 0x0000); 
+}
diff --git a/drivers/picochip/soft_reset.h b/drivers/picochip/soft_reset.h
new file mode 100644
index 0000000..0e4086a
--- /dev/null
+++ b/drivers/picochip/soft_reset.h
@@ -0,0 +1,31 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2006 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file soft_reset.h
+ * \brief Header for performing a software reset of the picoArray
+ */
+
+#ifndef __PICOIF_SOFT_RESET_H__
+#define  __PICOIF_SOFT_RESET_H__
+
+/*!
+ * Perform a soft reset of the picoArray.
+ *
+ * @param procif_base The base address of the procif of the device to reset.
+ * @param ahb_base The base address of the AHB2Pico of the device to reset.
+ */
+void picoArraySoftReset (void __iomem *procif_base, void __iomem *ahb_base );
+
+#endif /* __PICOIF_SOFT_RESET_H__ */
diff --git a/drivers/picochip/soft_reset_memif.h b/drivers/picochip/soft_reset_memif.h
new file mode 100644
index 0000000..6366a92
--- /dev/null
+++ b/drivers/picochip/soft_reset_memif.h
@@ -0,0 +1,11791 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file soft_reset_memif.h
+ * \brief Header for performing a software reset of the picoArray MemIf
+ */
+
+#ifndef __PICOIF_SOFT_RESET_MEMIF_H__
+#define  __PICOIF_SOFT_RESET_MEMIF_H__
+
+static const unsigned int soft_reset_memif [] = {
+  0x00082048, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00049000, // CADDR
+  0x00010042, // CDATA
+  0x000101F0, // CDATA
+  0x00049008, // CADDR
+  0x00010052, // CDATA
+  0x000101F0, // CDATA
+  0x00049010, // CADDR
+  0x00010062, // CDATA
+  0x000101F0, // CDATA
+  0x00049018, // CADDR
+  0x00010072, // CDATA
+  0x000101F0, // CDATA
+  0x00049020, // CADDR
+  0x00010082, // CDATA
+  0x000101F0, // CDATA
+  0x00049028, // CADDR
+  0x00010092, // CDATA
+  0x000101F0, // CDATA
+  0x00049030, // CADDR
+  0x000100A2, // CDATA
+  0x000101F0, // CDATA
+  0x00049038, // CADDR
+  0x000100B2, // CDATA
+  0x000101F0, // CDATA
+  0x00049040, // CADDR
+  0x000100C2, // CDATA
+  0x000101F0, // CDATA
+  0x00049048, // CADDR
+  0x000100D2, // CDATA
+  0x000101F0, // CDATA
+  0x00049050, // CADDR
+  0x00010041, // CDATA
+  0x000101F0, // CDATA
+  0x00049058, // CADDR
+  0x00010051, // CDATA
+  0x000101F0, // CDATA
+  0x00049060, // CADDR
+  0x00010061, // CDATA
+  0x000101F0, // CDATA
+  0x00049068, // CADDR
+  0x000100F2, // CDATA
+  0x000101F0, // CDATA
+  0x00049070, // CADDR
+  0x000100E2, // CDATA
+  0x000101F0, // CDATA
+  0x00049078, // CADDR
+  0x000100D2, // CDATA
+  0x000101F0, // CDATA
+  0x00049080, // CADDR
+  0x00010132, // CDATA
+  0x000101F0, // CDATA
+  0x00049088, // CADDR
+  0x00010122, // CDATA
+  0x000101F0, // CDATA
+  0x00049090, // CADDR
+  0x00010112, // CDATA
+  0x000101F0, // CDATA
+  0x00049098, // CADDR
+  0x00010102, // CDATA
+  0x000101F0, // CDATA
+  0x000490A0, // CADDR
+  0x000100F2, // CDATA
+  0x000101F0, // CDATA
+  0x000490A8, // CADDR
+  0x000100E2, // CDATA
+  0x000101F0, // CDATA
+  0x000490B0, // CADDR
+  0x000100C2, // CDATA
+  0x000101F0, // CDATA
+  0x000490B8, // CADDR
+  0x000100B2, // CDATA
+  0x000101F0, // CDATA
+  0x000490C0, // CADDR
+  0x000100A2, // CDATA
+  0x000101F0, // CDATA
+  0x000490C8, // CADDR
+  0x00010092, // CDATA
+  0x000101F0, // CDATA
+  0x000490E0, // CADDR
+  0x00010082, // CDATA
+  0x000101F0, // CDATA
+  0x000490E8, // CADDR
+  0x00010072, // CDATA
+  0x000101F0, // CDATA
+  0x00040001, // CADDR
+  0x00010100, // CDATA
+  0x00018000, // CDATA
+  0x00040005, // CADDR
+  0x00010100, // CDATA
+  0x00018000, // CDATA
+  0x00040009, // CADDR
+  0x00010100, // CDATA
+  0x00018000, // CDATA
+  0x0004000D, // CADDR
+  0x00010100, // CDATA
+  0x00018000, // CDATA
+  0x00040024, // CADDR
+  0x00010000, // CDATA
+  0x00040028, // CADDR
+  0x00010000, // CDATA
+  0x0004002A, // CADDR
+  0x00010000, // CDATA
+  0x00040309, // CADDR
+  0x00010002, // CDATA
+  0x00044014, // CADDR
+  0x00010003, // CDATA
+  0x00045020, // CADDR
+  0x00010000, // CDATA
+  0x0004A038, // CADDR
+  0x00011FFF, // CDATA
+  0x000107FF, // CDATA
+  0x00010FFF, // CDATA
+  0x00082028, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100F1, // CDATA
+  0x00040002, // CADDR (gen)
+  0x00010000, // CDATA
+  0x00040004, // CADDR
+  0x000100F1, // CDATA
+  0x00040006, // CADDR (gen)
+  0x00010000, // CDATA
+  0x00040008, // CADDR
+  0x000100F1, // CDATA
+  0x0004000a, // CADDR (gen)
+  0x00010000, // CDATA
+  0x0004000C, // CADDR
+  0x000100F1, // CDATA
+  0x0004000e, // CADDR (gen)
+  0x00010000, // CDATA
+  0x00040010, // CADDR
+  0x000100F1, // CDATA
+  0x00040012, // CADDR (gen)
+  0x00010000, // CDATA
+  0x00040014, // CADDR
+  0x000100F1, // CDATA
+  0x00040016, // CADDR (gen)
+  0x00010000, // CDATA
+  0x00040020, // CADDR
+  0x00040040, // CADDR
+  0x00040050, // CADDR
+  0x00040091, // CADDR
+  0x00014803, // CDATA
+  0x00040094, // CADDR
+  0x00014A03, // CDATA
+  0x00040097, // CADDR
+  0x00014A03, // CDATA
+  0x0004009A, // CADDR
+  0x00014A03, // CDATA
+  0x0004009C, // CADDR
+  0x00010001, // CDATA
+  0x00049000, // CADDR
+  0x00010022, // CDATA
+  0x000101F3, // CDATA
+  0x00049008, // CADDR
+  0x00010102, // CDATA
+  0x000101F3, // CDATA
+  0x00049010, // CADDR
+  0x000101A2, // CDATA
+  0x000101F3, // CDATA
+  0x00049018, // CADDR
+  0x00010081, // CDATA
+  0x000101F2, // CDATA
+  0x00049020, // CADDR
+  0x000101E2, // CDATA
+  0x000101F3, // CDATA
+  0x00049028, // CADDR
+  0x00010122, // CDATA
+  0x000101F3, // CDATA
+  0x00049030, // CADDR
+  0x00010182, // CDATA
+  0x000101F3, // CDATA
+  0x00049038, // CADDR
+  0x00010061, // CDATA
+  0x000101F2, // CDATA
+  0x00049040, // CADDR
+  0x000101C2, // CDATA
+  0x000101F3, // CDATA
+  0x00049048, // CADDR
+  0x00010142, // CDATA
+  0x000101F3, // CDATA
+  0x00049050, // CADDR
+  0x00010162, // CDATA
+  0x000101F3, // CDATA
+  0x00049058, // CADDR
+  0x00010041, // CDATA
+  0x000101F2, // CDATA
+  0x00049060, // CADDR
+  0x000100A1, // CDATA
+  0x000101F3, // CDATA
+  0x00049068, // CADDR
+  0x00010081, // CDATA
+  0x000101F3, // CDATA
+  0x00049070, // CADDR
+  0x00010082, // CDATA
+  0x000101F3, // CDATA
+  0x00049078, // CADDR
+  0x000100A2, // CDATA
+  0x000101F2, // CDATA
+  0x00049080, // CADDR
+  0x000100C1, // CDATA
+  0x000101F3, // CDATA
+  0x00049088, // CADDR
+  0x00010061, // CDATA
+  0x000101F3, // CDATA
+  0x00049090, // CADDR
+  0x00010062, // CDATA
+  0x000101F3, // CDATA
+  0x00049098, // CADDR
+  0x000100C2, // CDATA
+  0x000101F2, // CDATA
+  0x000490A0, // CADDR
+  0x000100E1, // CDATA
+  0x000101F3, // CDATA
+  0x000490A8, // CADDR
+  0x00010041, // CDATA
+  0x000101F3, // CDATA
+  0x000490B0, // CADDR
+  0x00010042, // CDATA
+  0x000101F3, // CDATA
+  0x000490B8, // CADDR
+  0x000100E2, // CDATA
+  0x000101F2, // CDATA
+  0x00040054, // CADDR
+  0x00040055, // CADDR
+  0x0004004F, // CADDR
+  0x00082008, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00049011, // CADDR
+  0x000101F0, // CDATA
+  0x00049010, // CADDR
+  0x00010041, // CDATA
+  0x00049019, // CADDR
+  0x000101F0, // CDATA
+  0x00049018, // CADDR
+  0x000100D1, // CDATA
+  0x00049021, // CADDR
+  0x000101F0, // CDATA
+  0x00049020, // CADDR
+  0x000100C1, // CDATA
+  0x00049029, // CADDR
+  0x000101F0, // CDATA
+  0x00049028, // CADDR
+  0x000100B1, // CDATA
+  0x00049031, // CADDR
+  0x000101F0, // CDATA
+  0x00049030, // CADDR
+  0x000100A1, // CDATA
+  0x00049039, // CADDR
+  0x000101F0, // CDATA
+  0x00049038, // CADDR
+  0x00010091, // CDATA
+  0x00049041, // CADDR
+  0x000101F0, // CDATA
+  0x00049040, // CADDR
+  0x00010081, // CDATA
+  0x00049049, // CADDR
+  0x000101F0, // CDATA
+  0x00049048, // CADDR
+  0x00010071, // CDATA
+  0x00049051, // CADDR
+  0x000101F0, // CDATA
+  0x00049050, // CADDR
+  0x00010061, // CDATA
+  0x00049059, // CADDR
+  0x000101F0, // CDATA
+  0x00049058, // CADDR
+  0x00010051, // CDATA
+  0x00049061, // CADDR
+  0x000101F0, // CDATA
+  0x00049060, // CADDR
+  0x00010101, // CDATA
+  0x00049069, // CADDR
+  0x000101F0, // CDATA
+  0x00049068, // CADDR
+  0x000100F1, // CDATA
+  0x00049071, // CADDR
+  0x000101F0, // CDATA
+  0x00049070, // CADDR
+  0x000100E1, // CDATA
+  0x00049101, // CADDR
+  0x000101F0, // CDATA
+  0x00049100, // CADDR
+  0x00010162, // CDATA
+  0x00049109, // CADDR
+  0x000101F0, // CDATA
+  0x00049108, // CADDR
+  0x00010132, // CDATA
+  0x00049111, // CADDR
+  0x000101F0, // CDATA
+  0x00049110, // CADDR
+  0x00010142, // CDATA
+  0x00049119, // CADDR
+  0x000101F0, // CDATA
+  0x00049118, // CADDR
+  0x00010152, // CDATA
+  0x00049121, // CADDR
+  0x000101F0, // CDATA
+  0x00049120, // CADDR
+  0x00010172, // CDATA
+  0x00049129, // CADDR
+  0x000101F0, // CDATA
+  0x00049128, // CADDR
+  0x00010182, // CDATA
+  0x00049131, // CADDR
+  0x000101F0, // CDATA
+  0x00049130, // CADDR
+  0x00010192, // CDATA
+  0x00049139, // CADDR
+  0x000101F0, // CDATA
+  0x00049138, // CADDR
+  0x00010091, // CDATA
+  0x00049141, // CADDR
+  0x000101F0, // CDATA
+  0x00049140, // CADDR
+  0x00010061, // CDATA
+  0x00049149, // CADDR
+  0x000101F0, // CDATA
+  0x00049148, // CADDR
+  0x00010071, // CDATA
+  0x00049151, // CADDR
+  0x000101F0, // CDATA
+  0x00049150, // CADDR
+  0x00010081, // CDATA
+  0x00049000, // CADDR
+  0x00010121, // CDATA
+  0x000101F0, // CDATA
+  0x00049008, // CADDR
+  0x00010111, // CDATA
+  0x000101F0, // CDATA
+  0x00049168, // CADDR
+  0x00010051, // CDATA
+  0x000101F0, // CDATA
+  0x00049170, // CADDR
+  0x00010041, // CDATA
+  0x000101F0, // CDATA
+  0x00049886, // CADDR
+  0x00010000, // CDATA
+  0x00082118, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x00011F17, // CDATA
+  0x000100A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010010, // CDATA
+  0x000101A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010810, // CDATA
+  0x000102A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011010, // CDATA
+  0x000103A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011810, // CDATA
+  0x000104A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00012010, // CDATA
+  0x000105A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00012810, // CDATA
+  0x000106A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00013010, // CDATA
+  0x000107A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00013810, // CDATA
+  0x000108A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00014010, // CDATA
+  0x000109A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00014810, // CDATA
+  0x00015008, // CDATA
+  0x00010040, // CDATA
+  0x00010007, // CDATA
+  0x00049000, // CADDR
+  0x00010101, // CDATA
+  0x000101F1, // CDATA
+  0x00049008, // CADDR
+  0x000100F1, // CDATA
+  0x000101F1, // CDATA
+  0x00049010, // CADDR
+  0x000100E1, // CDATA
+  0x000101F1, // CDATA
+  0x00049018, // CADDR
+  0x00010161, // CDATA
+  0x000101F1, // CDATA
+  0x00049020, // CADDR
+  0x00010131, // CDATA
+  0x000101F1, // CDATA
+  0x00049028, // CADDR
+  0x00010141, // CDATA
+  0x000101F1, // CDATA
+  0x00049030, // CADDR
+  0x00010151, // CDATA
+  0x000101F1, // CDATA
+  0x00049038, // CADDR
+  0x00010171, // CDATA
+  0x000101F1, // CDATA
+  0x00049040, // CADDR
+  0x00010181, // CDATA
+  0x000101F1, // CDATA
+  0x00049048, // CADDR
+  0x00010191, // CDATA
+  0x000101F1, // CDATA
+  0x00049050, // CADDR
+  0x00010051, // CDATA
+  0x000101F0, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x00082128, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x00011F17, // CDATA
+  0x000100A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010010, // CDATA
+  0x000101A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010810, // CDATA
+  0x000102A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011010, // CDATA
+  0x000103A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011810, // CDATA
+  0x00012008, // CDATA
+  0x00010040, // CDATA
+  0x00010007, // CDATA
+  0x00049000, // CADDR
+  0x00010091, // CDATA
+  0x000101F1, // CDATA
+  0x00049008, // CADDR
+  0x00010061, // CDATA
+  0x000101F1, // CDATA
+  0x00049010, // CADDR
+  0x00010071, // CDATA
+  0x000101F1, // CDATA
+  0x00049018, // CADDR
+  0x00010081, // CDATA
+  0x000101F1, // CDATA
+  0x00049020, // CADDR
+  0x00010101, // CDATA
+  0x000101F0, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x00082129, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x00011F17, // CDATA
+  0x000100A7, // CDATA
+  0x00010740, // CDATA
+  0x00010703, // CDATA
+  0x00010010, // CDATA
+  0x0001FE17, // CDATA
+  0x0001D840, // CDATA
+  0x00010007, // CDATA
+  0x000101A7, // CDATA
+  0x0001C740, // CDATA
+  0x00010702, // CDATA
+  0x00010810, // CDATA
+  0x0001FE17, // CDATA
+  0x0001D840, // CDATA
+  0x0001A707, // CDATA
+  0x00014002, // CDATA
+  0x000102C7, // CDATA
+  0x00011007, // CDATA
+  0x00011710, // CDATA
+  0x000140FE, // CDATA
+  0x000107D8, // CDATA
+  0x000103A7, // CDATA
+  0x00010740, // CDATA
+  0x00010703, // CDATA
+  0x00011810, // CDATA
+  0x0001FE17, // CDATA
+  0x0001D840, // CDATA
+  0x00010007, // CDATA
+  0x00012008, // CDATA
+  0x00010040, // CDATA
+  0x00010007, // CDATA
+  0x00010000, // CDATA
+  0x00049000, // CADDR
+  0x00010121, // CDATA
+  0x000101F1, // CDATA
+  0x00049008, // CADDR
+  0x00010111, // CDATA
+  0x000101F1, // CDATA
+  0x00049010, // CADDR
+  0x00010051, // CDATA
+  0x000101F1, // CDATA
+  0x00049018, // CADDR
+  0x00010041, // CDATA
+  0x000101F1, // CDATA
+  0x00049020, // CADDR
+  0x00010111, // CDATA
+  0x000101F0, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x00082138, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x00011F17, // CDATA
+  0x000100A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010010, // CDATA
+  0x000101A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010810, // CDATA
+  0x000102A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011010, // CDATA
+  0x000103A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011810, // CDATA
+  0x000104A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00012010, // CDATA
+  0x000105A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00012810, // CDATA
+  0x000106A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00013010, // CDATA
+  0x000107A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00013810, // CDATA
+  0x000108A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00014010, // CDATA
+  0x000109A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00014810, // CDATA
+  0x00015008, // CDATA
+  0x00010040, // CDATA
+  0x00010007, // CDATA
+  0x00049000, // CADDR
+  0x00010042, // CDATA
+  0x000101F1, // CDATA
+  0x00049008, // CADDR
+  0x00010052, // CDATA
+  0x000101F1, // CDATA
+  0x00049010, // CADDR
+  0x00010062, // CDATA
+  0x000101F1, // CDATA
+  0x00049018, // CADDR
+  0x00010072, // CDATA
+  0x000101F1, // CDATA
+  0x00049020, // CADDR
+  0x00010082, // CDATA
+  0x000101F1, // CDATA
+  0x00049028, // CADDR
+  0x00010092, // CDATA
+  0x000101F1, // CDATA
+  0x00049030, // CADDR
+  0x000100A2, // CDATA
+  0x000101F1, // CDATA
+  0x00049038, // CADDR
+  0x000100B2, // CDATA
+  0x000101F1, // CDATA
+  0x00049040, // CADDR
+  0x000100C2, // CDATA
+  0x000101F1, // CDATA
+  0x00049048, // CADDR
+  0x000100D2, // CDATA
+  0x000101F1, // CDATA
+  0x00049050, // CADDR
+  0x00010122, // CDATA
+  0x000101F0, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x00082148, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x00011F17, // CDATA
+  0x000100A7, // CDATA
+  0x00010740, // CDATA
+  0x00010703, // CDATA
+  0x00010010, // CDATA
+  0x0001FE17, // CDATA
+  0x0001D840, // CDATA
+  0x00010007, // CDATA
+  0x000101A7, // CDATA
+  0x0001C740, // CDATA
+  0x00010702, // CDATA
+  0x00010810, // CDATA
+  0x0001FE17, // CDATA
+  0x0001D840, // CDATA
+  0x0001A707, // CDATA
+  0x00014002, // CDATA
+  0x000102C7, // CDATA
+  0x00011007, // CDATA
+  0x00011710, // CDATA
+  0x000140FE, // CDATA
+  0x000107D8, // CDATA
+  0x000103A7, // CDATA
+  0x00010740, // CDATA
+  0x00010703, // CDATA
+  0x00011810, // CDATA
+  0x0001FE17, // CDATA
+  0x0001D840, // CDATA
+  0x00010007, // CDATA
+  0x00012008, // CDATA
+  0x00010040, // CDATA
+  0x00010007, // CDATA
+  0x00010000, // CDATA
+  0x00049000, // CADDR
+  0x000100F1, // CDATA
+  0x000101F1, // CDATA
+  0x00049008, // CADDR
+  0x000100E1, // CDATA
+  0x000101F1, // CDATA
+  0x00049010, // CADDR
+  0x00010082, // CDATA
+  0x000101F1, // CDATA
+  0x00049018, // CADDR
+  0x00010072, // CDATA
+  0x000101F1, // CDATA
+  0x00049020, // CADDR
+  0x00010052, // CDATA
+  0x000101F0, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x0008214B, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x00011F17, // CDATA
+  0x000100A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010010, // CDATA
+  0x000101A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010810, // CDATA
+  0x000102A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011010, // CDATA
+  0x000103A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011810, // CDATA
+  0x00012008, // CDATA
+  0x00010040, // CDATA
+  0x00010007, // CDATA
+  0x00049000, // CADDR
+  0x000100C2, // CDATA
+  0x000101F1, // CDATA
+  0x00049008, // CADDR
+  0x000100B2, // CDATA
+  0x000101F1, // CDATA
+  0x00049010, // CADDR
+  0x000100A2, // CDATA
+  0x000101F1, // CDATA
+  0x00049018, // CADDR
+  0x00010092, // CDATA
+  0x000101F1, // CDATA
+  0x00049020, // CADDR
+  0x00010042, // CDATA
+  0x000101F0, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x00082158, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x00011F17, // CDATA
+  0x000100A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010010, // CDATA
+  0x000101A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010810, // CDATA
+  0x000102A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011010, // CDATA
+  0x000103A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011810, // CDATA
+  0x000104A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00012010, // CDATA
+  0x000105A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00012810, // CDATA
+  0x000106A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00013010, // CDATA
+  0x000107A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00013810, // CDATA
+  0x000108A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00014010, // CDATA
+  0x000109A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00014810, // CDATA
+  0x00015008, // CDATA
+  0x00010040, // CDATA
+  0x00010007, // CDATA
+  0x00049000, // CADDR
+  0x00010041, // CDATA
+  0x000101F1, // CDATA
+  0x00049008, // CADDR
+  0x00010051, // CDATA
+  0x000101F1, // CDATA
+  0x00049010, // CADDR
+  0x00010061, // CDATA
+  0x000101F1, // CDATA
+  0x00049018, // CADDR
+  0x000100D1, // CDATA
+  0x000101F1, // CDATA
+  0x00049020, // CADDR
+  0x00010131, // CDATA
+  0x000101F1, // CDATA
+  0x00049028, // CADDR
+  0x00010121, // CDATA
+  0x000101F1, // CDATA
+  0x00049030, // CADDR
+  0x00010111, // CDATA
+  0x000101F1, // CDATA
+  0x00049038, // CADDR
+  0x00010101, // CDATA
+  0x000101F1, // CDATA
+  0x00049040, // CADDR
+  0x000100F1, // CDATA
+  0x000101F1, // CDATA
+  0x00049048, // CADDR
+  0x000100E1, // CDATA
+  0x000101F1, // CDATA
+  0x00049050, // CADDR
+  0x00010062, // CDATA
+  0x000101F0, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x00082218, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x00011F17, // CDATA
+  0x000100A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010010, // CDATA
+  0x000101A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00010810, // CDATA
+  0x000102A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011010, // CDATA
+  0x000103A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00011810, // CDATA
+  0x000104A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00012010, // CDATA
+  0x000105A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00012810, // CDATA
+  0x000106A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00013010, // CDATA
+  0x000107A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00013810, // CDATA
+  0x000108A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00014010, // CDATA
+  0x000109A7, // CDATA
+  0x00018740, // CDATA
+  0x00010701, // CDATA
+  0x00014810, // CDATA
+  0x00015008, // CDATA
+  0x00010040, // CDATA
+  0x00010007, // CDATA
+  0x00049000, // CADDR
+  0x00010041, // CDATA
+  0x000101F1, // CDATA
+  0x00049008, // CADDR
+  0x000100D1, // CDATA
+  0x000101F1, // CDATA
+  0x00049010, // CADDR
+  0x000100C1, // CDATA
+  0x000101F1, // CDATA
+  0x00049018, // CADDR
+  0x000100B1, // CDATA
+  0x000101F1, // CDATA
+  0x00049020, // CADDR
+  0x000100A1, // CDATA
+  0x000101F1, // CDATA
+  0x00049028, // CADDR
+  0x00010091, // CDATA
+  0x000101F1, // CDATA
+  0x00049030, // CADDR
+  0x00010081, // CDATA
+  0x000101F1, // CDATA
+  0x00049038, // CADDR
+  0x00010071, // CDATA
+  0x000101F1, // CDATA
+  0x00049040, // CADDR
+  0x00010061, // CDATA
+  0x000101F1, // CDATA
+  0x00049048, // CADDR
+  0x00010051, // CDATA
+  0x000101F1, // CDATA
+  0x00049050, // CADDR
+  0x00010041, // CDATA
+  0x000101F0, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x00082238, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x00010010, // CDATA
+  0x00010810, // CDATA
+  0x00011010, // CDATA
+  0x00011810, // CDATA
+  0x00012010, // CDATA
+  0x00012810, // CDATA
+  0x00013010, // CDATA
+  0x00013810, // CDATA
+  0x00014010, // CDATA
+  0x0001FE17, // CDATA
+  0x000100F7, // CDATA
+  0x00010000, // CDATA
+  0x00049000, // CADDR
+  0x00010121, // CDATA
+  0x000101F1, // CDATA
+  0x00049008, // CADDR
+  0x00010062, // CDATA
+  0x000101F1, // CDATA
+  0x00049010, // CADDR
+  0x00010042, // CDATA
+  0x000101F1, // CDATA
+  0x00049018, // CADDR
+  0x00010041, // CDATA
+  0x000101F1, // CDATA
+  0x00049020, // CADDR
+  0x00010051, // CDATA
+  0x000101F1, // CDATA
+  0x00049028, // CADDR
+  0x00010101, // CDATA
+  0x000101F1, // CDATA
+  0x00049030, // CADDR
+  0x00010111, // CDATA
+  0x000101F1, // CDATA
+  0x00049038, // CADDR
+  0x00010052, // CDATA
+  0x000101F1, // CDATA
+  0x00049040, // CADDR
+  0x000100A2, // CDATA
+  0x000101F3, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x00082C28, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x0001003F, // CDATA
+  0x00010130, // CDATA
+  0x00012F10, // CDATA
+  0x0001302F, // CDATA
+  0x0001E001, // CDATA
+  0x0001DEAD, // CDATA
+  0x00013F27, // CDATA
+  0x0001BEEF, // CDATA
+  0x0001603F, // CDATA
+  0x00010130, // CDATA
+  0x00010070, // CDATA
+  0x00010000, // CDATA
+  0x0001FF9B, // CDATA
+  0x00010102, // CDATA
+  0x00014000, // CDATA
+  0x00010D87, // CDATA
+  0x0001A707, // CDATA
+  0x00014006, // CDATA
+  0x00010347, // CDATA
+  0x00016A07, // CDATA
+  0x00010861, // CDATA
+  0x00011730, // CDATA
+  0x0001401F, // CDATA
+  0x000107AC, // CDATA
+  0x000100A7, // CDATA
+  0x00018740, // CDATA
+  0x00013703, // CDATA
+  0x00017A86, // CDATA
+  0x00010871, // CDATA
+  0x00011700, // CDATA
+  0x0001401F, // CDATA
+  0x000107CC, // CDATA
+  0x00018184, // CDATA
+  0x00014740, // CDATA
+  0x00010704, // CDATA
+  0x000106A7, // CDATA
+  0x0001C740, // CDATA
+  0x00010702, // CDATA
+  0x00013108, // CDATA
+  0x00011F17, // CDATA
+  0x0001C040, // CDATA
+  0x0001EA07, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA68, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA78, // CDATA
+  0x000120E2, // CDATA
+  0x00014088, // CDATA
+  0x0001070C, // CDATA
+  0x0001603F, // CDATA
+  0x00010130, // CDATA
+  0x00010070, // CDATA
+  0x0001FF9B, // CDATA
+  0x00010202, // CDATA
+  0x00014000, // CDATA
+  0x00010D87, // CDATA
+  0x0001A707, // CDATA
+  0x00014007, // CDATA
+  0x00010347, // CDATA
+  0x00016A07, // CDATA
+  0x00010861, // CDATA
+  0x00011738, // CDATA
+  0x0001401F, // CDATA
+  0x000107AC, // CDATA
+  0x000101A7, // CDATA
+  0x00018740, // CDATA
+  0x00013703, // CDATA
+  0x00017A86, // CDATA
+  0x00010871, // CDATA
+  0x00011708, // CDATA
+  0x0001401F, // CDATA
+  0x000107CC, // CDATA
+  0x00018184, // CDATA
+  0x00014740, // CDATA
+  0x00010704, // CDATA
+  0x000107A7, // CDATA
+  0x0001C740, // CDATA
+  0x00010702, // CDATA
+  0x00013908, // CDATA
+  0x00011F17, // CDATA
+  0x0001C040, // CDATA
+  0x0001EA07, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA68, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA78, // CDATA
+  0x000120E2, // CDATA
+  0x00014088, // CDATA
+  0x0001070C, // CDATA
+  0x0001603F, // CDATA
+  0x00010130, // CDATA
+  0x00010070, // CDATA
+  0x0001FF9B, // CDATA
+  0x00010402, // CDATA
+  0x00014000, // CDATA
+  0x00010D87, // CDATA
+  0x0001A707, // CDATA
+  0x00014008, // CDATA
+  0x00010347, // CDATA
+  0x00016A07, // CDATA
+  0x00010861, // CDATA
+  0x00011740, // CDATA
+  0x0001401F, // CDATA
+  0x000107AC, // CDATA
+  0x000102A7, // CDATA
+  0x00018740, // CDATA
+  0x00013703, // CDATA
+  0x00017A86, // CDATA
+  0x00010871, // CDATA
+  0x00011710, // CDATA
+  0x0001401F, // CDATA
+  0x000107CC, // CDATA
+  0x00018184, // CDATA
+  0x00014740, // CDATA
+  0x00010704, // CDATA
+  0x000108A7, // CDATA
+  0x0001C740, // CDATA
+  0x00010702, // CDATA
+  0x00014108, // CDATA
+  0x00011F17, // CDATA
+  0x0001C040, // CDATA
+  0x0001EA07, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA68, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA78, // CDATA
+  0x000120E2, // CDATA
+  0x00014088, // CDATA
+  0x0001070C, // CDATA
+  0x0001603F, // CDATA
+  0x00010130, // CDATA
+  0x00010070, // CDATA
+  0x0001FF9B, // CDATA
+  0x00010802, // CDATA
+  0x00014000, // CDATA
+  0x00010D87, // CDATA
+  0x0001A707, // CDATA
+  0x00014009, // CDATA
+  0x00010347, // CDATA
+  0x00016A07, // CDATA
+  0x00010861, // CDATA
+  0x00011748, // CDATA
+  0x0001401F, // CDATA
+  0x000107AC, // CDATA
+  0x000103A7, // CDATA
+  0x00018740, // CDATA
+  0x00013703, // CDATA
+  0x00017A86, // CDATA
+  0x00010871, // CDATA
+  0x00011718, // CDATA
+  0x0001401F, // CDATA
+  0x000107CC, // CDATA
+  0x00018184, // CDATA
+  0x00014740, // CDATA
+  0x00010704, // CDATA
+  0x000109A7, // CDATA
+  0x0001C740, // CDATA
+  0x00010702, // CDATA
+  0x00014908, // CDATA
+  0x00011F17, // CDATA
+  0x0001C040, // CDATA
+  0x0001EA07, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA68, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA78, // CDATA
+  0x000120E2, // CDATA
+  0x00014088, // CDATA
+  0x0001070C, // CDATA
+  0x0001603F, // CDATA
+  0x00010130, // CDATA
+  0x00010070, // CDATA
+  0x0001FF9B, // CDATA
+  0x00011002, // CDATA
+  0x00014000, // CDATA
+  0x00010D87, // CDATA
+  0x0001A707, // CDATA
+  0x0001400A, // CDATA
+  0x00010347, // CDATA
+  0x00016A07, // CDATA
+  0x00010861, // CDATA
+  0x00011750, // CDATA
+  0x0001401F, // CDATA
+  0x000107AC, // CDATA
+  0x000104A7, // CDATA
+  0x00018740, // CDATA
+  0x00013703, // CDATA
+  0x00017A86, // CDATA
+  0x00010871, // CDATA
+  0x00011720, // CDATA
+  0x0001401F, // CDATA
+  0x000107CC, // CDATA
+  0x00018184, // CDATA
+  0x00014740, // CDATA
+  0x00010704, // CDATA
+  0x00010AA7, // CDATA
+  0x0001C740, // CDATA
+  0x00010702, // CDATA
+  0x00015108, // CDATA
+  0x00011F17, // CDATA
+  0x0001C040, // CDATA
+  0x0001EA07, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA68, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA78, // CDATA
+  0x000120E2, // CDATA
+  0x00014088, // CDATA
+  0x0001070C, // CDATA
+  0x0001603F, // CDATA
+  0x00010130, // CDATA
+  0x00010070, // CDATA
+  0x0001FF9B, // CDATA
+  0x00012002, // CDATA
+  0x00014000, // CDATA
+  0x00010D87, // CDATA
+  0x0001A707, // CDATA
+  0x0001400B, // CDATA
+  0x00010347, // CDATA
+  0x00016A07, // CDATA
+  0x00010861, // CDATA
+  0x00011758, // CDATA
+  0x0001401F, // CDATA
+  0x000107AC, // CDATA
+  0x000105A7, // CDATA
+  0x00018740, // CDATA
+  0x00013703, // CDATA
+  0x00017A86, // CDATA
+  0x00010871, // CDATA
+  0x00011728, // CDATA
+  0x0001401F, // CDATA
+  0x000107CC, // CDATA
+  0x00018184, // CDATA
+  0x00014740, // CDATA
+  0x00010704, // CDATA
+  0x00010BA7, // CDATA
+  0x0001C740, // CDATA
+  0x00010702, // CDATA
+  0x00015908, // CDATA
+  0x00011F17, // CDATA
+  0x0001C040, // CDATA
+  0x0001EA07, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA68, // CDATA
+  0x000120E2, // CDATA
+  0x0001EA78, // CDATA
+  0x000120E2, // CDATA
+  0x00014088, // CDATA
+  0x0001070C, // CDATA
+  0x0001FF9B, // CDATA
+  0x00010102, // CDATA
+  0x00014000, // CDATA
+  0x00010447, // CDATA
+  0x0001A707, // CDATA
+  0x00014013, // CDATA
+  0x000102C7, // CDATA
+  0x00011007, // CDATA
+  0x00011798, // CDATA
+  0x0001401F, // CDATA
+  0x000107B4, // CDATA
+  0x0001FF9B, // CDATA
+  0x00010202, // CDATA
+  0x00014000, // CDATA
+  0x000104C7, // CDATA
+  0x0001A707, // CDATA
+  0x00014014, // CDATA
+  0x00010347, // CDATA
+  0x00011007, // CDATA
+  0x000117A0, // CDATA
+  0x0001401F, // CDATA
+  0x000107B4, // CDATA
+  0x00010000, // CDATA
+  0x0001FF9B, // CDATA
+  0x00010402, // CDATA
+  0x00014000, // CDATA
+  0x000104C7, // CDATA
+  0x0001A707, // CDATA
+  0x00014015, // CDATA
+  0x00010347, // CDATA
+  0x00011007, // CDATA
+  0x000117A8, // CDATA
+  0x0001401F, // CDATA
+  0x000107B4, // CDATA
+  0x00010000, // CDATA
+  0x0001FF9B, // CDATA
+  0x00010802, // CDATA
+  0x00014000, // CDATA
+  0x000104C7, // CDATA
+  0x0001A707, // CDATA
+  0x00014016, // CDATA
+  0x00010347, // CDATA
+  0x00011007, // CDATA
+  0x000117B0, // CDATA
+  0x0001401F, // CDATA
+  0x000107B4, // CDATA
+  0x00010000, // CDATA
+  0x0001FF9B, // CDATA
+  0x00011002, // CDATA
+  0x00014000, // CDATA
+  0x000104C7, // CDATA
+  0x0001A707, // CDATA
+  0x00014017, // CDATA
+  0x00010347, // CDATA
+  0x00011007, // CDATA
+  0x000117B8, // CDATA
+  0x0001401F, // CDATA
+  0x000107B4, // CDATA
+  0x00010000, // CDATA
+  0x0001FF9B, // CDATA
+  0x00012002, // CDATA
+  0x00014000, // CDATA
+  0x00010447, // CDATA
+  0x0001A707, // CDATA
+  0x00014018, // CDATA
+  0x000102C7, // CDATA
+  0x00011007, // CDATA
+  0x000117C0, // CDATA
+  0x0001401F, // CDATA
+  0x000107B4, // CDATA
+  0x0001C808, // CDATA
+  0x00010040, // CDATA
+  0x00010007, // CDATA
+  0x00010000, // CDATA
+  0x00010000, // CDATA
+  0x00049000, // CADDR
+  0x00010021, // CDATA
+  0x000101F2, // CDATA
+  0x00049008, // CADDR
+  0x000101E1, // CDATA
+  0x000101F2, // CDATA
+  0x00049010, // CADDR
+  0x000101C1, // CDATA
+  0x000101F2, // CDATA
+  0x00049018, // CADDR
+  0x000100A1, // CDATA
+  0x000101F2, // CDATA
+  0x00049020, // CADDR
+  0x000100C1, // CDATA
+  0x000101F2, // CDATA
+  0x00049028, // CADDR
+  0x000100E1, // CDATA
+  0x000101F2, // CDATA
+  0x00049030, // CADDR
+  0x00010101, // CDATA
+  0x000101F2, // CDATA
+  0x00049038, // CADDR
+  0x00010121, // CDATA
+  0x000101F2, // CDATA
+  0x00049040, // CADDR
+  0x00010141, // CDATA
+  0x000101F2, // CDATA
+  0x00049048, // CADDR
+  0x00010081, // CDATA
+  0x000101F2, // CDATA
+  0x00049050, // CADDR
+  0x00010061, // CDATA
+  0x000101F2, // CDATA
+  0x00049058, // CADDR
+  0x00010041, // CDATA
+  0x000101F2, // CDATA
+  0x00049060, // CADDR
+  0x000101A1, // CDATA
+  0x000101F2, // CDATA
+  0x00049068, // CADDR
+  0x00010181, // CDATA
+  0x000101F2, // CDATA
+  0x00049070, // CADDR
+  0x00010161, // CDATA
+  0x000101F2, // CDATA
+  0x00049080, // CADDR
+  0x00010081, // CDATA
+  0x000101F2, // CDATA
+  0x00049088, // CADDR
+  0x00010061, // CDATA
+  0x000101F2, // CDATA
+  0x00049090, // CADDR
+  0x00010041, // CDATA
+  0x000101F2, // CDATA
+  0x00049098, // CADDR
+  0x00010081, // CDATA
+  0x000101F3, // CDATA
+  0x000490A0, // CADDR
+  0x00010061, // CDATA
+  0x000101F3, // CDATA
+  0x000490A8, // CADDR
+  0x00010041, // CDATA
+  0x000101F3, // CDATA
+  0x000490B0, // CADDR
+  0x000100A1, // CDATA
+  0x000101F3, // CDATA
+  0x000490B8, // CADDR
+  0x000100C1, // CDATA
+  0x000101F3, // CDATA
+  0x000490C0, // CADDR
+  0x000100E1, // CDATA
+  0x000101F3, // CDATA
+  0x000490C8, // CADDR
+  0x000100A1, // CDATA
+  0x000101F2, // CDATA
+  0x0004A038, // CADDR
+  0x0001000F, // CDATA
+  0x0004A042, // CADDR
+  0x00010000, // CDATA
+  0x00082010, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082020, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082030, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB0C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB0D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x00082040, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001C36D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082050, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082110, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010036, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082120, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB5D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB5D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB5D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB5D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB5D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB5D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2C, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB5D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB5D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082130, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082140, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001CB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001CB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001CB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001CB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082150, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x00010036, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082210, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082220, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DA6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DA6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DA6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DA6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001D96D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082230, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB5C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB5C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB5C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB5C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB5C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB5C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB5C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB5C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082240, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001D76D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001D76D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001D76D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001CB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001D76D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001C36D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082250, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x00015B6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x00015B6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x00015B6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x00015B6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082330, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082340, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082430, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082440, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082530, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082540, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082630, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082640, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082730, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082740, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082830, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082840, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082930, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082940, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082A30, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x00010030, // CDATA
+  0x0001DB6C, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082A40, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B0, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082C30, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB2D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x00082C40, // AEID
+  0x0004A060, // CADDR
+  0x00010000, // CDATA
+  0x00040000, // CADDR
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B2, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x000100B6, // CDATA
+  0x0001DB6D, // CDATA
+  0x0008FFFF, // AEID
+  0x0004A062, // CADDR
+  0x00010034, // CDATA
+};
+
+#endif /* __PICOIF_SOFT_RESET_MEMIF_H__ */
+
diff --git a/drivers/picochip/utilities_internal.c b/drivers/picochip/utilities_internal.c
new file mode 100644
index 0000000..54dc3b1
--- /dev/null
+++ b/drivers/picochip/utilities_internal.c
@@ -0,0 +1,55 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file utilities_internal.c
+ * \brief Implementation of utility functions for the picoIf driver.
+ *
+ * Implementation of utility functions for the picoIf driver.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include "utilities_internal.h"
+
+void __iomem *
+request_and_map( const char *name,
+                 unsigned long addr,
+                 size_t len )
+{
+    void __iomem *ret = NULL;
+    struct resource *r = request_mem_region( addr, len, name );
+    if ( !r )
+        goto out;
+
+    ret = ioremap( addr, len );
+    if ( !ret )
+    {
+        release_resource( r );
+        goto out;
+    }
+
+out:
+    return ret;
+}
+
+void
+unmap_and_release( unsigned long addr,
+                   size_t len,
+                   void __iomem *vaddr )
+{
+    iounmap( vaddr );
+    release_mem_region( addr, len );
+}
diff --git a/drivers/picochip/utilities_internal.h b/drivers/picochip/utilities_internal.h
new file mode 100644
index 0000000..c30bf23
--- /dev/null
+++ b/drivers/picochip/utilities_internal.h
@@ -0,0 +1,51 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file utilities_internal.h
+ * \brief Definition of utility functions for the picoIf driver.
+ */
+
+#ifndef __PICOIF_UTILITIES_INTERNAL_H__
+#define __PICOIF_UTILITIES_INTERNAL_H__
+
+/*!
+ * Generic request and map function. Maps a physical address into a kernel
+ * virtual address.
+ *
+ * @param name The name of the memory region being mapped.
+ * @param addr The physical address of the memory.
+ * @param len The length of the memory region in bytes.
+ * @return Returns a pointer to the virtual address on success, NULL on
+ * failure.
+ */
+void __iomem *
+request_and_map( const char *name,
+                 unsigned long addr,
+                 size_t len );
+
+/*!
+ * Generic unmap and release function. Unmaps a kernel virtual address and
+ * releases the resource.
+ *
+ * @param addr The physical address of the memory.
+ * @param len The length of the memory region in bytes.
+ * @param vaddr The virtual address to unmap.
+ */
+void
+unmap_and_release( unsigned long addr,
+                   size_t len,
+                   void __iomem *vaddr );
+
+#endif /* !__PICOIF_UTILITIES_INTERNAL_H__ */
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 303272a..c081ef3 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -1510,6 +1510,23 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 			handled = 1;
 
 			end = NULL;
+
+#if defined(CONFIG_SERIAL_8250_FIRECRACKER) || defined(CONFIG_ARCH_PC302)
+		/* 
+		 * If we are supporting the Synopsys UART in the 
+		 * Firecracker, we need to handle the additional 
+		 * 'busy' interrupt. We simply reset the interrupt
+		 * condition and handle the interrupt.
+		 * 
+		 */
+		} else if ((iir & UART_IIR_ID_MASK) == 
+				UART_IIR_FIRECRACKER_BUSY) {
+			/* Read USR to clear busy interrupt */
+			serial_in(up, UART_FIRECRACKER_USR);
+			handled = 1;
+			end = NULL;
+#endif
+
 		} else if (end == NULL)
 			end = l;
 
diff --git a/drivers/serial/8250_early.c b/drivers/serial/8250_early.c
index f279745..51a3497 100644
--- a/drivers/serial/8250_early.c
+++ b/drivers/serial/8250_early.c
@@ -48,7 +48,9 @@ static struct early_serial8250_device early_device;
 
 static unsigned int __init serial_in(struct uart_port *port, int offset)
 {
-	if (port->iotype == UPIO_MEM)
+        if (port->iotype == UPIO_MEM32)
+                return readl(port->membase + offset);
+        else if (port->iotype == UPIO_MEM)
 		return readb(port->membase + offset);
 	else
 		return inb(port->iobase + offset);
@@ -56,6 +58,8 @@ static unsigned int __init serial_in(struct uart_port *port, int offset)
 
 static void __init serial_out(struct uart_port *port, int offset, int value)
 {
+        if (port->iotype == UPIO_MEM32)
+                writel(value, port->membase + offset);
 	if (port->iotype == UPIO_MEM)
 		writeb(value, port->membase + offset);
 	else
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 579d63a..d5b572e 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -258,6 +258,15 @@ config SERIAL_8250_ACORN
 	  system, say Y to this option.  The driver can handle 1, 2, or 3 port
 	  cards.  If unsure, say N.
 
+config SERIAL_8250_FIRECRACKER
+	bool "Firecracker serial port support"
+	depends on SERIAL_8250 && ARCH_FIRECRACKER || ARCH_PC302
+	help
+	  If you have a Firecracker (pc20x) hardware and want to use the 
+	  serial port, say Y to this option.  The driver can handle 1 or
+	  2 serial ports.
+	  If unsure, say N.
+
 config SERIAL_8250_AU1X00
 	bool "Au1x00 serial port support"
 	depends on SERIAL_8250 != n && SOC_AU1X00
diff --git a/drivers/serial/cpm_uart/cpm_uart_core.c b/drivers/serial/cpm_uart/cpm_uart_core.c
index bde4b4b..78592fe 100644
--- a/drivers/serial/cpm_uart/cpm_uart_core.c
+++ b/drivers/serial/cpm_uart/cpm_uart_core.c
@@ -411,6 +411,14 @@ static int cpm_uart_startup(struct uart_port *port)
 	if (retval)
 		return retval;
 
+	if (!(pinfo->flags & FLAG_CONSOLE)) {
+		if (IS_SMC(pinfo))
+			cpm_uart_init_smc(pinfo);
+		else
+			cpm_uart_init_scc(pinfo);
+	}
+
+
 	/* Startup rx-int */
 	if (IS_SMC(pinfo)) {
 		setbits8(&pinfo->smcp->smc_smcm, SMCM_RX);
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index b9d0efb..eec2e0f 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -100,6 +100,13 @@ config SPI_BUTTERFLY
 	  inexpensive battery powered microcontroller evaluation board.
 	  This same cable can be used to flash new firmware.
 
+config SPI_FIRECRACKER
+	tristate "Firecracker SPI by GPIO"
+	depends on SPI_MASTER && ARCH_FIRECRACKER && SPI_BITBANG && EXPERIMENTAL
+	help
+	  SPI driver for picoChip Firecracker series ARM SoCs using
+	  GPIO lines to provide the SPI bus.
+
 config SPI_IMX
 	tristate "Freescale iMX SPI controller"
 	depends on ARCH_IMX && EXPERIMENTAL
@@ -155,6 +162,12 @@ config SPI_ORION
 	help
 	  This enables using the SPI master controller on the Orion chips.
 
+config SPI_PC302
+	tristate "picoChip PC302 SPI support"
+	depends on ARCH_PC302
+	help
+	  Enables using the SPI master controller the on picoChip PC302 device.
+          
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
 	depends on ARCH_PXA && EXPERIMENTAL
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index ccf18de..a39d2f3 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -29,6 +29,8 @@ obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
+obj-$(CONFIG_SPI_FIRECRACKER)		+= spi_pc202_gpio.o
+obj-$(CONFIG_SPI_PC302)                 += pc302_spi.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
diff --git a/drivers/spi/pc302_spi.c b/drivers/spi/pc302_spi.c
new file mode 100644
index 0000000..763d796
--- /dev/null
+++ b/drivers/spi/pc302_spi.c
@@ -0,0 +1,833 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file pc302_spi.c
+* \brief SPI driver for the PC302.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <linux/spi/spi.h>
+#include <mach/hardware.h>
+#include "pc302_spi.h"
+
+/* Macros ------------------------------------------------------------------ */
+/*!
+ * The name used for the platform device and driver to allow Linux to match up
+ * the correct ends.
+ */
+#define CARDNAME "pc302-spi"
+
+/*!
+ * A name for this module
+ */
+#define TITLE "PC302 SPI Driver"
+
+/*!
+ * AHB Bus clock frequency
+ */
+#define PC302_AHB_CLOCK_FREQ    (PC302_TIMER_FREQ)
+
+/*!
+ * Max number of queued SPI messages this driver can handle
+ */
+ #define PC302_MAX_QUEUED_SPI_MESSAGES (2)
+
+/* Constants --------------------------------------------------------------- */
+/* !
+ *  \brief This structure is used for generic and device specific
+ *         spi driver data.
+ */
+struct pc302_spi
+{
+    void __iomem    *regs;
+
+    /* Max clock speed that the SPI block can run at */
+    unsigned int    spi_max_clock;
+
+    /* Min clock speed that the SPI block can run at */
+    unsigned int    spi_min_clock;
+
+    /* Pointer to hold location of the Tx data 'copy' */
+    char            *local_buf;
+
+    /* Length of the Tx data 'copy' */
+    unsigned int    byte_count_tx;
+};
+
+/*!
+ * \brief Function return codes
+ */
+enum
+{
+    SUCCESS = 0,    /* Successful outcome */
+    FAILURE = 1     /* Error response */
+};
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ * \brief Read a 16 bit value from a register in the SPI block
+ *
+ * \param master Pointer to the spi_master struct
+ * \param register_offset The register to read from
+ *
+ * \return The 16 bit value read from the hardware
+ */
+static u16
+spi_ioread16(struct spi_master *master,
+             unsigned int register_offset);
+
+/*!
+ * \brief Write a 16 bit value to a register in the SPI block
+ *
+ * \param master Pointer to the spi_master struct
+ * \param value The value to write
+ * \param register_offset The register to write to
+ */
+static void
+spi_iowrite16(struct spi_master *master,
+              u16 value,
+              unsigned int register_offset);
+
+/*!
+ * \brief Setup the SPI block ready for a SPI transfer
+ *
+ * \param spi Pointer to the spi_device struct
+ *
+ * \return 0 on success, non zero on error
+ */
+static int
+pc302spi_setup(struct spi_device *spi);
+
+/*!
+ * \brief Cleanup things after a transfer
+ *
+ * \param spi Pointer to the spi_device struct
+ */
+static void
+pc302spi_cleanup(struct spi_device *spi);
+
+/*!
+ * \brief Perform an SPI transfer
+ *
+ * \param spi Pointer to the spi_device struct
+ * \param mesg Pointer to the spi_message struct
+ *
+ * \return 0 on success, non zero on error
+ *
+ * Note: It is imperative that the Tx fifo never empties during operation,
+ *       if this happens the chip select will be negated by the SPI block,
+ *       the spi flash will 'forget' what it is doing and it will
+ *       all end in tears !
+ */
+static int
+pc302spi_transfer(struct spi_device *spi,
+                  struct spi_message *mesg);
+
+/*!
+ * \brief Activate the SPI chip select
+ *
+ * \param spi Pointer to the spi_device struct
+ *
+ * Note: This does not actually assert a chip select,
+ *       it merely controls the muxing in the axi2cfg block to allow
+ *       the SPI block to take control of the chip select pins.
+ */
+static void
+pc302spi_cs_activate(struct spi_device *spi);
+
+/*!
+ * \brief De-Activate the SPI chip select
+ *
+ * \param spi Pointer to the spi_device struct
+ *
+ * Note: This does not actually negate a chip select,
+ *       it merely controls the muxing in the axi2cfg block to allow
+ *       the EBI block to take control of the chip select pins.
+ */
+static void
+pc302spi_cs_deactivate(struct spi_device *spi);
+
+/*!
+ * Platform driver 'probe' method.
+ *
+ * \param pdev A pointer to the platform_device structure.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+spi_drv_probe(struct platform_device *pdev);
+
+/*!
+ * Platform driver 'remove' method.
+ *
+ * \param pdev A pointer to the platform_device structure.
+ *
+ * \return Zero on success, non zero on error.
+ */
+static int
+spi_drv_remove(struct platform_device *pdev);
+
+/* Functions --------------------------------------------------------------- */
+
+static u16
+spi_ioread16(struct spi_master *master,
+             unsigned int register_offset)
+{
+    struct pc302_spi *priv = spi_master_get_devdata(master);
+    void __iomem *p = priv->regs + register_offset;
+
+    return ioread16(p);
+}
+
+static void
+spi_iowrite16(struct spi_master *master,
+              u16 value,
+              unsigned int register_offset)
+{
+    struct pc302_spi *priv = spi_master_get_devdata(master);
+    void __iomem *p = priv->regs + register_offset;
+
+    iowrite16(value, p);
+}
+
+static int
+pc302spi_setup(struct spi_device *spi)
+{
+    struct spi_master   *master = spi->master;
+    struct pc302_spi *priv = spi_master_get_devdata(master);
+
+    u32 ctrlr0 = 0;
+    u32 sckdv = 0;
+
+    /* Have we been passed a valid combination of bus and cs ?
+     * Note: PC302 device has a single SPI controller (bus) and
+     *       4 possible SPI chip selects
+     */
+    if (master->bus_num > (s16)(PC302_MAX_NUMBER_SPI_BUSSES - 1))
+    {
+        /* Oops, request bus is out of range. */
+        printk(KERN_ERR "%s: SPI 'bus' (%d) out of range. "
+               "(We only have %d SPI bus(ses) available).\n",
+               CARDNAME, (unsigned int)master->bus_num,
+               (unsigned int)PC302_MAX_NUMBER_SPI_BUSSES);
+        return -EINVAL;
+    }
+
+    /* Have we been passed a valid chip select ? */
+    if (spi->chip_select > (u8)(PC302_MAX_NUMBER_SPI_CS - 1))
+    {
+        /* Oops, requested chip select is out of range */
+        printk(KERN_ERR "%s: SPI 'cs' (%d) out of range. "
+               "(We only have %d 'cs' available.\n",
+               CARDNAME, (unsigned int)spi->chip_select,
+               (unsigned int)PC302_MAX_NUMBER_SPI_CS);
+        return -EINVAL;
+    }
+
+    /* Have we been passed a valid number of bits per word ? */
+    if ((spi->bits_per_word == 0) || (spi->bits_per_word != 8))
+    {
+        /* Set default bits per word */
+        spi->bits_per_word = 8;
+    }
+
+    /* Have we been passed a valid SPI bus clock rate ? */
+    if ((spi->max_speed_hz < priv->spi_min_clock) ||
+        (spi->max_speed_hz > priv->spi_max_clock))
+    {
+    	/* Oops, we do not support this requested SPI bus clock rate */
+        printk(KERN_ERR "%s: SPI bus 'hz' (%d) out of range. "
+               "(Min = %d Hz, Max = %d Hz).\n", CARDNAME,
+               (unsigned int)spi->max_speed_hz,
+               priv->spi_min_clock, priv->spi_max_clock);
+        return -EINVAL;
+    }
+
+    /* Have we been passed a valid SPI mode ? */
+    if ((spi->mode & (SPI_CPHA | SPI_CPOL)) != SPI_MODE_3)
+    {
+        /* Oops, we only support spi mode 3 */
+        printk(KERN_ERR "%s: SPI 'mode' out of range. "
+               "(We only support SPI 'mode' %d).\n",
+               CARDNAME, (unsigned int)SPI_MODE_3);
+        return -EINVAL;
+    }
+
+    /* Is the user trying to use active high chip selects ? */
+    if ((spi->mode & SPI_CS_HIGH ) == SPI_CS_HIGH)
+    {
+        /* Oops, we only support active low chip selects */
+        printk(KERN_ERR "%s: Only active low chip selects supported\n",
+               CARDNAME);
+        return -EINVAL;
+    }
+
+    /* Is the user trying to send the data LSB first ? */
+    if ((spi->mode & SPI_LSB_FIRST ) == SPI_LSB_FIRST)
+    {
+        /* Oops, we only support data transmission MSB first */
+        printk(KERN_ERR "%s: Only MSB first data transmission supported\n",
+               CARDNAME);
+        return -EINVAL;
+    }
+
+    /* Disable SPI operations
+     * Note: We can't program up the block registers unless
+     *       the block is disabled
+     */
+    spi_iowrite16(master, PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+    /* Program up some bits in Control Register 0.
+     * Note: As TMOD bits set to 00 (Transmit & Receive),
+     *       we do not need to worry about the ctrlr1 register
+     *
+     * Note: Only 8 bit data supported.
+     */
+    ctrlr0 = PC302_SPI_DATA_FRM_8_BIT;
+
+    /* Set the clock phase */
+    if (spi->mode & SPI_CPHA)
+    {
+        ctrlr0 |= PC302_SPI_SCPH;
+    }
+
+    /* Set the clock polarity */
+    if (spi->mode & SPI_CPOL)
+    {
+        ctrlr0 |= PC302_SPI_SCPOL;
+    }
+
+    spi_iowrite16(master, ctrlr0, SSI_CTRL_REG_0_REG_OFFSET);
+
+    /* Setup the SPI bus clock rate */
+    sckdv = (PC302_AHB_CLOCK_FREQ / spi->max_speed_hz);
+    spi_iowrite16(master, sckdv, SSI_BAUD_RATE_SEL_REG_OFFSET);
+
+    /* Mask all interrupts from the SPI block */
+    spi_iowrite16(master, PC302_SPI_MASK_ALL_INTS, SSI_IMR_REG_OFFSET);
+
+    return SUCCESS;
+}
+
+static void
+pc302spi_cleanup(struct spi_device *spi)
+{
+    struct spi_master   *master = spi->master;
+
+    /* Disable SPI operations */
+    spi_iowrite16(master, PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+}
+
+static int
+pc302spi_transfer(struct spi_device *spi,
+                  struct spi_message *mesg)
+{
+    struct spi_master   *master = spi->master;
+    struct pc302_spi *priv = spi_master_get_devdata(master);
+    struct spi_transfer *transfer = NULL;
+
+    unsigned int num_lists = 0;
+    unsigned int adjust_len = 0;
+
+    int ret = 0;
+
+    char data = 0;
+
+    u16 status = 0;
+
+    u32 sckdv = 0;
+
+    char *tx_buf;
+    char *rx_buf;
+
+    unsigned long flags;
+
+    mesg->actual_length = 0;
+    mesg->status = 0;
+
+    /* Check for invalid messages and transfers */
+    if (list_empty(&mesg->transfers) || !mesg->complete)
+    {
+        return -ENOMSG;
+    }
+
+    /* Count the number list entries */
+    list_for_each_entry(transfer, &mesg->transfers, transfer_list)
+    {
+        num_lists++;
+    }
+
+    /* This driver assumes that we will only ever have 2 messages queued
+     * up. If we have any more then we can't cope !
+     */
+    if (num_lists > PC302_MAX_QUEUED_SPI_MESSAGES)
+    {
+        WARN(1, "%s: Too many SPI messages queued up\n", CARDNAME);
+        return -EMSGSIZE;
+    }
+
+    /* Disable interrupts */
+    local_irq_save(flags);
+
+    list_for_each_entry(transfer, &mesg->transfers, transfer_list)
+    {
+        unsigned int bits_per_word = spi->bits_per_word;
+        unsigned int tx_byte_count = 0;
+        unsigned int byte_count = 0;
+
+        if (transfer == NULL)
+        {
+            ret = -ENOMSG;
+            goto out_msg_rejected;
+        }
+
+        if ((transfer->tx_buf == NULL) &&
+            (transfer->rx_buf == NULL) &&
+            transfer->len)
+        {
+	    printk(KERN_ERR "%s: Message rejected : "
+                   "invalid transfer data buffers\n",
+                   CARDNAME);
+
+	    ret = -EINVAL;
+            goto out_msg_rejected;
+        }
+
+        /* Initialise our 'local' copy of the tx and rx buffer pointers */
+        rx_buf = (char *)transfer->rx_buf;
+        tx_buf = (char *)transfer->tx_buf;
+
+        /* Do we need to adjust the transfer size ? */
+        if (transfer->bits_per_word)
+        {
+            bits_per_word = transfer->bits_per_word;
+        }
+
+        if (bits_per_word != 8)
+        {
+	    printk(KERN_ERR "%s: Message rejected : "
+                   "invalid transfer size (%d bits)\n",
+                   CARDNAME, bits_per_word);
+
+	    ret = -EINVAL;
+            goto out_msg_rejected;
+        }
+
+        /* Do we need to adjust the transfer speed ? */
+        if (transfer->speed_hz &&
+            (transfer->speed_hz < priv->spi_min_clock))
+        {
+	    printk(KERN_ERR "%s: Message rejected : "
+                   "device min speed (%d Hz) exceeds "
+		   "required transfer speed (%d Hz)\n",
+		   CARDNAME, priv->spi_min_clock, transfer->speed_hz);
+
+	    ret = -EINVAL;
+            goto out_msg_rejected;
+        }
+
+        /* Do we need to adjust the transfer speed ? */
+        if (transfer->speed_hz &&
+            (transfer->speed_hz > priv->spi_max_clock))
+        {
+	    printk(KERN_ERR "%s: Message rejected : "
+                   "device max speed (%d Hz) is less than the "
+		   "required transfer speed (%d Hz)\n",
+		   CARDNAME, priv->spi_max_clock, transfer->speed_hz);
+
+	    ret = -EINVAL;
+            goto out_msg_rejected;
+        }
+
+        /* Setup the new SPI bus clock rate */
+        if (transfer->speed_hz)
+        {
+            sckdv = (PC302_AHB_CLOCK_FREQ / transfer->speed_hz);
+            spi_iowrite16(master, sckdv, SSI_BAUD_RATE_SEL_REG_OFFSET);
+        }
+
+        /* Assert the required SPI chip select */
+        pc302spi_cs_activate(spi);
+
+        /* Enable SPI block operations */
+        spi_iowrite16(master, PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+        /* Work out what we are being asked to do.
+         * This is all a bit horrible, and relies on
+         * some knowledge of how this driver will be used !
+         *
+         * Note: This is necessary because the SPI block only asserts
+         *       the chip select when there is data in the tx fifo.
+         */
+
+        if ((tx_buf != NULL) && (rx_buf == NULL) &&
+            (num_lists > 1)  && (priv->local_buf == NULL))
+        {
+            /* This is a multi-part transaction starting with a transmit,
+             * therefore we take a local copy of the pointer to the
+             * data to tx, and the tx data length so we can use it
+             * with the next transaction.
+             *
+             * Remember, we need to be vary careful about the chip select.
+             */
+
+            /* Update our private data */
+            priv->local_buf = tx_buf;
+            priv->byte_count_tx = transfer->len;
+
+            /* We now have a copy of the data so we can null the
+             * tx data pointer.
+             *
+             * Note: This stops this data being transmitted now, and waits
+             *       for the next list transaction to be processed.
+             */
+            tx_buf = NULL;
+        }
+
+        adjust_len = priv->byte_count_tx;
+        for (byte_count = 0; byte_count < (transfer->len + adjust_len); )
+        {
+	    if ((tx_buf == NULL) && (rx_buf == NULL))
+            {
+                /* We can bail out and not do anything here */
+                break;
+            }
+
+            status = spi_ioread16(master, SSI_STATUS_REG_OFFSET);
+
+            /* Transmit data */
+            while (tx_byte_count < priv->byte_count_tx)
+            {
+                /* The Tx fifo is 16 entries deep, we should never fill
+                   this up sending a 'command' to the flash.  Therefore
+                   we do not check the tx fifo status */
+                spi_iowrite16(master, *priv->local_buf++,
+                              SSI_DATA_REG_OFFSET);
+                tx_byte_count++;
+            }
+
+            while ((tx_byte_count < (transfer->len + adjust_len)) &&
+                   (status & PC302_SPI_STATUS_TFNF))
+            {
+                /* Lets just fill the tx fifo */
+                if (tx_buf)
+                {
+                    spi_iowrite16(master, *tx_buf++,
+                                  SSI_DATA_REG_OFFSET);
+                }
+                else
+                {
+                    /* Just transmit zeros */
+                    spi_iowrite16(master, 0, SSI_DATA_REG_OFFSET);
+                }
+                tx_byte_count++;
+
+                /* We may fill the tx fifo, so a re-read of
+                   the status register is a good idea */
+               status = spi_ioread16(master, SSI_STATUS_REG_OFFSET);
+            }
+
+            /* Receive Data */
+            if (status & PC302_SPI_STATUS_RFNE)
+            {
+                /* We have some data available in the receive fifo */
+                if (rx_buf)
+                {
+                    /* We have somewhere to put it */
+                    data = (char)spi_ioread16(master, SSI_DATA_REG_OFFSET);
+
+                    /* If we transmitted any saved data we need to throw
+                     * away priv->byte_count_tx chars from the rx fifo
+                     */
+                    if (priv->byte_count_tx)
+                    {
+                        /* Bin the read data */
+                        priv->byte_count_tx--;
+                    }
+                    else
+                    {
+                        /* Save the read data */
+                        *rx_buf++ = data;
+                    }
+                }
+                else
+                {
+                    /* Just read the fifo and dump the data */
+                    (void)spi_ioread16(master, SSI_DATA_REG_OFFSET);
+                }
+
+                /* Increment the loop count */
+                byte_count++;
+	    }
+        }
+
+        /* wait until the transfer is completely done before we
+         * deactivate CS.
+	 */
+        do
+        {
+            status = spi_ioread16(master, SSI_STATUS_REG_OFFSET);
+            status &= PC302_SPI_STATUS_BUSY;
+
+	 } while (status);
+
+        mesg->actual_length += transfer->len;
+    }
+
+    /* Enable interrupts */
+    local_irq_restore(flags);
+
+    pc302spi_cs_deactivate(spi);
+
+    /* Clear up our private data */
+    if (priv->local_buf)
+    {
+        priv->local_buf = NULL;
+        priv->byte_count_tx = 0;
+    }
+
+    mesg->status = SUCCESS;
+    if (mesg->complete)
+    {
+        mesg->complete(mesg->context);
+    }
+
+    return SUCCESS;
+
+out_msg_rejected:
+    /* Message rejected and not queued */
+
+    /* Enable interrupts */
+    local_irq_restore(flags);
+
+    mesg->status = ret;
+    if (mesg->complete)
+    {
+        mesg->complete(mesg->context);
+    }
+
+    return ret;
+}
+
+static void
+pc302spi_cs_activate(struct spi_device *spi)
+{
+    struct spi_master   *master = spi->master;
+
+    u32 syscfg_mask = (AXI2CFG_DECODE_MUX_0 |
+                       AXI2CFG_DECODE_MUX_1 |
+                       AXI2CFG_DECODE_MUX_2 |
+                       AXI2CFG_DECODE_MUX_3);
+
+    /* Make sure the SPI block is disabled */
+    spi_iowrite16(master, PC302_SPI_DISABLE,
+                  SSI_ENABLE_REG_REG_OFFSET);
+
+    /* Write to the Slave Enable Register */
+    spi_iowrite16(master, (u16)(1 << spi->chip_select),
+                  SSI_SLAVE_ENABLE_REG_OFFSET);
+
+    /* Sort out the SPI/EBI chip select muxing.
+     * Note: Set all chip select muxing to be SPI
+     */
+    syscfg_update(syscfg_mask, 0);
+}
+
+static void
+pc302spi_cs_deactivate(struct spi_device *spi)
+{
+    struct spi_master   *master = spi->master;
+
+    u32 syscfg_mask = (AXI2CFG_DECODE_MUX_0 |
+                       AXI2CFG_DECODE_MUX_1 |
+                       AXI2CFG_DECODE_MUX_2 |
+                       AXI2CFG_DECODE_MUX_3);
+
+    /* Make sure the SPI is disabled */
+    spi_iowrite16(master, PC302_SPI_DISABLE,
+                  SSI_ENABLE_REG_REG_OFFSET);
+
+    /* Write to the Slave Enable Register,
+     * Note: Just disable all chip selects for now
+     */
+    spi_iowrite16(master, PC302_SPI_SLAVES_DISABLE,
+                  SSI_SLAVE_ENABLE_REG_OFFSET);
+
+    /* Sort out the SPI/EBI chip select muxing.
+     * Note: Set all chip select muxing to be EBI
+     */
+    syscfg_update(syscfg_mask, syscfg_mask);
+}
+
+static int
+spi_drv_probe(struct platform_device *pdev)
+{
+    struct resource     *regs;
+    struct spi_master   *master;
+    struct pc302_spi    *priv;
+    int ret;
+
+    regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!regs)
+    {
+        /* Oops, we can't obtain any resources */
+        printk(KERN_ERR "%s: could not obtain platform resources.\n",
+                         CARDNAME);
+        ret = -EINVAL;
+        goto out;
+    }
+
+    if (!request_mem_region(regs->start, (regs->end - regs->start) + 1,
+                            CARDNAME))
+    {
+        /* Oops, we can't obtain the required memory region */
+        printk(KERN_ERR "%s: memory mapping error, Address=0x%08x,"
+                        " Size=0x%08x\n", CARDNAME, regs->start,
+                         (regs->end - regs->start) + 1);
+        ret = -ENOMEM;
+        goto out;
+    }
+
+    master = spi_alloc_master(&pdev->dev, sizeof *priv);
+    if (!master)
+    {
+        /* Oops, something wrong here */
+        printk(KERN_ERR "%s: could not allocate spi_master structure.\n",
+                         CARDNAME);
+        ret = -ENOMEM;
+	goto out_alloc_failed;
+    }
+
+    master->bus_num = pdev->id;
+    master->num_chipselect = 4;
+    master->setup = pc302spi_setup;
+    master->transfer = pc302spi_transfer;
+    master->cleanup = pc302spi_cleanup;
+    platform_set_drvdata(pdev, master);
+
+    priv = spi_master_get_devdata(master);
+
+    priv->regs = ioremap(regs->start, (regs->end - regs->start) + 1);
+    if (!priv->regs)
+    {
+        /* Oops, we can't remap io memory */
+        printk(KERN_ERR "%s: could not remap io addresses.\n",
+                         CARDNAME);
+	ret = -ENOMEM;
+	goto out_ioremap_failed;
+    }
+
+    /* Max clock speed that the SPI block can run at */
+    priv->spi_max_clock = (PC302_AHB_CLOCK_FREQ / PC302_MIN_SPI_CLK_DIVIDER);
+
+    /* Min clock speed that the SPI block can run at */
+    priv->spi_min_clock = (PC302_AHB_CLOCK_FREQ / PC302_MAX_SPI_CLK_DIVIDER);
+
+    /* Initialise some private variables */
+    priv->byte_count_tx = 0;
+    priv->local_buf = NULL;
+
+    ret = spi_register_master(master);
+    if (ret != 0)
+    {
+        /* Oops, we can't register as a spi master */
+        printk(KERN_ERR "%s: could not register a spi master.\n",
+                         CARDNAME);
+	goto out_registration_failed;
+    }
+
+    return SUCCESS;
+
+out_registration_failed:
+
+out_ioremap_failed:
+    iounmap(priv->regs);
+
+out_alloc_failed:
+    release_mem_region (regs->start, (regs->end - regs->start) + 1);
+    spi_master_put(master);
+
+out:
+    printk(KERN_ERR "%s: SPI driver registration failed\n", CARDNAME);
+    return ret;
+}
+
+static int
+spi_drv_remove(struct platform_device *pdev)
+{
+    struct resource     *regs = platform_get_resource
+                                (pdev, IORESOURCE_MEM, 0);
+    struct spi_master   *master = platform_get_drvdata(pdev);
+    struct pc302_spi    *priv = spi_master_get_devdata(master);
+
+    iounmap(priv->regs);
+    release_mem_region(regs->start, (regs->end - regs->start) + 1);
+    spi_unregister_master(master);
+
+    return SUCCESS;
+}
+
+/*!
+ * Platform driver data structure.
+ */
+static struct
+platform_driver spi_driver =
+{
+    .probe      = spi_drv_probe,
+    .remove     = spi_drv_remove,
+    .driver     =
+    {
+        .name   = CARDNAME,
+    }
+};
+
+static int
+spi_init_module(void)
+{
+    int ret = 0;
+
+    /* Register the platform driver */
+    ret = platform_driver_register(&spi_driver);
+    if (ret != 0)
+    {
+        printk(KERN_INFO "%s " CONFIG_LOCALVERSION " failed to loaded\n",
+               TITLE);
+        return ret;
+    }
+
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " loaded\n", TITLE);
+
+    return ret;
+}
+
+static void
+spi_cleanup_module(void)
+{
+    platform_driver_unregister(&spi_driver);
+    printk(KERN_INFO "%s " CONFIG_LOCALVERSION " unloaded\n", TITLE);
+}
+
+module_init(spi_init_module);
+module_exit(spi_cleanup_module);
+
+MODULE_AUTHOR("picoChip");
+MODULE_DESCRIPTION("picoChip PC302 SPI Controller Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/pc302_spi.h b/drivers/spi/pc302_spi.h
new file mode 100644
index 0000000..6308b3c
--- /dev/null
+++ b/drivers/spi/pc302_spi.h
@@ -0,0 +1,71 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file pc302_spi.h
+* \brief Definitions for the PC302 SPI Block.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef PC302_SPI_H
+#define PC302_SPI_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif  /* __cplusplus */
+
+/* Constants --------------------------------------------------------------- */
+
+/* Types ------------------------------------------------------------------- */
+
+/* Macros ------------------------------------------------------------------ */
+#define PC302_MAX_NUMBER_SPI_CS     (4)
+#define PC302_MAX_NUMBER_SPI_BUSSES (1)
+#define PC302_MIN_SPI_CLK_DIVIDER   (2)
+#define PC302_MAX_SPI_CLK_DIVIDER   (65534)
+
+/* SSI_CTRL_REG_0_REG_OFFSET bites */
+#define PC302_SPI_LOOPBACK_MODE     (1 << 11)
+#define PC302_SPI_NORMAL_MODE       (0)
+#define PC302_SPI_TMOD_TX_RX        (0x0)
+#define PC302_SPI_TMOD_TX           (0x1 << 8)
+#define PC302_SPI_TMOD_RX           (0x2 << 8)
+#define PC302_SPI_TMOD_EEPROM_RX    (0x3 << 8)
+#define PC302_SPI_SCPOL             (1 << 7)
+#define PC302_SPI_SCPH              (1 << 6)
+#define PC302_SPI_MOTO_FORMAT       (0x0)
+#define PC302_SPI_DATA_FRM_8_BIT    (0x7)
+
+
+/* SSI_ENABLE_REG_REG_OFFSET bits */
+#define PC302_SPI_ENABLE            (1)
+#define PC302_SPI_DISABLE           (0)
+
+/* SSI_SLAVE_ENABLE_REG_OFFSET bits */
+#define PC302_SPI_SLAVES_DISABLE    (0)
+
+/* SSI_STATUS_REG_OFFSET bits */
+#define PC302_SPI_STATUS_DCOL       (1 << 6)
+#define PC302_SPI_STATUS_TXE        (1 << 5)
+#define PC302_SPI_STATUS_RFF        (1 << 4)
+#define PC302_SPI_STATUS_RFNE       (1 << 3)
+#define PC302_SPI_STATUS_TFE        (1 << 2)
+#define PC302_SPI_STATUS_TFNF       (1 << 1)
+#define PC302_SPI_STATUS_BUSY       (1 << 0)
+
+/* SSI_IMR_REG_RESET bits */
+#define PC302_SPI_MASK_ALL_INTS     (0xFFFF)
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif /* PC302_SPI_H */
diff --git a/drivers/spi/spi_pc202_gpio.c b/drivers/spi/spi_pc202_gpio.c
new file mode 100644
index 0000000..b5301e5
--- /dev/null
+++ b/drivers/spi/spi_pc202_gpio.c
@@ -0,0 +1,528 @@
+/**
+ * \file pc202spi.c
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright 2009 picoChip Designs LTD, All Rights Reserved.
+ * http://www.picochip.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This file implements an SPI driver for PC202
+ * Taken from spi_s3c24xx_gpio.c
+ *
+ * PC202 GPIO based SPI driver
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <linux/picochip/gpio.h>
+#include <linux/picochip/devices/pc202.h>
+
+#include <mach/hardware.h>
+#include <mach/spi-gpio.h>
+#include <mach/gpio_assignment.h>
+
+/* Internal state data structure */
+struct pc202_spigpio {
+    /* Bitbang helper context */
+    struct spi_bitbang bitbang;
+
+    /* platform data passed at probe time */
+    struct firecracker_spigpio_info *info;
+};
+
+/* Conversion functions from bit fields to pin numbers */
+static int
+gpio_set_pin_high(u8 pin)
+{
+    /* This function will set one or more pins supplied from the pin bit field.
+       gpio_set_value() accepts a single pin number. Value must be 0 or
+       non-zero */
+
+    int ret = 0;
+    unsigned n = 0;
+    while(pin)
+    {
+        if (pin & (1 << n))
+        {
+            ret = gpio_set_value(PC202_GPIO_PIN_ARM_0+n, 1);
+            if (ret < 0)
+            {
+                return ret;
+            }
+            pin &= ~(1<< n);
+        }
+        n++;
+    }
+
+    return 0;
+}
+
+static int
+gpio_set_pin_low(u8 pin)
+{
+    /* This function will set one or more pins supplied from the pin bit field.
+       gpio_set_value() accepts a single pin number. Value must be 0 or
+       non-zero */
+
+    int ret = 0;
+    unsigned n=0;
+    while(pin)
+    {
+        if (pin & (1 << n))
+        {
+            ret = gpio_set_value(PC202_GPIO_PIN_ARM_0+n, 0);
+            if (ret < 0)
+            {
+                return ret;
+            }
+
+            pin &= ~(1<< n);
+        }
+        n++;
+    }
+
+    return 0;
+}
+
+static int
+gpio_get_pin_state(u8 pin)
+{
+    /* This function returns the state of one or more pins supplied in the
+       pin bit field. gpio_get_value() accepts a single pin number and
+       returns a zero or non-zero number */
+
+    int ret = 0;
+    unsigned n=0;
+    while(pin)
+    {
+        if (pin & (1 << n))
+        {
+            int value = gpio_get_value(PC202_GPIO_PIN_ARM_0+n);
+            if (value < 0)
+            {
+                return value;
+            }
+            else if (value != 0)
+            {
+                ret |= (1 << n);
+            }
+
+            pin &= ~(1<< n);
+        }
+        n++;
+    }
+
+    return ret;
+}
+
+static int
+gpio_set_pin_input(u8 pin)
+{
+    /* This function will set the direction of one or more gpio supplied in
+       the pin bit field */
+
+    int ret = 0;
+    unsigned n=0;
+    while(pin)
+    {
+        if (pin & (1 << n))
+        {
+            ret = gpio_direction_input(PC202_GPIO_PIN_ARM_0+n);
+            if (ret < 0)
+            {
+                return ret;
+            }
+
+            pin &= ~(1<< n);
+        }
+        n++;
+    }
+
+    return 0;
+}
+ 
+static int
+gpio_set_pin_output(u8 pin)
+{
+    /* This function will set the direction of one or more gpio supplied in
+       the pin bit field */
+
+    int ret = 0;
+    unsigned n=0;
+    while(pin)
+    {
+        if (pin & (1 << n))
+        {
+            ret = gpio_direction_output(PC202_GPIO_PIN_ARM_0+n, 0);
+            if (ret < 0)
+            {
+                return ret;
+            }
+
+            pin &= ~(1<< n);
+        }
+        n++;
+    }
+
+    return 0;
+}
+
+static int
+GPIO_REQUEST( unsigned pin,
+              const char *label )
+{
+    /* This function will convert the pin bit field into a series of calls
+       using a single pin number */
+
+    int ret = 0;
+    unsigned n=0;
+    while(pin)
+    {
+        if (pin & (1 << n))
+        {
+            ret = gpio_request(PC202_GPIO_PIN_ARM_0+n, label);
+            if (ret < 0)
+            {
+                return ret;
+            }
+
+            pin &= ~(1<< n);
+        }
+        n++;
+    }
+
+    return 0;
+}
+ 
+static void
+GPIO_FREE( unsigned pin )
+{
+    /* This function will convert the pin bit field into a series of calls
+       using a single pin number */
+
+    unsigned n=0;
+    while(pin)
+    {
+        if (pin & (1 << n))
+        {
+            gpio_free(PC202_GPIO_PIN_ARM_0+n);
+            pin &= ~(1<< n);
+        }
+        n++;
+    }
+}
+ 
+/* Get out internal state from the spi device */
+static inline struct pc202_spigpio *spidev_to_sg(struct spi_device *spi)
+{
+    return spi->controller_data;
+}
+
+/* Called by the bitbanged code to set the clock pin */
+static inline void setsck(struct spi_device *dev, int on)
+{
+    struct pc202_spigpio *sg = spidev_to_sg(dev);
+    int ret;
+
+    if (on) 
+    {
+        ret = gpio_set_pin_high(sg->info->pin_clk);
+        if ( ret )
+            printk( KERN_ALERT "failed to set GPIO value (high) "
+                "for clk pin(s) 0x%08x\n", sg->info->pin_clk );
+    }
+    else
+    {
+        ret = gpio_set_pin_low(sg->info->pin_clk);
+        if ( ret )
+            printk( KERN_ALERT "failed to set GPIO value (low) "
+                "for clk pin(s) 0x%08x\n", sg->info->pin_clk );
+    }
+}
+
+/* Called by the bitbanged code to set the mosi pin */
+static inline void setmosi(struct spi_device *dev, int on)
+{
+    struct pc202_spigpio *sg = spidev_to_sg(dev);
+    int ret;
+
+    if (on)
+    {
+        ret = gpio_set_pin_high(sg->info->pin_mosi);
+        if ( ret )
+            printk( KERN_ALERT "failed to set GPIO value (high) for "
+                "mosi pin(s) 0x%08x\n",
+                sg->info->pin_mosi );
+    }
+    else
+    {
+        ret = gpio_set_pin_low(sg->info->pin_mosi);
+        if ( ret )
+            printk( KERN_ALERT "failed to set GPIO value (low) for "
+                "mosi pin(s) 0x%08x\n", sg->info->pin_mosi );
+    }
+}
+
+/* Called by the bitbanged code to get the miso pin */
+static inline u32 getmiso(struct spi_device *dev)
+{
+    int ret;
+    struct pc202_spigpio *sg = spidev_to_sg(dev);
+    ret = gpio_get_pin_state(sg->info->pin_miso);
+    if (ret < 0)
+        printk( KERN_ALERT "failed to read GPIO value for miso pin %dd\n",
+            sg->info->pin_miso );
+    return ret ? 1 : 0; 
+}
+
+/* Called by the bitbanged code to do a delay */
+#define spidelay(x) ndelay(x)
+
+/* Include the bitbanged code */
+#define EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+
+/* Called by the bitbanged code to send and receive in mode 0 or 2. This
+ * function relies on bitbanged code for its operation
+ */
+static u32 pc202_spigpio_txrx_mode0(struct spi_device *spi,
+        unsigned nsecs, u32 word, u8 bits)
+{
+    printk(KERN_DEBUG "spi txrx0 mode%u word = 0x%08x, bits=%u\n",
+          spi->mode, word, bits);
+    return bitbang_txrx_be_cpha0(
+            spi, nsecs, (spi->mode & SPI_CPOL) ? 1 : 0, word, bits);
+}
+
+/* Called by the bitbanged code to send and receive in mode 1 or 3. This
+ * function relies on bitbanged code for its operation
+ */
+static u32 pc202_spigpio_txrx_mode1(struct spi_device *spi,
+        unsigned nsecs, u32 word, u8 bits)
+{
+    printk(KERN_DEBUG "spi txrx1 mode%u word = 0x%08x, bits=%u\n",
+         spi->mode, word, bits);
+    return bitbang_txrx_be_cpha1(
+            spi, nsecs, (spi->mode & SPI_CPOL) ? 1 : 0, word, bits);
+}
+
+/* Called by the bitbanged code to select the chip */
+static void pc202_spigpio_chipselect(struct spi_device *dev, int value)
+{
+    struct pc202_spigpio *sg = spidev_to_sg(dev);
+    int ret;
+    int gpio_pin = dev->chip_select == 0 ? ARM_GPIO_SPI_CS0 : ARM_GPIO_SPI_CS1;
+
+    /* Reset any active chip selects */
+    ret = gpio_set_pin_low(sg->info->pin_cs);
+    if (ret)
+        printk( KERN_ALERT "failed to set GPIO value (low) for cs pin(s) "
+            "0x%08x\n", sg->info->pin_cs );
+
+    /* If the chip is to be activated, set its chip select pattern */
+    if (value == BITBANG_CS_ACTIVE)
+    {
+        printk(KERN_DEBUG "spi CS high 0x%02x\n", dev->chip_select);
+        ret = gpio_set_pin_high(gpio_pin);
+        if (ret)
+            printk(KERN_ALERT "failed to set GPIO value (high) for gpio "
+                "pin(s) 0x%08x (ret=%d)\n", gpio_pin, ret ); 
+    }
+    else
+    {
+        printk(KERN_DEBUG "spi CS low\n");
+
+        /* Provide one clock cycle to reset the SPI transfer */
+        setsck(dev, 0);
+        setsck(dev, 1);
+    }
+}
+
+
+/* Probe function for the GPIO bitbashed SPI. This uses the bitbash helper
+ * code for its implementation.
+ */
+static int pc202_spigpio_probe(struct platform_device *dev)
+{
+    struct spi_master   *master;
+    struct pc202_spigpio  *sp;
+    int ret;
+    int i;
+
+    master = spi_alloc_master(&dev->dev, sizeof(struct pc202_spigpio));
+    if (master == NULL) {
+        dev_err(&dev->dev, "failed to allocate spi master\n");
+        ret = -ENOMEM;
+        goto err;
+    }
+
+    sp = spi_master_get_devdata(master);
+
+    platform_set_drvdata(dev, sp);
+
+    /* We have 2 masters - one for each FPGA. */
+    master->num_chipselect = 2;
+    master->bus_num = 0;
+
+    /* copy in the platform data */
+    sp->info = dev->dev.platform_data;
+
+    /* setup spi bitbang adaptor */
+    sp->bitbang.master = spi_master_get(master);
+    sp->bitbang.chipselect = pc202_spigpio_chipselect;
+
+    sp->bitbang.txrx_word[SPI_MODE_0] = pc202_spigpio_txrx_mode0;
+    sp->bitbang.txrx_word[SPI_MODE_1] = pc202_spigpio_txrx_mode1;
+    sp->bitbang.txrx_word[SPI_MODE_2] = pc202_spigpio_txrx_mode0;
+    sp->bitbang.txrx_word[SPI_MODE_3] = pc202_spigpio_txrx_mode1;
+
+    /* acquire spi pins */
+    ret = GPIO_REQUEST(sp->info->pin_clk, "SPI CLK");
+    if (ret)
+        printk( KERN_ALERT "failed to acquire SPI CLK pin(s) 0x%08x\n",
+            sp->info->pin_clk );
+
+    ret = GPIO_REQUEST(sp->info->pin_mosi, "SPI MOSI");
+    if (ret)
+        printk( KERN_ALERT "failed to acquire SPI MOSI pin(s) 0x%08x\n",
+            sp->info->pin_mosi );
+
+    ret = GPIO_REQUEST(sp->info->pin_cs, "SPI CS");
+    if (ret)
+        printk(KERN_ALERT "failed to acquire SPI CS pin(s) 0x%08x\n",
+            sp->info->pin_cs );
+
+    ret = GPIO_REQUEST(sp->info->pin_miso, "SPI MISO");
+    if (ret)
+        printk(KERN_ALERT "failed to acquire SPI MISO pin(s) 0x%08x\n",
+            sp->info->pin_miso );
+
+    /* set state of spi pins */
+    ret = gpio_set_pin_low(sp->info->pin_clk);
+    if (ret)
+        printk(KERN_ALERT "failed to set GPIO value (low) for clk pin(s) "
+            "0x%08x\n", sp->info->pin_clk );
+
+    ret = gpio_set_pin_low(sp->info->pin_mosi);
+    if (ret)
+        printk( KERN_ALERT "failed to set GPIO value (low) for mosi pin(s) "
+            "0x%08x\n", sp->info->pin_mosi );
+
+    ret = gpio_set_pin_low(sp->info->pin_cs);
+    if (ret)
+        printk(KERN_ALERT "failed to set GPIO value (low) for cs pin(s) "
+            "0x%08x\n", sp->info->pin_cs );
+
+    /* Set the pin directions */
+    ret = gpio_set_pin_output(sp->info->pin_clk);
+    if (ret)
+        printk(KERN_ALERT "failed to set GPIO direction (output) for clk "
+            "pin(s) 0x%08x\n", sp->info->pin_clk );
+
+    ret = gpio_set_pin_output(sp->info->pin_mosi);
+    if (ret)
+        printk(KERN_ALERT "failed to set GPIO direction (output) for mosi "
+            "pin(s) 0x%08x\n", sp->info->pin_mosi );
+
+    ret = gpio_set_pin_input(sp->info->pin_miso);
+    if (ret)
+        printk(KERN_ALERT "failed to set GPIO direction (input) for miso "
+            "pin(s) 0x%08x\n", sp->info->pin_miso );
+
+    ret = gpio_set_pin_output(sp->info->pin_cs);
+    if (ret)
+        printk(KERN_ALERT "failed to set GPIO direction (output) for cs pin(s) "
+            "0x%08x\n", sp->info->pin_cs );
+
+    ret = spi_bitbang_start(&sp->bitbang);
+    if (ret)
+        goto err_no_bitbang;
+
+    /* register the chips to go with the board */
+
+    for (i = 0; i < sp->info->board_size; i++) {
+        dev_info(&dev->dev, "registering %p: %s\n",
+                &sp->info->board_info[i],
+                sp->info->board_info[i].modalias);
+
+        sp->info->board_info[i].controller_data = sp;
+        spi_new_device(master, sp->info->board_info + i);
+    }
+
+    return 0;
+
+err_no_bitbang:
+    spi_master_put(sp->bitbang.master);
+err:
+    return ret;
+
+}
+
+/* Remove the GPIO bitbashed SPI interface */
+static int pc202_spigpio_remove(struct platform_device *dev)
+{
+    struct pc202_spigpio *sp = platform_get_drvdata(dev);
+
+    spi_bitbang_stop(&sp->bitbang);
+    spi_master_put(sp->bitbang.master);
+
+    GPIO_FREE(sp->info->pin_clk);
+    GPIO_FREE(sp->info->pin_mosi);
+    GPIO_FREE(sp->info->pin_cs);
+    GPIO_FREE(sp->info->pin_miso);
+
+    return 0;
+}
+
+/* all gpio should be held over suspend/resume, so we should
+ * not need to deal with this
+ */
+
+#define pc202_spigpio_suspend NULL
+#define pc202_spigpio_resume NULL
+
+/* GPIO bitbashed SPI interface declaration structure */
+static struct platform_driver pc202_spigpio_drv = {
+    .probe      = pc202_spigpio_probe,
+    .remove     = pc202_spigpio_remove,
+    .suspend    = pc202_spigpio_suspend,
+    .resume     = pc202_spigpio_resume,
+    .driver     = {
+        .name   = "pc20x-spi-gpio",
+        .owner  = THIS_MODULE,
+    },
+};
+
+/* Module initialisation, declare the SPI interface */
+static int __init pc202_spigpio_init(void)
+{
+    printk("pc20x SPI-GPIO driver, version 0.01 loaded\n");
+    return platform_driver_register(&pc202_spigpio_drv);
+}
+
+/* Module shut-down, remove the SPI interface */
+static void __exit pc202_spigpio_exit(void)
+{
+    platform_driver_unregister(&pc202_spigpio_drv);
+}
+
+module_init(pc202_spigpio_init);
+module_exit(pc202_spigpio_exit);
+
+MODULE_DESCRIPTION("pc20x bitbang SPI Driver");
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index 8b7c419..3e7f70a 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_USB_SL811_HCD)	+= host/
 obj-$(CONFIG_USB_U132_HCD)	+= host/
 obj-$(CONFIG_USB_R8A66597_HCD)	+= host/
 obj-$(CONFIG_USB_HWA_HCD)	+= host/
+obj-$(CONFIG_USB_ISP1760_HCD)	+= host/
 
 obj-$(CONFIG_USB_C67X00_HCD)	+= c67x00/
 
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index f3a75a9..0208326 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -110,7 +110,7 @@ config USB_ISP116X_HCD
 
 config USB_ISP1760_HCD
 	tristate "ISP 1760 HCD support"
-	depends on USB && EXPERIMENTAL && (PCI || PPC_OF)
+	depends on USB && EXPERIMENTAL
 	---help---
 	  The ISP1760 chip is a USB 2.0 host controller.
 
diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c
index 8017f1c..7299b72 100644
--- a/drivers/usb/host/isp1760-hcd.c
+++ b/drivers/usb/host/isp1760-hcd.c
@@ -820,6 +820,8 @@ static void enqueue_an_ATL_packet(struct usb_hcd *hcd, struct isp1760_qh *qh,
 	u32 atl_regs, payload;
 	u32 buffstatus;
 
+	/* wait for the SKIPMAP register to be updated */
+	udelay(1);
 	skip_map = isp1760_readl(hcd->regs + HC_ATL_PTD_SKIPMAP_REG);
 
 	BUG_ON(!skip_map);
@@ -854,6 +856,8 @@ static void enqueue_an_INT_packet(struct usb_hcd *hcd, struct isp1760_qh *qh,
 	u32 int_regs, payload;
 	u32 buffstatus;
 
+	/* wait for the SKIPMAP register to be updated */
+	udelay(1);
 	skip_map = isp1760_readl(hcd->regs + HC_INT_PTD_SKIPMAP_REG);
 
 	BUG_ON(!skip_map);
@@ -2236,9 +2240,10 @@ void deinit_kmem_cache(void)
 	kmem_cache_destroy(qh_cachep);
 }
 
-struct usb_hcd *isp1760_register(u64 res_start, u64 res_len, int irq,
-		u64 irqflags, struct device *dev, const char *busname,
-		unsigned int devflags)
+struct usb_hcd *isp1760_register(phys_addr_t res_start, resource_size_t res_len,
+				 int irq, unsigned long irqflags,
+				 struct device *dev, const char *busname,
+				 unsigned int devflags)
 {
 	struct usb_hcd *hcd;
 	struct isp1760_hcd *priv;
diff --git a/drivers/usb/host/isp1760-hcd.h b/drivers/usb/host/isp1760-hcd.h
index 4377277..9f9f0bd 100644
--- a/drivers/usb/host/isp1760-hcd.h
+++ b/drivers/usb/host/isp1760-hcd.h
@@ -2,9 +2,10 @@
 #define _ISP1760_HCD_H_
 
 /* exports for if */
-struct usb_hcd *isp1760_register(u64 res_start, u64 res_len, int irq,
-		u64 irqflags, struct device *dev, const char *busname,
-		unsigned int devflags);
+struct usb_hcd *isp1760_register(phys_addr_t res_start, resource_size_t res_len,
+				 int irq, unsigned long irqflags,
+				 struct device *dev, const char *busname,
+				 unsigned int devflags);
 int init_kmem_once(void);
 void deinit_kmem_cache(void);
 
diff --git a/drivers/usb/host/isp1760-if.c b/drivers/usb/host/isp1760-if.c
index b87ca7c..a1a3cfa 100644
--- a/drivers/usb/host/isp1760-if.c
+++ b/drivers/usb/host/isp1760-if.c
@@ -10,6 +10,7 @@
 
 #include <linux/usb.h>
 #include <linux/io.h>
+#include <linux/platform_device.h>
 
 #include "../core/hcd.h"
 #include "isp1760-hcd.h"
@@ -286,39 +287,101 @@ static struct pci_driver isp1761_pci_driver = {
 };
 #endif
 
+static int __devinit isp1760_plat_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct usb_hcd *hcd;
+	struct resource *mem_res;
+	struct resource *irq_res;
+	resource_size_t mem_size;
+	unsigned long irqflags = IRQF_SHARED | IRQF_DISABLED;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		pr_warning("isp1760: Memory resource not available\n");
+		ret = -ENODEV;
+		goto out;
+	}
+	mem_size = resource_size(mem_res);
+	if (!request_mem_region(mem_res->start, mem_size, "isp1760")) {
+		pr_warning("isp1760: Cannot reserve the memory resource\n");
+		ret = -EBUSY;
+		goto out;
+	}
+
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq_res) {
+		pr_warning("isp1760: IRQ resource not available\n");
+		return -ENODEV;
+	}
+	irqflags |= irq_res->flags & IRQF_TRIGGER_MASK;
+
+	hcd = isp1760_register(mem_res->start, mem_size, irq_res->start,
+			       irqflags, &pdev->dev, dev_name(&pdev->dev), 0);
+	if (IS_ERR(hcd)) {
+		pr_warning("isp1760: Failed to register the HCD device\n");
+		ret = -ENODEV;
+		goto cleanup;
+	}
+
+	pr_info("ISP1760 USB device initialised\n");
+	return ret;
+
+cleanup:
+	release_mem_region(mem_res->start, mem_size);
+out:
+	return ret;
+}
+
+static int __devexit isp1760_plat_remove(struct platform_device *pdev)
+{
+	struct resource *mem_res;
+	resource_size_t mem_size;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mem_size = resource_size(mem_res);
+	release_mem_region(mem_res->start, mem_size);
+
+	return 0;
+}
+
+static struct platform_driver isp1760_plat_driver = {
+	.probe	= isp1760_plat_probe,
+	.remove	= isp1760_plat_remove,
+	.driver	= {
+		.name	= "isp1760",
+	},
+};
+
 static int __init isp1760_init(void)
 {
-	int ret;
+	int ret, any_ret = -ENODEV;
 
 	init_kmem_once();
 
+	ret = platform_driver_register(&isp1760_plat_driver);
+	if (!ret)
+		any_ret = 0;
 #ifdef CONFIG_PPC_OF
 	ret = of_register_platform_driver(&isp1760_of_driver);
-	if (ret) {
-		deinit_kmem_cache();
-		return ret;
-	}
+	if (!ret)
+		any_ret = 0;
 #endif
 #ifdef CONFIG_PCI
 	ret = pci_register_driver(&isp1761_pci_driver);
-	if (ret)
-		goto unreg_of;
+	if (!ret)
+		any_ret = 0;
 #endif
-	return ret;
 
-#ifdef CONFIG_PCI
-unreg_of:
-#endif
-#ifdef CONFIG_PPC_OF
-	of_unregister_platform_driver(&isp1760_of_driver);
-#endif
-	deinit_kmem_cache();
-	return ret;
+	if (any_ret)
+		deinit_kmem_cache();
+	return any_ret;
 }
 module_init(isp1760_init);
 
 static void __exit isp1760_exit(void)
 {
+	platform_driver_unregister(&isp1760_plat_driver);
 #ifdef CONFIG_PPC_OF
 	of_unregister_platform_driver(&isp1760_of_driver);
 #endif
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 4fd3fa5..0b10197 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -233,6 +233,16 @@ config ORION5X_WATCHDOG
 	  To compile this driver as a module, choose M here: the
 	  module will be called orion5x_wdt.
 
+config PC302_WATCHDOG
+	tristate "PC302 watchdog"
+	depends on ARCH_PC302
+        select WATCHDOG_NOWAYOUT
+	help
+	  Say Y here if to include support for the watchdog timer
+	  in the picoChip PC302 processors.
+	  To compile this driver as a module, choose M here: the
+	  module will be called pc302_wdt.
+
 # ARM26 Architecture
 
 # AVR32 Architecture
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index e352bbb..01a705b 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -41,6 +41,7 @@ obj-$(CONFIG_PNX4008_WATCHDOG) += pnx4008_wdt.o
 obj-$(CONFIG_IOP_WATCHDOG) += iop_wdt.o
 obj-$(CONFIG_DAVINCI_WATCHDOG) += davinci_wdt.o
 obj-$(CONFIG_ORION5X_WATCHDOG) += orion5x_wdt.o
+obj-$(CONFIG_PC302_WATCHDOG) += pc302_wdt.o
 
 # ARM26 Architecture
 
diff --git a/drivers/watchdog/pc302_wdt.c b/drivers/watchdog/pc302_wdt.c
new file mode 100644
index 0000000..2dd78ff
--- /dev/null
+++ b/drivers/watchdog/pc302_wdt.c
@@ -0,0 +1,755 @@
+/**
+ *
+ * \file pc302_wdt.c
+ *
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright 2008 picoChip Designs LTD, All Rights Reserved.
+ * http://www.picochip.com
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This file implements a driver for the picoChip PC302 watchdog device in the
+ * ARM subsystem.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/device.h>
+#include <linux/watchdog.h>
+#include <linux/fs.h>
+#include <linux/sysfs.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <linux/interrupt.h>
+#include <mach/reset.h>
+
+/**
+ * The name used for the platform device and driver to allow Linux to match
+ * them up.
+ */
+#define CARDNAME    "pc302wdt"
+
+/**
+ * The maximum TOP value that can be set in the watchdog.
+ */
+#define PC302_WDOG_MAX_TOP   ( 15 )
+
+/**
+ * The number of times the counter is decremented every second.
+ */
+#define PC302_WDOG_TICKS_PER_SECOND  ( 200000000 )
+
+/**
+ * The number of possible timeout values.
+ */
+#define PC302_WDT_NUM_TIMEOUTS  ( 16 )
+
+/**
+ * Open the watchdog driver device file.
+ */
+static int pc302wdt_open( struct inode *inode,
+                    struct file *filp );
+
+/**
+ * Write to the watchdog device. Note that the values that are written are
+ * discarded, writing simply pokes the watchdog.
+ */
+static ssize_t pc302wdt_write( struct file *filp,
+                         const char __user *buf,
+                         size_t len,
+                         loff_t *offset );
+
+/**
+ * ioctl() call for the watchdog device driver. Used to set the timeout, poke
+ * the hardware and to get the current timeout value.
+ */
+static int pc302wdt_ioctl( struct inode *inode,
+                     struct file *filp,
+                     unsigned int cmd,
+                     unsigned long arg );
+
+/**
+ * Release method for the watchdog device driver. Removes all sysfs files and
+ * deregisters the device.
+ */
+static int pc302wdt_release( struct inode *inodw,
+                       struct file *filp );
+
+/**
+ * Set the timeout period for the watchdog.
+ *
+ * \param top_s The timeout period (in seconds).
+ * \return Returns the value that was set on success, negative on failure.
+ */
+static int pc302wdt_set_top( unsigned top_s );
+
+/**
+ * Add the sysfs files. This should only be done once per module insertion.
+ */
+static void pc302wdt_sysfs_add( void );
+
+/**
+ * Poke the watchdog to prevent it from expiring.
+ */
+static void pc302wdt_keepalive( void );
+
+/**
+ * Remove the sysfs files.
+ */
+static void pc302wdt_sysfs_remove( void );
+
+/**
+ * Check if the watchdog is enabled. This uses the contents of the control
+ * register in case the module is reloaded.
+ *
+ * \return Returns non-zero if enabled, zero if disabled.
+ */
+static int pc302wdt_is_enabled( void );
+
+/**
+ * Check if the pretimeout is enabled. This uses the contents of the control
+ * register in case the module is reloaded.
+ *
+ * \return Returns non-zero if enabled, zero if disabled.
+ */
+static int pc302wdt_pretimeout_used( void );
+
+/**
+ * Set the pretimeout.
+ *
+ * \param timeout The timeout value to use (in seconds).
+ * \return Returns the new pretimeout value.
+ */
+static int pc302wdt_set_pretimeout( int timeout );
+
+/**
+ * Get the time left until the WDT expires (in seconds).
+ *
+ * \return Returns the time left (in seconds).
+ */
+static u32 pc302wdt_time_left( void );
+
+/**
+ * ISR for the watchdog timer expiry. This routine will clear the interrupt
+ * and the watchdog will begin decrementing again. When the pretimeout is
+ * enabled, as long as this ISR returns, the system will not reset.
+ */
+static irqreturn_t pc302wdt_isr( int irq, void *dev );
+
+/**
+ * Probe function for the driver. When the module gets loaded, the kernel
+ * should use the cardname to match this driver to the watchdog
+ * platform_device.
+ *
+ * \param pdev The platform_device that this driver should drive.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int pc302wdt_drv_probe( struct platform_device *pdev );
+
+/**
+ * Removal method for the driver. This will get called when the module is
+ * unloaded and the driver is unregistered.
+ *
+ * \param pdev The platform_device that is being unloaded.
+ * \return Returns zero on success, non-zero on failure.
+ */
+static int pc302wdt_drv_remove( struct platform_device *pdev );
+
+/**
+ * File operations for the watchdog device driver.
+ */
+static struct file_operations wdt_fops = {
+    .open = pc302wdt_open,
+    .write = pc302wdt_write,
+    .ioctl = pc302wdt_ioctl,
+    .release = pc302wdt_release
+};
+
+/**
+ * Reset the platform by causing the watchdog to expire.
+ *
+ * \param mode Not used.
+ * \param cookie Not used.
+ */
+static void pc302wdt_platform_reset( char mode,
+                                     void *cookie );
+
+static struct {
+
+    /**
+     * Internal data structures for the watchdog device driver.
+     */
+    struct miscdevice dev;
+
+    /**
+     * The platform device that the driver interfaces with. Used for the sysfs
+     * entries.
+     */
+    struct platform_device *pdev;
+
+    /**
+     * The current timeout value (in seconds) of the watchdog.
+     */
+    unsigned int top;
+
+    /**
+     * Boolean flag for the enabled status of the watchdog.
+     */
+    int enabled;
+
+    /**
+     * Lock for the structure.
+     */
+    spinlock_t lock;
+
+    /**
+     * The memory region that maps the registers.
+     */
+    void __iomem *mem_region;
+
+    /**
+     * Boolean flag for using pretimeout. If enabled, the watchdog will
+     * generate an interrupt and restart the counter before resetting.
+     */
+    int use_pretimeout;
+
+    /**
+     * Boolean flag for doing a system reset. If set, then kicking the
+     * watchdog should have no effect.
+     */
+    int reset_pending;
+
+} pc302wdt_int = {
+
+    .dev = {
+        .fops = &wdt_fops,
+        .name = "watchdog",
+        .minor = WATCHDOG_MINOR
+    },
+
+    .lock = __SPIN_LOCK_UNLOCKED( lock ),
+
+    .top = 15,
+    
+    .mem_region = NULL,
+
+    .use_pretimeout = 0,
+
+    .reset_pending = 0,
+};
+
+/**
+ * The PC302 watchdog supports 16 different timeout values, but 12 of these
+ * values are all sub-1-second. As the watchdog API uses 1 second resolution,
+ * these values aren't useful. These values are fixed in hardware and based on
+ * the peripheral clock running at 200MHz.
+ *
+ * The timeout values in seconds. When selecting a timeout value, the driver
+ * should find the timeout that is at least the requested value if possible.
+ * If the requested value is larger than the maximum timeout, use the maximum.
+ */
+static const unsigned pc302wdt_timeouts[ 16 ] =
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 5, 10 };
+
+/*
+ * Show the current timeout value (in seconds) that the WDT is configured for.
+ */
+static ssize_t
+pc302wdt_sysfs_timeout_show( struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf )
+{
+    int ret;
+
+    spin_lock( &pc302wdt_int.lock );
+    ret = sprintf( buf, "%d\n", pc302wdt_int.enabled ?
+                        pc302wdt_timeouts[ pc302wdt_int.top ] : -1 );
+    spin_unlock( &pc302wdt_int.lock );
+
+    return ret;
+}
+
+static DEVICE_ATTR( timeout, S_IRUGO, pc302wdt_sysfs_timeout_show, NULL );
+
+/*
+ * Show whether the WDT is currently enabled or not.
+ */
+static ssize_t
+pc302wdt_sysfs_enabled_show( struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf )
+{
+    int ret;
+
+    spin_lock( &pc302wdt_int.lock );
+    ret = sprintf( buf, "%c\n", pc302wdt_int.enabled ? '1' : '0' );
+    spin_unlock( &pc302wdt_int.lock );
+
+    return ret;
+}
+
+static DEVICE_ATTR( enabled, S_IRUGO, pc302wdt_sysfs_enabled_show, NULL );
+
+/*
+ * Show whether the pretimeout is currently enabled or not.
+ */
+static ssize_t
+pc302wdt_sysfs_pretimeout_show( struct device *dev,
+                                struct device_attribute *attr,
+                                char *buf )
+{
+    int ret;
+
+    spin_lock( &pc302wdt_int.lock );
+    ret = sprintf( buf, "%d\n", pc302wdt_int.use_pretimeout ?
+                        pc302wdt_timeouts[ pc302wdt_int.top ] : -1 );
+    spin_unlock( &pc302wdt_int.lock );
+
+    return ret;
+}
+
+static DEVICE_ATTR( pretimeout, S_IRUGO, pc302wdt_sysfs_pretimeout_show,
+                    NULL );
+
+/*
+ * Show the current value of the counter in the WDT.
+ */
+static ssize_t
+pc302wdt_sysfs_counter_show( struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf )
+{
+    u32 ccv;
+
+    spin_lock( &pc302wdt_int.lock );
+    ccv = ioread32( pc302wdt_int.mem_region +
+                    WDOG_CURRENT_COUNT_REG_OFFSET );
+    spin_unlock( &pc302wdt_int.lock );
+
+    return sprintf( buf, "%u\n", ccv );
+}
+
+static DEVICE_ATTR( counter, S_IRUGO, pc302wdt_sysfs_counter_show, NULL );
+
+/*
+ * Show the time left until the WDT fires.
+ */
+static ssize_t
+pc302wdt_sysfs_time_left_show( struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf )
+{
+    int ret;
+
+    spin_lock( &pc302wdt_int.lock );
+    ret = sprintf( buf, "%i\n",
+                    pc302wdt_int.enabled ? pc302wdt_time_left() : -1 );
+    spin_unlock( &pc302wdt_int.lock );
+
+    return ret;
+}
+
+static DEVICE_ATTR( time_left, S_IRUGO, pc302wdt_sysfs_time_left_show, NULL );
+
+/**
+ * The group of attributes that should be added to the watchdog device. This
+ * will most likely end up in /sys/devices/platform/pc302_wdt
+ */
+static struct attribute *pc302wdt_attrs[] = {
+    &dev_attr_timeout.attr,
+    &dev_attr_enabled.attr,
+    &dev_attr_counter.attr,
+    &dev_attr_pretimeout.attr,
+    &dev_attr_time_left.attr,
+    NULL
+};
+
+/**
+ * Add the attributes as a group/
+ */
+static struct attribute_group pc302wdt_attr_group = {
+    .attrs = pc302wdt_attrs
+};
+
+static void
+pc302wdt_sysfs_remove( void )
+{
+    sysfs_remove_group( &pc302wdt_int.dev.this_device->kobj,
+                        &pc302wdt_attr_group );
+}
+
+static void
+pc302wdt_sysfs_add( void )
+{
+    int ret;
+
+    ret = sysfs_create_group( &pc302wdt_int.pdev->dev.kobj,
+                              &pc302wdt_attr_group );
+    ret = sysfs_create_link( &pc302wdt_int.dev.this_device->kobj,
+                             &pc302wdt_int.pdev->dev.kobj, "device" );
+}
+
+static int
+pc302wdt_open( struct inode *inode,
+                struct file *filp )
+{
+    u32 control_reg;
+
+    if ( !pc302wdt_is_enabled() )
+    {
+        spin_lock( &pc302wdt_int.lock );
+
+        /* The watchdog is not currently enabled. Set the timeout to the
+         * maximum and then start it. */
+        pc302wdt_set_top( PC302_WDOG_MAX_TOP );
+        control_reg =
+            ioread32( pc302wdt_int.mem_region + WDOG_CONTROL_REG_OFFSET );
+        control_reg |= WDOGCONTROLREGWDT_ENMASK;
+        iowrite32( control_reg,
+                   pc302wdt_int.mem_region + WDOG_CONTROL_REG_OFFSET );
+        pc302wdt_int.enabled = 1;
+
+        spin_unlock( &pc302wdt_int.lock );
+    }
+
+    return 0;
+}
+
+ssize_t
+pc302wdt_write( struct file *filp,
+                const char __user *buf,
+                size_t len,
+                loff_t *offset )
+{
+    pc302wdt_keepalive();
+
+    return len;
+}
+
+static u32
+pc302wdt_time_left( void )
+{
+    u32 counter_val;
+    spin_lock( &pc302wdt_int.lock );
+    counter_val = ioread32( pc302wdt_int.mem_region +
+                            WDOG_CURRENT_COUNT_REG_OFFSET );
+    spin_unlock( &pc302wdt_int.lock );
+    return counter_val / PC302_WDOG_TICKS_PER_SECOND;
+}
+
+static void
+pc302wdt_keepalive( void )
+{
+    if ( !pc302wdt_int.reset_pending )
+        iowrite32( WDOG_COUNTER_RESTART_KICK_VALUE,
+                   pc302wdt_int.mem_region + WDOG_COUNTER_RESTART_REG_OFFSET );
+}
+
+static int
+pc302wdt_ioctl( struct inode *inode,
+                 struct file *filp,
+                 unsigned int cmd,
+                 unsigned long arg )
+{
+    int val;
+    int ret;
+    int err = 0;
+
+    if ( _IOC_DIR( cmd ) & _IOC_READ )
+        err = !access_ok( VERIFY_WRITE, ( void __user * )arg,
+                          _IOC_SIZE( cmd ) );
+    else if ( _IOC_DIR( cmd ) & _IOC_WRITE )
+        err = !access_ok( VERIFY_READ, ( void __user * )arg,
+                          _IOC_SIZE( cmd ) );
+
+    if ( err )
+        return -EFAULT;
+
+    switch ( cmd )
+    {
+        /* Kick the watchdog to prevent it from expiring. */
+        case WDIOC_KEEPALIVE:
+            ret = 0;
+            pc302wdt_keepalive();
+            break;
+
+        /* Set a new timeout value. */
+        case WDIOC_SETTIMEOUT:
+            ret = __get_user( val, ( int __user * )arg );
+            if ( ret )
+                break;
+            val = pc302wdt_set_top( val );
+            ret = __put_user( val, ( int __user * )arg );
+            break;
+
+        /* Get the time left until expiry. */
+        case WDIOC_GETTIMELEFT:
+            ret = __get_user( val, ( int __user * )arg );
+            if ( ret )
+                break;
+            val = pc302wdt_time_left();
+            ret = __put_user( val, ( int __user * )arg );
+            break;
+
+        /* Set the pretimeout. */
+        case WDIOC_SETPRETIMEOUT:
+            ret = __get_user( val, ( int __user * )arg );
+            if ( ret )
+                break;
+            val = pc302wdt_set_pretimeout( val );
+            ret = __put_user( val, ( int __user * )arg );
+            break;
+
+        default:
+            printk( KERN_DEBUG "pc302wdt: invalid ioctl() cmd (%u)\n", cmd );
+            ret = -EINVAL;
+            break;
+    }
+
+    return ret;
+}
+
+static int
+pc302wdt_set_top( unsigned top_s )
+{
+    unsigned i;
+    int top_val = -1;
+    unsigned long flags;
+
+    /* Iterate over the timeout values until we find the closest match. We
+     * always look for >=. */
+    for ( i = 0; i < PC302_WDT_NUM_TIMEOUTS; ++i )
+    {
+        if ( pc302wdt_timeouts[ i ] >= top_s )
+        {
+            top_val = i;
+            break;
+        }
+    }
+
+    /* If we didn't find a suitable value, it must have been too large. Go
+     * with the biggest that we can. */
+    if ( top_val < 0 )
+        top_val = PC302_WDT_NUM_TIMEOUTS - 1;
+
+    /* Set the new value in the watchdog. */
+    spin_lock_irqsave( &pc302wdt_int.lock, flags );
+    iowrite32( top_val,
+               pc302wdt_int.mem_region + WDOG_TIMEOUT_RANGE_REG_OFFSET );
+    pc302wdt_int.top = top_val;
+    spin_unlock_irqrestore( &pc302wdt_int.lock, flags );
+
+    return pc302wdt_timeouts[ top_val ];
+}
+
+static int
+pc302wdt_release( struct inode *inodw,
+                  struct file *filp )
+{
+    return 0;
+}
+
+static int
+pc302wdt_is_enabled( void )
+{
+    u32 control_reg;
+    spin_lock( &pc302wdt_int.lock );
+    control_reg =
+        ioread32( pc302wdt_int.mem_region + WDOG_CONTROL_REG_OFFSET );
+    spin_unlock( &pc302wdt_int.lock );
+
+    return ( control_reg & WDOGCONTROLREGWDT_ENMASK );
+}
+
+static int
+pc302wdt_set_pretimeout( int timeout )
+{
+    u32 control_reg;
+    int ret;
+
+    spin_lock( &pc302wdt_int.lock );
+
+    control_reg =
+        ioread32( pc302wdt_int.mem_region + WDOG_CONTROL_REG_OFFSET );
+
+    /* We cannot choose an arbitrary pretimeout, so we interpret a timeout of
+     * 0 as disable the pretimeout, and anything else as enable it. */
+    if ( timeout )
+        control_reg |= WDOGCONTROLREGRMODMASK;
+    else
+        control_reg &= ~( ( u32 )WDOGCONTROLREGRMODMASK );
+
+    iowrite32( control_reg, pc302wdt_int.mem_region + WDOG_CONTROL_REG_OFFSET );
+
+    /* The pretimeout will be the same as the timeout period so return this.
+     */
+    ret = ( control_reg & WDOGCONTROLREGRMODMASK ) ?
+        pc302wdt_timeouts[ pc302wdt_int.top ] : 0;
+
+    spin_unlock( &pc302wdt_int.lock );
+
+    return ret;
+}
+
+static int
+pc302wdt_pretimeout_used( void )
+{
+    u32 control_reg;
+    spin_lock( &pc302wdt_int.lock );
+    control_reg =
+        ioread32( pc302wdt_int.mem_region + WDOG_CONTROL_REG_OFFSET );
+    spin_unlock( &pc302wdt_int.lock );
+
+    return ( control_reg & WDOGCONTROLREGRMODMASK );
+}
+
+static irqreturn_t
+pc302wdt_isr( int irq,
+              void *dev )
+{
+    /* Clear the interrupt in the device. Reading the register will clear the
+     * interrupt but the value is of no interest so we can discard it. */
+    ioread32( pc302wdt_int.mem_region + WDOG_CLEAR_REG_OFFSET );
+
+    return IRQ_HANDLED;
+}
+
+static void
+pc302wdt_platform_reset( char mode,
+                         void *cookie )
+{
+    u32 control_reg =
+            ioread32( pc302wdt_int.mem_region + WDOG_CONTROL_REG_OFFSET );
+    control_reg |= WDOGCONTROLREGWDT_ENMASK;
+    iowrite32( control_reg,
+               pc302wdt_int.mem_region + WDOG_CONTROL_REG_OFFSET );
+    wmb();
+
+    /* Disable the pretimeout. */
+    pc302wdt_set_pretimeout( 0 );
+
+    /* Set the timeout to the minimum possible. */
+    pc302wdt_set_top( 0 );
+
+    pc302wdt_int.reset_pending = 1;
+}
+
+static int
+pc302wdt_drv_probe( struct platform_device *pdev )
+{
+    int ret;
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+    struct resource *irq = platform_get_resource( pdev, IORESOURCE_IRQ, 0 );
+
+    if ( !mem || !irq )
+        return -EINVAL;
+
+    /* Map the memory. */
+    if ( !request_mem_region( mem->start, ( mem->end - mem->start ) + 1,
+                              CARDNAME ) )
+        return -EBUSY;
+
+    pc302wdt_int.mem_region =
+        ioremap( mem->start, ( mem->end - mem->start ) + 1 );
+    if ( !pc302wdt_int.mem_region )
+    {
+        ret = -EBUSY;
+        goto remap_failed;
+    }
+
+    ret = request_irq( irq->start, pc302wdt_isr, IRQF_DISABLED, CARDNAME,
+                       &pc302wdt_int.dev );
+    if ( ret )
+        goto irq_request_failed;
+
+    pc302wdt_int.enabled = pc302wdt_is_enabled() ? 1 : 0;
+    pc302wdt_int.use_pretimeout = pc302wdt_pretimeout_used() ? 1 : 0;
+    pc302wdt_int.pdev = pdev;
+
+    /* Register the device and configure the sysfs attributes. */
+    ret = misc_register( &pc302wdt_int.dev );
+    if ( ret )
+        goto register_failed;
+    pc302wdt_sysfs_add();
+
+    register_reset_handler( pc302wdt_platform_reset, NULL );
+
+    /* Disable the pretimeout. If we panic then we don't want a pretimeout
+     * otherwise we'll never reset. */
+    pc302wdt_set_pretimeout( 0 );
+
+    return 0;
+
+register_failed:
+    free_irq( irq->start, &pc302wdt_int.dev );
+
+irq_request_failed:
+    iounmap( pc302wdt_int.mem_region );
+
+remap_failed:
+    release_mem_region( mem->start, ( mem->end - mem->start ) + 1 );
+    pc302wdt_int.mem_region = NULL;
+
+    printk( KERN_ERR "PC302 Watchdog registration failed\n" );
+
+    return ret;
+}
+
+static int
+pc302wdt_drv_remove( struct platform_device *pdev )
+{
+    struct resource *mem = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+    struct resource *irq = platform_get_resource( pdev, IORESOURCE_IRQ, 0 );
+
+    if ( pc302wdt_int.mem_region )
+    {
+        iounmap( pc302wdt_int.mem_region );
+        release_mem_region( mem->start, ( mem->end - mem->start ) + 1 );
+    }
+
+    free_irq( irq->start, &pc302wdt_int.dev );
+
+    misc_deregister( &pc302wdt_int.dev );
+    pc302wdt_sysfs_remove();
+
+    deregister_reset_handler( pc302wdt_platform_reset, NULL );
+
+    return 0;
+}
+
+static struct platform_driver pc302wdt_driver = {
+    .probe = pc302wdt_drv_probe,
+    .remove = pc302wdt_drv_remove,
+    .driver = {
+        .name = CARDNAME,
+    }
+};
+
+static int
+pc302wdt_watchdog_init( void )
+{
+    return platform_driver_register( &pc302wdt_driver );
+}
+
+static void
+pc302wdt_watchdog_exit( void )
+{
+    platform_driver_unregister( &pc302wdt_driver );
+}
+
+module_init( pc302wdt_watchdog_init );
+module_exit( pc302wdt_watchdog_exit );
+
+MODULE_AUTHOR( "Jamie Iles" );
+MODULE_DESCRIPTION( "picoChip PC302 Watchdog Driver" );
+MODULE_LICENSE( "GPL");
+
diff --git a/fs/affs/file.c b/fs/affs/file.c
index 1377b12..9246cb4 100644
--- a/fs/affs/file.c
+++ b/fs/affs/file.c
@@ -628,7 +628,7 @@ static int affs_write_begin_ofs(struct file *file, struct address_space *mapping
 	}
 
 	index = pos >> PAGE_CACHE_SHIFT;
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page)
 		return -ENOMEM;
 	*pagep = page;
diff --git a/fs/afs/write.c b/fs/afs/write.c
index d6b85da..3fb36d4 100644
--- a/fs/afs/write.c
+++ b/fs/afs/write.c
@@ -144,7 +144,7 @@ int afs_write_begin(struct file *file, struct address_space *mapping,
 	candidate->state = AFS_WBACK_PENDING;
 	init_waitqueue_head(&candidate->waitq);
 
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page) {
 		kfree(candidate);
 		return -ENOMEM;
diff --git a/fs/buffer.c b/fs/buffer.c
index 10179cf..e556455 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -1988,7 +1988,7 @@ int block_write_begin(struct file *file, struct address_space *mapping,
 	page = *pagep;
 	if (page == NULL) {
 		ownpage = 1;
-		page = __grab_cache_page(mapping, index);
+		page = grab_cache_page_write_begin(mapping, index, flags);
 		if (!page) {
 			status = -ENOMEM;
 			goto out;
@@ -2494,7 +2494,7 @@ int nobh_write_begin(struct file *file, struct address_space *mapping,
 	from = pos & (PAGE_CACHE_SIZE - 1);
 	to = from + len;
 
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page)
 		return -ENOMEM;
 	*pagep = page;
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index f0a81e6..586d2be 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -2073,7 +2073,7 @@ static int cifs_write_begin(struct file *file, struct address_space *mapping,
 
 	cFYI(1, ("write_begin from %lld len %d", (long long)pos, len));
 
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page) {
 		rc = -ENOMEM;
 		goto out;
diff --git a/fs/compat_ioctl.c b/fs/compat_ioctl.c
index 5235c67..a5001a6 100644
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@ -2555,6 +2555,7 @@ HANDLE_IOCTL(SIOCSIFMAP, dev_ifsioc)
 HANDLE_IOCTL(SIOCGIFADDR, dev_ifsioc)
 HANDLE_IOCTL(SIOCSIFADDR, dev_ifsioc)
 HANDLE_IOCTL(SIOCSIFHWBROADCAST, dev_ifsioc)
+HANDLE_IOCTL(SIOCSHWTSTAMP, dev_ifsioc)
 
 /* ioctls used by appletalk ddp.c */
 HANDLE_IOCTL(SIOCATALKDIFADDR, dev_ifsioc)
diff --git a/fs/ecryptfs/mmap.c b/fs/ecryptfs/mmap.c
index 04d7b3f..46cec2b 100644
--- a/fs/ecryptfs/mmap.c
+++ b/fs/ecryptfs/mmap.c
@@ -288,7 +288,7 @@ static int ecryptfs_write_begin(struct file *file,
 	loff_t prev_page_end_size;
 	int rc = 0;
 
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page)
 		return -ENOMEM;
 	*pagep = page;
diff --git a/fs/ext3/inode.c b/fs/ext3/inode.c
index f8424ad..846e8ca 100644
--- a/fs/ext3/inode.c
+++ b/fs/ext3/inode.c
@@ -1160,7 +1160,7 @@ static int ext3_write_begin(struct file *file, struct address_space *mapping,
 	to = from + len;
 
 retry:
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page)
 		return -ENOMEM;
 	*pagep = page;
diff --git a/fs/ext3/namei.c b/fs/ext3/namei.c
index 3e5edc9..a48e965 100644
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@ -2170,8 +2170,7 @@ retry:
 		 * We have a transaction open.  All is sweetness.  It also sets
 		 * i_size in generic_commit_write().
 		 */
-		err = __page_symlink(inode, symname, l,
-				mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);
+		err = __page_symlink(inode, symname, l, 1);
 		if (err) {
 			drop_nlink(inode);
 			ext3_mark_inode_dirty(handle, inode);
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index be21a5a..8e46b19 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1345,7 +1345,7 @@ retry:
 		goto out;
 	}
 
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page) {
 		ext4_journal_stop(handle);
 		ret = -ENOMEM;
@@ -2549,7 +2549,7 @@ retry:
 		goto out;
 	}
 
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page) {
 		ext4_journal_stop(handle);
 		ret = -ENOMEM;
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 63adcb7..92c8397 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -2208,8 +2208,7 @@ retry:
 		 * We have a transaction open.  All is sweetness.  It also sets
 		 * i_size in generic_commit_write().
 		 */
-		err = __page_symlink(inode, symname, l,
-				mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS);
+		err = __page_symlink(inode, symname, l, 1);
 		if (err) {
 			clear_nlink(inode);
 			ext4_mark_inode_dirty(handle, inode);
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 34930a9..4c9ee70 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -646,7 +646,7 @@ static int fuse_write_begin(struct file *file, struct address_space *mapping,
 {
 	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
 
-	*pagep = __grab_cache_page(mapping, index);
+	*pagep = grab_cache_page_write_begin(mapping, index, flags);
 	if (!*pagep)
 		return -ENOMEM;
 	return 0;
@@ -779,7 +779,7 @@ static ssize_t fuse_fill_write_pages(struct fuse_req *req,
 			break;
 
 		err = -ENOMEM;
-		page = __grab_cache_page(mapping, index);
+		page = grab_cache_page_write_begin(mapping, index, 0);
 		if (!page)
 			break;
 
diff --git a/fs/gfs2/ops_address.c b/fs/gfs2/ops_address.c
index 2756381..15f710f 100644
--- a/fs/gfs2/ops_address.c
+++ b/fs/gfs2/ops_address.c
@@ -675,7 +675,7 @@ static int gfs2_write_begin(struct file *file, struct address_space *mapping,
 		goto out_trans_fail;
 
 	error = -ENOMEM;
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	*pagep = page;
 	if (unlikely(!page))
 		goto out_endtrans;
diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c
index 3a31451..5c538e0 100644
--- a/fs/hostfs/hostfs_kern.c
+++ b/fs/hostfs/hostfs_kern.c
@@ -501,7 +501,7 @@ int hostfs_write_begin(struct file *file, struct address_space *mapping,
 {
 	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
 
-	*pagep = __grab_cache_page(mapping, index);
+	*pagep = grab_cache_page_write_begin(mapping, index, flags);
 	if (!*pagep)
 		return -ENOMEM;
 	return 0;
diff --git a/fs/jffs2/file.c b/fs/jffs2/file.c
index 5a98aa8..5edc2bf 100644
--- a/fs/jffs2/file.c
+++ b/fs/jffs2/file.c
@@ -132,7 +132,7 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 	uint32_t pageofs = index << PAGE_CACHE_SHIFT;
 	int ret = 0;
 
-	pg = __grab_cache_page(mapping, index);
+	pg = grab_cache_page_write_begin(mapping, index, flags);
 	if (!pg)
 		return -ENOMEM;
 	*pagep = pg;
diff --git a/fs/libfs.c b/fs/libfs.c
index e960a83..bdaec17 100644
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -360,7 +360,7 @@ int simple_write_begin(struct file *file, struct address_space *mapping,
 	index = pos >> PAGE_CACHE_SHIFT;
 	from = pos & (PAGE_CACHE_SIZE - 1);
 
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page)
 		return -ENOMEM;
 
diff --git a/fs/mpage.c b/fs/mpage.c
index 552b80b..979a4a9 100644
--- a/fs/mpage.c
+++ b/fs/mpage.c
@@ -51,6 +51,7 @@ static void mpage_end_io_read(struct bio *bio, int err)
 			prefetchw(&bvec->bv_page->flags);
 
 		if (uptodate) {
+			flush_dcache_page(page);
 			SetPageUptodate(page);
 		} else {
 			ClearPageUptodate(page);
diff --git a/fs/namei.c b/fs/namei.c
index d34e0f9..2a56898 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -2786,18 +2786,23 @@ void page_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)
 	}
 }
 
-int __page_symlink(struct inode *inode, const char *symname, int len,
-		gfp_t gfp_mask)
+/*
+ * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS
+ */
+int __page_symlink(struct inode *inode, const char *symname, int len, int nofs)
 {
 	struct address_space *mapping = inode->i_mapping;
 	struct page *page;
 	void *fsdata;
 	int err;
 	char *kaddr;
+	unsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;
+	if (nofs)
+		flags |= AOP_FLAG_NOFS;
 
 retry:
 	err = pagecache_write_begin(NULL, mapping, 0, len-1,
-				AOP_FLAG_UNINTERRUPTIBLE, &page, &fsdata);
+				flags, &page, &fsdata);
 	if (err)
 		goto fail;
 
@@ -2821,7 +2826,7 @@ fail:
 int page_symlink(struct inode *inode, const char *symname, int len)
 {
 	return __page_symlink(inode, symname, len,
-			mapping_gfp_mask(inode->i_mapping));
+			!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));
 }
 
 const struct inode_operations page_symlink_inode_operations = {
diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index d319b49..90f292b 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -354,7 +354,7 @@ static int nfs_write_begin(struct file *file, struct address_space *mapping,
 		file->f_path.dentry->d_name.name,
 		mapping->host->i_ino, len, (long long) pos);
 
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page)
 		return -ENOMEM;
 	*pagep = page;
diff --git a/fs/reiserfs/inode.c b/fs/reiserfs/inode.c
index 6c4c2c6..8a6bfb4 100644
--- a/fs/reiserfs/inode.c
+++ b/fs/reiserfs/inode.c
@@ -2556,7 +2556,7 @@ static int reiserfs_write_begin(struct file *file,
 	}
 
 	index = pos >> PAGE_CACHE_SHIFT;
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (!page)
 		return -ENOMEM;
 	*pagep = page;
diff --git a/fs/smbfs/file.c b/fs/smbfs/file.c
index e4f8d51..92d5e8f 100644
--- a/fs/smbfs/file.c
+++ b/fs/smbfs/file.c
@@ -297,7 +297,7 @@ static int smb_write_begin(struct file *file, struct address_space *mapping,
 			struct page **pagep, void **fsdata)
 {
 	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
-	*pagep = __grab_cache_page(mapping, index);
+	*pagep = grab_cache_page_write_begin(mapping, index, flags);
 	if (!*pagep)
 		return -ENOMEM;
 	return 0;
diff --git a/fs/ubifs/file.c b/fs/ubifs/file.c
index 2624411..b1496f5 100644
--- a/fs/ubifs/file.c
+++ b/fs/ubifs/file.c
@@ -219,7 +219,8 @@ static void release_existing_page_budget(struct ubifs_info *c)
 }
 
 static int write_begin_slow(struct address_space *mapping,
-			    loff_t pos, unsigned len, struct page **pagep)
+			    loff_t pos, unsigned len, struct page **pagep,
+			    unsigned flags)
 {
 	struct inode *inode = mapping->host;
 	struct ubifs_info *c = inode->i_sb->s_fs_info;
@@ -247,7 +248,7 @@ static int write_begin_slow(struct address_space *mapping,
 	if (unlikely(err))
 		return err;
 
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (unlikely(!page)) {
 		ubifs_release_budget(c, &req);
 		return -ENOMEM;
@@ -438,7 +439,7 @@ static int ubifs_write_begin(struct file *file, struct address_space *mapping,
 		return -EROFS;
 
 	/* Try out the fast-path part first */
-	page = __grab_cache_page(mapping, index);
+	page = grab_cache_page_write_begin(mapping, index, flags);
 	if (unlikely(!page))
 		return -ENOMEM;
 
@@ -483,7 +484,7 @@ static int ubifs_write_begin(struct file *file, struct address_space *mapping,
 		unlock_page(page);
 		page_cache_release(page);
 
-		return write_begin_slow(mapping, pos, len, pagep);
+		return write_begin_slow(mapping, pos, len, pagep, flags);
 	}
 
 	/*
diff --git a/include/asm-arm/hardware/rvidcc.h b/include/asm-arm/hardware/rvidcc.h
new file mode 100644
index 0000000..2aec6bd
--- /dev/null
+++ b/include/asm-arm/hardware/rvidcc.h
@@ -0,0 +1,35 @@
+/* 
+   Copyright (C) 2004-2007 ARM Limited.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License version 2
+   as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+   As a special exception, if other files instantiate templates or use macros
+   or inline functions from this file, or you compile this file and link it
+   with other works to produce a work based on this file, this file does not
+   by itself cause the resulting work to be covered by the GNU General Public
+   License. However the source code for this file must still be made available
+   in accordance with section (3) of the GNU General Public License.
+
+   This exception does not invalidate any other reasons why a work based on
+   this file might be covered by the GNU General Public License.
+*/
+
+#ifndef __RVIDCC_H
+#define __RVIDCC_H
+
+/* Ioctl defines */
+#define DCC_SETPOLLPERIOD  _IOW('T', 1, int) 
+#define DCC_GETPOLLPERIOD  _IOR('T', 2, int) 
+
+#endif
diff --git a/include/linux/async_tx.h b/include/linux/async_tx.h
index 0f50d4c..45f6297 100644
--- a/include/linux/async_tx.h
+++ b/include/linux/async_tx.h
@@ -59,9 +59,7 @@ enum async_tx_flags {
 };
 
 #ifdef CONFIG_DMA_ENGINE
-void async_tx_issue_pending_all(void);
-enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx);
-void async_tx_run_dependencies(struct dma_async_tx_descriptor *tx);
+#define async_tx_issue_pending_all dma_issue_pending_all
 #ifdef CONFIG_ARCH_HAS_ASYNC_TX_FIND_CHANNEL
 #include <asm/async_tx.h>
 #else
@@ -77,19 +75,6 @@ static inline void async_tx_issue_pending_all(void)
 	do { } while (0);
 }
 
-static inline enum dma_status
-dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx)
-{
-	return DMA_SUCCESS;
-}
-
-static inline void
-async_tx_run_dependencies(struct dma_async_tx_descriptor *tx,
-	struct dma_chan *host_chan)
-{
-	do { } while (0);
-}
-
 static inline struct dma_chan *
 async_tx_find_channel(struct dma_async_tx_descriptor *depend_tx,
 	enum dma_transaction_type tx_type, struct page **dst, int dst_count,
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index f88d32f..28e1665 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -24,6 +24,9 @@ struct clocksource;
 /**
  * struct clocksource - hardware abstraction for a free running counter
  *	Provides mostly state-free accessors to the underlying hardware.
+ *      Also provides utility functions which convert the underlying
+ *      hardware cycle values into a non-decreasing count of nanoseconds
+ *      ("time").
  *
  * @name:		ptr to clocksource name
  * @list:		list head for registration
@@ -43,6 +46,9 @@ struct clocksource;
  *				The ideal clocksource. A must-use where
  *				available.
  * @read:		returns a cycle value
+ * @read_clock:         alternative to read which gets a pointer to the clock
+ *                      source so that the same code can read different clocks;
+ *                      either read or read_clock must be set
  * @mask:		bitmask for two's complement
  *			subtraction of non 64 bit counters
  * @mult:		cycle to nanosecond multiplier (adjusted by NTP)
@@ -62,6 +68,7 @@ struct clocksource {
 	struct list_head list;
 	int rating;
 	cycle_t (*read)(void);
+        cycle_t (*read_clock)(struct clocksource *cs);
 	cycle_t mask;
 	u32 mult;
 	u32 mult_orig;
@@ -170,7 +177,7 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
  */
 static inline cycle_t clocksource_read(struct clocksource *cs)
 {
-	return cs->read();
+	return (cs->read ? cs->read() : cs->read_clock(cs));
 }
 
 /**
@@ -190,6 +197,116 @@ static inline s64 cyc2ns(struct clocksource *cs, cycle_t cycles)
 }
 
 /**
+ * clocksource_read_ns - get nanoseconds since last call of this function
+ *                       (never negative)
+ * @cs:         Pointer to clocksource
+ *
+ * When the underlying cycle counter runs over, this will be handled
+ * correctly as long as it does not run over more than once between
+ * calls.
+ *
+ * The first call to this function for a new clock source initializes
+ * the time tracking and returns bogus results.
+ */
+static inline s64 clocksource_read_ns(struct clocksource *cs)
+{
+	cycle_t cycle_now, cycle_delta;
+	s64 ns_offset;
+
+	/* read clocksource: */
+	cycle_now = clocksource_read(cs);
+
+	/* calculate the delta since the last clocksource_read_ns: */
+	cycle_delta = (cycle_now - cs->cycle_last) & cs->mask;
+
+	/* convert to nanoseconds: */
+	ns_offset = cyc2ns(cs, cycle_delta);
+
+	/* update time stamp of clocksource_read_ns call: */
+	cs->cycle_last = cycle_now;
+
+	return ns_offset;
+}
+
+/**
+ * clocksource_init_time - initialize a clock source for use with
+ *                         %clocksource_read_time() and
+ *                         %clocksource_cyc2time()
+ * @cs:            Pointer to clocksource.
+ * @start_tstamp:  Arbitrary initial time stamp.
+ *
+ * After this call the current cycle register (roughly) corresponds to
+ * the initial time stamp. Every call to %clocksource_read_time()
+ * increments the time stamp counter by the number of elapsed
+ * nanoseconds.
+ */
+static inline void clocksource_init_time(struct clocksource *cs,
+					u64 start_tstamp)
+{
+	cs->cycle_last = clocksource_read(cs);
+	cs->xtime_nsec = start_tstamp;
+}
+
+/**
+ * clocksource_read_time - return nanoseconds since %clocksource_init_time()
+ *                         plus the initial time stamp
+ * @cs:          Pointer to clocksource.
+ *
+ * In other words, keeps track of time since the same epoch as
+ * the function which generated the initial time stamp. Don't mix
+ * with calls to %clocksource_read_ns()!
+ */
+static inline u64 clocksource_read_time(struct clocksource *cs)
+{
+	u64 nsec;
+
+	/* increment time by nanoseconds since last call */
+	nsec = clocksource_read_ns(cs);
+	nsec += cs->xtime_nsec;
+	cs->xtime_nsec = nsec;
+
+	return nsec;
+}
+
+/**
+ * clocksource_cyc2time - convert an absolute cycle time stamp to same
+ *                        time base as values returned by
+ *                        %clocksource_read_time()
+ * @cs:            Pointer to clocksource.
+ * @cycle_tstamp:  a value returned by cs->read()
+ *
+ * Cycle time stamps that are converted correctly as long as they
+ * fall into the time interval [-1/2 max cycle count, 1/2 cycle count],
+ * with "max cycle count" == cs->mask+1.
+ *
+ * This avoids situations where a cycle time stamp is generated, the
+ * current cycle counter is updated, and then when transforming the
+ * time stamp the value is treated as if it was in the future. Always
+ * updating the cycle counter would also work, but incurr additional
+ * overhead.
+ */
+static inline u64 clocksource_cyc2time(struct clocksource *cs,
+				cycle_t cycle_tstamp)
+{
+	u64 cycle_delta = (cycle_tstamp - cs->cycle_last) & cs->mask;
+	u64 nsec;
+
+	/*
+	 * Instead of always treating cycle_tstamp as more recent
+	 * than cs->cycle_last, detect when it is too far in the
+	 * future and treat it as old time stamp instead.
+	 */
+	if (cycle_delta > cs->mask / 2) {
+		cycle_delta = (cs->cycle_last - cycle_tstamp) & cs->mask;
+		nsec = cs->xtime_nsec - cyc2ns(cs, cycle_delta);
+	} else {
+		nsec = cyc2ns(cs, cycle_delta) + cs->xtime_nsec;
+	}
+
+	return nsec;
+}
+
+/**
  * clocksource_calculate_interval - Calculates a clocksource interval struct
  *
  * @c:		Pointer to clocksource.
diff --git a/include/linux/clocksync.h b/include/linux/clocksync.h
new file mode 100644
index 0000000..e8c8fad
--- /dev/null
+++ b/include/linux/clocksync.h
@@ -0,0 +1,139 @@
+/*
+ * Utility code which helps transforming between hardware time stamps
+ * generated by a clocksource and system time. The clocksource is
+ * assumed to return monotonically increasing time (but this code does
+ * its best to compensate if that is not the case) whereas system time
+ * may jump.
+ */
+#ifndef _LINUX_CLOCKSYNC_H
+#define _LINUX_CLOCKSYNC_H
+
+#include <linux/clocksource.h>
+#include <linux/ktime.h>
+
+/**
+ * struct clocksync - stores state and configuration for the two clocks
+ *
+ * Initialize to zero, then set clock, systime, num_samples.
+ *
+ * Transformation between HW time and system time is done with:
+ * HW time transformed = HW time + offset +
+ *                       (HW time - last_update) * skew / CLOCKSYNC_SKEW_RESOLUTION
+ *
+ * @clock:           the source for HW time stamps (%clocksource_read_time)
+ * @systime:         function returning current system time (ktime_get
+ *                   for monotonic time, or ktime_get_real for wall clock)
+ * @num_samples:     number of times that HW time and system time are to
+ *                   be compared when determining their offset
+ * @offset:          (system time - HW time) at the time of the last update
+ * @skew:            average (system time - HW time) / delta HW time *
+ *                   CLOCKSYNC_SKEW_RESOLUTION
+ * @last_update:     last HW time stamp when clock offset was measured
+ */
+struct clocksync {
+	struct clocksource *clock;
+	ktime_t (*systime)(void);
+	int num_samples;
+
+	s64 offset;
+	s64 skew;
+	u64 last_update;
+};
+
+/**
+ * CLOCKSYNC_SKEW_RESOLUTION - fixed point arithmetic scale factor for skew
+ *
+ * Usually one would measure skew in ppb (parts per billion, 1e9), but
+ * using a factor of 2 simplifies the math.
+ */
+#define CLOCKSYNC_SKEW_RESOLUTION (((s64)1)<<30)
+
+/**
+ * clocksync_hw2sys - transform HW time stamp into corresponding system time
+ * @sync:             context for clock sync
+ * @hwtstamp:         the result of %clocksource_read_time or
+ *                    %clocksource_cyc2time
+ */
+static inline ktime_t clocksync_hw2sys(struct clocksync *sync,
+					u64 hwtstamp)
+{
+	u64 nsec;
+
+	nsec = hwtstamp + sync->offset;
+	nsec += (s64)(hwtstamp - sync->last_update) * sync->skew /
+		CLOCKSYNC_SKEW_RESOLUTION;
+
+	return ns_to_ktime(nsec);
+}
+
+/**
+ * clocksync_offset - measure current (system time - HW time) offset
+ * @sync:             context for clock sync
+ * @offset:           average offset during sample period returned here
+ * @hwtstamp:         average HW time during sample period returned here
+ *
+ * Returns number of samples used. Might be zero (= no result) in the
+ * unlikely case that system time was monotonically decreasing for all
+ * samples (= broken).
+ */
+int clocksync_offset(struct clocksync *sync,
+		s64 *offset,
+		u64 *hwtstamp);
+
+/**
+ * clocksync_update - update offset and skew by measuring current offset
+ * @sync:             context for clock sync
+ * @hwtstamp:         the result of %clocksource_read_time or
+ *                    %clocksource_cyc2time, pass zero to force update
+ *
+ * Updates are only done at most once per second.
+ */
+static inline void clocksync_update(struct clocksync *sync,
+			u64 hwtstamp)
+{
+	s64 offset;
+	u64 average_time;
+
+	if (hwtstamp &&
+		(s64)(hwtstamp - sync->last_update) < NSEC_PER_SEC)
+		return;
+
+	if (!clocksync_offset(sync, &offset, &average_time))
+		return;
+
+	printk(KERN_DEBUG
+		"average offset: %lld\n", offset);
+
+	if (!sync->last_update) {
+		sync->last_update = average_time;
+		sync->offset = offset;
+		sync->skew = 0;
+	} else {
+		s64 delta_nsec = average_time - sync->last_update;
+
+		/* avoid division by negative or small deltas */
+		if (delta_nsec >= 10000) {
+			s64 delta_offset_nsec = offset - sync->offset;
+			s64 skew = delta_offset_nsec *
+				CLOCKSYNC_SKEW_RESOLUTION /
+				delta_nsec;
+
+			/**
+			 * Calculate new overall skew as 4/16 the
+			 * old value and 12/16 the new one. This is
+			 * a rather arbitrary tradeoff between
+			 * only using the latest measurement (0/16 and
+			 * 16/16) and even more weight on past measurements.
+			 */
+#define CLOCKSYNC_NEW_SKEW_PER_16 12
+			sync->skew =
+				((16 - CLOCKSYNC_NEW_SKEW_PER_16) * sync->skew +
+					CLOCKSYNC_NEW_SKEW_PER_16 * skew) /
+				16;
+			sync->last_update = average_time;
+			sync->offset = offset;
+		}
+	}
+}
+
+#endif /* _LINUX_CLOCKSYNC_H */
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index adb0b08..6ce0c29 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -29,32 +29,6 @@
 #include <linux/dma-mapping.h>
 
 /**
- * enum dma_state - resource PNP/power management state
- * @DMA_RESOURCE_SUSPEND: DMA device going into low power state
- * @DMA_RESOURCE_RESUME: DMA device returning to full power
- * @DMA_RESOURCE_AVAILABLE: DMA device available to the system
- * @DMA_RESOURCE_REMOVED: DMA device removed from the system
- */
-enum dma_state {
-	DMA_RESOURCE_SUSPEND,
-	DMA_RESOURCE_RESUME,
-	DMA_RESOURCE_AVAILABLE,
-	DMA_RESOURCE_REMOVED,
-};
-
-/**
- * enum dma_state_client - state of the channel in the client
- * @DMA_ACK: client would like to use, or was using this channel
- * @DMA_DUP: client has already seen this channel, or is not using this channel
- * @DMA_NAK: client does not want to see any more channels
- */
-enum dma_state_client {
-	DMA_ACK,
-	DMA_DUP,
-	DMA_NAK,
-};
-
-/**
  * typedef dma_cookie_t - an opaque DMA cookie
  *
  * if dma_cookie_t is >0 it's a DMA request cookie, <0 it's an error code
@@ -89,6 +63,7 @@ enum dma_transaction_type {
 	DMA_MEMSET,
 	DMA_MEMCPY_CRC32C,
 	DMA_INTERRUPT,
+	DMA_PRIVATE,
 	DMA_SLAVE,
 };
 
@@ -96,18 +71,6 @@ enum dma_transaction_type {
 #define DMA_TX_TYPE_END (DMA_SLAVE + 1)
 
 /**
- * enum dma_slave_width - DMA slave register access width.
- * @DMA_SLAVE_WIDTH_8BIT: Do 8-bit slave register accesses
- * @DMA_SLAVE_WIDTH_16BIT: Do 16-bit slave register accesses
- * @DMA_SLAVE_WIDTH_32BIT: Do 32-bit slave register accesses
- */
-enum dma_slave_width {
-	DMA_SLAVE_WIDTH_8BIT,
-	DMA_SLAVE_WIDTH_16BIT,
-	DMA_SLAVE_WIDTH_32BIT,
-};
-
-/**
  * enum dma_ctrl_flags - DMA flags to augment operation preparation,
  * 	control completion, and communicate status.
  * @DMA_PREP_INTERRUPT - trigger an interrupt (callback) upon completion of
@@ -132,32 +95,6 @@ enum dma_ctrl_flags {
 typedef struct { DECLARE_BITMAP(bits, DMA_TX_TYPE_END); } dma_cap_mask_t;
 
 /**
- * struct dma_slave - Information about a DMA slave
- * @dev: device acting as DMA slave
- * @dma_dev: required DMA master device. If non-NULL, the client can not be
- *	bound to other masters than this.
- * @tx_reg: physical address of data register used for
- *	memory-to-peripheral transfers
- * @rx_reg: physical address of data register used for
- *	peripheral-to-memory transfers
- * @reg_width: peripheral register width
- *
- * If dma_dev is non-NULL, the client can not be bound to other DMA
- * masters than the one corresponding to this device. The DMA master
- * driver may use this to determine if there is controller-specific
- * data wrapped around this struct. Drivers of platform code that sets
- * the dma_dev field must therefore make sure to use an appropriate
- * controller-specific dma slave structure wrapping this struct.
- */
-struct dma_slave {
-	struct device		*dev;
-	struct device		*dma_dev;
-	dma_addr_t		tx_reg;
-	dma_addr_t		rx_reg;
-	enum dma_slave_width	reg_width;
-};
-
-/**
  * struct dma_chan_percpu - the per-CPU part of struct dma_chan
  * @refcount: local_t used for open-coded "bigref" counting
  * @memcpy_count: transaction counter
@@ -165,7 +102,6 @@ struct dma_slave {
  */
 
 struct dma_chan_percpu {
-	local_t refcount;
 	/* stats */
 	unsigned long memcpy_count;
 	unsigned long bytes_transferred;
@@ -176,13 +112,14 @@ struct dma_chan_percpu {
  * @device: ptr to the dma device who supplies this channel, always !%NULL
  * @cookie: last cookie value returned to client
  * @chan_id: channel ID for sysfs
- * @class_dev: class device for sysfs
+ * @dev: class device for sysfs
  * @refcount: kref, used in "bigref" slow-mode
  * @slow_ref: indicates that the DMA channel is free
  * @rcu: the DMA channel's RCU head
  * @device_node: used to add this to the device chan list
  * @local: per-cpu pointer to a struct dma_chan_percpu
  * @client-count: how many clients are using this channel
+ * @table_count: number of appearances in the mem-to-mem allocation table
  */
 struct dma_chan {
 	struct dma_device *device;
@@ -190,73 +127,43 @@ struct dma_chan {
 
 	/* sysfs */
 	int chan_id;
-	struct device dev;
-
-	struct kref refcount;
-	int slow_ref;
-	struct rcu_head rcu;
+	struct dma_chan_dev *dev;
 
 	struct list_head device_node;
 	struct dma_chan_percpu *local;
 	int client_count;
+	int table_count;
 };
 
-#define to_dma_chan(p) container_of(p, struct dma_chan, dev)
-
-void dma_chan_cleanup(struct kref *kref);
-
-static inline void dma_chan_get(struct dma_chan *chan)
-{
-	if (unlikely(chan->slow_ref))
-		kref_get(&chan->refcount);
-	else {
-		local_inc(&(per_cpu_ptr(chan->local, get_cpu())->refcount));
-		put_cpu();
-	}
-}
+/**
+ * struct dma_chan_dev - relate sysfs device node to backing channel device
+ * @chan - driver channel device
+ * @device - sysfs device
+ */
+struct dma_chan_dev {
+	struct dma_chan *chan;
+	struct device device;
+};
 
-static inline void dma_chan_put(struct dma_chan *chan)
+static inline const char *dma_chan_name(struct dma_chan *chan)
 {
-	if (unlikely(chan->slow_ref))
-		kref_put(&chan->refcount, dma_chan_cleanup);
-	else {
-		local_dec(&(per_cpu_ptr(chan->local, get_cpu())->refcount));
-		put_cpu();
-	}
+	return dev_name(&chan->dev->device);
 }
 
-/*
- * typedef dma_event_callback - function pointer to a DMA event callback
- * For each channel added to the system this routine is called for each client.
- * If the client would like to use the channel it returns '1' to signal (ack)
- * the dmaengine core to take out a reference on the channel and its
- * corresponding device.  A client must not 'ack' an available channel more
- * than once.  When a channel is removed all clients are notified.  If a client
- * is using the channel it must 'ack' the removal.  A client must not 'ack' a
- * removed channel more than once.
- * @client - 'this' pointer for the client context
- * @chan - channel to be acted upon
- * @state - available or removed
- */
-struct dma_client;
-typedef enum dma_state_client (*dma_event_callback) (struct dma_client *client,
-		struct dma_chan *chan, enum dma_state state);
+void dma_chan_cleanup(struct kref *kref);
 
 /**
- * struct dma_client - info on the entity making use of DMA services
- * @event_callback: func ptr to call when something happens
- * @cap_mask: only return channels that satisfy the requested capabilities
- *  a value of zero corresponds to any capability
- * @slave: data for preparing slave transfer. Must be non-NULL iff the
- *  DMA_SLAVE capability is requested.
- * @global_node: list_head for global dma_client_list
+ * typedef dma_filter_fn - callback filter for dma_request_channel
+ * @chan: channel to be reviewed
+ * @filter_param: opaque parameter passed through dma_request_channel
+ *
+ * When this optional parameter is specified in a call to dma_request_channel a
+ * suitable channel is passed to this routine for further dispositioning before
+ * being returned.  Where 'suitable' indicates a non-busy channel that
+ * satisfies the given capability mask.  It returns 'true' to indicate that the
+ * channel is suitable.
  */
-struct dma_client {
-	dma_event_callback	event_callback;
-	dma_cap_mask_t		cap_mask;
-	struct dma_slave	*slave;
-	struct list_head	global_node;
-};
+typedef bool (*dma_filter_fn)(struct dma_chan *chan, void *filter_param);
 
 typedef void (*dma_async_tx_callback)(void *dma_async_param);
 /**
@@ -323,14 +230,10 @@ struct dma_device {
 	dma_cap_mask_t  cap_mask;
 	int max_xor;
 
-	struct kref refcount;
-	struct completion done;
-
 	int dev_id;
 	struct device *dev;
 
-	int (*device_alloc_chan_resources)(struct dma_chan *chan,
-			struct dma_client *client);
+	int (*device_alloc_chan_resources)(struct dma_chan *chan);
 	void (*device_free_chan_resources)(struct dma_chan *chan);
 
 	struct dma_async_tx_descriptor *(*device_prep_dma_memcpy)(
@@ -362,9 +265,8 @@ struct dma_device {
 
 /* --- public DMA engine API --- */
 
-void dma_async_client_register(struct dma_client *client);
-void dma_async_client_unregister(struct dma_client *client);
-void dma_async_client_chan_request(struct dma_client *client);
+void dmaengine_get(void);
+void dmaengine_put(void);
 dma_cookie_t dma_async_memcpy_buf_to_buf(struct dma_chan *chan,
 	void *dest, void *src, size_t len);
 dma_cookie_t dma_async_memcpy_buf_to_pg(struct dma_chan *chan,
@@ -406,6 +308,12 @@ __dma_cap_set(enum dma_transaction_type tx_type, dma_cap_mask_t *dstp)
 	set_bit(tx_type, dstp->bits);
 }
 
+#define dma_cap_zero(mask) __dma_cap_zero(&(mask))
+static inline void __dma_cap_zero(dma_cap_mask_t *dstp)
+{
+	bitmap_zero(dstp->bits, DMA_TX_TYPE_END);
+}
+
 #define dma_has_cap(tx, mask) __dma_has_cap((tx), &(mask))
 static inline int
 __dma_has_cap(enum dma_transaction_type tx_type, dma_cap_mask_t *srcp)
@@ -475,11 +383,25 @@ static inline enum dma_status dma_async_is_complete(dma_cookie_t cookie,
 }
 
 enum dma_status dma_sync_wait(struct dma_chan *chan, dma_cookie_t cookie);
+#ifdef CONFIG_DMA_ENGINE
+enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx);
+#else
+static inline enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx)
+{
+	return DMA_SUCCESS;
+}
+#endif
 
 /* --- DMA device --- */
 
 int dma_async_device_register(struct dma_device *device);
 void dma_async_device_unregister(struct dma_device *device);
+void dma_run_dependencies(struct dma_async_tx_descriptor *tx);
+struct dma_chan *dma_find_channel(enum dma_transaction_type tx_type);
+void dma_issue_pending_all(void);
+#define dma_request_channel(mask, x, y) __dma_request_channel(&(mask), x, y)
+struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, dma_filter_fn fn, void *fn_param);
+void dma_release_channel(struct dma_chan *chan);
 
 /* --- Helper iov-locking functions --- */
 
diff --git a/include/linux/errqueue.h b/include/linux/errqueue.h
index 92f8d4f..86d88dd 100644
--- a/include/linux/errqueue.h
+++ b/include/linux/errqueue.h
@@ -16,6 +16,7 @@ struct sock_extended_err
 #define SO_EE_ORIGIN_LOCAL	1
 #define SO_EE_ORIGIN_ICMP	2
 #define SO_EE_ORIGIN_ICMP6	3
+#define SO_EE_ORIGIN_TIMESTAMPING 4
 
 #define SO_EE_OFFENDER(ee)	((struct sockaddr*)((ee)+1))
 
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4a853ef..efeff3d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -414,6 +414,9 @@ enum positive_aop_returns {
 
 #define AOP_FLAG_UNINTERRUPTIBLE	0x0001 /* will not do a short write */
 #define AOP_FLAG_CONT_EXPAND		0x0002 /* called from cont_expand */
+#define AOP_FLAG_NOFS			0x0004 /* used by filesystem to direct
+						* helper code (eg buffer layer)
+						* to clear GFP_FS from alloc */
 
 /*
  * oh the beauties of C type declarations.
@@ -2023,7 +2026,7 @@ extern int page_readlink(struct dentry *, char __user *, int);
 extern void *page_follow_link_light(struct dentry *, struct nameidata *);
 extern void page_put_link(struct dentry *, struct nameidata *, void *);
 extern int __page_symlink(struct inode *inode, const char *symname, int len,
-		gfp_t gfp_mask);
+		int nofs);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
 extern int generic_readlink(struct dentry *, char __user *, int);
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index 35a7b5e..13ce453 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -212,22 +212,34 @@ enum zone_type {
 	 * i386, x86_64 and multiple other arches
 	 * 			<16M.
 	 */
+#ifdef CONFIG_ZONE_DMA_IDX
+	ZONE_DMA = CONFIG_ZONE_DMA_IDX,
+#else
 	ZONE_DMA,
 #endif
+#endif
 #ifdef CONFIG_ZONE_DMA32
 	/*
 	 * x86_64 needs two ZONE_DMAs because it supports devices that are
 	 * only able to do DMA to the lower 16M but also 32 bit devices that
 	 * can only do DMA areas below 4G.
 	 */
+#ifdef CONFIG_ZONE_DMA32_IDX
+	ZONE_DMA32 = CONFIG_ZONE_DMA32_IDX,
+#else
 	ZONE_DMA32,
 #endif
+#endif
 	/*
 	 * Normal addressable memory is in ZONE_NORMAL. DMA operations can be
 	 * performed on pages in ZONE_NORMAL if the DMA devices support
 	 * transfers to all addressable memory.
 	 */
+#ifdef CONFIG_ZONE_NORMAL_IDX
+	ZONE_NORMAL = CONFIG_ZONE_NORMAL_IDX,
+#else
 	ZONE_NORMAL,
+#endif
 #ifdef CONFIG_HIGHMEM
 	/*
 	 * A memory area that is only addressable by the kernel through
@@ -237,9 +249,17 @@ enum zone_type {
 	 * table entries on i386) for each page that the kernel needs to
 	 * access.
 	 */
+#ifdef CONFIG_ZONE_HIGHMEM_IDX
+	ZONE_HIGHMEM = CONFIG_ZONE_HIGHMEM_IDX,
+#else
 	ZONE_HIGHMEM,
 #endif
+#endif
+#ifdef CONFIG_ZONE_MOVABLE_IDX
+	ZONE_MOVABLE = CONFIG_ZONE_MOVABLE_IDX,
+#else
 	ZONE_MOVABLE,
+#endif
 	__MAX_NR_ZONES
 };
 
diff --git a/include/linux/mtd/concat.h b/include/linux/mtd/concat.h
index c02f3d2..e80c674 100644
--- a/include/linux/mtd/concat.h
+++ b/include/linux/mtd/concat.h
@@ -13,7 +13,7 @@
 struct mtd_info *mtd_concat_create(
     struct mtd_info *subdev[],  /* subdevices to concatenate */
     int num_devs,               /* number of subdevices      */
-    char *name);                /* name for the new device   */
+    const char *name);          /* name for the new device   */
 
 void mtd_concat_destroy(struct mtd_info *mtd);
 
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index e26f549..9726288 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -764,6 +764,17 @@ struct net_device
 	/* for setting kernel sock attribute on TCP connection setup */
 #define GSO_MAX_SIZE		65536
 	unsigned int		gso_max_size;
+
+#define HAVE_HW_TIME_STAMP
+	/* Transforms original raw hardware time stamp to
+	 * system time base. Always required when supporting
+	 * hardware time stamping.
+	 *
+	 * Returns empty stamp (= all zero) if conversion wasn't
+	 * possible.
+	 */
+	ktime_t             (*hwtstamp_raw2sys)(struct net_device *dev,
+						ktime_t hwstamp);
 };
 #define to_net_dev(d) container_of(d, struct net_device, dev)
 
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 709742b..01ca085 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -241,7 +241,8 @@ unsigned find_get_pages_contig(struct address_space *mapping, pgoff_t start,
 unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
 			int tag, unsigned int nr_pages, struct page **pages);
 
-struct page *__grab_cache_page(struct address_space *mapping, pgoff_t index);
+struct page *grab_cache_page_write_begin(struct address_space *mapping,
+			pgoff_t index, unsigned flags);
 
 /*
  * Returns locked page at given index in given cache, creating it if needed.
diff --git a/include/linux/pc302fuse.h b/include/linux/pc302fuse.h
new file mode 100644
index 0000000..3f5333c
--- /dev/null
+++ b/include/linux/pc302fuse.h
@@ -0,0 +1,155 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006-2008 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#ifndef __PC302FUSE_H__
+#define __PC302FUSE_H__
+
+#include <linux/ioctl.h>
+
+/**
+ * \brief Data structure used for passing commands from userspace to kernel
+ * space.
+ */
+typedef struct
+{
+    /** The offset of the fuse (bit number). */
+    unsigned offset;
+
+    /**
+     * The value the fuse is set to if reading, invalid if blowing a fuse. If
+     * reading the estimated elapsed VDDQ time, this will be the time in
+     * micro-seconds.
+     */
+    int value;
+
+} pcfuse_t;
+
+/** The base to register ioctl commands from. */
+#define PC302_FUSE_IOCTL_BASE   'p'
+
+#define PC302_FUSE_IOCTL_START  ( 0xA0 )
+
+/** Get the status of a fuse. */
+#define PC302_FUSE_GET          _IOWR( PC302_FUSE_IOCTL_BASE, \
+        PC302_FUSE_IOCTL_START + 0, pcfuse_t )
+/** Blow a fuse. */
+#define PC302_FUSE_BLOW         _IOWR( PC302_FUSE_IOCTL_BASE, \
+        PC302_FUSE_IOCTL_START + 1, pcfuse_t )
+/** Get the estimated VDDQ elapsed time. */
+#define PC302_FUSE_GET_VDDQ     _IOR( PC302_FUSE_IOCTL_BASE, \
+        PC302_FUSE_IOCTL_START + 2, pcfuse_t )
+
+#define PC302_FUSE_IOCTL_NUM_IOCTL  ( 3 )
+
+/** The total number of fuses in the PC302 (including reserved bits). */
+#define PC302_FUSE_NUM_FUSES    ( 4096 )
+
+/**
+ * \brief Structure to represent a fuse range.
+ */
+struct fuse_range_t
+{
+    /** The index of the first fuse in the range. */
+    int start;
+
+    /** The index of the last fuse in the range. */
+    int end;
+};
+
+/** Create a fuse_range_t given the start and end positions. */
+#define PC302_FUSE_MK_RANGE( _start, _end ) \
+    ( const struct fuse_range_t ) { .start = _start, .end = _end }
+
+/*
+ * Begin fuse bit and range definitions.
+ *
+ * FB is an abbreviation of *F*use *B*it.
+ * FR is an abbreviation of *F*use *R*ange.
+ */
+
+#define PC302_FB_SECURE_BOOT                              ( 992 )
+#define PC302_FB_DISABLE_TRUSTZONE                        ( 993 )
+#define PC302_FB_GLOBAL_LAST_TIME_PROGRAM                 ( 994 )
+#define PC302_FB_DISABLE_DEBUG                            ( 995 )
+#define PC302_FB_DISABLE_ISC                              ( 996 )
+#define PC302_FB_DISABLE_JTAG                             ( 997 )
+#define PC302_FB_DISABLE_INVASIVE_DEBUG_IN_SECURE         ( 998 )
+#define PC302_FB_DISABLE_NON_INVASIVE_DEBUG_IN_SECURE     ( 999 )
+#define PC302_FB_DISABLE_CP15_REGISTER                    ( 1000 )
+#define PC302_FB_DUAL_SINGLE_MEMIF                        ( 1001 )
+#define PC302_FB_DISABLE_NON_SECURE_PARALLEL_FLASH        ( 1002 )
+
+#define PC302_FUSE_ROBP_BASE                              ( 928 )
+#define PC302_FUSE_LTP_BASE                               ( 938 )
+#define PC302_FUSE_DJTAGRK_BASE                           ( 948 )
+
+/* Secure boot. */
+#define PC302_FR_SECURE_BOOTSTRAP           PC302_FUSE_MK_RANGE( 0, 127 )
+#define PC302_FB_SECURE_BOOTSTRAP_ROPB      ( PC302_FUSE_ROBP_BASE + 0 )
+#define PC302_FB_SECURE_BOOTSTRAP_LTP       ( PC302_FUSE_LTP_BASE + 0 )
+#define PC302_FB_SECURE_BOOTSTRAP_DJRK      ( PC302_FUSE_DJTAGRK_BASE + 0 )
+
+#define PC302_FR_COUNTER_IV                 PC302_FUSE_MK_RANGE( 128, 255 )
+#define PC302_FB_COUNTER_IV_ROPB            ( PC302_FUSE_ROBP_BASE + 1 )
+#define PC302_FB_COUNTER_IV_LTP             ( PC302_FUSE_LTP_BASE + 1 )
+#define PC302_FB_COUNTER_IV_DJRK            ( PC302_FUSE_DJTAGRK_BASE + 1 )
+
+/* Key 2. */
+#define PC302_FR_KEY2                       PC302_FUSE_MK_RANGE( 256, 383 )
+#define PC302_FB_KEY2_ROPB                  ( PC302_FUSE_ROBP_BASE + 2 )
+#define PC302_FB_KEY2_LTP                   ( PC302_FUSE_LTP_BASE + 2 )
+#define PC302_FB_KEY2_DJRK                  ( PC302_FUSE_DJTAGRK_BASE + 2 )
+
+/* Key 3. */
+#define PC302_FR_KEY3                       PC302_FUSE_MK_RANGE( 384, 511 )
+#define PC302_FB_KEY3_ROPB                  ( PC302_FUSE_ROBP_BASE + 3 )
+#define PC302_FB_KEY3_LTP                   ( PC302_FUSE_LTP_BASE + 3 )
+#define PC302_FB_KEY3_DJRK                  ( PC302_FUSE_DJTAGRK_BASE + 3 )
+
+/* Key 4. */
+#define PC302_FR_KEY4                       PC302_FUSE_MK_RANGE( 512, 639 )
+#define PC302_FB_KEY4_ROPB                  ( PC302_FUSE_ROBP_BASE + 4 )
+#define PC302_FB_KEY4_LTP                   ( PC302_FUSE_LTP_BASE + 4 )
+#define PC302_FB_KEY4_DJRK                  ( PC302_FUSE_DJTAGRK_BASE + 4 )
+
+/* Key 5. */
+#define PC302_FR_KEY5                       PC302_FUSE_MK_RANGE( 640, 767 )
+#define PC302_FB_KEY5_ROPB                  ( PC302_FUSE_ROBP_BASE + 5 )
+#define PC302_FB_KEY5_LTP                   ( PC302_FUSE_LTP_BASE + 5 )
+#define PC302_FB_KEY5_DJRK                  ( PC302_FUSE_DJTAGRK_BASE + 5 )
+
+/* Die identification number. */
+#define PC302_FR_DIE_IDENT                  PC302_FUSE_MK_RANGE( 768, 895 )
+#define PC302_FB_DIE_IDENT_ROPB             ( PC302_FUSE_ROBP_BASE + 6 )
+#define PC302_FB_DIE_IDENT_LTP              ( PC302_FUSE_LTP_BASE + 6 )
+#define PC302_FB_DIE_IDENT_DJRK             ( PC302_FUSE_DJTAGRK_BASE + 6 )
+
+/* Customer partition 1. */
+#define PC302_FR_PARTITION_1                PC302_FUSE_MK_RANGE( 1024, 2047 )
+#define PC302_FB_PARTITION_1_ROPB           ( PC302_FUSE_ROBP_BASE + 7 )
+#define PC302_FB_PARTITION_1_LTP            ( PC302_FUSE_LTP_BASE + 7 )
+#define PC302_FB_PARTITION_1_DJRK           ( PC302_FUSE_DJTAGRK_BASE + 7 )
+
+/* Customer partition 2. */
+#define PC302_FR_PARTITION_2                PC302_FUSE_MK_RANGE( 2048, 3071 )
+#define PC302_FB_PARTITION_2_ROPB           ( PC302_FUSE_ROBP_BASE + 8 )
+#define PC302_FB_PARTITION_2_LTP            ( PC302_FUSE_LTP_BASE + 8 )
+#define PC302_FB_PARTITION_2_DJRK           ( PC302_FUSE_DJTAGRK_BASE + 8 )
+
+/* Customer partition 3. */
+#define PC302_FR_PARTITION_3                PC302_FUSE_MK_RANGE( 3072, 4095 )
+#define PC302_FB_PARTITION_3_ROPB           ( PC302_FUSE_ROBP_BASE + 9 )
+#define PC302_FB_PARTITION_3_LTP            ( PC302_FUSE_LTP_BASE + 9 )
+#define PC302_FB_PARTITION_3_DJRK           ( PC302_FUSE_DJTAGRK_BASE + 9 )
+
+#endif /* !__PC302FUSE_H__ */
+
diff --git a/include/linux/perfcounters.h b/include/linux/perfcounters.h
new file mode 100644
index 0000000..0a54811
--- /dev/null
+++ b/include/linux/perfcounters.h
@@ -0,0 +1,112 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006-2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+#ifndef __PERFCOUNTERS_H__
+#define __PERFCOUNTERS_H__
+
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+
+struct perfcounter;
+
+#define PERFCOUNTER_MAX_NAME        ( 32 )
+
+/*
+ * Operations for performance counters. At a minimum, counters must implement
+ * enable, disable and read methods.
+ */
+struct perfcounter_ops
+{
+    /* Enable the counter. */
+    int ( *enable )( struct perfcounter *counter );
+
+    /* Disable the counter. */
+    int ( *disable )( struct perfcounter *counter );
+
+    /* Read the value of the counter. */
+    int ( *read )( struct perfcounter *counter,
+                   u64 *val );
+
+    /* Reset the counter back to 0. */
+    int ( *reset )( struct perfcounter *counter );
+
+    /* Set the event that the counter should monitor. */
+    int ( *set_event)( struct perfcounter *counter,
+                       int event );
+
+    /* Interrupt for counter overflow. This is responsible for maintaining a
+     * larger count. */
+    irqreturn_t ( *overflow )( struct perfcounter *counter );
+};
+
+/*
+ * Performance counter structure.
+ */
+struct perfcounter
+{
+    /* The unique name of the performance counter. This name is used for the
+     * sysfs entry and the device node. These will be:
+     *   /sys/class/perfcounter/_name_/
+     *   /dev/_name_
+     */
+    const char              name[ PERFCOUNTER_MAX_NAME ];
+
+    /* The operations for the counter. */
+    struct perfcounter_ops  *ops;
+
+    /*
+     * The interrupt that the counter generates at overflow. This may be
+     * omitted if not required. If set, the ops must have an overflow method.
+     */
+    unsigned int            irq;
+
+    /* The IRQ flags to pass to request_irq(). */
+    unsigned long           irq_flags;
+
+    struct module           *owner;
+
+    /*
+     * Fields that are populated by the performance counter subsystem. These
+     * fields should not be manipulated by users.
+     */
+
+    /* Boolean flag to indicate the enabled/disabled status of the counter. */
+    int                     enabled;
+
+    /* The base count of the counter. This should be incremented by 2^32 when
+     * the counter overflows and added to the counter value when read. */
+    u64                     base_count;
+
+    /* The event that the counter is monitoring. This is ignored if the
+     * counter is not configurable. */
+    int                     event;
+
+    /* The character device for the counter. */
+    struct cdev             cdev;
+
+    /* The actual sysfs device used for manipulating the counter. */
+    struct device           *dev;
+};
+
+/* Register a new performance counter. This will register the counter with the
+ * performance counter subsystem and leave it disabled at start. */
+int
+perfcounter_register( struct perfcounter *counter );
+
+/* Remove a counter from the performance counter subsystem. */
+int
+perfcounter_unregister( struct perfcounter *counter );
+
+#endif /* __PERFCOUNTERS_H__ */
diff --git a/include/linux/picochip/devices/pc202.h b/include/linux/picochip/devices/pc202.h
new file mode 100644
index 0000000..05a4633
--- /dev/null
+++ b/include/linux/picochip/devices/pc202.h
@@ -0,0 +1,241 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file pc202.h
+ * \brief PC202 resource definition file.
+ *
+ * This file defines a list of resources including DMA channels, GPRs and
+ * interrupt sources in the PC202 and PC205 devices.
+ */
+
+#ifndef __PICOIF_PC202_H__
+#define __PICOIF_PC202_H__
+
+/*!
+ * \brief DMA channel identifiers for PC202 / PC205 devices.
+ *
+ * This enum defines a list of DMA channels that are available for data
+ * transport in PC202 / PC205 devices.
+ */
+enum picoifDMAId_PC202
+{
+    PC202_DMA_PROCIF_0 = 0x0000,
+    PC202_DMA_PROCIF_1,
+    PC202_DMA_PROCIF_2,
+    PC202_DMA_PROCIF_3,
+    PC202_DMA_AHB2PICO_0,
+    PC202_DMA_AHB2PICO_1,
+    PC202_DMA_AHB2PICO_2,
+    PC202_DMA_AHB2PICO_3,
+    PICO_NUM_DMA_CHANNELS,
+
+};
+
+/*!
+ * \brief GPR identifiers for PC202 / PC205 devices.
+ *
+ * This enum defines a list of general purpose registers (GPRs) that are
+ * available for reading/writing and transport use in PC202 / PC205 devices.
+ */
+enum picoifGPRId_PC202
+{
+    PC202_GPR_PROCIF_0 = 0x1000,
+    PC202_GPR_PROCIF_1,
+    PC202_GPR_PROCIF_2,
+    PC202_GPR_PROCIF_3,
+    PC202_GPR_PROCIF_4,
+    PC202_GPR_PROCIF_5,
+    PC202_GPR_PROCIF_6,
+    PC202_GPR_PROCIF_7,
+    PC202_GPR_PROCIF_8,
+    PC202_GPR_PROCIF_9,
+    PC202_GPR_PROCIF_10,
+    PC202_GPR_PROCIF_11,
+    PC202_GPR_PROCIF_12,
+    PC202_GPR_PROCIF_13,
+    PC202_GPR_PROCIF_14,
+    PC202_GPR_PROCIF_15,
+    PC202_GPR_PROCIF_16,
+    PC202_GPR_PROCIF_17,
+    PC202_GPR_PROCIF_18,
+    PC202_GPR_PROCIF_19,
+    PC202_GPR_PROCIF_20,
+    PC202_GPR_PROCIF_21,
+    PC202_GPR_PROCIF_22,
+    PC202_GPR_PROCIF_23,
+    PC202_GPR_ITM,
+    PC202_GPR_ITS,
+    PC202_GPR_AHB2PICO_0,
+    PC202_GPR_AHB2PICO_1,
+    PC202_GPR_AHB2PICO_2,
+    PC202_GPR_AHB2PICO_3,
+    PC202_GPR_AHB2PICO_4,
+    PC202_GPR_AHB2PICO_5,
+    PC202_GPR_AHB2PICO_6,
+    PC202_GPR_AHB2PICO_7,
+    PC202_GPR_AHB2PICO_8,
+    PC202_GPR_AHB2PICO_9,
+    PC202_GPR_AHB2PICO_10,
+    PC202_GPR_AHB2PICO_11,
+    PC202_GPR_AHB2PICO_12,
+    PC202_GPR_AHB2PICO_13,
+    PC202_GPR_AHB2PICO_14,
+    PC202_GPR_AHB2PICO_15,
+    PC202_GPR_AHB2PICO_16,
+    PC202_GPR_AHB2PICO_17,
+    PC202_GPR_AHB2PICO_18,
+    PC202_GPR_AHB2PICO_19,
+    PC202_GPR_AHB2PICO_20,
+    PC202_GPR_AHB2PICO_21,
+    PC202_GPR_AHB2PICO_22,
+    PC202_GPR_AHB2PICO_23,
+    PICO_NUM_GPRS,
+
+};
+
+/*!
+ * \brief IRQ identifiers for PC202 / PC205 devices.
+ *
+ * This enum defines a list of interrupt sources that are available for
+ * transport use in PC202 / PC205 devices.
+ */
+enum picoifIRQId_PC202
+{
+    PC202_IRQ_PROCIF = 0x2000,
+    PC202_IRQ_AHB2PICO_0,
+    PC202_IRQ_AHB2PICO_1,
+    PC202_IRQ_AHB2PICO_2,
+    PC202_IRQ_AHB2PICO_3,
+    PC202_IRQ_AHB2PICO_4,
+    PC202_IRQ_AHB2PICO_5,
+    PC202_IRQ_AHB2PICO_6,
+    PC202_IRQ_AHB2PICO_7,
+    PC202_IRQ_AHB2PICO_8,
+    PC202_IRQ_AHB2PICO_9,
+    PC202_IRQ_AHB2PICO_10,
+    PC202_IRQ_AHB2PICO_11,
+    PC202_IRQ_AHB2PICO_12,
+    PC202_IRQ_AHB2PICO_13,
+    PC202_IRQ_AHB2PICO_14,
+    PC202_IRQ_AHB2PICO_15,
+    PC202_IRQ_AHB2PICO_16,
+    PC202_IRQ_AHB2PICO_17,
+    PC202_IRQ_AHB2PICO_18,
+    PC202_IRQ_AHB2PICO_19,
+    PC202_IRQ_AHB2PICO_20,
+    PC202_IRQ_AHB2PICO_21,
+    PC202_IRQ_AHB2PICO_22,
+    PC202_IRQ_AHB2PICO_23,
+    PICO_NUM_IRQS,
+
+};
+
+/*! 
+ * \brief GPIO and SDGPIO identifiers for PC202 devices.
+ *  
+ * This enum defines a list of (SD)GPIO sources that are available for
+ * use in PC202 devices.
+ */ 
+enum picoifGpioPinNum_PC202
+{
+    PC202_GPIO_PIN_INVAL = -1,  /*< Invalid pin configuration. */
+    PC202_GPIO_PIN_ARM_0 =  0,  /* ARM GPIO pin identifiers. */
+    PC202_GPIO_PIN_ARM_1,
+    PC202_GPIO_PIN_ARM_2,
+    PC202_GPIO_PIN_ARM_3,
+    PC202_GPIO_PIN_ARM_4,
+    PC202_GPIO_PIN_ARM_5,
+    PC202_GPIO_PIN_ARM_6,
+    PC202_GPIO_PIN_ARM_7,
+    PC202_GPIO_PIN_SDGPIO_0,    /* SDGPIO pin identifiers. */
+    PC202_GPIO_PIN_SDGPIO_1,
+    PC202_GPIO_PIN_SDGPIO_2,
+    PC202_GPIO_PIN_SDGPIO_3,
+    PC202_GPIO_PIN_SDGPIO_4,
+    PC202_GPIO_PIN_SDGPIO_5,
+    PC202_GPIO_PIN_SDGPIO_6,
+    PC202_GPIO_PIN_SDGPIO_7,
+    PC202_GPIO_PIN_SDGPIO_8,
+    PC202_GPIO_PIN_SDGPIO_9,
+    PC202_GPIO_PIN_SDGPIO_10,
+    PC202_GPIO_PIN_SDGPIO_11,
+    PC202_GPIO_PIN_SDGPIO_12,
+    PC202_GPIO_PIN_SDGPIO_13,
+    PC202_GPIO_PIN_SDGPIO_14,
+    PC202_GPIO_PIN_SDGPIO_15,
+    PC202_GPIO_PIN_SDGPIO_16,
+    PC202_GPIO_PIN_SDGPIO_17,
+    PC202_GPIO_PIN_SDGPIO_18,
+    PC202_GPIO_PIN_SDGPIO_19,
+    PC202_GPIO_PIN_SDGPIO_20,
+    PC202_GPIO_PIN_SDGPIO_21,
+    PC202_GPIO_PIN_SDGPIO_22,
+    PC202_GPIO_PIN_SDGPIO_23,
+    PC202_GPIO_PIN_SDGPIO_24,
+    PC202_GPIO_PIN_SDGPIO_25,
+    PC202_GPIO_PIN_SDGPIO_26,
+    PC202_GPIO_PIN_SDGPIO_27,
+    PC202_GPIO_PIN_SDGPIO_28,
+    PC202_GPIO_PIN_SDGPIO_29,
+    PC202_GPIO_PIN_SDGPIO_30,
+    PC202_GPIO_PIN_SDGPIO_31,
+    PICO_NUM_GPIOS,
+
+};
+
+/*!
+ * \brief Type for identifying registers in a picoArray.
+ *
+ * GPR identifier. This is used to define a GPR resource for transports and
+ * for GPR accesses - these should be used rather than absolute GPR numbers.
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifGPRId_PC202 picoifGPRId_t;
+
+/*!
+ * \brief Type for identifying DMA channels in a picoArray.
+ *
+ * DMA identifier. This is used to define a DMA resource for transports these
+ * should be used rather than absolute DMA channel numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifDMAId_PC202 picoifDMAId_t;
+
+/*!
+ * \brief Type for identifying IRQ numbers in a picoArray.
+ *
+ * IRQ identifier. This is used to define an IRQ resource for transports these
+ * should be used rather than absolute IRQ numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifIRQId_PC202 picoifIRQId_t;
+
+/*!
+ * \brief Type for identifying (SD)GPIO pins in a picoArray.
+ *
+ * GPIO identifier. This is used to define an GPIO resource which 
+ * should be used rather than absolute GPIO numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifGpioPinNum_PC202 picoifGpioPinNum_t;
+
+#endif /* !__PICOIF_PC202_H__ */
diff --git a/include/linux/picochip/devices/pc203.h b/include/linux/picochip/devices/pc203.h
new file mode 100644
index 0000000..c77d45c
--- /dev/null
+++ b/include/linux/picochip/devices/pc203.h
@@ -0,0 +1,192 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file pc203.h
+ * \brief PC203 resource definition file.
+ *
+ * This file defines a list of resources including DMA channels, GPRs and
+ * interrupt sources in the PC203 device.
+ *
+ */
+
+#ifndef __PICOIF_PC203_H__
+#define __PICOIF_PC203_H__
+
+/*!
+ * \brief DMA channel identifiers for PC203 devices.
+ *
+ * This enum defines a list of DMA channels that are available for data
+ * transport in PC203 devices.
+ */
+enum picoifDMAId_PC203
+{
+    PC203_DMA_PROCIF_0 = 0x0000,
+    PC203_DMA_PROCIF_1,
+    PC203_DMA_PROCIF_2,
+    PC203_DMA_PROCIF_3,
+    PICO_NUM_DMA_CHANNELS,
+};
+
+/*!
+ * \brief GPR identifiers for PC203 devices.
+ *
+ * This enum defines a list of general purpose registers (GPRs) that are
+ * available for reading/writing and transport use in PC203 devices.
+ */
+enum picoifGPRId_PC203
+{
+    PC203_GPR_PROCIF_0 = 0x1000,
+    PC203_GPR_PROCIF_1,
+    PC203_GPR_PROCIF_2,
+    PC203_GPR_PROCIF_3,
+    PC203_GPR_PROCIF_4,
+    PC203_GPR_PROCIF_5,
+    PC203_GPR_PROCIF_6,
+    PC203_GPR_PROCIF_7,
+    PC203_GPR_PROCIF_8,
+    PC203_GPR_PROCIF_9,
+    PC203_GPR_PROCIF_10,
+    PC203_GPR_PROCIF_11,
+    PC203_GPR_PROCIF_12,
+    PC203_GPR_PROCIF_13,
+    PC203_GPR_PROCIF_14,
+    PC203_GPR_PROCIF_15,
+    PC203_GPR_PROCIF_16,
+    PC203_GPR_PROCIF_17,
+    PC203_GPR_PROCIF_18,
+    PC203_GPR_PROCIF_19,
+    PC203_GPR_PROCIF_20,
+    PC203_GPR_PROCIF_21,
+    PC203_GPR_PROCIF_22,
+    PC203_GPR_PROCIF_23,
+    PC203_GPR_ITM,
+    PC203_GPR_ITS,
+    PICO_NUM_GPRS,
+};
+
+/*!
+ * \brief IRQ identifiers for PC203 devices.
+ *
+ * This enum defines a list of interrupt sources that are available for
+ * transport use in PC203 devices.
+ */
+enum picoifIRQId_PC203
+{
+    PC203_IRQ_PROCIF = 0x2000,
+    PC203_IRQ_AHB2PICO_0,
+    PC203_IRQ_AHB2PICO_1,
+    PC203_IRQ_AHB2PICO_2,
+    PC203_IRQ_AHB2PICO_3,
+    PC203_IRQ_AHB2PICO_4,
+    PC203_IRQ_AHB2PICO_5,
+    PC203_IRQ_AHB2PICO_6,
+    PC203_IRQ_AHB2PICO_7,
+    PC203_IRQ_AHB2PICO_8,
+    PC203_IRQ_AHB2PICO_9,
+    PC203_IRQ_AHB2PICO_10,
+    PC203_IRQ_AHB2PICO_11,
+    PC203_IRQ_AHB2PICO_12,
+    PC203_IRQ_AHB2PICO_13,
+    PC203_IRQ_AHB2PICO_14,
+    PC203_IRQ_AHB2PICO_15,
+    PC203_IRQ_AHB2PICO_16,
+    PC203_IRQ_AHB2PICO_17,
+    PC203_IRQ_AHB2PICO_18,
+    PC203_IRQ_AHB2PICO_19,
+    PC203_IRQ_AHB2PICO_20,
+    PC203_IRQ_AHB2PICO_21,
+    PC203_IRQ_AHB2PICO_22,
+    PC203_IRQ_AHB2PICO_23,
+    PICO_NUM_IRQS,
+};
+
+/*! 
+ * \brief GPIO and SDGPIO identifiers for PC203 devices.
+ *  
+ * This enum defines a list of (SD)GPIO sources that are available for
+ * use in PC203 devices.
+ */ 
+enum picoifGpioPinNum_PC203
+{
+    PC203_GPIO_PIN_INVAL = -1,  /*< Invalid pin configuration. */
+    PC203_GPIO_PIN_SDGPIO_0,    /* SDGPIO pin identifiers. */
+    PC203_GPIO_PIN_SDGPIO_1,
+    PC203_GPIO_PIN_SDGPIO_2,
+    PC203_GPIO_PIN_SDGPIO_3,
+    PC203_GPIO_PIN_SDGPIO_4,
+    PC203_GPIO_PIN_SDGPIO_5,
+    PC203_GPIO_PIN_SDGPIO_6,
+    PC203_GPIO_PIN_SDGPIO_7,
+    PC203_GPIO_PIN_SDGPIO_8,
+    PC203_GPIO_PIN_SDGPIO_9,
+    PC203_GPIO_PIN_SDGPIO_10,
+    PC203_GPIO_PIN_SDGPIO_11,
+    PC203_GPIO_PIN_SDGPIO_12,
+    PC203_GPIO_PIN_SDGPIO_13,
+    PC203_GPIO_PIN_SDGPIO_14,
+    PC203_GPIO_PIN_SDGPIO_15,
+    PC203_GPIO_PIN_SDGPIO_16,
+    PC203_GPIO_PIN_SDGPIO_17,
+    PC203_GPIO_PIN_SDGPIO_18,
+    PC203_GPIO_PIN_SDGPIO_19,
+    PC203_GPIO_PIN_SDGPIO_20,
+    PC203_GPIO_PIN_SDGPIO_21,
+    PC203_GPIO_PIN_SDGPIO_22,
+    PC203_GPIO_PIN_SDGPIO_23,
+    PC203_GPIO_PIN_SDGPIO_24,
+    PC203_GPIO_PIN_SDGPIO_25,
+    PC203_GPIO_PIN_SDGPIO_26,
+    PC203_GPIO_PIN_SDGPIO_27,
+    PC203_GPIO_PIN_SDGPIO_28,
+    PC203_GPIO_PIN_SDGPIO_29,
+    PC203_GPIO_PIN_SDGPIO_30,
+    PC203_GPIO_PIN_SDGPIO_31,
+    PICO_NUM_GPIOS,
+
+};
+
+/*!
+ * \brief Type for identifying registers in a picoArray.
+ *
+ * GPR identifier. This is used to define a GPR resource for transports and
+ * for GPR accesses - these should be used rather than absolute GPR numbers.
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifGPRId_PC203 picoifGPRId_t;
+
+/*!
+ * \brief Type for identifying DMA channels in a picoArray.
+ *
+ * DMA identifier. This is used to define a DMA resource for transports these
+ * should be used rather than absolute DMA channel numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifDMAId_PC203 picoifDMAId_t;
+
+/*!
+ * \brief Type for identifying (SD)GPIO pins in a picoArray.
+ *
+ * GPIO identifier. This is used to define an GPIO resource which
+ * should be used rather than absolute GPIO numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifGpioPinNum_PC203 picoifGpioPinNum_t;
+
+#endif /* !__PICOIF_PC203_H__ */
diff --git a/include/linux/picochip/devices/pc302.h b/include/linux/picochip/devices/pc302.h
new file mode 100644
index 0000000..72d6636
--- /dev/null
+++ b/include/linux/picochip/devices/pc302.h
@@ -0,0 +1,205 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file pc302.h
+ * \brief PC302 resource definition file.
+ *
+ * This file defines a list of resources including DMA channels, GPRs and
+ * interrupt sources in the PC302 device.
+ */
+
+#ifndef __PICOIF_PC302_H__
+#define __PICOIF_PC302_H__
+
+/*!
+ * \brief DMA channel identifiers for PC302 devices.
+ *
+ * This enum defines a list of DMA channels that are available for data
+ * transport in PC302 devices.
+ */
+enum picoifDMAId_PC302
+{
+    PC302_DMA_AXI2PICO_0 = 0x0000,
+    PC302_DMA_AXI2PICO_1,
+    PC302_DMA_AXI2PICO_2,
+    PC302_DMA_AXI2PICO_3,
+    PC302_DMA_AXI2PICO_4,
+    PC302_DMA_AXI2PICO_5,
+    PC302_DMA_AXI2PICO_6,
+    PC302_DMA_AXI2PICO_7,
+    PICO_NUM_DMA_CHANNELS,
+
+};
+
+/*!
+ * \brief GPR identifiers for PC302 devices.
+ *
+ * This enum defines a list of general purpose registers (GPRs) that are
+ * available for reading/writing and transport use in PC302 devices.
+ */
+enum picoifGPRId_PC302
+{
+    PC302_GPR_AXI2PICO_0 = 0x1000,
+    PC302_GPR_AXI2PICO_1,
+    PC302_GPR_AXI2PICO_2,
+    PC302_GPR_AXI2PICO_3,
+    PC302_GPR_AXI2PICO_4,
+    PC302_GPR_AXI2PICO_5,
+    PC302_GPR_AXI2PICO_6,
+    PC302_GPR_AXI2PICO_7,
+    PC302_GPR_AXI2PICO_8,
+    PC302_GPR_AXI2PICO_9,
+    PC302_GPR_AXI2PICO_10,
+    PC302_GPR_AXI2PICO_11,
+    PC302_GPR_AXI2PICO_12,
+    PC302_GPR_AXI2PICO_13,
+    PC302_GPR_AXI2PICO_14,
+    PC302_GPR_AXI2PICO_15,
+    PC302_GPR_AXI2PICO_16,
+    PC302_GPR_AXI2PICO_17,
+    PC302_GPR_AXI2PICO_18,
+    PC302_GPR_AXI2PICO_19,
+    PC302_GPR_AXI2PICO_20,
+    PC302_GPR_AXI2PICO_21,
+    PC302_GPR_AXI2PICO_22,
+    PC302_GPR_AXI2PICO_23,
+    PICO_NUM_GPRS,
+
+};
+
+/*!
+ * \brief IRQ identifiers for PC302 devices.
+ *
+ * This enum defines a list of interrupt sources that are available for
+ * transport use in PC302 devices.
+ */
+enum picoifIRQId_PC302
+{
+    PC302_IRQ_AXI2PICO_0 = 0x2000,
+    PC302_IRQ_AXI2PICO_1,
+    PC302_IRQ_AXI2PICO_2,
+    PC302_IRQ_AXI2PICO_3,
+    PC302_IRQ_AXI2PICO_4,
+    PC302_IRQ_AXI2PICO_5,
+    PC302_IRQ_AXI2PICO_6,
+    PC302_IRQ_AXI2PICO_7,
+    PC302_IRQ_AXI2PICO_8,
+    PC302_IRQ_AXI2PICO_9,
+    PC302_IRQ_AXI2PICO_10,
+    PC302_IRQ_AXI2PICO_11,
+    PC302_IRQ_AXI2PICO_12,
+    PC302_IRQ_AXI2PICO_13,
+    PC302_IRQ_AXI2PICO_14,
+    PC302_IRQ_AXI2PICO_15,
+    PC302_IRQ_AXI2PICO_16,
+    PC302_IRQ_AXI2PICO_17,
+    PC302_IRQ_AXI2PICO_18,
+    PC302_IRQ_AXI2PICO_19,
+    PC302_IRQ_AXI2PICO_20,
+    PC302_IRQ_AXI2PICO_21,
+    PC302_IRQ_AXI2PICO_22,
+    PC302_IRQ_AXI2PICO_23,
+    PICO_NUM_IRQS,
+
+};
+
+/*!
+ * \brief GPIO and SDGPIO identifiers for PC302 devices.
+ *
+ * This enum defines a list of (SD)GPIO sources that are available for
+ * use in PC302 devices.
+ */
+enum picoifGpioPinNum_PC302
+{
+    PC302_GPIO_PIN_INVAL = -1,  /*< Invalid pin configuration. */
+    PC302_GPIO_PIN_ARM_0 =  0,  /* ARM GPIO pin identifiers. */
+    PC302_GPIO_PIN_ARM_1,
+    PC302_GPIO_PIN_ARM_2,
+    PC302_GPIO_PIN_ARM_3,
+    PC302_GPIO_PIN_ARM_4,
+    PC302_GPIO_PIN_ARM_5,
+    PC302_GPIO_PIN_ARM_6,
+    PC302_GPIO_PIN_ARM_7,
+    PC302_GPIO_PIN_SDGPIO_0,    /* SDGPIO pin identifiers. */
+    PC302_GPIO_PIN_SDGPIO_1,
+    PC302_GPIO_PIN_SDGPIO_2,
+    PC302_GPIO_PIN_SDGPIO_3,
+    PC302_GPIO_PIN_SDGPIO_4,
+    PC302_GPIO_PIN_SDGPIO_5,
+    PC302_GPIO_PIN_SDGPIO_6,
+    PC302_GPIO_PIN_SDGPIO_7,
+    PC302_GPIO_PIN_ARM_8,      /* ARM shared pins. */
+    PC302_GPIO_PIN_ARM_9,
+    PC302_GPIO_PIN_ARM_10,
+    PC302_GPIO_PIN_ARM_11,
+    PC302_GPIO_PIN_ARM_12,
+    PC302_GPIO_PIN_ARM_13,
+    PC302_GPIO_PIN_ARM_14,
+    PC302_GPIO_PIN_ARM_15,
+    PC302_GPIO_PIN_SDGPIO_8,  /* SDGPIO shared pins. */
+    PC302_GPIO_PIN_SDGPIO_9,
+    PC302_GPIO_PIN_SDGPIO_10,
+    PC302_GPIO_PIN_SDGPIO_11,
+    PC302_GPIO_PIN_SDGPIO_12,
+    PC302_GPIO_PIN_SDGPIO_13,
+    PC302_GPIO_PIN_SDGPIO_14,
+    PC302_GPIO_PIN_SDGPIO_15,
+    PICO_NUM_GPIOS,
+};
+
+/*!
+ * \brief Type for identifying registers in a picoArray.
+ *
+ * GPR identifier. This is used to define a GPR resource for transports and
+ * for GPR accesses - these should be used rather than absolute GPR numbers.
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifGPRId_PC302 picoifGPRId_t;
+
+/*!
+ * \brief Type for identifying DMA channels in a picoArray.
+ *
+ * DMA identifier. This is used to define a DMA resource for transports these
+ * should be used rather than absolute DMA channel numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifDMAId_PC302 picoifDMAId_t;
+
+/*!
+ * \brief Type for identifying IRQ numbers in a picoArray.
+ *
+ * IRQ identifier. This is used to define an IRQ resource for transports these
+ * should be used rather than absolute IRQ numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifIRQId_PC302 picoifIRQId_t;
+
+/*!
+ * \brief Type for identifying (SD)GPIO pins in a picoArray.
+ *
+ * GPIO identifier. This is used to define an GPIO resource which
+ * should be used rather than absolute GPIO numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifGpioPinNum_PC302 picoifGpioPinNum_t;
+
+#endif /* !__PICOIF_PC302_H__ */
diff --git a/include/linux/picochip/fpga_cpe20x.h b/include/linux/picochip/fpga_cpe20x.h
new file mode 100644
index 0000000..4bef999
--- /dev/null
+++ b/include/linux/picochip/fpga_cpe20x.h
@@ -0,0 +1,130 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2006 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ *
+ */
+
+/*!
+ * \file fpga_cpe20x.h
+ * \brief Firecracker - FPGA device driver header file
+ *
+ */
+
+#ifndef __FPGA_CPE20X_H__
+#define __FPGA_CPE20X_H__
+
+/*!
+ * Get the handle of an FPGA device for use with read/write functions
+ */
+void
+*fpga_get_handle(unsigned int fpga_device_id);
+
+/* Read/Write Calls may only be used from a context that may sleep */
+
+/*!
+ * Read one of the FPGA registers
+ */
+u16
+fpga_read_reg(void *handle,
+              unsigned int reg_addr);
+
+/*!
+ * Write one of the FPGA registers
+ */
+void
+fpga_write_reg(void *handle,
+               unsigned int reg_addr,
+               u16 value);
+
+/*!
+ * Platform data structure associated with each fpga
+ */
+struct fpga_platform_data
+{
+    unsigned int fpga_device_id;
+};
+
+
+/*!
+ * Device ID's for use with fpga_get_handle
+ */
+#define FPGA_RC_ID                      (1)
+#define FPGA_AD_ID                      (2)
+
+/* SPI protocol definitions */
+
+/*!
+ * First 16 bit word, address/command
+ */
+#define FPGA_SPI_ADDR_SHIFT             (8)
+#define FPGA_SPI_ADDR_MASK              (0xff << FPGA_SPI_ADDR_SHIFT)
+#define FPGA_SPI_CMD_R_NW               (1 << 7)
+#define FPGA_SPI_CMD_RST                (1 << 6)
+
+
+/*!
+ * FPGA registers - BANK 0
+ */
+#define FPGA_TYPE_ID_REG                (0x00)
+#define FPGA_VERSION_REG                (0x01)
+#define FPGA_MODE_REG                   (0x02)
+#define FPGA_TEST_REG                   (0x03)
+#define FPGA_TEST_COUNTER_REG           (0x04)
+#define FPGA_IRQ_SELECT_REG             (0x05)
+#define FPGA_IRQ_STATUS_REG             (0x06)
+#define FPGA_IRQ_ENABLE_REG             (0x07)
+#define FPGA_IRQ_DMA_SELECT_REG         (0x08)
+#define FPGA_PICOARRAY_RESET_REG        (0x09)
+#define FPGA_PICOARRAY_CONTROL_REG      (0x0a)
+
+/*!
+ * FPGA bank select - BANK 1,2,3,4.
+ * Note: Use these with the following macros. For example to select the
+ * LED enable register (addr 0x4a) use:
+ *  FPGA_LED_REG(FPGA_OE)
+ */
+#define FPGA_INPUT                      (1)
+#define FPGA_OUTPUT                     (2)
+#define FPGA_SELECT                     (3)
+#define FPGA_OE                         (4)
+
+/*!
+ * Back registers
+ */
+#define FPGA_ADIB_CH0_RX_REG(__B)       (0x00 + ((__B) * 0x10)
+#define FPGA_ADIB_CH1_TX_REG(__B)       (0x01 + ((__B) * 0x10)
+#define FPGA_ADIC_CH0_RX_REG(__B)       (0x02 + ((__B) * 0x10)
+#define FPGA_ADIC_CH1_TX_REG(__B)       (0x03 + ((__B) * 0x10)
+#define FPGA_REG4(__B)                  (0x04 + ((__B) * 0x10)
+#define FPGA_REG5(__B)                  (0x05 + ((__B) * 0x10)
+#define FPGA_REG6(__B)                  (0x06 + ((__B) * 0x10)
+#define FPGA_SD_GPIO_LOW_REG(__B)       (0x07 + ((__B) * 0x10)
+#define FPGA_SD_GPIO_HIGH_REG(__B)      (0x08 + ((__B) * 0x10)
+#define FPGA_ARM_GPIO_REG(__B)          (0x09 + ((__B) * 0x10)
+#define FPGA_LED_REG(__B)               (0x0a + ((__B) * 0x10)
+#define FPGA_REG11(__B)                 (0x0b + ((__B) * 0x10)
+#define FPGA_REG12(__B)                 (0x0c + ((__B) * 0x10)
+#define FPGA_REG13(__B)                 (0x0d + ((__B) * 0x10)
+#define FPGA_REG14(__B)                 (0x0e + ((__B) * 0x10)
+#define FPGA_REG15(__B)                 (0x0f + ((__B) * 0x10)
+
+
+/* FPGA register bit definitions (incomplete) */
+
+/*!
+ * FPGA_TYPE_ID_REG bits
+ */
+#define FPGA_DEVICE_ID_SHIFT            (0)
+#define FPGA_DEVICE_ID_MASK             (0x0f << FPGA_DEVICE_ID_SHIFT)
+
+#endif /* __FPGA_CPE20X_H__ */
+
diff --git a/include/linux/picochip/gpio.h b/include/linux/picochip/gpio.h
new file mode 100644
index 0000000..ec980c2
--- /dev/null
+++ b/include/linux/picochip/gpio.h
@@ -0,0 +1,167 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file gpio.h
+ * \brief Kernel API core functionality for picoIf GPIO.
+ *
+ * This file defines functions for configuration and control of (SD)GPIO lines.
+ *
+ */
+
+#ifndef __PICOIF_GPIO_H__
+#define __PICOIF_GPIO_H__
+
+/*!
+ * Check if a GPIO pin ID is a valid GPIO pin in this system
+ *
+ * @param gpio The ID of the GPIO pin
+ * @return Returns 1 if gpio is a valid pin, 0 otherwise
+ */
+__must_check int
+gpio_is_valid( int gpio );
+
+/*!
+ * Request a new GPIO pin. This implements part of the Linux GPIO guidelines.
+ *
+ * @param gpio The pin ID to request
+ * @param label The name of the pin - this only serves as a tag for debugging
+ * so can be anything.
+ * @return Returns zero on success, non-zero on failure
+ * @return Returns zero on success, non-zero on failure.
+ */
+__must_check int
+gpio_request( unsigned gpio,
+              const char *label );
+
+/*!
+ * Free a GPIO pin previously requested with gpio_request().
+ *
+ * @param gpio The GPIO ID to free.
+ */
+void
+gpio_free( unsigned gpio );
+
+/*!
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * input.
+ *
+ * @param gpio The GPIO ID to configure.
+ * @return Returns zero on success, non-zero on failure.
+ */
+__must_check int
+gpio_direction_input( unsigned gpio );
+
+/*!
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * input.
+ *
+ * @param gpio The GPIO ID to configure.
+ * @param value The initial output value for the gpio pin.
+ * @return Returns zero on success, non-zero on failure.
+ */
+__must_check int
+gpio_direction_output( unsigned gpio,
+                       int value );
+
+/*!
+ * Check if a GPIO pin can sleep. Implemented as part of the Linux GPIO
+ * guidelines
+ *
+ * @return Always returns zero as none of our GPIOs can sleep
+ */
+__must_check int
+gpio_cansleep( unsigned gpio );
+
+/*!
+ * Export the GPIO pin implemented as part of the Linux GPIO guidelines.
+ *
+ * @param gpio The GPIO ID to export.
+ * @paran direction_may_change Boolean indicating the direction can change
+ * @return -ENODEV as this operation is not supported
+ */
+__must_check int
+gpio_export( unsigned gpio,
+             bool direction_may_change );
+
+/*!
+ * Un-export the GPIO pin implemented as part of the Linux GPIO guidelines.
+ *
+ * @param gpio The GPIO ID to un-export.
+ * @return -ENODEV as this operation is not supported
+ */
+__must_check int
+gpio_unexport( unsigned gpio );
+
+/*!
+ * Return the GPIO value and put the GPIO into sleep mode as specified in the
+ * Linux GPIO guidelines
+ *
+ * @param gpio The GPIO ID to read
+ * @return -EIO as none of our GPIOs can be put to sleep.
+ */
+__must_check int
+gpio_get_value_cansleep( unsigned gpio );
+
+/*!
+ * Set the GPIO value and put the GPIO into sleep mode as specified in the
+ * Linux GPIO guidelines
+ *
+ * @param gpio The GPIO ID to read
+ * @return -EIO as none of our GPIOs can be put to sleep.
+ */
+__must_check int
+gpio_set_value_cansleep( unsigned gpio,
+                         int value );
+
+/*!
+ * Set the value of the GPIO pin.
+ *
+ * @param gpio The ID of the pin to set the value of.
+ * @param value The value to set the pin to.
+ * @return zero on success, negative on failure
+ */
+__must_check int
+gpio_set_value( unsigned gpio,
+                int value );
+
+/*!
+ * Get the value of the GPIO pin.
+ *
+ * @param gpio The ID of the pin to get the value of.
+ * @param value The value to set the pin to.
+ * @return The GPIO value on success, negative on failure
+ */
+__must_check int
+gpio_get_value( unsigned gpio );
+
+/*!
+ * Given a GPIO pin ID, find the IRQ number that it can generate.
+ *
+ * @param gpio The GPIO pin to get the IRQ line for.
+ * @return Returns the IRQ number on success, negative on failure.
+ */
+__must_check int
+gpio_to_irq( unsigned gpio );
+
+/*!
+ * Given a IRQ line number, find the GPIO pin ID that can generate it.
+ *
+ * @param irq The IRQ line that can be generated by the GPIO.
+ * @return Returns the GPIO pin number on success, negative on failure.
+ */
+__must_check int
+irq_to_gpio( unsigned irq );
+
+#endif /* __PICOIF_GPIO_H__ */
diff --git a/include/linux/picochip/gpio_ioctl.h b/include/linux/picochip/gpio_ioctl.h
new file mode 100644
index 0000000..a737e48
--- /dev/null
+++ b/include/linux/picochip/gpio_ioctl.h
@@ -0,0 +1,115 @@
+/*
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *
+ * Copyright (c) 2006-2008 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file gpio_iotctl.h
+ * \brief Definition of picogpio ioctl types and associated data.
+ *
+ * This file defines the ioctl() calls used for picogpio configuration and any
+ * associated shared structures that are used to pass data from userspace into
+ * kernelspace.
+ */
+
+#ifndef __GPIO_IOCTL_H__
+#define __GPIO_IOCTL_H__
+
+#ifdef __KERNEL__
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#else /* __KERNEL__ */
+#include <sys/ioctl.h>
+#include <stdint.h>
+
+typedef uint8_t u8;
+typedef uint16_t u16;
+#endif /* __KERNEL__ */
+
+/*!
+ * \brief Data structure used for passing GPIO commands from userspace to kernel
+ * space.
+ */
+typedef struct
+{
+    unsigned pin;              /*!< Pin emumeration to use */
+    int value;                 /*!< Value to read / write */
+} picogpio_op_t;
+
+/*!
+ * \brief Data structure used for passing SDGPIO commands from userspace to
+ * kernel space.
+ */
+typedef struct
+{
+    unsigned pin;              /*!< Pin emumeration to use */ 
+    u8 converter_size;         /*!< The converter size in bits */   
+    u16 analogue_rate;         /*!< The analogue rate value of the DAC */
+
+} picogpio_analogue_config_t;
+
+/*!
+ * \brief Enumeration for specifing pin direction
+ */
+enum picogpio_pin_direction
+{
+    PICOGPIO_INPUT,           /*!< Pin is an input */
+    PICOGPIO_OUTPUT,          /*!< Pin is an output */
+};
+
+/* Lint errors 835, 506, 845, 944, 944, and 831 are supressed in these
+ * definitions as the warnings are generated by the magic ioctl code and can't
+ * be fixed here. */
+
+/*! The base to register ioctl commands from. */
+#define PICOGPIO_IOCTL_BASE   'g'
+
+/*! Offset for iotcl parameters */
+#define PICOGPIO_IOCTL_START  ( 0x00 )
+
+/*! Acquire a GPIO pin. */
+#define PICOGPIO_ACQUIRE         /*lint -e(835, 506, 845, 941, 944, 831)*/ \
+                                 _IOR( PICOGPIO_IOCTL_BASE, \
+        PICOGPIO_IOCTL_START + 0, picogpio_op_t )
+
+/*! Release a GPIO pin. */
+#define PICOGPIO_RELEASE         /*lint -e(835, 506, 845, 941, 944, 831)*/ \
+                                 _IOR( PICOGPIO_IOCTL_BASE, \
+        PICOGPIO_IOCTL_START + 1, picogpio_op_t )
+
+/*! Get the GPIO pin direction. */
+#define PICOGPIO_GET_DIRECTION   /*lint -e(835, 506, 845, 941, 944, 831)*/ \
+                                 _IOWR( PICOGPIO_IOCTL_BASE, \
+        PICOGPIO_IOCTL_START + 2, picogpio_op_t )
+
+#define PICOGPIO_SET_DIRECTION   /*lint -e(835, 506, 845, 941, 944, 831)*/ \
+                                 _IOR( PICOGPIO_IOCTL_BASE, \
+        PICOGPIO_IOCTL_START + 3, picogpio_op_t )
+
+/*! Get the GPIO pin value. */
+#define PICOGPIO_GET_VALUE       /*lint -e(835, 506, 845, 941, 944, 831)*/ \
+                                 _IOWR( PICOGPIO_IOCTL_BASE, \
+        PICOGPIO_IOCTL_START + 4, picogpio_op_t )
+
+/*! Set the GPIO pin value. */
+#define PICOGPIO_SET_VALUE       /*lint -e(835, 506, 845, 941, 944, 831)*/ \
+                                 _IOR( PICOGPIO_IOCTL_BASE, \
+        PICOGPIO_IOCTL_START + 5, picogpio_op_t )
+
+/*! Configure an analogue GPIO pin. */
+#define PICOGPIO_ANALOGUE_CONFIG /*lint -e(835, 506, 845, 941, 944, 831)*/ \
+                                 _IOR( PICOGPIO_IOCTL_BASE, \
+        PICOGPIO_IOCTL_START + 6, picogpio_analogue_config_t )
+
+/*! Number of valid ioctl parameters */
+#define PICOGPIO_IOCTL_NUM_IOCTL  ( 7 )
+
+#endif /* !__GPIO_IOCTL_H__ */
+
diff --git a/include/linux/picochip/picoif.h b/include/linux/picochip/picoif.h
new file mode 100644
index 0000000..7755ac2
--- /dev/null
+++ b/include/linux/picochip/picoif.h
@@ -0,0 +1,231 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif.h
+ * \brief Kernel API core functionality for picoIf.
+ *
+ * This file defines functions for configuration and control of picoArray devices.
+ *
+ */
+
+/*! @defgroup kernelAPI */
+
+/*!
+ *  \addtogroup kernelAPI
+ *  @{
+ *
+ *   \brief This group defines the picoIf kernel API.
+ *
+ *   \addtogroup kernelAPICore
+ *    @{
+ */
+
+#ifndef __PICOIF_PICOIF_H__
+#define __PICOIF_PICOIF_H__
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/scatterlist.h>
+
+struct picoif_module;
+
+/*!
+ * \brief Context for a transport instance opened.
+ *
+ * This represents a transport instance and points to the module that should
+ * handle the transport and the private data for that transport instance.
+ */
+struct picoif_context
+{
+    struct picoif_module    *module;        /*!< The module that implements
+                                             *  the transport. */
+
+    void                    *private_data;  /*!< Private data for the
+                                             *  transport instance. */
+
+    wait_queue_head_t       writeq;         /*!< Wait queue for blocking
+                                             *   writes. */
+
+    wait_queue_head_t       readq;          /*!< Wait queue for blocking
+                                             *   reads. */
+};
+
+/*!
+ * Perform a read from the configuration bus.
+ *
+ * @param dev_num The logical device number to read from.
+ * @param caeid The CAEID of the AE to read from.
+ * @param address The address inside the AE to begin reading from.
+ * @param count The number of 16-bit words to read.
+ * @param[out] buf Pointer to an array of u16s to store the data read.
+ * @return Returns the number of 16-bit words read on success, negative on
+ * failure.
+ */
+int
+picoif_config_read( unsigned dev_num,
+                    u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *buf );
+
+/*!
+ * Perform a write to the configuration bus.
+ *
+ * @param dev_num The logical device number to write to.
+ * @param caeid The CAEID of the AE to write to.
+ * @param address The address inside the AE to begin writing to.
+ * @param count The number of 16-bit words to write.
+ * @param buf Pointer to an array of u16s to write.
+ * @return Returns the number of 16-bit words written on success, negative on
+ * failure.
+ */
+int
+picoif_config_write( unsigned dev_num,
+                     u16 caeid,
+                     u16 address,
+                     u16 count,
+                     u16 *buf );
+
+/*!
+ * Write to a general purpose register (GPR) in a picoArray. It is possible
+ * that the reg_id may be a valid register but is being used exclusively for a
+ * transport. If this is the case then this function will return -EBUSY and
+ * the register will not be written to.
+ *
+ * If the register does not have any space to write into, then -EAGAIN will
+ * be returned.
+ *
+ * @param dev_num The logical device number of the device to use.
+ * @param reg_id The ID of the register to write to.
+ * @param value The value to write to the register.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_register_write( unsigned dev_num,
+                       unsigned reg_id,
+                       u32 value );
+
+/*!
+ * Read from a general purpose register (GPR) in a picoArray. It is possible
+ * that the reg_id may be a valid register but is being used exclusively for a
+ * transport. If this is the case then this function will return -EBUSY and
+ * the register will not be read from.
+ *
+ * If the register does not have any data available to read, then -EAGAIN will
+ * be returned.
+ *
+ * @param dev_num The logical device number of the device to use.
+ * @param reg_id The ID of the register to write to.
+ * @param[out] value A pointer to the address where the register value should
+ * be stored.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_register_read( unsigned dev_num,
+                      unsigned reg_id,
+                      u32 *value );
+
+/*!
+ * Perform a picoArray load by multiple loads to the configuration bus write
+ * port.
+ *
+ * @param dev_num The logical device number to write to.
+ * @param buf Pointer to an array of u32s to write.
+ * @return Returns the number of 32-bit words written on success, negative on
+ * failure.
+ */
+int
+picoif_pa_load( unsigned dev_num,
+                u32 *buf,
+                struct scatterlist *sgl );
+
+/*!
+ * Get the number of devices in the system.
+ *
+ * @return Returns the number of devices in the system.
+ */
+unsigned
+picoif_num_devices( void );
+
+/*!
+ * Reset all of the devices in the system.
+ *
+ * @return Returns zero on success, non-zero on failure.
+ */
+int
+picoif_reset( void );
+
+/*!
+ * Start all devices running.
+ *
+ * @return returns zero on success, non-zero on failure.
+ */
+int
+picoif_start_all( void );
+
+/*!
+ * Stop all devices running.
+ *
+ * @return returns zero on success, non-zero on failure.
+ */
+int
+picoif_stop_all( void );
+
+/*! @} */
+
+/*!
+ * Generic read method for transport instances in kernelspace. This is used
+ * to read from a transport instance when the transport type is unknown and
+ * the transport specific read function is simply a wrapper around this.
+ *
+ * @param ctx The context to read from.
+ * @param buf The buffer to store the data read into.
+ * @param len The maximum number of bytes to read.
+ * @return Returns the number of bytes read on success, negative on failure.
+ */
+ssize_t
+picoif_transport_generic_read( struct picoif_context *ctx,
+                               u8 *buf,
+                               size_t len );
+
+/*!
+ * Generic write method for transport instances in kernelspace. This is used
+ * to write to a transport instance when the transport type is unknown and
+ * the transport specific write function is simply a wrapper around this.
+ *
+ * @param ctx The context to write to.
+ * @param buf The buffer of data to write.
+ * @param len The maximum number of bytes to write.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+ssize_t
+picoif_transport_generic_write( struct picoif_context *ctx,
+                                const u8 *buf,
+                                size_t len );
+
+/*!
+ * Generic close method for a transport instance in kernelspace. This is used
+ * to close a transport instance when the transport type is unknown and the
+ * transport specific close function is simply a wrapper around this.
+ *
+ * @param ctx The transport instance to close.
+ */
+void
+picoif_transport_generic_close( struct picoif_context *ctx );
+
+/*! @} */
+
+#endif /* !__PICOIF_PICOIF_H__ */
diff --git a/include/linux/picochip/picoif_ioctl.h b/include/linux/picochip/picoif_ioctl.h
new file mode 100644
index 0000000..8a4354a
--- /dev/null
+++ b/include/linux/picochip/picoif_ioctl.h
@@ -0,0 +1,190 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif_ioctl.h
+ * \brief Definition of picoIf ioctl types and associated data.
+ *
+ * This file defines the ioctl() calls used for picoIf configuration and any
+ * associated shared structures that are used to pass data from userspace into
+ * kernelspace.
+ */
+
+#ifndef __PICOIF_PICOIF_IOCTL_H__
+#define __PICOIF_PICOIF_IOCTL_H__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <asm/ioctl.h>
+#else /* __KERNEL__ */
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+#define __user
+#endif /* __KERNEL__ */
+
+/*!
+ * \brief Structure to pass config read/write requests between userspace and
+ * the kernel.
+ */
+struct picoif_cfg_req
+{
+    __u16           dev;        /*!< Logical picoArray device number to use. */
+    __u16           caeid;      /*!< CAEID to address. */
+    __u16           ae_addr;    /*!< The address inside the AE. */
+    __u16 __user    *buf;       /*!< The buffer to read/write from/to. */
+    unsigned        count;      /*!< The number of 16 bit words to read/write. */
+};
+
+/*!
+ * \brief Structure to pass a request for a new transport instance from
+ * userspace to the kernel.
+ */
+struct picoif_new_trans_req
+{
+    const char      description[ 32 ];  /*!< Description of the transport
+                                         *   type. */
+    void __user     *params;            /*!< Extra parameters for the
+                                         *   transport. */
+};
+
+/*!
+ * \brief Structure to pass register read/write requests between userspace and
+ * the kernel.
+ */
+struct picoif_reg_req
+{
+    __u16           dev;        /*!< Logical picoArray device number to use. */
+    __u16           reg_id;     /*!< The register to read/write. */
+    __u32           value;      /*!< The value of the register. */
+};
+
+/*!
+ * \brief Structure to pass multiple config write requests between
+ * userspace and the kernel.
+ */
+struct picoif_multi_reg_req
+{
+    __u16           dev;        /*!< Logical picoArray device number to use. */
+    __u32 __user    *buf;       /*!< The buffer to write to. */
+    __u32           count;      /*!< The number of 32 bit words to write. */
+};
+
+/*! The magic number for picoIf ioctl() messages. */
+#define PICOIF_IOC_MAGIC       'p'
+
+/* Lint errors 835, 506, 845, 944, 944, and 831 are supressed in these
+ * definitions as the warnings are generated by the magic ioctl code and can't
+ * be fixed here. */
+
+/*! Config read request. */
+#define PICOIF_IOC_CFG_READ    /*lint -e(835, 506, 845, 941, 944, 831)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 0, \
+                                      struct picoif_cfg_req )
+
+/*! Config write request. */
+#define PICOIF_IOC_CFG_WRITE   /*lint -e(835, 506, 845, 944, 831 )*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 1, \
+                                      struct picoif_cfg_req )
+
+/*! Multi Config write request. */
+#define PICOIF_IOC_MULTI_CFG_WRITE   /*lint -e(835, 506, 845, 831, 944)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 2, \
+                                      struct picoif_multi_reg_req )
+
+/*! Register read request. */
+#define PICOIF_IOC_REG_READ    /*lint -e(835, 506, 845, 944, 831)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 3, \
+                                      struct picoif_reg_req )
+
+/*! Register write request. */
+#define PICOIF_IOC_REG_WRITE   /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 4, \
+                                      struct picoif_reg_req )
+
+/*! Request to reset all picoArrays. */
+#define PICOIF_IOC_RESET       /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IO( PICOIF_IOC_MAGIC, 5 )
+
+/*! Request to get the number of picoArrays in the system */
+#define PICOIF_IOC_NUMDEV      /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IOR( PICOIF_IOC_MAGIC, 6, unsigned )
+
+/*! Convert a file descriptor into a transport instance. */
+#define PICOIF_IOC_NEW_TRANS   /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 7, \
+                                      struct picoif_new_trans_req )
+
+/*! Request to start all picoArrays. */
+#define PICOIF_IOC_STARTALL    /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IO( PICOIF_IOC_MAGIC, 8 )
+
+/*! Request to stop all picoArrays. */
+#define PICOIF_IOC_STOPALL    /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IO( PICOIF_IOC_MAGIC, 9 )
+
+/*! The number of picoIf ioctl()s. */
+#define PICOIF_IOC_NUM         ( 10 )
+
+/*!
+ * \brief Structure to pass parameters for a new GPR interrupt transport
+ * instance.
+ */
+struct picoif_gpr_int_params
+{
+    unsigned        dev_num;        /*!< The logical device number to use. */
+    int             irq_num;        /*!< The GPR IRQ number to use. */
+};
+
+/*!
+ * \brief Structure to pass parameters for a new DMA DL/UL transport
+ * instance.
+ */
+struct picoif_dma_params
+{
+    unsigned        dev_num;        /*!< The logical device number to use. */
+    int             channel;        /*!< The DMA channel to use. */
+    size_t          buf_size;       /*!< The buffer size to use. */
+};
+
+/*!
+ * \brief Structure to pass parameters for a new HwIF UL transport
+ * instance.
+ */
+struct picoif_hwif_params
+{
+    unsigned        dev_num;        /*!< The picoArray to use. */
+    int             int_clear_gpr;  /*!< The interrupt clear GPR to use. */
+    unsigned        int_num;        /*!< Interrupt number to use. */
+    int             channel;        /*!< The DMA channel to use. */
+    size_t          buf_size;       /*!< The buffer size to use. */
+    int             status_gpr;     /*!< The Status GPR */
+    int             count_gpr;      /*!< The count GPR */  
+};
+
+/*!
+ * \brief Structure to pass parameters for a new HwIF 2 UL transport
+ * instance.
+ */
+struct picoif_hwif2_params
+{
+    unsigned        dev_num;        /*!< Device number to use. */
+    unsigned        int_num;        /*!< Interrupt number to use. */
+    int             channel;        /*!< The DMA channel to use. */
+    size_t          buf_size;       /*!< The buffer size to use. */
+    int             its_gpr;        /*!< The ITS GPR */
+    int             itm_gpr;        /*!< The ITM GPR */
+};
+
+#endif /* !__PICOIF_PICOIF_IOCTL_H__ */
diff --git a/include/linux/picochip/transports/dma.h b/include/linux/picochip/transports/dma.h
new file mode 100644
index 0000000..4dc5fef
--- /dev/null
+++ b/include/linux/picochip/transports/dma.h
@@ -0,0 +1,112 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma.h
+ *
+ * \brief Public picoIf DMA transport method kernel API.
+ *  \addtogroup kernelAPI
+ *  @{
+ *   \addtogroup DMA
+ *    @{
+ */
+
+#ifndef __PICOIF_PUBLIC_DMA_H__
+#define __PICOIF_PUBLIC_DMA_H__
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+
+struct picoif_context;
+
+/*!
+ * Open a new instance of the DMA DL transport.
+ *
+ * @param dev_num The logical device number of the picoArray to use.
+ * @param dma_chan The identifier of the DMA channel to use. This should be
+ * taken from the picoifDMAId_t enumeration for the appropriate device type.
+ * @param buf_size The size of buffer in bytes to allocate for this channel
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_dma_open_dl( unsigned dev_num,
+                    int dma_chan,
+                    size_t buf_size );
+
+/*!
+ * Open a new instance of the DMA UL transport.
+ *
+ * @param dev_num The logical device number of the picoArray to use.
+ * @param dma_chan The identifier of the DMA channel to use. This should be
+ * taken from the picoifDMAId_t enumeration for the appropriate device type.
+ * @param buf_size The size of buffer in bytes to allocate for this channel
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_dma_open_ul( unsigned dev_num,
+                    int dma_chan,
+                    size_t buf_size );
+
+/*!
+ * Read from the DMA channel up to the size of data specified
+ *
+ * @param ctx The open context of the transport.
+ * @param buf The buffer to write the DMA'd data into.
+ * @param len The length of the buffer in bytes.
+ * @return Returns the number of bytes read into the buffer on success,
+ * negative on failure. If no data is available to read, the -EAGAIN will be
+ * returned.
+ */
+static inline ssize_t
+picoif_dma_read( struct picoif_context *ctx,
+                 u8 *buf,
+                 size_t len )
+{
+    return picoif_transport_generic_read( ctx, buf, len );
+}
+
+/*!
+ * Write to the data supplied in a kernel mapped buffer into a DMA transport.
+ *
+ * @param ctx The open context of the transport.
+ * @param buf The buffer containing the data to transfer by DMA.
+ * @param len The length of the buffer in bytes.
+ * @return Returns the number of bytes written to the transport on success,
+ * negative on failure. If there is no space in the transport to buffer the
+ * data the -EAGAIN is returned.
+ */
+static inline ssize_t
+picoif_dma_write( struct picoif_context *ctx,
+                  u8 *buf,
+                  size_t len )
+{
+    return picoif_transport_generic_write( ctx, buf, len );
+}
+
+/*!
+ * Close an open instance of a DMA transport.
+ *
+ * @param ctx The context to close.
+ */
+static inline void
+picoif_dma_close( struct picoif_context *ctx )
+{
+    picoif_transport_generic_close( ctx );
+}
+
+/*! @} */
+/*! @} */
+
+#endif /* !__PICOIF_PUBLIC_DMA_H__ */
diff --git a/include/linux/picochip/transports/gpr_interrupt.h b/include/linux/picochip/transports/gpr_interrupt.h
new file mode 100644
index 0000000..ba96cf4
--- /dev/null
+++ b/include/linux/picochip/transports/gpr_interrupt.h
@@ -0,0 +1,99 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file gpr_interrupt.h
+ *
+ * \brief Public picoIf GPR interrupt transport method kernel API.
+ *  \addtogroup kernelAPI
+ *  @{
+ *   \addtogroup GPRIrq
+ *    @{
+ */
+
+#ifndef __PICOIF_PUBLIC_GPR_INTERRUPT_H__
+#define __PICOIF_PUBLIC_GPR_INTERRUPT_H__
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+
+struct picoif_context;
+
+/*!
+ * Open a new instance of the GPR interrupt transport.
+ *
+ * @param dev_num The logical device number of the picoArray to use.
+ * @param irq_num The identifier of the GPR number to use. This should be
+ * taken from the picoifGPRId_t enumeration.
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_gpr_irq_ul( unsigned dev_num,
+                   int irq_num );
+
+/*!
+ * Open a new instance of the GPR interrupt transport. This is like
+ * picoif_gpr_irq_ul() but rather than the read method returning the number of
+ * interrupts raised, the buffer will contain the values of the GPR at the
+ * time the interrupt was raised.
+ *
+ * @param dev_num The logical device number of the picoArray to use.
+ * @param irq_num The identifier of the IRQ source to use. This should be
+ * taken from the picoifIRQId_t enumeration.
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_gpr_irq_ul_with_values( unsigned dev_num,
+                               int irq_num );
+
+/*!
+ * Read from the GPR interrupt transport. If the values are not being
+ * recorded, the number of interrupts raised since the transport has last read
+ * will be encoded in host byte order in the first 4 bytes of the buffer so
+ * buf must be at least 4 bytes long. Alternatively, if the values are being
+ * recorded, then buf will contain the values of the GPR at interrupt time
+ * encoded in host byte order and the number of interrupts raised will be the
+ * return value divided by sizeof( u32 ).
+ *
+ * @param ctx The open context of the transport.
+ * @param buf The buffer to write the transport data into.
+ * @param len The length of the buffer in bytes.
+ * @return Returns the number of bytes read into the buffer on success,
+ * negative on failure. If no interrupts have been raised, then -EAGAIN will
+ * be returned.
+ */
+static inline ssize_t
+picoif_gpr_irq_ul_read( struct picoif_context *ctx,
+                        u8 *buf,
+                        size_t len )
+{
+    return picoif_transport_generic_read( ctx, buf, len );
+}
+
+/*!
+ * Close an open instance of a GPR interrupt transport.
+ *
+ * @param ctx The context to close.
+ */
+static inline void
+picoif_gpr_irq_ul_close( struct picoif_context *ctx )
+{
+    picoif_transport_generic_close( ctx );
+}
+
+/*! @} */
+/*! @} */
+
+#endif /* !__PICOIF_PUBLIC_GPR_INTERRUPT_H__ */
diff --git a/include/linux/picochip/transports/hwif.h b/include/linux/picochip/transports/hwif.h
new file mode 100644
index 0000000..3bac786
--- /dev/null
+++ b/include/linux/picochip/transports/hwif.h
@@ -0,0 +1,134 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file hwif.h
+ *
+ * \brief Public picoIf HwIf DMA transport method kernel API.
+ *  \addtogroup kernelAPI
+ *  @{
+ *   \addtogroup HwIf
+ *    @{
+ */
+
+#ifndef __PICOIF_PUBLIC_HWIF_H__
+#define __PICOIF_PUBLIC_HWIF_H__
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+
+struct picoif_context;
+
+/*!
+ * \brief Structure for the storage of the context in the HwIF transport
+ */
+struct picoif_hwif
+{
+    unsigned dev_num;       /*!< The device number to use in the transport. */
+    int int_clear_gpr;      /*!< The interrupt clear GPR to use. */
+};
+
+/*! Opaque pointer for the picoIf HwIf context. */
+typedef struct picoif_hwif * picoif_hwif_t;
+
+/*!
+ * Initialise a context (one per device) to support all HwIF UL transports.
+ * Once finished with, the context should be destroyed with
+ * picoifHwIF_DestroyContext().
+ *
+ * \param dev_num The logical device number to use for the transport.
+ * \param int_clear_gpr The GPR for clearing HwIF UL interrupts. This value
+ * should be taken from the picoIfGPRId_t enumeration.
+ * \return Returns a HwIF context.
+ */
+picoif_hwif_t
+picoif_hwif_init( unsigned dev_num,
+                  int int_clear_gpr );
+
+
+/*!
+ * Destroy a HwIf context used for creating transports. This may be safely
+ * destroyed once all transports using the context have been opened.
+ *
+ * \param context The context to destroy.
+ */
+void
+picoif_hwif_destroy_context( picoif_hwif_t context );
+
+/*!
+ * Create a new instance of a HwIF uplink DMA transport. This transport will
+ * allow DMA transfers from a picoArray DMA channel into a user buffer using
+ * the HwIF (Traditional ISR) mechanism. On success, a file descriptor is
+ * returned which may be read to transfer the data. When read(2) is called on
+ * the file descriptor, a transfer of all available bytes up to the specified
+ * number is made. By default this transport is configured in blocking mode
+ * but can be converted to non-blocking using the fcntl(2) command.
+ * 
+ * This function requires an interrupt clear GPR to be specified
+ * and this is done (first) by calling function picoifHwIf_Init().
+ *
+ * \param[in] hwif_context The HwIF context created by picoifHwIF_Init()
+ * \param interrupt_number The interrupt number to initiate a new transfer.
+ * \param dma_channel The DMA channel in the picoArray to use for the
+ *      transport. This should be taken from the picoIfDMAId_t enumeration.
+ * \param dma_status_gpr DMA status GPR. This value should be taken from the
+ * picoIfGPRId_t enumeration.
+ * \param dma_count_gpr DMA count GPR. This value should be taken from the
+ * picoIfGPRId_t enumeration.
+ * \param buffer_size The internal buffer size used for DMA transfers in bytes.
+ *      This should be large enough such that it does not often fill up and
+ *      reduce throughput.
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_hwif_dmaul_open( const picoif_hwif_t hwif_context,
+                        unsigned interrupt_number,
+                        int dma_channel,
+                        int dma_status_gpr,
+                        int dma_count_gpr,
+                        size_t buffer_size );
+
+/*!
+ * Read from the HwIf DMA channel up to the size of data specified
+ *
+ * @param ctx The open context of the transport.
+ * @param buf The buffer to write the DMA'd data into.
+ * @param len The length of the buffer in bytes.
+ * @return Returns the number of bytes read into the buffer on success,
+ * negative on failure. If no data is available to read, the -EAGAIN will be
+ * returned.
+ */
+static inline ssize_t
+picoif_hwif_dmaul_read( struct picoif_context *ctx,
+                        u8 *buf,
+                        size_t len )
+{
+    return picoif_transport_generic_read( ctx, buf, len );
+}
+
+/*!
+ * Close an open instance of a HwIf DMA transport.
+ *
+ * @param ctx The context to close.
+ */
+static inline void
+picoif_hwif_dmaul_close( struct picoif_context *ctx )
+{
+    picoif_transport_generic_close( ctx );
+}
+
+/*! @} */
+/*! @} */
+
+#endif /* !__PICOIF_PUBLIC_HWIF_H__ */
diff --git a/include/linux/picochip/transports/hwif2.h b/include/linux/picochip/transports/hwif2.h
new file mode 100644
index 0000000..11c0983
--- /dev/null
+++ b/include/linux/picochip/transports/hwif2.h
@@ -0,0 +1,129 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file hwif2.h
+ *
+ * \brief Public picoIf HwIf2 transport method kernel API.
+ *  \addtogroup kernelAPI
+ *  @{
+ *   \addtogroup HwIf2
+ *    @{
+ */
+
+#ifndef __PICOIF_PUBLIC_HWIF2_H__
+#define __PICOIF_PUBLIC_HWIF2_H__
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+
+struct picoif_context;
+
+/*!
+ * \brief Structure for the storage of the context in the HwIF2 transport
+ */
+struct picoif_hwif2
+{
+    unsigned  dev_num;       /*!< The device number to use in the transport. */
+    int its_gpr;             /*!< The uplink handshaking GPR. */
+    int itm_gpr;             /*!< The downlink handshaking GPR */
+};
+
+/*! Opaque pointer for the picoIf HwIf context. */
+typedef struct picoif_hwif2 * picoif_hwif2_t;
+
+/*!
+ * Initialise a context (one per device) to support all HwIF2 UL transports.
+ * Once finished with, the context should be destroyed with
+ * picoifHwIF2_DestroyContext().
+ * 
+ * \param dev_num The logical device number to use for the transport. 
+ * \param its_gpr The GPR for handshaking in the picoArray to host direction.
+ *      This value should be taken from the picoIfGPRId_t enumeration.
+ * \param itm_gpr The GPR for handshaking in the host to picoArray direction.
+ *      This value should be taken from the picoIfGPRId_t enumeration.
+ * \return Returns a HwIF2 context.
+ */
+picoif_hwif2_t
+picoif_hwif2_init( unsigned dev_num, 
+                   int its_gpr,
+                   int itm_gpr );
+
+/*!
+ * Destroy a HwIf2 context used for creating transports. This may be safely
+ * destroyed once all transports using the context have been opened.
+ *
+ * \param context The context to destroy.
+ */
+void
+picoif_hwif2_destroy_context( picoif_hwif2_t context );
+
+/*!
+ * Create a new instance of a HwIF2 uplink DMA transport. This transport
+ * will allow DMA transfers from a picoArray DMA channel into a user buffer
+ * using the HwIF2 mechanism. On success, a file descriptor is returned which
+ * may be read to transfer the data. When read(2) is called on the file
+ * descriptor, a transfer of all available bytes up to the specified number is
+ * made. By default this transport is configured in blocking mode but can be
+ * converted to non-blocking using the fcntl(2) command.
+ * 
+ * \param[in] hwif2_context The HwIF2 context created by picoifHwIF2_Init()
+ * \param interrupt_number The interrupt number to initiate a new transfer.
+ * \param dma_channel The DMA channel in the picoArray to use for the
+ *      transport. This value should be taken from the picoIfDMAId_t
+ *      enumeration.
+ * \param buffer_size The internal buffer size used for DMA transfers in bytes.
+ *      This should be large enough such that it does not often fill up and
+ *      reduce throughput.
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_hwif2_dmaul_open( const picoif_hwif2_t hwif2_context,
+                         unsigned interrupt_number,
+                         int dma_channel,
+                         size_t buffer_size );
+
+/*!
+ * Read from the HwIf2 DMA channel up to the size of data specified
+ *
+ * @param ctx The open context of the transport.
+ * @param buf The buffer to write the DMA'd data into.
+ * @param len The length of the buffer in bytes.
+ * @return Returns the number of bytes read into the buffer on success,
+ * negative on failure. If no data is available to read, the -EAGAIN will be
+ * returned.
+ */
+static inline ssize_t
+picoif_hwif2_dmaul_read( struct picoif_context *ctx,
+                         u8 *buf,
+                         size_t len )
+{
+    return picoif_transport_generic_read( ctx, buf, len );
+}
+
+/*!
+ * Close an open instance of a HwIf2 DMA transport.
+ *
+ * @param ctx The context to close.
+ */
+static inline void
+picoif_hwif2_dmaul_close( struct picoif_context *ctx )
+{
+    picoif_transport_generic_close( ctx );
+}
+
+/*! @} */
+/*! @} */
+
+#endif /* !__PICOIF_PUBLIC_HWIF2_H__ */
diff --git a/include/linux/reboot.h b/include/linux/reboot.h
index 988e55f..98954ae 100644
--- a/include/linux/reboot.h
+++ b/include/linux/reboot.h
@@ -33,6 +33,7 @@
 #define	LINUX_REBOOT_CMD_RESTART2	0xA1B2C3D4
 #define	LINUX_REBOOT_CMD_SW_SUSPEND	0xD000FCE2
 #define	LINUX_REBOOT_CMD_KEXEC		0x45584543
+#define LINUX_REBOOT_CMD_HARD		0x12344321
 
 
 #ifdef __KERNEL__
diff --git a/include/linux/serial_reg.h b/include/linux/serial_reg.h
index 96c0d93..ab1d893 100644
--- a/include/linux/serial_reg.h
+++ b/include/linux/serial_reg.h
@@ -324,5 +324,14 @@
 #define UART_OMAP_SYSC		0x15	/* System configuration register */
 #define UART_OMAP_SYSS		0x16	/* System status register */
 
+/* 
+ * Extra serial register definitions for the Synopsys UARTs in
+ * picoChip Firecracker processors.
+ */
+#define UART_FIRECRACKER_USR            0x1f    /* UART Status Register */
+
+#define UART_IIR_FIRECRACKER_BUSY	0x07    /* Busy interrupt ID */
+#define UART_IIR_ID_MASK		0x0F    /* Interrupt ID mask */
+
 #endif /* _LINUX_SERIAL_REG_H */
 
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 2725f4e..a22a873 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -200,12 +200,42 @@ typedef unsigned int sk_buff_data_t;
 typedef unsigned char *sk_buff_data_t;
 #endif
 
+
+/**
+ * sk_buff_hwtstamp - hardware/software time stamping instructions
+ * (for outgoing packets) or result (for packets processes by the
+ * network device)
+ *
+ * @hwtstamp: hardware time stamp; software time stamps are stored
+ *            in skb->tstamp
+ * @tstamp_tx_hardware: generate hardware time stamp
+ * @tstamp_tx_software: generate software time stamp
+ * @tstamp_tx_in_progress: device driver is going to provide hardware
+ *                         time stamp
+ */
+union sk_buff_hwtstamp
+{
+	ktime_t		hwtstamp;
+	struct {
+		__u64	hwtstamp_padding:60,
+			tstamp_tx_hardware:1,
+			tstamp_tx_software:1,
+			tstamp_tx_in_progress:1;
+	};
+};
+
 /** 
  *	struct sk_buff - socket buffer
  *	@next: Next buffer in list
  *	@prev: Previous buffer in list
  *	@sk: Socket we are owned by
- *	@tstamp: Time we arrived
+ *	@tstamp: Time we arrived: generated by ktime_get_real() and
+ *	         thus is recorded in system time.
+ *      @hwtstamp: Time we arrived or were sent: generated by the
+ *	           network device and therefore not directly related to
+ *	           system time. For outgoing packets the time stamp
+ *	           is not valid yet. Instead the union is used to
+ *	           transport time stamping requests to the device.
  *	@dev: Device we arrived on/are leaving by
  *	@transport_header: Transport layer header
  *	@network_header: Network layer header
@@ -263,6 +293,7 @@ struct sk_buff {
 
 	struct sock		*sk;
 	ktime_t			tstamp;
+	union sk_buff_hwtstamp  hwtstamp;
 	struct net_device	*dev;
 
 	union {
@@ -411,15 +442,6 @@ extern void	      skb_over_panic(struct sk_buff *skb, int len,
 				     void *here);
 extern void	      skb_under_panic(struct sk_buff *skb, int len,
 				      void *here);
-extern void	      skb_truesize_bug(struct sk_buff *skb);
-
-static inline void skb_truesize_check(struct sk_buff *skb)
-{
-	int len = sizeof(struct sk_buff) + skb->len;
-
-	if (unlikely((int)skb->truesize < len))
-		skb_truesize_bug(skb);
-}
 
 extern int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
 			int getfrag(void *from, char *to, int offset,
@@ -1695,6 +1717,11 @@ static inline void skb_copy_to_linear_data_offset(struct sk_buff *skb,
 
 extern void skb_init(void);
 
+static inline ktime_t skb_get_ktime(const struct sk_buff *skb)
+{
+	return skb->tstamp;
+}
+
 /**
  *	skb_get_timestamp - get timestamp from a skb
  *	@skb: skb to get stamp from
@@ -1709,6 +1736,11 @@ static inline void skb_get_timestamp(const struct sk_buff *skb, struct timeval *
 	*stamp = ktime_to_timeval(skb->tstamp);
 }
 
+static inline void skb_get_timestampns(const struct sk_buff *skb, struct timespec *stamp)
+{
+	*stamp = ktime_to_timespec(skb->tstamp);
+}
+
 static inline void __net_timestamp(struct sk_buff *skb)
 {
 	skb->tstamp = ktime_get_real();
@@ -1724,6 +1756,99 @@ static inline ktime_t net_invalid_timestamp(void)
 	return ktime_set(0, 0);
 }
 
+/**
+ * skb_hwtstamp_available - checks whether the time stamp value has
+ * been set (= non-zero) and really came from hardware
+ *
+ * Only works for packets which have been processed by the device
+ * driver.
+ */
+static inline int skb_hwtstamp_available(const struct sk_buff *skb)
+{
+	return skb->hwtstamp.hwtstamp.tv64 != 0;
+}
+
+/**
+ * skb_hwtstamp_set - stores a time stamp generated by hardware in the skb
+ * @skb:	time stamp is stored here
+ * @hwtstamp:	original, untransformed hardware time stamp
+ */
+static inline void skb_hwtstamp_set(struct sk_buff *skb,
+				ktime_t hwtstamp)
+{
+	skb->hwtstamp.hwtstamp = hwtstamp;
+}
+
+/**
+ * skb_hwtstamp_raw - fills the timespec with the original, "raw" time
+ * stamp as generated by the hardware when it processed the packet
+ * 
+ * Returns 1 if such a hardware time stamp is unavailable or cannot be
+ * inferred. Otherwise it returns 0 and doesn't modify the timespec.
+ */
+int skb_hwtstamp_raw(const struct sk_buff *skb, struct timespec *ts);
+
+/**
+ * skb_hwtstamp_transformed - fills the timespec with the hardware
+ * time stamp generated when the hardware processed the packet,
+ * transformed to system time
+ *
+ * Beware that this transformation is not perfect: packet A received on
+ * interface 1 before packet B on interface 2 might have a higher
+ * transformed time stamp.
+ *
+ * Returns 1 if a transformed hardware time stamp is available, 0
+ * otherwise. In that case the timespec is left unchanged.
+ */
+int skb_hwtstamp_transformed(const struct sk_buff *skb, struct timespec *ts);
+
+static inline int skb_hwtstamp_check_tx_hardware(struct sk_buff *skb)
+{
+	return skb->hwtstamp.tstamp_tx_hardware;
+}
+
+static inline int skb_hwtstamp_check_tx_software(struct sk_buff *skb)
+{
+	return skb->hwtstamp.tstamp_tx_software;
+}
+
+static inline int skb_hwtstamp_check_tx_in_progress(struct sk_buff *skb)
+{
+	return skb->hwtstamp.tstamp_tx_in_progress;
+}
+
+static inline void skb_hwtstamp_set_tx_in_progress(struct sk_buff *skb)
+{
+	skb->hwtstamp.tstamp_tx_in_progress = 1;
+}
+
+/**
+ * skb_hwtstamp_tx - queue clone of skb with send time stamp
+ * @orig_skb: the original outgoing packet
+ * @stamp: either raw hardware time stamp or result of ktime_get_real()
+ * @dev: NULL if time stamp from ktime_get_real(), otherwise device
+ *       which generated the hardware time stamp; the device may or
+ *       may not implement the system time<->hardware time mapping
+ *       functions
+ *
+ * This function will not actually timestamp the skb, but, if the skb has a
+ * socket associated, clone the skb, timestamp it, and queue it to the error
+ * queue of the socket. Errors are silently ignored.
+ */
+void skb_hwtstamp_tx(struct sk_buff *orig_skb,
+		ktime_t stamp,
+		struct net_device *dev);
+
+/**
+ * skb_tx_software_timestamp - software fallback for send time stamping
+ */
+static inline void skb_tx_software_timestamp(struct sk_buff *skb)
+{
+	if (skb_hwtstamp_check_tx_software(skb) &&
+		!skb_hwtstamp_check_tx_in_progress(skb))
+		skb_hwtstamp_tx(skb, ktime_get_real(), NULL);
+}
+
 extern __sum16 __skb_checksum_complete_head(struct sk_buff *skb, int len);
 extern __sum16 __skb_checksum_complete(struct sk_buff *skb);
 
diff --git a/include/linux/sockios.h b/include/linux/sockios.h
index abef759..209ee22 100644
--- a/include/linux/sockios.h
+++ b/include/linux/sockios.h
@@ -122,6 +122,9 @@
 #define SIOCBRADDIF	0x89a2		/* add interface to bridge      */
 #define SIOCBRDELIF	0x89a3		/* remove interface from bridge */
 
+/* hardware time stamping: parameters in net/timestamping.h */
+#define SIOCSHWTSTAMP   0x89b0
+
 /* Device private ioctl calls */
 
 /*
diff --git a/include/net/ip.h b/include/net/ip.h
index bc026ec..9bc2b65 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -55,6 +55,7 @@ struct ipcm_cookie
 	__be32			addr;
 	int			oif;
 	struct ip_options	*opt;
+	union sk_buff_hwtstamp	tstamp_tx;
 };
 
 #define IPCB(skb) ((struct inet_skb_parm*)((skb)->cb))
diff --git a/include/net/netdma.h b/include/net/netdma.h
index f28c6e0..cbe2737 100644
--- a/include/net/netdma.h
+++ b/include/net/netdma.h
@@ -27,11 +27,11 @@
 static inline struct dma_chan *get_softnet_dma(void)
 {
 	struct dma_chan *chan;
+
 	rcu_read_lock();
 	chan = rcu_dereference(__get_cpu_var(softnet_data).net_dma);
-	if (chan)
-		dma_chan_get(chan);
 	rcu_read_unlock();
+
 	return chan;
 }
 
diff --git a/include/net/sock.h b/include/net/sock.h
index 2f47107..eb7e1b3 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -152,7 +152,7 @@ struct sock_common {
   *	@sk_allocation: allocation mode
   *	@sk_sndbuf: size of send buffer in bytes
   *	@sk_flags: %SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE,
-  *		   %SO_OOBINLINE settings
+  *		   %SO_OOBINLINE settings, %SO_TIMESTAMPING settings
   *	@sk_no_check: %SO_NO_CHECK setting, wether or not checkup packets
   *	@sk_route_caps: route capabilities (e.g. %NETIF_F_TSO)
   *	@sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4)
@@ -413,6 +413,13 @@ enum sock_flags {
 	SOCK_RCVTSTAMPNS, /* %SO_TIMESTAMPNS setting */
 	SOCK_LOCALROUTE, /* route locally only, %SO_DONTROUTE setting */
 	SOCK_QUEUE_SHRUNK, /* write queue has been shrunk recently */
+	SOCK_TIMESTAMPING_TX_HARDWARE, /* %SO_TIMESTAMPING %SOF_TIMESTAMPING_TX_HARDWARE */
+	SOCK_TIMESTAMPING_TX_SOFTWARE, /* %SO_TIMESTAMPING %SOF_TIMESTAMPING_TX_SOFTWARE */
+	SOCK_TIMESTAMPING_RX_HARDWARE, /* %SO_TIMESTAMPING %SOF_TIMESTAMPING_RX_HARDWARE */
+	SOCK_TIMESTAMPING_RX_SOFTWARE, /* %SO_TIMESTAMPING %SOF_TIMESTAMPING_RX_SOFTWARE */
+	SOCK_TIMESTAMPING_SOFTWARE,    /* %SO_TIMESTAMPING %SOF_TIMESTAMPING_SOFTWARE */
+	SOCK_TIMESTAMPING_RAW_HARDWARE, /* %SO_TIMESTAMPING %SOF_TIMESTAMPING_RAW_HARDWARE */
+	SOCK_TIMESTAMPING_SYS_HARDWARE, /* %SO_TIMESTAMPING %SOF_TIMESTAMPING_SYS_HARDWARE */        
 };
 
 static inline void sock_copy_flags(struct sock *nsk, struct sock *osk)
@@ -784,7 +791,6 @@ static inline void sk_mem_uncharge(struct sock *sk, int size)
 
 static inline void sk_wmem_free_skb(struct sock *sk, struct sk_buff *skb)
 {
-	skb_truesize_check(skb);
 	sock_set_flag(sk, SOCK_QUEUE_SHRUNK);
 	sk->sk_wmem_queued -= skb->truesize;
 	sk_mem_uncharge(sk, skb->truesize);
@@ -1266,13 +1272,36 @@ sock_recv_timestamp(struct msghdr *msg, struct sock *sk, struct sk_buff *skb)
 {
 	ktime_t kt = skb->tstamp;
 
-	if (sock_flag(sk, SOCK_RCVTSTAMP))
+	/*
+	 * generate control messages if receive time stamping requested
+	 * or if time stamp available (RX hardware or TX software/hardware
+	 * case) and reporting via SO_TIMESTAMPING enabled
+	 */
+	if ((sock_flag(sk, SOCK_RCVTSTAMP) ||
+		sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE)) ||
+		(kt.tv64 && sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) ||
+		(skb_hwtstamp_available(skb) &&
+			(sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE) ||
+				sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE))))	
 		__sock_recv_timestamp(msg, sk, skb);
 	else
 		sk->sk_stamp = kt;
 }
 
 /**
+ * sock_tx_timestamp - checks whether the outgoing packet is to be time stamped
+ * @msg: outgoing packet
+ * @sk: socket sending this packet
+ * @stamp_tx: filled with instructions for time stamping
+ *
+ * Currently only depends on SOCK_TIMESTAMPING* flags. Returns error code if
+ * parameters are invalid.
+ */
+extern int sock_tx_timestamp(struct msghdr *msg,
+			struct sock *sk,
+			union sk_buff_hwtstamp *stamp_tx);
+
+/**
  * sk_eat_skb - Release a skb if it is no longer needed
  * @sk: socket to eat this skb from
  * @skb: socket buffer to eat
@@ -1340,7 +1369,7 @@ static inline struct sock *skb_steal_sock(struct sk_buff *skb)
 	return NULL;
 }
 
-extern void sock_enable_timestamp(struct sock *sk);
+extern void sock_enable_timestamp(struct sock *sk, int flag);
 extern int sock_get_timestamp(struct sock *, struct timeval __user *);
 extern int sock_get_timestampns(struct sock *, struct timespec __user *);
 
diff --git a/include/net/timestamping.h b/include/net/timestamping.h
new file mode 100644
index 0000000..0f7d416
--- /dev/null
+++ b/include/net/timestamping.h
@@ -0,0 +1,95 @@
+#ifndef _NET_TIMESTAMPING_H
+#define _NET_TIMESTAMPING_H
+
+#include <linux/socket.h>   /* for SO_TIMESTAMPING */
+
+/**
+ * user space linux/socket.h might not have these defines yet:
+ * provide fallback
+ */
+#if !defined(__kernel__) && !defined(SO_TIMESTAMPING)
+# define SO_TIMESTAMPING         37
+# define SCM_TIMESTAMPING        SO_TIMESTAMPING
+#endif
+
+/** %SO_TIMESTAMPING gets an integer bit field comprised of these values */
+enum {
+	SOF_TIMESTAMPING_TX_HARDWARE = (1<<0),
+	SOF_TIMESTAMPING_TX_SOFTWARE = (1<<1),
+	SOF_TIMESTAMPING_RX_HARDWARE = (1<<2),
+	SOF_TIMESTAMPING_RX_SOFTWARE = (1<<3),
+	SOF_TIMESTAMPING_SOFTWARE = (1<<4),
+	SOF_TIMESTAMPING_SYS_HARDWARE = (1<<5),
+	SOF_TIMESTAMPING_RAW_HARDWARE = (1<<6),
+	SOF_TIMESTAMPING_MASK = (SOF_TIMESTAMPING_RAW_HARDWARE - 1) | SOF_TIMESTAMPING_RAW_HARDWARE
+};
+
+#if !defined(__kernel__) && !defined(SIOCSHWTSTAMP)
+# define SIOCSHWTSTAMP 0x89b0
+#endif
+
+/** %SIOCSHWTSTAMP expects a struct ifreq with a ifr_data pointer to this struct  */
+struct hwtstamp_config {
+	int flags;           /**\u2264 no flags defined right now, must be zero */
+	int tx_type;         /**\u2264 one of HWTSTAMP_TX_* */
+	int rx_filter_type;  /**\u2264 one of HWTSTAMP_RX_* */
+};
+
+/** possible values for hwtstamp_config->tx_type */
+enum {
+	/**
+	 * no outgoing packet will need hardware time stamping;
+	 * should a packet arrive which asks for it, no hardware
+	 * time stamping will be done
+	 */
+	HWTSTAMP_TX_OFF,
+
+	/**
+	 * enables hardware time stamping for outgoing packets;
+	 * the sender of the packet decides which are to be
+	 * time stamped by setting SOF_TIMESTAMPING_TX_SOFTWARE
+	 * before sending the packet
+	 */
+	HWTSTAMP_TX_ON,
+};
+
+/** possible values for hwtstamp_config->rx_filter_type */
+enum {
+	/** time stamp no incoming packet at all */
+	HWTSTAMP_FILTER_NONE,
+
+	/** time stamp any incoming packet */
+	HWTSTAMP_FILTER_ALL,
+
+        /** return value: time stamp all packets requested plus some others */
+        HWTSTAMP_FILTER_SOME,
+
+	/** PTP v1, UDP, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_EVENT,
+	/** PTP v1, UDP, Sync packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_SYNC,
+	/** PTP v1, UDP, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ,
+	/** PTP v2, UDP, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V2_L4_EVENT,
+	/** PTP v2, UDP, Sync packet */
+	HWTSTAMP_FILTER_PTP_V2_L4_SYNC,
+	/** PTP v2, UDP, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ,
+
+	/** 802.AS1, Ethernet, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V2_L2_EVENT,
+	/** 802.AS1, Ethernet, Sync packet */
+	HWTSTAMP_FILTER_PTP_V2_L2_SYNC,
+	/** 802.AS1, Ethernet, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ,
+
+	/** PTP v2/802.AS1, any layer, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V2_EVENT,
+	/** PTP v2/802.AS1, any layer, Sync packet */
+	HWTSTAMP_FILTER_PTP_V2_SYNC,
+	/** PTP v2/802.AS1, any layer, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ,
+};
+
+#endif /* _NET_TIMESTAMPING_H */
diff --git a/init/main.c b/init/main.c
index 7e117a2..030b507 100644
--- a/init/main.c
+++ b/init/main.c
@@ -785,8 +785,11 @@ static void __init do_pre_smp_initcalls(void)
 
 static void run_init_process(char *init_filename)
 {
+	long ret;
+
 	argv_init[0] = init_filename;
-	kernel_execve(init_filename, argv_init, envp_init);
+	ret = kernel_execve(init_filename, argv_init, envp_init);
+	printk(KERN_INFO "%s exit code: %ld\n", init_filename, ret);
 }
 
 /* This is a non __init function. Force it to be noinline otherwise gcc
diff --git a/kernel/sys.c b/kernel/sys.c
index 31deba8..bd549ff 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -375,6 +375,10 @@ asmlinkage long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user
 		kernel_restart(NULL);
 		break;
 
+	case LINUX_REBOOT_CMD_HARD:
+		kernel_restart("cpld");
+		break;
+
 	case LINUX_REBOOT_CMD_CAD_ON:
 		C_A_D = 1;
 		break;
diff --git a/kernel/time/Makefile b/kernel/time/Makefile
index 905b0b5..6279fb0 100644
--- a/kernel/time/Makefile
+++ b/kernel/time/Makefile
@@ -1,4 +1,4 @@
-obj-y += timekeeping.o ntp.o clocksource.o jiffies.o timer_list.o
+obj-y += timekeeping.o ntp.o clocksource.o jiffies.o timer_list.o clocksync.o
 
 obj-$(CONFIG_GENERIC_CLOCKEVENTS_BUILD)		+= clockevents.o
 obj-$(CONFIG_GENERIC_CLOCKEVENTS)		+= tick-common.o
diff --git a/kernel/time/clocksync.c b/kernel/time/clocksync.c
new file mode 100644
index 0000000..e907782
--- /dev/null
+++ b/kernel/time/clocksync.c
@@ -0,0 +1,118 @@
+/*
+ * Utility code which helps transforming between hardware time stamps
+ * generated by a clocksource and system time.
+ *
+ * Copyright (C) 2008 Intel, Patrick Ohly (patrick.ohly <at> intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/clocksync.h>
+#include <linux/module.h>
+
+int clocksync_offset(struct clocksync *sync,
+		s64 *offset,
+		u64 *hwtstamp)
+{
+	u64 starthw = 0, endhw = 0;
+	struct {
+		s64 offset;
+		s64 duration_sys;
+	} buffer[10], sample, *samples;
+	int counter = 0, i;
+	int used;
+	int index;
+	int num_samples = sync->num_samples;
+
+	if (num_samples > sizeof(buffer)/sizeof(buffer[0])) {
+		samples = kmalloc(sizeof(*samples) * num_samples, GFP_ATOMIC);
+		if (!samples) {
+			samples = buffer;
+			num_samples = sizeof(buffer)/sizeof(buffer[0]);
+		}
+	} else {
+		samples = buffer;
+	}
+
+	/* run until we have enough valid samples, but do not try forever */
+	i = 0;
+	counter = 0;
+	while (1) {
+		u64 ts;
+		ktime_t start, end;
+
+		start = sync->systime();
+		ts = clocksource_read_time(sync->clock);
+		end = sync->systime();
+
+		if (!i) {
+			starthw = ts;
+		}
+
+		/* ignore negative durations */
+		sample.duration_sys = ktime_to_ns(ktime_sub(end, start));
+		if (sample.duration_sys >= 0) {
+			/*
+			 * assume symetric delay to and from HW: average system time
+			 * corresponds to measured HW time
+			 */
+			sample.offset = ktime_to_ns(ktime_add(end, start)) / 2 -
+				ts;
+
+			/* simple insertion sort based on duration */
+			index = counter - 1;
+			while (index >= 0) {
+				if(samples[index].duration_sys < sample.duration_sys) {
+					break;
+				}
+				samples[index + 1] = samples[index];
+				index--;
+			}
+			samples[index + 1] = sample;
+			counter++;
+		}
+
+		i++;
+		if (counter >= num_samples || i >= 100000) {
+			endhw = ts;
+			break;
+		}
+	}
+
+	*hwtstamp = (endhw + starthw) / 2;
+
+	/* remove outliers by only using 75% of the samples */
+	used = counter * 3 / 4;
+	if (!used) {
+		used = counter;
+	}
+	if (used) {
+		/* calculate average */
+		s64 off = 0;
+		for (index = 0; index < used; index++) {
+			off += samples[index].offset;
+		}
+		//off /= used;
+                do_div (off, used);
+		*offset = off;
+	}
+
+	if (samples && samples != buffer)
+		kfree(samples);
+
+	return used;
+}
+
+EXPORT_SYMBOL_GPL(clocksync_offset);
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index b0f239e..918648e 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -394,7 +394,7 @@ config LOCKDEP
 	bool
 	depends on DEBUG_KERNEL && TRACE_IRQFLAGS_SUPPORT && STACKTRACE_SUPPORT && LOCKDEP_SUPPORT
 	select STACKTRACE
-	select FRAME_POINTER if !X86 && !MIPS && !PPC
+	select FRAME_POINTER if !X86 && !MIPS && !PPC && !ARM_UNWIND
 	select KALLSYMS
 	select KALLSYMS_ALL
 
diff --git a/mm/filemap.c b/mm/filemap.c
index f3e5f89..f8c6927 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -2140,19 +2140,24 @@ EXPORT_SYMBOL(generic_file_direct_write);
  * Find or create a page at the given pagecache position. Return the locked
  * page. This function is specifically for buffered writes.
  */
-struct page *__grab_cache_page(struct address_space *mapping, pgoff_t index)
+struct page *grab_cache_page_write_begin(struct address_space *mapping,
+					pgoff_t index, unsigned flags)
 {
 	int status;
 	struct page *page;
+	gfp_t gfp_notmask = 0;
+	if (flags & AOP_FLAG_NOFS)
+		gfp_notmask = __GFP_FS;
 repeat:
 	page = find_lock_page(mapping, index);
 	if (likely(page))
 		return page;
 
-	page = page_cache_alloc(mapping);
+	page = __page_cache_alloc(mapping_gfp_mask(mapping) & ~gfp_notmask);
 	if (!page)
 		return NULL;
-	status = add_to_page_cache_lru(page, mapping, index, GFP_KERNEL);
+	status = add_to_page_cache_lru(page, mapping, index,
+						GFP_KERNEL & ~gfp_notmask);
 	if (unlikely(status)) {
 		page_cache_release(page);
 		if (status == -EEXIST)
@@ -2161,7 +2166,7 @@ repeat:
 	}
 	return page;
 }
-EXPORT_SYMBOL(__grab_cache_page);
+EXPORT_SYMBOL(grab_cache_page_write_begin);
 
 static ssize_t generic_perform_write(struct file *file,
 				struct iov_iter *i, loff_t pos)
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index d8ac014..09b6fd7 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -106,16 +106,16 @@ EXPORT_SYMBOL(totalram_pages);
 
 static char * const zone_names[MAX_NR_ZONES] = {
 #ifdef CONFIG_ZONE_DMA
-	 "DMA",
+	[ZONE_DMA]	= "DMA",
 #endif
 #ifdef CONFIG_ZONE_DMA32
-	 "DMA32",
+	[ZONE_DMA32]	= "DMA32",
 #endif
-	 "Normal",
+	[ZONE_NORMAL]	= "Normal",
 #ifdef CONFIG_HIGHMEM
-	 "HighMem",
+	[ZONE_HIGHMEN]	= "HighMem",
 #endif
-	 "Movable",
+	[ZONE_MOVABLE]	= "Movable",
 };
 
 int min_free_kbytes = 1024;
diff --git a/net/can/raw.c b/net/can/raw.c
index 6e0663f..d4a38e3 100644
--- a/net/can/raw.c
+++ b/net/can/raw.c
@@ -618,6 +618,7 @@ static int raw_sendmsg(struct kiocb *iocb, struct socket *sock,
 	struct raw_sock *ro = raw_sk(sk);
 	struct sk_buff *skb;
 	struct net_device *dev;
+	union sk_buff_hwtstamp tstamp_tx;
 	int ifindex;
 	int err;
 
@@ -639,6 +640,10 @@ static int raw_sendmsg(struct kiocb *iocb, struct socket *sock,
 	if (!dev)
 		return -ENXIO;
 
+	err = sock_tx_timestamp(msg, sk, &tstamp_tx);
+	if (err < 0)
+		return err;
+
 	skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT,
 				  &err);
 	if (!skb) {
@@ -654,6 +659,7 @@ static int raw_sendmsg(struct kiocb *iocb, struct socket *sock,
 	}
 	skb->dev = dev;
 	skb->sk  = sk;
+	skb->hwtstamp = tstamp_tx;
 
 	err = can_send(skb, ro->loopback);
 
diff --git a/net/compat.c b/net/compat.c
index a3a2ba0..fb01ed9 100644
--- a/net/compat.c
+++ b/net/compat.c
@@ -216,7 +216,7 @@ Efault:
 int put_cmsg_compat(struct msghdr *kmsg, int level, int type, int len, void *data)
 {
 	struct compat_timeval ctv;
-	struct compat_timespec cts;
+	struct compat_timespec cts[3];
 	struct compat_cmsghdr __user *cm = (struct compat_cmsghdr __user *) kmsg->msg_control;
 	struct compat_cmsghdr cmhdr;
 	int cmlen;
@@ -233,12 +233,17 @@ int put_cmsg_compat(struct msghdr *kmsg, int level, int type, int len, void *dat
 		data = &ctv;
 		len = sizeof(ctv);
 	}
-	if (level == SOL_SOCKET && type == SCM_TIMESTAMPNS) {
+	if (level == SOL_SOCKET &&
+		(type == SCM_TIMESTAMPNS || type == SCM_TIMESTAMPING)) {
+		int count = type == SCM_TIMESTAMPNS ? 1 : 3;
+		int i;
 		struct timespec *ts = (struct timespec *)data;
-		cts.tv_sec = ts->tv_sec;
-		cts.tv_nsec = ts->tv_nsec;
+		for (i = 0; i < count; i++) {
+			cts[i].tv_sec = ts[i].tv_sec;
+			cts[i].tv_nsec = ts[i].tv_nsec;
+		}
 		data = &cts;
-		len = sizeof(cts);
+		len = sizeof(cts[0]) * count;
 	}
 
 	cmlen = CMSG_COMPAT_LEN(len);
@@ -455,7 +460,7 @@ int compat_sock_get_timestamp(struct sock *sk, struct timeval __user *userstamp)
 	struct timeval tv;
 
 	if (!sock_flag(sk, SOCK_TIMESTAMP))
-		sock_enable_timestamp(sk);
+		sock_enable_timestamp(sk, SOCK_TIMESTAMP);
 	tv = ktime_to_timeval(sk->sk_stamp);
 	if (tv.tv_sec == -1)
 		return err;
@@ -479,7 +484,7 @@ int compat_sock_get_timestampns(struct sock *sk, struct timespec __user *usersta
 	struct timespec ts;
 
 	if (!sock_flag(sk, SOCK_TIMESTAMP))
-		sock_enable_timestamp(sk);
+		sock_enable_timestamp(sk, SOCK_TIMESTAMP);
 	ts = ktime_to_timespec(sk->sk_stamp);
 	if (ts.tv_sec == -1)
 		return err;
diff --git a/net/core/dev.c b/net/core/dev.c
index 9174c77..b22822c 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -165,25 +165,6 @@ static DEFINE_SPINLOCK(ptype_lock);
 static struct list_head ptype_base[PTYPE_HASH_SIZE] __read_mostly;
 static struct list_head ptype_all __read_mostly;	/* Taps */
 
-#ifdef CONFIG_NET_DMA
-struct net_dma {
-	struct dma_client client;
-	spinlock_t lock;
-	cpumask_t channel_mask;
-	struct dma_chan **channels;
-};
-
-static enum dma_state_client
-netdev_dma_event(struct dma_client *client, struct dma_chan *chan,
-	enum dma_state state);
-
-static struct net_dma net_dma = {
-	.client = {
-		.event_callback = netdev_dma_event,
-	},
-};
-#endif
-
 /*
  * The @dev_base_head list is protected by @dev_base_lock and the rtnl
  * semaphore.
@@ -1654,6 +1635,8 @@ static int dev_gso_segment(struct sk_buff *skb)
 int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,
 			struct netdev_queue *txq)
 {
+	int rc;
+
 	if (likely(!skb->next)) {
 		if (!list_empty(&ptype_all))
 			dev_queue_xmit_nit(skb, dev);
@@ -1665,13 +1648,29 @@ int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,
 				goto gso;
 		}
 
-		return dev->hard_start_xmit(skb, dev);
+		rc = dev->hard_start_xmit(skb, dev);
+		/*
+		 * TODO: if skb_orphan() was called by
+		 * dev->hard_start_xmit() (for example, the unmodified
+		 * igb driver does that; bnx2 doesn't), then
+		 * skb_tx_software_timestamp() will be unable to send
+		 * back the time stamp.
+		 *
+		 * How can this be prevented? Always create another
+		 * reference to the socket before calling
+		 * dev->hard_start_xmit()? Prevent that skb_orphan()
+		 * does anything in dev->hard_start_xmit() by clearing
+		 * the skb destructor before the call and restoring it
+		 * afterwards, then doing the skb_orphan() ourselves?
+		 */
+		if (likely(!rc))
+			skb_tx_software_timestamp(skb);
+		return rc;
 	}
 
 gso:
 	do {
 		struct sk_buff *nskb = skb->next;
-		int rc;
 
 		skb->next = nskb->next;
 		nskb->next = NULL;
@@ -1681,6 +1680,7 @@ gso:
 			skb->next = nskb;
 			return rc;
 		}
+		skb_tx_software_timestamp(skb);
 		if (unlikely(netif_tx_queue_stopped(txq) && skb->next))
 			return NETDEV_TX_BUSY;
 	} while (skb->next);
@@ -2442,14 +2442,7 @@ out:
 	 * There may not be any more sk_buffs coming right now, so push
 	 * any pending DMA copies to hardware
 	 */
-	if (!cpus_empty(net_dma.channel_mask)) {
-		int chan_idx;
-		for_each_cpu_mask_nr(chan_idx, net_dma.channel_mask) {
-			struct dma_chan *chan = net_dma.channels[chan_idx];
-			if (chan)
-				dma_async_memcpy_issue_pending(chan);
-		}
-	}
+	dma_issue_pending_all();
 #endif
 
 	return;
@@ -3655,6 +3648,7 @@ static int dev_ifsioc(struct net *net, struct ifreq *ifr, unsigned int cmd)
 			    cmd == SIOCSMIIREG ||
 			    cmd == SIOCBRADDIF ||
 			    cmd == SIOCBRDELIF ||
+			    cmd == SIOCSHWTSTAMP ||
 			    cmd == SIOCWANDEV) {
 				err = -EOPNOTSUPP;
 				if (dev->do_ioctl) {
@@ -3810,6 +3804,7 @@ int dev_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 		case SIOCBONDCHANGEACTIVE:
 		case SIOCBRADDIF:
 		case SIOCBRDELIF:
+		case SIOCSHWTSTAMP:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
 			/* fall through */
@@ -4596,122 +4591,6 @@ static int dev_cpu_callback(struct notifier_block *nfb,
 	return NOTIFY_OK;
 }
 
-#ifdef CONFIG_NET_DMA
-/**
- * net_dma_rebalance - try to maintain one DMA channel per CPU
- * @net_dma: DMA client and associated data (lock, channels, channel_mask)
- *
- * This is called when the number of channels allocated to the net_dma client
- * changes.  The net_dma client tries to have one DMA channel per CPU.
- */
-
-static void net_dma_rebalance(struct net_dma *net_dma)
-{
-	unsigned int cpu, i, n, chan_idx;
-	struct dma_chan *chan;
-
-	if (cpus_empty(net_dma->channel_mask)) {
-		for_each_online_cpu(cpu)
-			rcu_assign_pointer(per_cpu(softnet_data, cpu).net_dma, NULL);
-		return;
-	}
-
-	i = 0;
-	cpu = first_cpu(cpu_online_map);
-
-	for_each_cpu_mask_nr(chan_idx, net_dma->channel_mask) {
-		chan = net_dma->channels[chan_idx];
-
-		n = ((num_online_cpus() / cpus_weight(net_dma->channel_mask))
-		   + (i < (num_online_cpus() %
-			cpus_weight(net_dma->channel_mask)) ? 1 : 0));
-
-		while(n) {
-			per_cpu(softnet_data, cpu).net_dma = chan;
-			cpu = next_cpu(cpu, cpu_online_map);
-			n--;
-		}
-		i++;
-	}
-}
-
-/**
- * netdev_dma_event - event callback for the net_dma_client
- * @client: should always be net_dma_client
- * @chan: DMA channel for the event
- * @state: DMA state to be handled
- */
-static enum dma_state_client
-netdev_dma_event(struct dma_client *client, struct dma_chan *chan,
-	enum dma_state state)
-{
-	int i, found = 0, pos = -1;
-	struct net_dma *net_dma =
-		container_of(client, struct net_dma, client);
-	enum dma_state_client ack = DMA_DUP; /* default: take no action */
-
-	spin_lock(&net_dma->lock);
-	switch (state) {
-	case DMA_RESOURCE_AVAILABLE:
-		for (i = 0; i < nr_cpu_ids; i++)
-			if (net_dma->channels[i] == chan) {
-				found = 1;
-				break;
-			} else if (net_dma->channels[i] == NULL && pos < 0)
-				pos = i;
-
-		if (!found && pos >= 0) {
-			ack = DMA_ACK;
-			net_dma->channels[pos] = chan;
-			cpu_set(pos, net_dma->channel_mask);
-			net_dma_rebalance(net_dma);
-		}
-		break;
-	case DMA_RESOURCE_REMOVED:
-		for (i = 0; i < nr_cpu_ids; i++)
-			if (net_dma->channels[i] == chan) {
-				found = 1;
-				pos = i;
-				break;
-			}
-
-		if (found) {
-			ack = DMA_ACK;
-			cpu_clear(pos, net_dma->channel_mask);
-			net_dma->channels[i] = NULL;
-			net_dma_rebalance(net_dma);
-		}
-		break;
-	default:
-		break;
-	}
-	spin_unlock(&net_dma->lock);
-
-	return ack;
-}
-
-/**
- * netdev_dma_register - register the networking subsystem as a DMA client
- */
-static int __init netdev_dma_register(void)
-{
-	net_dma.channels = kzalloc(nr_cpu_ids * sizeof(struct net_dma),
-								GFP_KERNEL);
-	if (unlikely(!net_dma.channels)) {
-		printk(KERN_NOTICE
-				"netdev_dma: no memory for net_dma.channels\n");
-		return -ENOMEM;
-	}
-	spin_lock_init(&net_dma.lock);
-	dma_cap_set(DMA_MEMCPY, net_dma.client.cap_mask);
-	dma_async_client_register(&net_dma.client);
-	dma_async_client_chan_request(&net_dma.client);
-	return 0;
-}
-
-#else
-static int __init netdev_dma_register(void) { return -ENODEV; }
-#endif /* CONFIG_NET_DMA */
 
 /**
  *	netdev_increment_features - increment feature set by one
@@ -4908,8 +4787,6 @@ static int __init net_dev_init(void)
 		queue->backlog.weight = weight_p;
 	}
 
-	netdev_dma_register();
-
 	dev_boot_phase = 0;
 
 	open_softirq(NET_TX_SOFTIRQ, net_tx_action);
@@ -4918,6 +4795,9 @@ static int __init net_dev_init(void)
 	hotcpu_notifier(dev_cpu_callback, 0);
 	dst_init();
 	dev_mcast_init();
+	#ifdef CONFIG_NET_DMA
+	dmaengine_get();
+	#endif
 	rc = 0;
 out:
 	return rc;
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 65f7757..f6b7365 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -44,6 +44,7 @@
 #include <linux/in.h>
 #include <linux/inet.h>
 #include <linux/slab.h>
+#include <linux/inetdevice.h>
 #include <linux/netdevice.h>
 #ifdef CONFIG_NET_CLS_ACT
 #include <net/pkt_sched.h>
@@ -55,6 +56,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/init.h>
 #include <linux/scatterlist.h>
+#include <linux/errqueue.h>
 
 #include <net/protocol.h>
 #include <net/dst.h>
@@ -147,14 +149,6 @@ void skb_under_panic(struct sk_buff *skb, int sz, void *here)
 	BUG();
 }
 
-void skb_truesize_bug(struct sk_buff *skb)
-{
-	WARN(net_ratelimit(), KERN_ERR "SKB BUG: Invalid truesize (%u) "
-	       "len=%u, sizeof(sk_buff)=%Zd\n",
-	       skb->truesize, skb->len, sizeof(struct sk_buff));
-}
-EXPORT_SYMBOL(skb_truesize_bug);
-
 /* 	Allocate a new skbuff. We do this ourselves so we can fill in a few
  *	'private' fields and also do memory statistics to find all the
  *	[BEEP] leaks.
@@ -496,6 +490,7 @@ EXPORT_SYMBOL(skb_recycle_check);
 static void __copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
 {
 	new->tstamp		= old->tstamp;
+	new->hwtstamp		= old->hwtstamp;
 	new->dev		= old->dev;
 	new->transport_header	= old->transport_header;
 	new->network_header	= old->network_header;
@@ -2394,6 +2389,41 @@ err:
 
 EXPORT_SYMBOL_GPL(skb_segment);
 
+int skb_hwtstamp_raw(const struct sk_buff *skb, struct timespec *ts)
+{
+	if (skb_hwtstamp_available(skb)) {
+		*ts = ktime_to_timespec(skb->hwtstamp.hwtstamp);
+		return 1;
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(skb_hwtstamp_raw);
+
+int skb_hwtstamp_transformed(const struct sk_buff *skb, struct timespec *ts)
+{
+	struct rtable *rt;
+	struct in_device *idev;
+	struct net_device *netdev;
+
+        if (skb_hwtstamp_available(skb) &&
+		(rt = skb->rtable) != NULL &&
+		(idev = rt->idev) != NULL &&
+		(netdev = idev->dev) != NULL  &&
+		netdev->hwtstamp_raw2sys) {
+		ktime_t hwtstamp_sys =
+			netdev->hwtstamp_raw2sys(netdev,
+						skb->hwtstamp.hwtstamp);
+		if (hwtstamp_sys.tv64) {
+			*ts = ktime_to_timespec(hwtstamp_sys);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(skb_hwtstamp_transformed);
+
 void __init skb_init(void)
 {
 	skbuff_head_cache = kmem_cache_create("skbuff_head_cache",
@@ -2600,6 +2630,40 @@ int skb_cow_data(struct sk_buff *skb, int tailbits, struct sk_buff **trailer)
 	return elt;
 }
 
+void skb_hwtstamp_tx(struct sk_buff *orig_skb,
+		ktime_t stamp,
+		struct net_device *dev)
+{
+	struct sock *sk = orig_skb->sk;
+	struct sock_exterr_skb *serr;
+	struct sk_buff *skb;
+	int err = -ENOMEM;
+
+	if (!sk)
+		return;
+
+	skb = skb_clone(orig_skb, GFP_ATOMIC);
+	if (!skb)
+		return;
+
+	if (dev) {
+		skb->hwtstamp.hwtstamp = stamp;
+	} else {
+		skb->tstamp = stamp;
+		skb->hwtstamp.hwtstamp.tv64 = 0;
+	}
+
+	serr = SKB_EXT_ERR(skb);
+	memset(serr, 0, sizeof(serr));
+	serr->ee.ee_errno = ENOMSG;
+	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
+	err = sock_queue_err_skb(sk, skb);
+	if (err)
+		kfree_skb(skb);
+}
+EXPORT_SYMBOL_GPL(skb_hwtstamp_tx);
+
+
 /**
  * skb_partial_csum_set - set up and verify partial csum values for packet
  * @skb: the skb to set
diff --git a/net/core/sock.c b/net/core/sock.c
index edf7220..8f0eeac 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -120,6 +120,7 @@
 #include <net/net_namespace.h>
 #include <net/request_sock.h>
 #include <net/sock.h>
+#include <net/timestamping.h>
 #include <net/xfrm.h>
 #include <linux/ipsec.h>
 
@@ -255,11 +256,14 @@ static void sock_warn_obsolete_bsdism(const char *name)
 	}
 }
 
-static void sock_disable_timestamp(struct sock *sk)
+static void sock_disable_timestamp(struct sock *sk, int flag)
 {
-	if (sock_flag(sk, SOCK_TIMESTAMP)) {
-		sock_reset_flag(sk, SOCK_TIMESTAMP);
-		net_disable_timestamp();
+	if (sock_flag(sk, flag)) {
+		sock_reset_flag(sk, flag);
+		if (!sock_flag(sk, SOCK_TIMESTAMP) &&
+			!sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE)) {
+			net_disable_timestamp();
+		}
 	}
 }
 
@@ -614,13 +618,36 @@ set_rcvbuf:
 			else
 				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
 			sock_set_flag(sk, SOCK_RCVTSTAMP);
-			sock_enable_timestamp(sk);
+			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
 		} else {
 			sock_reset_flag(sk, SOCK_RCVTSTAMP);
 			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
 		}
 		break;
 
+	case SO_TIMESTAMPING:
+		if (val & ~SOF_TIMESTAMPING_MASK) {
+			ret = EINVAL;
+			break;
+		}
+		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
+				val & SOF_TIMESTAMPING_TX_HARDWARE);
+		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
+				val & SOF_TIMESTAMPING_TX_SOFTWARE);
+		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
+				val & SOF_TIMESTAMPING_RX_HARDWARE);
+		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
+			sock_enable_timestamp(sk, SOCK_TIMESTAMPING_RX_SOFTWARE);
+		else
+			sock_disable_timestamp(sk, SOCK_TIMESTAMPING_RX_SOFTWARE);
+		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
+				val & SOF_TIMESTAMPING_SOFTWARE);
+		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
+				val & SOF_TIMESTAMPING_SYS_HARDWARE);
+		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
+				val & SOF_TIMESTAMPING_RAW_HARDWARE);
+		break;
+
 	case SO_RCVLOWAT:
 		if (val < 0)
 			val = INT_MAX;
@@ -766,6 +793,24 @@ int sock_getsockopt(struct socket *sock, int level, int optname,
 		v.val = sock_flag(sk, SOCK_RCVTSTAMPNS);
 		break;
 
+	case SO_TIMESTAMPING:
+		v.val = 0;
+		if (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE))
+			v.val |= SOF_TIMESTAMPING_TX_HARDWARE;
+		if (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE))
+			v.val |= SOF_TIMESTAMPING_TX_SOFTWARE;
+		if (sock_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE))
+			v.val |= SOF_TIMESTAMPING_RX_HARDWARE;
+		if (sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE))
+			v.val |= SOF_TIMESTAMPING_RX_SOFTWARE;
+		if (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE))
+			v.val |= SOF_TIMESTAMPING_SOFTWARE;
+		if (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE))
+			v.val |= SOF_TIMESTAMPING_SYS_HARDWARE;
+		if (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE))
+			v.val |= SOF_TIMESTAMPING_RAW_HARDWARE;
+		break;
+
 	case SO_RCVTIMEO:
 		lv=sizeof(struct timeval);
 		if (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) {
@@ -967,7 +1012,8 @@ void sk_free(struct sock *sk)
 		rcu_assign_pointer(sk->sk_filter, NULL);
 	}
 
-	sock_disable_timestamp(sk);
+	sock_disable_timestamp(sk, SOCK_TIMESTAMP);
+	sock_disable_timestamp(sk, SOCK_TIMESTAMPING_RX_SOFTWARE);
 
 	if (atomic_read(&sk->sk_omem_alloc))
 		printk(KERN_DEBUG "%s: optmem leakage (%d bytes) detected.\n",
@@ -1135,7 +1181,6 @@ void sock_rfree(struct sk_buff *skb)
 {
 	struct sock *sk = skb->sk;
 
-	skb_truesize_check(skb);
 	atomic_sub(skb->truesize, &sk->sk_rmem_alloc);
 	sk_mem_uncharge(skb->sk, skb->truesize);
 }
@@ -1781,7 +1826,7 @@ int sock_get_timestamp(struct sock *sk, struct timeval __user *userstamp)
 {
 	struct timeval tv;
 	if (!sock_flag(sk, SOCK_TIMESTAMP))
-		sock_enable_timestamp(sk);
+		sock_enable_timestamp(sk, SOCK_TIMESTAMP);
 	tv = ktime_to_timeval(sk->sk_stamp);
 	if (tv.tv_sec == -1)
 		return -ENOENT;
@@ -1797,7 +1842,7 @@ int sock_get_timestampns(struct sock *sk, struct timespec __user *userstamp)
 {
 	struct timespec ts;
 	if (!sock_flag(sk, SOCK_TIMESTAMP))
-		sock_enable_timestamp(sk);
+		sock_enable_timestamp(sk, SOCK_TIMESTAMP);
 	ts = ktime_to_timespec(sk->sk_stamp);
 	if (ts.tv_sec == -1)
 		return -ENOENT;
@@ -1809,11 +1854,20 @@ int sock_get_timestampns(struct sock *sk, struct timespec __user *userstamp)
 }
 EXPORT_SYMBOL(sock_get_timestampns);
 
-void sock_enable_timestamp(struct sock *sk)
+void sock_enable_timestamp(struct sock *sk, int flag)
 {
-	if (!sock_flag(sk, SOCK_TIMESTAMP)) {
-		sock_set_flag(sk, SOCK_TIMESTAMP);
-		net_enable_timestamp();
+	if (!sock_flag(sk, flag)) {
+		sock_set_flag(sk, flag);
+		/*
+		 * we just set one of the two flags which require net
+		 * time stamping, but time stamping might have been on
+		 * already because of the other one
+		 */
+		if (!sock_flag(sk,
+				flag == SOCK_TIMESTAMP ?
+				SOCK_TIMESTAMPING_RX_SOFTWARE :
+				SOCK_TIMESTAMP))
+			net_enable_timestamp();
 	}
 }
 
diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c
index 72b2de7..5fa1030 100644
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@ -375,6 +375,7 @@ static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)
 	inet->tos = ip_hdr(skb)->tos;
 	daddr = ipc.addr = rt->rt_src;
 	ipc.opt = NULL;
+	ipc.tstamp_tx.hwtstamp.tv64 = 0;
 	if (icmp_param->replyopts.optlen) {
 		ipc.opt = &icmp_param->replyopts;
 		if (ipc.opt->srr)
@@ -532,6 +533,7 @@ void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)
 	inet_sk(sk)->tos = tos;
 	ipc.addr = iph->saddr;
 	ipc.opt = &icmp_param.replyopts;
+	ipc.tstamp_tx.hwtstamp.tv64 = 0;
 
 	{
 		struct flowi fl = {
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index d2a8f8b..28089d4 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -940,6 +940,7 @@ alloc_new_skb:
 			skb->ip_summed = csummode;
 			skb->csum = 0;
 			skb_reserve(skb, hh_len);
+			skb->hwtstamp = ipc->tstamp_tx;
 
 			/*
 			 *	Find where to start putting bytes.
@@ -1354,6 +1355,7 @@ void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *ar
 
 	daddr = ipc.addr = rt->rt_src;
 	ipc.opt = NULL;
+	ipc.tstamp_tx.hwtstamp.tv64 = 0;
 
 	if (replyopts.opt.optlen) {
 		ipc.opt = &replyopts.opt;
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index cd97574..902094c 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -493,6 +493,7 @@ static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 
 	ipc.addr = inet->saddr;
 	ipc.opt = NULL;
+	ipc.tstamp_tx.hwtstamp.tv64 = 0;
 	ipc.oif = sk->sk_bound_dev_if;
 
 	if (msg->msg_controllen) {
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index c5aca0b..40ec69f 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -1630,7 +1630,6 @@ skip_copy:
 
 		/* Safe to free early-copied skbs now */
 		__skb_queue_purge(&sk->sk_async_wait_queue);
-		dma_chan_put(tp->ucopy.dma_chan);
 		tp->ucopy.dma_chan = NULL;
 	}
 	if (tp->ucopy.pinned_list) {
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 98c1fd0..9f5fc00 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -540,6 +540,7 @@ int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		return -EOPNOTSUPP;
 
 	ipc.opt = NULL;
+	ipc.tstamp_tx.hwtstamp.tv64 = 0;
 
 	if (up->pending) {
 		/*
@@ -587,6 +588,9 @@ int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 	ipc.addr = inet->saddr;
 
 	ipc.oif = sk->sk_bound_dev_if;
+	err = sock_tx_timestamp(msg, sk, &ipc.tstamp_tx);
+	if (err)
+		return err;
 	if (msg->msg_controllen) {
 		err = ip_cmsg_send(sock_net(sk), msg, &ipc);
 		if (err)
diff --git a/net/socket.c b/net/socket.c
index 76ba80a..024d513 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -546,6 +546,18 @@ void sock_release(struct socket *sock)
 	sock->file = NULL;
 }
 
+int sock_tx_timestamp(struct msghdr *msg, struct sock *sk,
+		union sk_buff_hwtstamp *tstamp_tx)
+{
+	tstamp_tx->hwtstamp.tv64 = 0;
+	tstamp_tx->tstamp_tx_hardware =
+		sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE);
+	tstamp_tx->tstamp_tx_software =
+		sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE);
+	return 0;
+}
+EXPORT_SYMBOL(sock_tx_timestamp);
+
 static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 				 struct msghdr *msg, size_t size)
 {
@@ -602,26 +614,49 @@ int kernel_sendmsg(struct socket *sock, struct msghdr *msg,
 void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,
 	struct sk_buff *skb)
 {
-	ktime_t kt = skb->tstamp;
-
-	if (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {
-		struct timeval tv;
-		/* Race occurred between timestamp enabling and packet
-		   receiving.  Fill in the current time for now. */
-		if (kt.tv64 == 0)
-			kt = ktime_get_real();
-		skb->tstamp = kt;
-		tv = ktime_to_timeval(kt);
-		put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP, sizeof(tv), &tv);
-	} else {
-		struct timespec ts;
-		/* Race occurred between timestamp enabling and packet
-		   receiving.  Fill in the current time for now. */
-		if (kt.tv64 == 0)
-			kt = ktime_get_real();
-		skb->tstamp = kt;
-		ts = ktime_to_timespec(kt);
-		put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS, sizeof(ts), &ts);
+	int need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);
+
+	/* Race occurred between timestamp enabling and packet
+	   receiving.  Fill in the current time for now. */
+	if (need_software_tstamp && skb->tstamp.tv64 == 0)
+		__net_timestamp(skb);
+
+	if (need_software_tstamp) {
+		if (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {
+			struct timeval tv;
+			skb_get_timestamp(skb, &tv);
+			put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,
+				sizeof(tv), &tv);
+		} else {
+			struct timespec ts;
+			skb_get_timestampns(skb, &ts);
+			put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,
+				sizeof(ts), &ts);
+		}
+	}
+
+	if (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE) ||
+		sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE) ||
+		sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE)) {
+		struct timespec ts[3];
+		int empty = 1;
+		memset(ts, 0, sizeof(ts));
+		if (skb->tstamp.tv64 &&
+			sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) {
+			skb_get_timestampns(skb, ts + 0);
+			empty = 0;
+		}
+		if (skb_hwtstamp_available(skb)) {
+			if (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE) &&
+				skb_hwtstamp_transformed(skb, ts + 1))
+				empty = 0;
+			if (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE) &&
+				skb_hwtstamp_raw(skb, ts + 2))
+				empty = 0;
+		}
+		if (!empty)
+			put_cmsg(msg, SOL_SOCKET,
+				SCM_TIMESTAMPING, sizeof(ts), &ts);
 	}
 }
 
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 508337f..456782b 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -2032,8 +2032,9 @@ int xfrm_init_state(struct xfrm_state *x)
 		x->inner_mode = inner_mode;
 	} else {
 		struct xfrm_mode *inner_mode_iaf;
+		int iafamily = AF_INET;
 
-		inner_mode = xfrm_get_mode(x->props.mode, AF_INET);
+		inner_mode = xfrm_get_mode(x->props.mode, x->props.family);
 		if (inner_mode == NULL)
 			goto error;
 
@@ -2041,22 +2042,17 @@ int xfrm_init_state(struct xfrm_state *x)
 			xfrm_put_mode(inner_mode);
 			goto error;
 		}
+		x->inner_mode = inner_mode;
 
-		inner_mode_iaf = xfrm_get_mode(x->props.mode, AF_INET6);
-		if (inner_mode_iaf == NULL)
-			goto error;
+		if (x->props.family == AF_INET)
+			iafamily = AF_INET6;
 
-		if (!(inner_mode_iaf->flags & XFRM_MODE_FLAG_TUNNEL)) {
-			xfrm_put_mode(inner_mode_iaf);
-			goto error;
-		}
-
-		if (x->props.family == AF_INET) {
-			x->inner_mode = inner_mode;
-			x->inner_mode_iaf = inner_mode_iaf;
-		} else {
-			x->inner_mode = inner_mode_iaf;
-			x->inner_mode_iaf = inner_mode;
+		inner_mode_iaf = xfrm_get_mode(x->props.mode, iafamily);
+		if (inner_mode_iaf) {
+			if (inner_mode_iaf->flags & XFRM_MODE_FLAG_TUNNEL)
+				x->inner_mode_iaf = inner_mode_iaf;
+			else
+				xfrm_put_mode(inner_mode_iaf);
 		}
 	}
 
